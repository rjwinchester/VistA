Released XU*8*680 SEQ #530
Extracted from mail message
**KIDS**:XU*8.0*680^

**INSTALL NAME**
XU*8.0*680
"BLD",9906,0)
XU*8.0*680^KERNEL^0^3161214^y
"BLD",9906,1,0)
^^1^1^3161027^
"BLD",9906,1,1,0)
JSON Encoding/Decoding utility.
"BLD",9906,4,0)
^9.64PA^^
"BLD",9906,6.3)
4
"BLD",9906,"KRN",0)
^9.67PA^779.2^20
"BLD",9906,"KRN",.4,0)
.4
"BLD",9906,"KRN",.401,0)
.401
"BLD",9906,"KRN",.402,0)
.402
"BLD",9906,"KRN",.403,0)
.403
"BLD",9906,"KRN",.5,0)
.5
"BLD",9906,"KRN",.84,0)
.84
"BLD",9906,"KRN",3.6,0)
3.6
"BLD",9906,"KRN",3.8,0)
3.8
"BLD",9906,"KRN",9.2,0)
9.2
"BLD",9906,"KRN",9.8,0)
9.8
"BLD",9906,"KRN",9.8,"NM",0)
^9.68A^3^3
"BLD",9906,"KRN",9.8,"NM",1,0)
XLFJSON^^0^B12212651
"BLD",9906,"KRN",9.8,"NM",2,0)
XLFJSOND^^0^B72001822
"BLD",9906,"KRN",9.8,"NM",3,0)
XLFJSONE^^0^B24814820
"BLD",9906,"KRN",9.8,"NM","B","XLFJSON",1)

"BLD",9906,"KRN",9.8,"NM","B","XLFJSOND",2)

"BLD",9906,"KRN",9.8,"NM","B","XLFJSONE",3)

"BLD",9906,"KRN",19,0)
19
"BLD",9906,"KRN",19.1,0)
19.1
"BLD",9906,"KRN",101,0)
101
"BLD",9906,"KRN",409.61,0)
409.61
"BLD",9906,"KRN",771,0)
771
"BLD",9906,"KRN",779.2,0)
779.2
"BLD",9906,"KRN",870,0)
870
"BLD",9906,"KRN",8989.51,0)
8989.51
"BLD",9906,"KRN",8989.52,0)
8989.52
"BLD",9906,"KRN",8994,0)
8994
"BLD",9906,"KRN","B",.4,.4)

"BLD",9906,"KRN","B",.401,.401)

"BLD",9906,"KRN","B",.402,.402)

"BLD",9906,"KRN","B",.403,.403)

"BLD",9906,"KRN","B",.5,.5)

"BLD",9906,"KRN","B",.84,.84)

"BLD",9906,"KRN","B",3.6,3.6)

"BLD",9906,"KRN","B",3.8,3.8)

"BLD",9906,"KRN","B",9.2,9.2)

"BLD",9906,"KRN","B",9.8,9.8)

"BLD",9906,"KRN","B",19,19)

"BLD",9906,"KRN","B",19.1,19.1)

"BLD",9906,"KRN","B",101,101)

"BLD",9906,"KRN","B",409.61,409.61)

"BLD",9906,"KRN","B",771,771)

"BLD",9906,"KRN","B",779.2,779.2)

"BLD",9906,"KRN","B",870,870)

"BLD",9906,"KRN","B",8989.51,8989.51)

"BLD",9906,"KRN","B",8989.52,8989.52)

"BLD",9906,"KRN","B",8994,8994)

"MBREQ")
0
"PKG",173,-1)
1^1
"PKG",173,0)
KERNEL^XU^SIGN-ON, SECURITY, MENU DRIVER, DEVICES, TASKMAN^
"PKG",173,20,0)
^9.402P^2^2
"PKG",173,20,1,0)
200^^XDRM200N
"PKG",173,20,1,1)

"PKG",173,20,2,0)
2^^RGDRM03
"PKG",173,20,2,1)

"PKG",173,20,"B",2,2)

"PKG",173,20,"B",200,1)

"PKG",173,22,0)
^9.49I^1^1
"PKG",173,22,1,0)
8.0^2950703^2951015^1
"PKG",173,22,1,"PAH",1,0)
680^3161214^520736444
"PKG",173,22,1,"PAH",1,1,0)
^^1^1^3161214
"PKG",173,22,1,"PAH",1,1,1,0)
JSON Encoding/Decoding utility.
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
NO
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
NO
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
NO
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
3
"RTN","XLFJSON")
0^1^B12212651^n/a
"RTN","XLFJSON",1,0)
XLFJSON ;SLC/KCM/TJB - Decode/Encode JSON ;26 Oct 2016
"RTN","XLFJSON",2,0)
 ;;8.0;KERNEL;**680**;Jul 10, 1995;Build 4
"RTN","XLFJSON",3,0)
 ;;Per VA Directive 6402, this routine should not be modified.
"RTN","XLFJSON",4,0)
 ;
"RTN","XLFJSON",5,0)
 ; Note:  Since the routines use closed array references, XUROOT and XUERR
"RTN","XLFJSON",6,0)
 ;        are used to reduce risk of naming conflicts on the closed array.
"RTN","XLFJSON",7,0)
 ;
"RTN","XLFJSON",8,0)
DECODE(XUJSON,XUROOT,XUERR)  ; Set JSON object into closed array ref XUROOT
"RTN","XLFJSON",9,0)
 ; Examples: D DECODE^XLFJSON("MYJSON","LOCALVAR","LOCALERR")
"RTN","XLFJSON",10,0)
 ;           D DECODE^XLFJSON("^MYJSON(1)","^GLO(99)","^TMP($J)")
"RTN","XLFJSON",11,0)
 ;
"RTN","XLFJSON",12,0)
 ; XUJSON: Required; string/array containing serialized JSON object
"RTN","XLFJSON",13,0)
 ; XUROOT: Required; closed array reference for M representation of object
"RTN","XLFJSON",14,0)
 ;  XUERR: Optional; closed array reference contains error messages, defaults to ^TMP("XLFJERR",$J)
"RTN","XLFJSON",15,0)
 ;
"RTN","XLFJSON",16,0)
 ;   XUIDX: points to next character in JSON string to process
"RTN","XLFJSON",17,0)
 ; XUSTACK: manages stack of subscripts
"RTN","XLFJSON",18,0)
 ;  XUPROP: true if next string is property name, otherwise treat as value
"RTN","XLFJSON",19,0)
 ;
"RTN","XLFJSON",20,0)
 G DIRECT^XLFJSOND
"RTN","XLFJSON",21,0)
 ;
"RTN","XLFJSON",22,0)
ENCODE(XUROOT,XUJSON,XUERR) ; XUROOT (M structure) --> XUJSON (array of strings)
"RTN","XLFJSON",23,0)
 ; Examples:  D ENCODE^XLFJSON("^GLO(99,2)","^TMP($J)")
"RTN","XLFJSON",24,0)
 ;            D ENCODE^XLFJSON("LOCALVAR","MYJSON","LOCALERR")
"RTN","XLFJSON",25,0)
 ;
"RTN","XLFJSON",26,0)
 ; XUROOT: Required; closed array reference for M representation of object
"RTN","XLFJSON",27,0)
 ; XUJSON: Required; destination variable for the string array formatted as JSON
"RTN","XLFJSON",28,0)
 ;  XUERR: Optional; closed array reference contains error messages, defaults to ^TMP("XLFJERR",$J)
"RTN","XLFJSON",29,0)
 ;
"RTN","XLFJSON",30,0)
 G DIRECT^XLFJSONE
"RTN","XLFJSON",31,0)
 ;
"RTN","XLFJSON",32,0)
 ;
"RTN","XLFJSON",33,0)
ESC(X) ; Escape string for JSON
"RTN","XLFJSON",34,0)
 ; X: Required; String to be escaped
"RTN","XLFJSON",35,0)
 Q $$ESC^XLFJSONE(X)
"RTN","XLFJSON",36,0)
 ;
"RTN","XLFJSON",37,0)
UES(X) ; Unescape JSON string
"RTN","XLFJSON",38,0)
 ; X: Required; String to be unescaped
"RTN","XLFJSON",39,0)
 Q $$UES^XLFJSOND(X)
"RTN","XLFJSON",40,0)
 ;
"RTN","XLFJSON",41,0)
ERRX(ID,VAL) ; Set the appropriate error message
"RTN","XLFJSON",42,0)
 ; switch (ID) -- XERRX ends statement
"RTN","XLFJSON",43,0)
 N ERRMSG
"RTN","XLFJSON",44,0)
 ;
"RTN","XLFJSON",45,0)
 ; Decode Error Messages
"RTN","XLFJSON",46,0)
 ;
"RTN","XLFJSON",47,0)
 I ID="STL{" S ERRMSG="Stack too large for new object." G XERRX
"RTN","XLFJSON",48,0)
 I ID="SUF}" S ERRMSG="Stack Underflow - extra } found" G XERRX
"RTN","XLFJSON",49,0)
 I ID="STL[" S ERRMSG="Stack too large for new array." G XERRX
"RTN","XLFJSON",50,0)
 I ID="SUF]" S ERRMSG="Stack Underflow - extra ] found." G XERRX
"RTN","XLFJSON",51,0)
 I ID="OBM" S ERRMSG="Array mismatch - expected ] got }." G XERRX
"RTN","XLFJSON",52,0)
 I ID="ARM" S ERRMSG="Object mismatch - expected } got ]." G XERRX
"RTN","XLFJSON",53,0)
 I ID="MPN" S ERRMSG="Missing property name." G XERRX
"RTN","XLFJSON",54,0)
 I ID="EXT" S ERRMSG="Expected true, got "_VAL G XERRX
"RTN","XLFJSON",55,0)
 I ID="EXF" S ERRMSG="Expected false, got "_VAL G XERRX
"RTN","XLFJSON",56,0)
 I ID="EXN" S ERRMSG="Expected null, got "_VAL G XERRX
"RTN","XLFJSON",57,0)
 I ID="TKN" S ERRMSG="Unable to identify type of token, value was "_VAL G XERRX
"RTN","XLFJSON",58,0)
 I ID="SCT" S ERRMSG="Stack mismatch - exit stack level was  "_VAL G XERRX
"RTN","XLFJSON",59,0)
 I ID="EIQ" S ERRMSG="Close quote not found before end of input." G XERRX
"RTN","XLFJSON",60,0)
 I ID="EIU" S ERRMSG="Unexpected end of input while unescaping." G XERRX
"RTN","XLFJSON",61,0)
 I ID="RSB" S ERRMSG="Reverse search for \ past beginning of input." G XERRX
"RTN","XLFJSON",62,0)
 I ID="ORN" S ERRMSG="Overrun while scanning name." G XERRX
"RTN","XLFJSON",63,0)
 I ID="OR#" S ERRMSG="Overrun while scanning number." G XERRX
"RTN","XLFJSON",64,0)
 I ID="ORB" S ERRMSG="Overrun while scanning boolean." G XERRX
"RTN","XLFJSON",65,0)
 I ID="ESC" S ERRMSG="Escaped character not recognized"_VAL G XERRX
"RTN","XLFJSON",66,0)
 I ID="NOV" S ERRMSG="Expected value, got "_VAL G XERRX
"RTN","XLFJSON",67,0)
 ;
"RTN","XLFJSON",68,0)
 ; Encode Error Messages
"RTN","XLFJSON",69,0)
 ;
"RTN","XLFJSON",70,0)
 I ID="SOB" S ERRMSG="Unable to serialize node as object, value was "_VAL G XERRX
"RTN","XLFJSON",71,0)
 I ID="SAR" S ERRMSG="Unable to serialize node as array, value was "_VAL G XERRX
"RTN","XLFJSON",72,0)
 S ERRMSG="Unspecified error "_ID_" "_$G(VAL)
"RTN","XLFJSON",73,0)
XERRX ; end switch
"RTN","XLFJSON",74,0)
 S @XUERR@(0)=$G(@XUERR@(0))+1
"RTN","XLFJSON",75,0)
 S @XUERR@(@XUERR@(0))=ERRMSG
"RTN","XLFJSON",76,0)
 S XUERRORS=XUERRORS+1
"RTN","XLFJSON",77,0)
 Q
"RTN","XLFJSOND")
0^2^B72001822^n/a
"RTN","XLFJSOND",1,0)
XLFJSOND ;SLC/KCM/TJB - Decode JSON ;26 Oct 2016
"RTN","XLFJSOND",2,0)
 ;;8.0;KERNEL;**680**;Jul 10, 1995;Build 4
"RTN","XLFJSOND",3,0)
 ;;Per VA Directive 6402, this routine should not be modified.
"RTN","XLFJSOND",4,0)
 ;
"RTN","XLFJSOND",5,0)
DECODE(XUJSON,XUROOT,XUERR) ; Set JSON object into closed array ref XUROOT
"RTN","XLFJSOND",6,0)
 ;
"RTN","XLFJSOND",7,0)
DIRECT ; TAG for use by DECODE^XLFJSON
"RTN","XLFJSOND",8,0)
 ;
"RTN","XLFJSOND",9,0)
 ; Examples: D DECODE^XLFJSON("MYJSON","LOCALVAR","LOCALERR")
"RTN","XLFJSOND",10,0)
 ;           D DECODE^XLFJSON("^MYJSON(1)","^GLO(99)","^TMP($J)")
"RTN","XLFJSOND",11,0)
 ;
"RTN","XLFJSOND",12,0)
 ; XUJSON: string/array containing serialized JSON object
"RTN","XLFJSOND",13,0)
 ; XUROOT: closed array reference for M representation of object
"RTN","XLFJSOND",14,0)
 ;  XUERR: contains error messages, defaults to ^TMP("XLFJERR",$J)
"RTN","XLFJSOND",15,0)
 ;
"RTN","XLFJSOND",16,0)
 ;   XUIDX: points to next character in JSON string to process
"RTN","XLFJSOND",17,0)
 ; XUSTACK: manages stack of subscripts
"RTN","XLFJSOND",18,0)
 ;  XUPROP: true if next string is property name, otherwise treat as value
"RTN","XLFJSOND",19,0)
 ;
"RTN","XLFJSOND",20,0)
 N XUMAX S XUMAX=4000 ; limit document lines to 4000 characters
"RTN","XLFJSOND",21,0)
 S XUERR=$G(XUERR,"^TMP(""XLFJERR"",$J)")
"RTN","XLFJSOND",22,0)
 ; If a simple string is passed in, move it to an temp array (XUINPUT)
"RTN","XLFJSOND",23,0)
 ; so that the processing is consistently on an array.
"RTN","XLFJSOND",24,0)
 I $D(@XUJSON)=1 N XUINPUT S XUINPUT(1)=@XUJSON,XUJSON="XUINPUT"
"RTN","XLFJSOND",25,0)
 S XUROOT=$NA(@XUROOT@("Z")),XUROOT=$E(XUROOT,1,$L(XUROOT)-4) ; make open array ref
"RTN","XLFJSOND",26,0)
 N XULINE,XUIDX,XUSTACK,XUPROP,XUVAL,XUTYPE,XUERRORS
"RTN","XLFJSOND",27,0)
 S XULINE=$O(@XUJSON@("")),XUIDX=1,XUSTACK=0,XUPROP=0,XUVAL=1,XUERRORS=0
"RTN","XLFJSOND",28,0)
 F  S XUTYPE=$$NXTKN() Q:XUTYPE=""  D  I XUERRORS Q
"RTN","XLFJSOND",29,0)
 . I XUVAL S XUVAL=0 I ("}],:"[XUTYPE) D ERRX("NOV",XUTYPE) Q  ; value was expected
"RTN","XLFJSOND",30,0)
 . I XUTYPE="{" S XUSTACK=XUSTACK+1,XUSTACK(XUSTACK)="",XUPROP=1 D:XUSTACK>64 ERRX("STL{") Q
"RTN","XLFJSOND",31,0)
 . I XUTYPE="}" D  QUIT
"RTN","XLFJSOND",32,0)
 . . I +XUSTACK(XUSTACK)=XUSTACK(XUSTACK),XUSTACK(XUSTACK) D ERRX("OBM") ; Numeric and true only
"RTN","XLFJSOND",33,0)
 . . S XUSTACK=XUSTACK-1 D:XUSTACK<0 ERRX("SUF}")
"RTN","XLFJSOND",34,0)
 . I XUTYPE="[" S XUSTACK=XUSTACK+1,XUSTACK(XUSTACK)=1 D:XUSTACK>64 ERRX("STL[") Q
"RTN","XLFJSOND",35,0)
 . I XUTYPE="]" D:'XUSTACK(XUSTACK) ERRX("ARM") S XUSTACK=XUSTACK-1 D:XUSTACK<0 ERRX("SUF]") Q
"RTN","XLFJSOND",36,0)
 . I XUTYPE="," D  Q
"RTN","XLFJSOND",37,0)
 . . I +XUSTACK(XUSTACK)=XUSTACK(XUSTACK),XUSTACK(XUSTACK) S XUSTACK(XUSTACK)=XUSTACK(XUSTACK)+1  ; VEN/SMH - next in array 
"RTN","XLFJSOND",38,0)
 . . E  S XUPROP=1                                   ; or next property name
"RTN","XLFJSOND",39,0)
 . I XUTYPE=":" S XUPROP=0,XUVAL=1 D:'$L($G(XUSTACK(XUSTACK))) ERRX("MPN") Q
"RTN","XLFJSOND",40,0)
 . I XUTYPE="""" D  Q
"RTN","XLFJSOND",41,0)
 . . I XUPROP S XUSTACK(XUSTACK)=$$NAMPARS() I 1
"RTN","XLFJSOND",42,0)
 . . E  D ADDSTR
"RTN","XLFJSOND",43,0)
 . S XUTYPE=$TR(XUTYPE,"TFN","tfn")
"RTN","XLFJSOND",44,0)
 . I XUTYPE="t" D SETBOOL("t") Q
"RTN","XLFJSOND",45,0)
 . I XUTYPE="f" D SETBOOL("f") Q
"RTN","XLFJSOND",46,0)
 . I XUTYPE="n" D SETBOOL("n") Q
"RTN","XLFJSOND",47,0)
 . I "0123456789+-.eE"[XUTYPE D SETNUM(XUTYPE) Q  ;S @$$CURNODE()=$$NUMPARS(XUTYPE) Q
"RTN","XLFJSOND",48,0)
 . D ERRX("TKN",XUTYPE)
"RTN","XLFJSOND",49,0)
 I XUSTACK'=0 D ERRX("SCT",XUSTACK)
"RTN","XLFJSOND",50,0)
 Q
"RTN","XLFJSOND",51,0)
NXTKN() ; Move the pointers to the beginning of the next token
"RTN","XLFJSOND",52,0)
 N XUDONE,XUEOF,XUTOKEN
"RTN","XLFJSOND",53,0)
 S XUDONE=0,XUEOF=0 F  D  Q:XUDONE!XUEOF  ; eat spaces & new lines until next visible char
"RTN","XLFJSOND",54,0)
 . I XUIDX>$L(@XUJSON@(XULINE)) S XULINE=$O(@XUJSON@(XULINE)),XUIDX=1 I 'XULINE S XUEOF=1 Q
"RTN","XLFJSOND",55,0)
 . I $A(@XUJSON@(XULINE),XUIDX)>32 S XUDONE=1 Q
"RTN","XLFJSOND",56,0)
 . S XUIDX=XUIDX+1
"RTN","XLFJSOND",57,0)
 Q:XUEOF ""  ; we're at the end of input
"RTN","XLFJSOND",58,0)
 S XUTOKEN=$E(@XUJSON@(XULINE),XUIDX),XUIDX=XUIDX+1
"RTN","XLFJSOND",59,0)
 Q XUTOKEN
"RTN","XLFJSOND",60,0)
 ;
"RTN","XLFJSOND",61,0)
ADDSTR ; Add string value to current node, escaping text along the way
"RTN","XLFJSOND",62,0)
 ; Expects XULINE,XUIDX to reference that starting point of the index
"RTN","XLFJSOND",63,0)
 ; TODO: add a mechanism to specify names that should not be escaped
"RTN","XLFJSOND",64,0)
 ;       just store as ":")= and ":",n)=
"RTN","XLFJSOND",65,0)
 ;
"RTN","XLFJSOND",66,0)
 ; Happy path -- we find the end quote in the same line
"RTN","XLFJSOND",67,0)
 N XUEND,XUX
"RTN","XLFJSOND",68,0)
 S XUEND=$F(@XUJSON@(XULINE),"""",XUIDX)
"RTN","XLFJSOND",69,0)
 I XUEND,($E(@XUJSON@(XULINE),XUEND-2)'="\") D SETSTR  QUIT  ;normal
"RTN","XLFJSOND",70,0)
 I XUEND,$$ISCLOSEQ(XULINE) D SETSTR QUIT  ;close quote preceded by escaped \
"RTN","XLFJSOND",71,0)
 ;
"RTN","XLFJSOND",72,0)
 ; Less happy path -- first quote wasn't close quote
"RTN","XLFJSOND",73,0)
 N XUDONE,XUTLINE
"RTN","XLFJSOND",74,0)
 S XUDONE=0,XUTLINE=XULINE ; XUTLINE for temporary increment of XULINE
"RTN","XLFJSOND",75,0)
 F  D  Q:XUDONE  Q:XUERRORS
"RTN","XLFJSOND",76,0)
 . ;if no quote on current line advance line, scan again
"RTN","XLFJSOND",77,0)
 . I 'XUEND S XUTLINE=XUTLINE+1,XUEND=1 I '$D(@XUJSON@(XUTLINE)) D ERRX("EIQ") Q
"RTN","XLFJSOND",78,0)
 . S XUEND=$F(@XUJSON@(XUTLINE),"""",XUEND)
"RTN","XLFJSOND",79,0)
 . Q:'XUEND  ; continue on to next line if no quote found on this one
"RTN","XLFJSOND",80,0)
 . I (XUEND>2),($E(@XUJSON@(XUTLINE),XUEND-2)'="\") S XUDONE=1 Q  ; found quote position
"RTN","XLFJSOND",81,0)
 . S XUDONE=$$ISCLOSEQ(XUTLINE) ; see if this is an escaped quote or closing quote
"RTN","XLFJSOND",82,0)
 Q:XUERRORS
"RTN","XLFJSOND",83,0)
 ; unescape from XUIDX to XUEND, using \-extension nodes as necessary
"RTN","XLFJSOND",84,0)
 D UESEXT
"RTN","XLFJSOND",85,0)
 ; now we need to move XULINE and XUIDX to next parsing point
"RTN","XLFJSOND",86,0)
 S XULINE=XUTLINE,XUIDX=XUEND
"RTN","XLFJSOND",87,0)
 Q
"RTN","XLFJSOND",88,0)
SETSTR ; Set simple string value from within same line
"RTN","XLFJSOND",89,0)
 ; expects XUJSON, XULINE, XUINX, XUEND
"RTN","XLFJSOND",90,0)
 N XUX
"RTN","XLFJSOND",91,0)
 S XUX=$E(@XUJSON@(XULINE),XUIDX,XUEND-2),XUIDX=XUEND
"RTN","XLFJSOND",92,0)
 S @$$CURNODE()=$$UES(XUX)
"RTN","XLFJSOND",93,0)
 ; "\s" node indicates value is really a string in case value 
"RTN","XLFJSOND",94,0)
 ;      collates as numeric or equals boolean keywords
"RTN","XLFJSOND",95,0)
 I XUX']]$C(1) S @$$CURNODE()@("\s")=""
"RTN","XLFJSOND",96,0)
 I XUX="true"!(XUX="false")!(XUX="null") S @$$CURNODE()@("\s")=""
"RTN","XLFJSOND",97,0)
 I XUIDX>$L(@XUJSON@(XULINE)) S XULINE=XULINE+1,XUIDX=1
"RTN","XLFJSOND",98,0)
 Q
"RTN","XLFJSOND",99,0)
UESEXT ; unescape from XULINE,XUIDX to XUTLINE,XUEND & extend (\) if necessary
"RTN","XLFJSOND",100,0)
 ; expects XULINE,XUIDX,XUTLINE,XUEND
"RTN","XLFJSOND",101,0)
 N XUI,XUY,XUSTART,XUSTOP,XUDONE,XUBUF,XUNODE,XUMORE,XUTO
"RTN","XLFJSOND",102,0)
 S XUNODE=$$CURNODE(),XUBUF="",XUMORE=0,XUSTOP=XUEND-2
"RTN","XLFJSOND",103,0)
 S XUI=XUIDX,XUY=XULINE,XUDONE=0
"RTN","XLFJSOND",104,0)
 F  D  Q:XUDONE  Q:XUERRORS
"RTN","XLFJSOND",105,0)
 . S XUSTART=XUI,XUI=$F(@XUJSON@(XUY),"\",XUI)
"RTN","XLFJSOND",106,0)
 . ; if we are on the last line, don't extract past XUSTOP
"RTN","XLFJSOND",107,0)
 . I (XUY=XUTLINE) S XUTO=$S('XUI:XUSTOP,XUI>XUSTOP:XUSTOP,1:XUI-2) I 1
"RTN","XLFJSOND",108,0)
 . E  S XUTO=$S('XUI:99999,1:XUI-2)
"RTN","XLFJSOND",109,0)
 . D ADDBUF($E(@XUJSON@(XUY),XUSTART,XUTO))
"RTN","XLFJSOND",110,0)
 . I (XUY'<XUTLINE),(('XUI)!(XUI>XUSTOP)) S XUDONE=1 QUIT  ; now past close quote
"RTN","XLFJSOND",111,0)
 . I 'XUI S XUY=XUY+1,XUI=1 QUIT  ; nothing escaped, go to next line
"RTN","XLFJSOND",112,0)
 . I XUI>$L(@XUJSON@(XUY)) S XUY=XUY+1,XUI=1 I '$D(@XUJSON@(XUY)) D ERRX("EIU")
"RTN","XLFJSOND",113,0)
 . N XUTGT S XUTGT=$E(@XUJSON@(XUY),XUI)
"RTN","XLFJSOND",114,0)
 . I XUTGT="u" D  I 1
"RTN","XLFJSOND",115,0)
 . . N XUTGTC S XUTGTC=$E(@XUJSON@(XUY),XUI+1,XUI+4),XUI=XUI+4
"RTN","XLFJSOND",116,0)
 . . I $L(XUTGTC)<4 S XUY=XUY+1,XUI=4-$L(XUTGTC),XUTGTC=XUTGTC_$E(@XUJSON@(XUY),1,XUI)
"RTN","XLFJSOND",117,0)
 . . D ADDBUF($C($$DEC^XLFUTL(XUTGTC,16)))
"RTN","XLFJSOND",118,0)
 . E  D ADDBUF($$REALCHAR(XUTGT))
"RTN","XLFJSOND",119,0)
 . S XUI=XUI+1
"RTN","XLFJSOND",120,0)
 . I (XUY'<XUTLINE),(XUI>XUSTOP) S XUDONE=1 ; XUI incremented past stop
"RTN","XLFJSOND",121,0)
 Q:XUERRORS
"RTN","XLFJSOND",122,0)
 D SAVEBUF
"RTN","XLFJSOND",123,0)
 Q
"RTN","XLFJSOND",124,0)
ADDBUF(XUX) ; add buffer of characters to destination
"RTN","XLFJSOND",125,0)
 ; expects XUBUF,XUMAX,XUNODE,XUMORE to be defined
"RTN","XLFJSOND",126,0)
 ; used directly by ADDSTR
"RTN","XLFJSOND",127,0)
 I $L(XUX)+$L(XUBUF)>XUMAX D SAVEBUF
"RTN","XLFJSOND",128,0)
 S XUBUF=XUBUF_XUX
"RTN","XLFJSOND",129,0)
 Q
"RTN","XLFJSOND",130,0)
SAVEBUF ; write out buffer to destination
"RTN","XLFJSOND",131,0)
 ; expects XUBUF,XUMAX,XUNODE,XUMORE to be defined
"RTN","XLFJSOND",132,0)
 ; used directly by ADDSTR,ADDBUF
"RTN","XLFJSOND",133,0)
 I XUMORE S @XUNODE@("\",XUMORE)=XUBUF
"RTN","XLFJSOND",134,0)
 I 'XUMORE S @XUNODE=XUBUF I $L(XUBUF)<19,+$E(XUBUF,1,18) S @XUNODE@("\s")=""
"RTN","XLFJSOND",135,0)
 S XUMORE=XUMORE+1,XUBUF=""
"RTN","XLFJSOND",136,0)
 Q
"RTN","XLFJSOND",137,0)
ISCLOSEQ(XUBLINE) ; return true if this is a closing, rather than escaped, quote
"RTN","XLFJSOND",138,0)
 ; expects
"RTN","XLFJSOND",139,0)
 ;   XUJSON: lines of the JSON encoded string
"RTN","XLFJSOND",140,0)
 ;    XUIDX: points to 1st character of the segment
"RTN","XLFJSOND",141,0)
 ;   XULINE: points to the line in which the segment starts
"RTN","XLFJSOND",142,0)
 ;    XUEND: points to 1st character after the " (may be past the end of the line)
"RTN","XLFJSOND",143,0)
 ; used directly by ADDSTR
"RTN","XLFJSOND",144,0)
 N XUBS,XUBIDX,XUBDONE
"RTN","XLFJSOND",145,0)
 S XUBS=0,XUBIDX=XUEND-2,XUBDONE=0 ; XUBIDX starts at 1st character before quote
"RTN","XLFJSOND",146,0)
 ; count the backslashes preceding the quote (odd number means the quote was escaped)
"RTN","XLFJSOND",147,0)
 F  D  Q:XUBDONE!XUERRORS
"RTN","XLFJSOND",148,0)
 . I XUBIDX<1 D  Q  ; when XUBIDX<1 go back a line
"RTN","XLFJSOND",149,0)
 . . S XUBLINE=XUBLINE-1 I XUBLINE<XULINE D ERRX("RSB") Q
"RTN","XLFJSOND",150,0)
 . . S XUBIDX=$L(@XUJSON@(XUBLINE))
"RTN","XLFJSOND",151,0)
 . I $E(@XUJSON@(XUBLINE),XUBIDX)'="\" S XUBDONE=1 Q
"RTN","XLFJSOND",152,0)
 . S XUBS=XUBS+1,XUBIDX=XUBIDX-1
"RTN","XLFJSOND",153,0)
 Q XUBS#2=0  ; XUBS is even if this is a close quote
"RTN","XLFJSOND",154,0)
 ;
"RTN","XLFJSOND",155,0)
NAMPARS() ; Return parsed name, advancing index past the close quote
"RTN","XLFJSOND",156,0)
 ; -- This assumes no embedded quotes are in the name itself --
"RTN","XLFJSOND",157,0)
 N XUEND,XUDONE,XUNAME
"RTN","XLFJSOND",158,0)
 S XUDONE=0,XUNAME=""
"RTN","XLFJSOND",159,0)
 F  D  Q:XUDONE  Q:XUERRORS
"RTN","XLFJSOND",160,0)
 . S XUEND=$F(@XUJSON@(XULINE),"""",XUIDX)
"RTN","XLFJSOND",161,0)
 . I XUEND S XUNAME=XUNAME_$E(@XUJSON@(XULINE),XUIDX,XUEND-2),XUIDX=XUEND,XUDONE=1
"RTN","XLFJSOND",162,0)
 . I 'XUEND S XUNAME=XUNAME_$E(@XUJSON@(XULINE),XUIDX,$L(@XUJSON@(XULINE)))
"RTN","XLFJSOND",163,0)
 . I 'XUEND!(XUEND>$L(@XUJSON@(XULINE))) S XULINE=XULINE+1,XUIDX=1 I '$D(@XUJSON@(XULINE)) D ERRX("ORN")
"RTN","XLFJSOND",164,0)
 ; prepend quote if label collates as numeric -- assumes no quotes in label
"RTN","XLFJSOND",165,0)
 I XUNAME']]$C(1) S XUNAME=""""""_XUNAME
"RTN","XLFJSOND",166,0)
 Q XUNAME
"RTN","XLFJSOND",167,0)
 ;
"RTN","XLFJSOND",168,0)
SETNUM(XUDIGIT) ; Set numeric along with any necessary modifier
"RTN","XLFJSOND",169,0)
 N XUX
"RTN","XLFJSOND",170,0)
 S XUX=$$NUMPARS(XUDIGIT)
"RTN","XLFJSOND",171,0)
 S @$$CURNODE()=+XUX
"RTN","XLFJSOND",172,0)
 ; if numeric is exponent, "0.nnn" or "-0.nnn" store original string
"RTN","XLFJSOND",173,0)
 I +XUX'=XUX S @$$CURNODE()@("\n")=XUX
"RTN","XLFJSOND",174,0)
 Q
"RTN","XLFJSOND",175,0)
NUMPARS(XUDIGIT) ; Return parsed number, advancing index past end of number
"RTN","XLFJSOND",176,0)
 ; XUIDX intially references the second digit
"RTN","XLFJSOND",177,0)
 N XUDONE,XUNUM
"RTN","XLFJSOND",178,0)
 S XUDONE=0,XUNUM=XUDIGIT
"RTN","XLFJSOND",179,0)
 F  D  Q:XUDONE  Q:XUERRORS
"RTN","XLFJSOND",180,0)
 . I '("0123456789+-.eE"[$E(@XUJSON@(XULINE),XUIDX)) S XUDONE=1 Q
"RTN","XLFJSOND",181,0)
 . S XUNUM=XUNUM_$E(@XUJSON@(XULINE),XUIDX)
"RTN","XLFJSOND",182,0)
 . S XUIDX=XUIDX+1 I XUIDX>$L(@XUJSON@(XULINE)) S XULINE=XULINE+1,XUIDX=1 I '$D(@XUJSON@(XULINE)) D ERRX("OR#")
"RTN","XLFJSOND",183,0)
 Q XUNUM
"RTN","XLFJSOND",184,0)
 ;
"RTN","XLFJSOND",185,0)
SETBOOL(XULTR) ; Parse and set boolean value, advancing index past end of value
"RTN","XLFJSOND",186,0)
 N XUDONE,XUBOOL,XUX
"RTN","XLFJSOND",187,0)
 S XUDONE=0,XUBOOL=XULTR
"RTN","XLFJSOND",188,0)
 F  D  Q:XUDONE  Q:XUERRORS
"RTN","XLFJSOND",189,0)
 . S XUX=$TR($E(@XUJSON@(XULINE),XUIDX),"TRUEFALSN","truefalsn")
"RTN","XLFJSOND",190,0)
 . I '("truefalsn"[XUX) S XUDONE=1 Q
"RTN","XLFJSOND",191,0)
 . S XUBOOL=XUBOOL_XUX
"RTN","XLFJSOND",192,0)
 . S XUIDX=XUIDX+1 I XUIDX>$L(@XUJSON@(XULINE)) S XULINE=XULINE+1,XUIDX=1 I '$D(@XUJSON@(XULINE)) D ERRX("ORB")
"RTN","XLFJSOND",193,0)
 I XULTR="t",(XUBOOL'="true") D ERRX("EXT",XUTYPE)
"RTN","XLFJSOND",194,0)
 I XULTR="f",(XUBOOL'="false") D ERRX("EXF",XUTYPE)
"RTN","XLFJSOND",195,0)
 I XULTR="n",(XUBOOL'="null") D ERRX("EXN",XUTYPE)
"RTN","XLFJSOND",196,0)
 S @$$CURNODE()=XUBOOL
"RTN","XLFJSOND",197,0)
 Q
"RTN","XLFJSOND",198,0)
 ;
"RTN","XLFJSOND",199,0)
OSETBOOL(XUX) ; set a value and increment XUIDX
"RTN","XLFJSOND",200,0)
 S @$$CURNODE()=XUX
"RTN","XLFJSOND",201,0)
 S XUIDX=XUIDX+$L(XUX)-1
"RTN","XLFJSOND",202,0)
 N XUDIFF S XUDIFF=XUIDX-$L(@XUJSON@(XULINE))  ; in case XUIDX moves to next line
"RTN","XLFJSOND",203,0)
 I XUDIFF>0 S XULINE=XULINE+1,XUIDX=XUDIFF I '$D(@XUJSON@(XULINE)) D ERRX("ORB")
"RTN","XLFJSOND",204,0)
 Q
"RTN","XLFJSOND",205,0)
CURNODE() ; Return a global/local variable name based on XUSTACK
"RTN","XLFJSOND",206,0)
 ; Expects XUSTACK to be defined already
"RTN","XLFJSOND",207,0)
 N XUI,XUSUBS
"RTN","XLFJSOND",208,0)
 S XUSUBS=""
"RTN","XLFJSOND",209,0)
 F XUI=1:1:XUSTACK S:XUI>1 XUSUBS=XUSUBS_"," D
"RTN","XLFJSOND",210,0)
 . I XUSTACK(XUI)=+XUSTACK(XUI) S XUSUBS=XUSUBS_XUSTACK(XUI) ; VEN/SMH Fix psudo array bug.
"RTN","XLFJSOND",211,0)
 . E  S XUSUBS=XUSUBS_""""_XUSTACK(XUI)_""""
"RTN","XLFJSOND",212,0)
 Q XUROOT_XUSUBS_")"
"RTN","XLFJSOND",213,0)
 ;
"RTN","XLFJSOND",214,0)
UES(X) ; Unescape JSON string
"RTN","XLFJSOND",215,0)
 ; copy segments from START to POS-2 (right before \)
"RTN","XLFJSOND",216,0)
 ; translate target character (which is at $F position)
"RTN","XLFJSOND",217,0)
 N POS,Y,START
"RTN","XLFJSOND",218,0)
 S POS=0,Y=""
"RTN","XLFJSOND",219,0)
 F  S START=POS+1 D  Q:START>$L(X)
"RTN","XLFJSOND",220,0)
 . S POS=$F(X,"\",START) ; find next position
"RTN","XLFJSOND",221,0)
 . I 'POS S Y=Y_$E(X,START,$L(X)),POS=$L(X) Q
"RTN","XLFJSOND",222,0)
 . ; otherwise handle escaped char
"RTN","XLFJSOND",223,0)
 . N TGT
"RTN","XLFJSOND",224,0)
 . S TGT=$E(X,POS),Y=Y_$E(X,START,POS-2)
"RTN","XLFJSOND",225,0)
 . I TGT="u" S Y=Y_$C($$DEC^XLFUTL($E(X,POS+1,POS+4),16)),POS=POS+4 Q
"RTN","XLFJSOND",226,0)
 . S Y=Y_$$REALCHAR(TGT)
"RTN","XLFJSOND",227,0)
 Q Y
"RTN","XLFJSOND",228,0)
 ;
"RTN","XLFJSOND",229,0)
REALCHAR(C) ; Return actual character from escaped
"RTN","XLFJSOND",230,0)
 I C="""" Q """"
"RTN","XLFJSOND",231,0)
 I C="/" Q "/"
"RTN","XLFJSOND",232,0)
 I C="\" Q "\"
"RTN","XLFJSOND",233,0)
 I C="b" Q $C(8)
"RTN","XLFJSOND",234,0)
 I C="f" Q $C(12)
"RTN","XLFJSOND",235,0)
 I C="n" Q $C(10)
"RTN","XLFJSOND",236,0)
 I C="r" Q $C(13)
"RTN","XLFJSOND",237,0)
 I C="t" Q $C(9)
"RTN","XLFJSOND",238,0)
 I C="u" ;case covered above in $$DEC^XLFUTL calls
"RTN","XLFJSOND",239,0)
 ;otherwise
"RTN","XLFJSOND",240,0)
 I $L($G(XUERR)) D ERRX("ESC",C)
"RTN","XLFJSOND",241,0)
 Q C
"RTN","XLFJSOND",242,0)
 ;
"RTN","XLFJSOND",243,0)
ERRX(ID,VAL) ; Set the appropriate error message
"RTN","XLFJSOND",244,0)
 D ERRX^XLFJSON(ID,$G(VAL))
"RTN","XLFJSOND",245,0)
 Q
"RTN","XLFJSONE")
0^3^B24814820^n/a
"RTN","XLFJSONE",1,0)
XLFJSONE ;SLC/KCM/TJB - Encode JSON ;26 Oct 2016
"RTN","XLFJSONE",2,0)
 ;;8.0;KERNEL;**680**;Jul 10, 1995;Build 4
"RTN","XLFJSONE",3,0)
 ;;Per VA Directive 6402, this routine should not be modified.
"RTN","XLFJSONE",4,0)
 ;
"RTN","XLFJSONE",5,0)
ENCODE(XUROOT,XUJSON,XUERR) ; XUROOT (M structure) --> XUJSON (array of strings)
"RTN","XLFJSONE",6,0)
 ;
"RTN","XLFJSONE",7,0)
DIRECT ; TAG for use by ENCODE^XLFJSON
"RTN","XLFJSONE",8,0)
 ;
"RTN","XLFJSONE",9,0)
 ; Examples:  D ENCODE^XLFJSON("^GLO(99,2)","^TMP($J)")
"RTN","XLFJSONE",10,0)
 ;            D ENCODE^XLFJSON("LOCALVAR","MYJSON","LOCALERR")
"RTN","XLFJSONE",11,0)
 ;
"RTN","XLFJSONE",12,0)
 ; XUROOT: closed array reference for M representation of object
"RTN","XLFJSONE",13,0)
 ; XUJSON: destination variable for the string array formatted as JSON
"RTN","XLFJSONE",14,0)
 ;  XUERR: contains error messages, defaults to ^TMP("XLFJERR",$J)
"RTN","XLFJSONE",15,0)
 ;
"RTN","XLFJSONE",16,0)
 S XUERR=$G(XUERR,"^TMP(""XLFJERR"",$J)")
"RTN","XLFJSONE",17,0)
 I '$L($G(XUROOT)) ; set error info
"RTN","XLFJSONE",18,0)
 I '$L($G(XUJSON)) ; set error info
"RTN","XLFJSONE",19,0)
 N XULINE,XUMAX,XUERRORS
"RTN","XLFJSONE",20,0)
 S XULINE=1,XUMAX=4000,XUERRORS=0  ; 96 more bytes of wiggle room
"RTN","XLFJSONE",21,0)
 S @XUJSON@(XULINE)=""
"RTN","XLFJSONE",22,0)
 D SEROBJ(XUROOT)
"RTN","XLFJSONE",23,0)
 Q
"RTN","XLFJSONE",24,0)
 ;
"RTN","XLFJSONE",25,0)
SEROBJ(XUROOT) ; Serialize into a JSON object
"RTN","XLFJSONE",26,0)
 N XUFIRST,XUSUB,XUNXT
"RTN","XLFJSONE",27,0)
 S @XUJSON@(XULINE)=@XUJSON@(XULINE)_"{"
"RTN","XLFJSONE",28,0)
 S XUFIRST=1
"RTN","XLFJSONE",29,0)
 S XUSUB="" F  S XUSUB=$O(@XUROOT@(XUSUB)) Q:XUSUB=""  D
"RTN","XLFJSONE",30,0)
 . S:'XUFIRST @XUJSON@(XULINE)=@XUJSON@(XULINE)_"," S XUFIRST=0
"RTN","XLFJSONE",31,0)
 . ; get the name part
"RTN","XLFJSONE",32,0)
 . D SERNAME(XUSUB)
"RTN","XLFJSONE",33,0)
 . ; if this is a value, serialize it
"RTN","XLFJSONE",34,0)
 . I $$ISVALUE(XUROOT,XUSUB) D SERVAL(XUROOT,XUSUB) Q
"RTN","XLFJSONE",35,0)
 . ; otherwise navigate to the next child object or array
"RTN","XLFJSONE",36,0)
 . I $D(@XUROOT@(XUSUB))=10 S XUNXT=$O(@XUROOT@(XUSUB,"")) D  Q
"RTN","XLFJSONE",37,0)
 . . I +XUNXT D SERARY($NA(@XUROOT@(XUSUB))) I 1
"RTN","XLFJSONE",38,0)
 . . E  D SEROBJ($NA(@XUROOT@(XUSUB)))
"RTN","XLFJSONE",39,0)
 . D ERRX("SOB",XUSUB)  ; should quit loop before here
"RTN","XLFJSONE",40,0)
 S @XUJSON@(XULINE)=@XUJSON@(XULINE)_"}"
"RTN","XLFJSONE",41,0)
 Q
"RTN","XLFJSONE",42,0)
SERARY(XUROOT) ; Serialize into a JSON array
"RTN","XLFJSONE",43,0)
 N XUFIRST,XUI,XUNXT
"RTN","XLFJSONE",44,0)
 S @XUJSON@(XULINE)=@XUJSON@(XULINE)_"["
"RTN","XLFJSONE",45,0)
 S XUFIRST=1
"RTN","XLFJSONE",46,0)
 S XUI=0 F  S XUI=$O(@XUROOT@(XUI)) Q:'XUI  D
"RTN","XLFJSONE",47,0)
 . S:'XUFIRST @XUJSON@(XULINE)=@XUJSON@(XULINE)_"," S XUFIRST=0
"RTN","XLFJSONE",48,0)
 . I $$ISVALUE(XUROOT,XUI) D SERVAL(XUROOT,XUI) Q  ; write value
"RTN","XLFJSONE",49,0)
 . I $D(@XUROOT@(XUI))=10 S XUNXT=$O(@XUROOT@(XUI,"")) D  Q
"RTN","XLFJSONE",50,0)
 . . I +XUNXT D SERARY($NA(@XUROOT@(XUI))) I 1
"RTN","XLFJSONE",51,0)
 . . E  D SEROBJ($NA(@XUROOT@(XUI)))
"RTN","XLFJSONE",52,0)
 . D ERRX("SAR",XUI)  ; should quit loop before here
"RTN","XLFJSONE",53,0)
 S @XUJSON@(XULINE)=@XUJSON@(XULINE)_"]"
"RTN","XLFJSONE",54,0)
 Q
"RTN","XLFJSONE",55,0)
SERNAME(XUSUB) ; Serialize the object name into JSON string
"RTN","XLFJSONE",56,0)
 I $E(XUSUB)="""" S XUSUB=$E(XUSUB,2,$L(XUSUB)) ; quote indicates numeric label
"RTN","XLFJSONE",57,0)
 I ($L(XUSUB)+$L(@XUJSON@(XULINE)))>XUMAX S XULINE=XULINE+1,@XUJSON@(XULINE)=""
"RTN","XLFJSONE",58,0)
 S @XUJSON@(XULINE)=@XUJSON@(XULINE)_""""_XUSUB_""""_":"
"RTN","XLFJSONE",59,0)
 Q
"RTN","XLFJSONE",60,0)
SERVAL(XUROOT,XUSUB) ; Serialize X into appropriate JSON representation
"RTN","XLFJSONE",61,0)
 N XUX,XUI,XUDONE
"RTN","XLFJSONE",62,0)
 ; if the node is already in JSON format, just add it
"RTN","XLFJSONE",63,0)
 I $D(@XUROOT@(XUSUB,":")) D  QUIT  ; <-- jump out here if preformatted
"RTN","XLFJSONE",64,0)
 . S XUX=$G(@XUROOT@(XUSUB,":")) D:$L(XUX) CONCAT
"RTN","XLFJSONE",65,0)
 . S XUI=0 F  S XUI=$O(@XUROOT@(XUSUB,":",XUI)) Q:'XUI  S XUX=@XUROOT@(XUSUB,":",XUI) D CONCAT
"RTN","XLFJSONE",66,0)
 ;
"RTN","XLFJSONE",67,0)
 S XUX=$G(@XUROOT@(XUSUB)),XUDONE=0
"RTN","XLFJSONE",68,0)
 ; handle the numeric, boolean, and null types
"RTN","XLFJSONE",69,0)
 I $D(@XUROOT@(XUSUB,"\n")) S:$L(@XUROOT@(XUSUB,"\n")) XUX=@XUROOT@(XUSUB,"\n") D CONCAT QUIT  ; when +X'=X
"RTN","XLFJSONE",70,0)
 I '$D(@XUROOT@(XUSUB,"\s")),$L(XUX) D  QUIT:XUDONE
"RTN","XLFJSONE",71,0)
 . I XUX']]$C(1) S XUX=$$JNUM(XUX) D CONCAT S XUDONE=1 QUIT
"RTN","XLFJSONE",72,0)
 . I XUX="true"!(XUX="false")!(XUX="null") D CONCAT S XUDONE=1 QUIT
"RTN","XLFJSONE",73,0)
 ; otherwise treat it as a string type
"RTN","XLFJSONE",74,0)
 S XUX=""""_$$ESC(XUX) ; open quote
"RTN","XLFJSONE",75,0)
 D CONCAT
"RTN","XLFJSONE",76,0)
 I $D(@XUROOT@(XUSUB,"\")) D  ; handle continuation nodes
"RTN","XLFJSONE",77,0)
 . S XUI=0 F  S XUI=$O(@XUROOT@(XUSUB,"\",XUI)) Q:'XUI   D
"RTN","XLFJSONE",78,0)
 . . S XUX=$$ESC(@XUROOT@(XUSUB,"\",XUI))
"RTN","XLFJSONE",79,0)
 . . D CONCAT
"RTN","XLFJSONE",80,0)
 S XUX="""" D CONCAT    ; close quote
"RTN","XLFJSONE",81,0)
 Q
"RTN","XLFJSONE",82,0)
CONCAT ; come here to concatenate to JSON string
"RTN","XLFJSONE",83,0)
 I ($L(XUX)+$L(@XUJSON@(XULINE)))>XUMAX S XULINE=XULINE+1,@XUJSON@(XULINE)=""
"RTN","XLFJSONE",84,0)
 S @XUJSON@(XULINE)=@XUJSON@(XULINE)_XUX
"RTN","XLFJSONE",85,0)
 Q
"RTN","XLFJSONE",86,0)
ISVALUE(XUROOT,XUSUB) ; Return true if this is a value node
"RTN","XLFJSONE",87,0)
 I $D(@XUROOT@(XUSUB))#2 Q 1
"RTN","XLFJSONE",88,0)
 N XUX S XUX=$O(@XUROOT@(XUSUB,""))
"RTN","XLFJSONE",89,0)
 Q:XUX="\" 1  ; word processing continuation node
"RTN","XLFJSONE",90,0)
 Q:XUX=":" 1  ; pre-formatted JSON node
"RTN","XLFJSONE",91,0)
 Q 0
"RTN","XLFJSONE",92,0)
 ;
"RTN","XLFJSONE",93,0)
NUMERIC(X) ; Return true if the numeric
"RTN","XLFJSONE",94,0)
 I $L(X)>18 Q 0        ; string (too long for numeric)
"RTN","XLFJSONE",95,0)
 I X=0 Q 1             ; numeric (value is zero)
"RTN","XLFJSONE",96,0)
 I +X=0 Q 0            ; string
"RTN","XLFJSONE",97,0)
 I $E(X,1)="." Q 0     ; not a JSON number (although numeric in M)
"RTN","XLFJSONE",98,0)
 I $E(X,1,2)="-." Q 0  ; not a JSON number
"RTN","XLFJSONE",99,0)
 I +X=X Q 1            ; numeric
"RTN","XLFJSONE",100,0)
 I X?1"0."1.n Q 1      ; positive fraction
"RTN","XLFJSONE",101,0)
 I X?1"-0."1.N Q 1     ; negative fraction
"RTN","XLFJSONE",102,0)
 S X=$TR(X,"e","E")
"RTN","XLFJSONE",103,0)
 I X?.1"-"1.N.1".".N1"E".1"+"1.N Q 1  ; {-}99{.99}E{+}99
"RTN","XLFJSONE",104,0)
 I X?.1"-"1.N.1".".N1"E-"1.N Q 1      ; {-}99{.99}E-99
"RTN","XLFJSONE",105,0)
 Q 0
"RTN","XLFJSONE",106,0)
 ;
"RTN","XLFJSONE",107,0)
ESC(X) ; Escape string for JSON
"RTN","XLFJSONE",108,0)
 N Y,I,PAIR,FROM,TO
"RTN","XLFJSONE",109,0)
 S Y=X
"RTN","XLFJSONE",110,0)
 F PAIR="\\","""""","//",$C(8,98),$C(12,102),$C(10,110),$C(13,114),$C(9,116) D
"RTN","XLFJSONE",111,0)
 . S FROM=$E(PAIR),TO=$E(PAIR,2)
"RTN","XLFJSONE",112,0)
 . S X=Y,Y=$P(X,FROM) F I=2:1:$L(X,FROM) S Y=Y_"\"_TO_$P(X,FROM,I)
"RTN","XLFJSONE",113,0)
 I Y?.E1.C.E S X=Y,Y="" F I=1:1:$L(X) S FROM=$A(X,I) D
"RTN","XLFJSONE",114,0)
 . ; skip NUL character, otherwise encode ctrl-char
"RTN","XLFJSONE",115,0)
 . I FROM<32 Q:FROM=0  S Y=Y_$$UCODE(FROM) Q
"RTN","XLFJSONE",116,0)
 . I FROM>126,(FROM<160) S Y=Y_$$UCODE(FROM) Q
"RTN","XLFJSONE",117,0)
 . S Y=Y_$E(X,I)
"RTN","XLFJSONE",118,0)
 Q Y
"RTN","XLFJSONE",119,0)
 ;
"RTN","XLFJSONE",120,0)
JNUM(N) ; Return JSON representation of a number
"RTN","XLFJSONE",121,0)
 I N'<1 Q N
"RTN","XLFJSONE",122,0)
 I N'>-1 Q N
"RTN","XLFJSONE",123,0)
 I N>0 Q "0"_N
"RTN","XLFJSONE",124,0)
 I N<0 Q "-0"_$P(N,"-",2,9)
"RTN","XLFJSONE",125,0)
 Q N
"RTN","XLFJSONE",126,0)
 ;
"RTN","XLFJSONE",127,0)
UCODE(C) ; Return \u00nn representation of decimal character value
"RTN","XLFJSONE",128,0)
 N H S H="0000"_$$CNV^XLFUTL(C,16)
"RTN","XLFJSONE",129,0)
 Q "\u"_$E(H,$L(H)-3,$L(H))
"RTN","XLFJSONE",130,0)
 ;
"RTN","XLFJSONE",131,0)
ERRX(ID,VAL) ; Set the appropriate error message
"RTN","XLFJSONE",132,0)
 D ERRX^XLFJSON(ID,$G(VAL))
"RTN","XLFJSONE",133,0)
 Q
"VER")
8.0^22.2
"BLD",9906,6)
^530
**END**
**END**

