Released XWB*1.1*64 SEQ #50
Extracted from mail message
**KIDS**:XWB*1.1*64^

**INSTALL NAME**
XWB*1.1*64
"BLD",1515,0)
XWB*1.1*64^RPC BROKER^0^3160819^y
"BLD",1515,1,0)
^^3^3^3160610^
"BLD",1515,1,1,0)
RPC Broker IPv6 and Security Updates
"BLD",1515,1,2,0)
 
"BLD",1515,1,3,0)
Please see full patch description of XWB*1.1*64 on FORUM.
"BLD",1515,4,0)
^9.64PA^^
"BLD",1515,6.3)
12
"BLD",1515,"ABPKG")
n
"BLD",1515,"KRN",0)
^9.67PA^9002226^22
"BLD",1515,"KRN",.4,0)
.4
"BLD",1515,"KRN",.4,"NM",0)
^9.68A^^0
"BLD",1515,"KRN",.401,0)
.401
"BLD",1515,"KRN",.402,0)
.402
"BLD",1515,"KRN",.402,"NM",0)
^9.68A^^0
"BLD",1515,"KRN",.403,0)
.403
"BLD",1515,"KRN",.5,0)
.5
"BLD",1515,"KRN",.84,0)
.84
"BLD",1515,"KRN",3.6,0)
3.6
"BLD",1515,"KRN",3.8,0)
3.8
"BLD",1515,"KRN",9.2,0)
9.2
"BLD",1515,"KRN",9.8,0)
9.8
"BLD",1515,"KRN",9.8,"NM",0)
^9.68A^48^10
"BLD",1515,"KRN",9.8,"NM",38,0)
XWBSEC^^0^B7994154
"BLD",1515,"KRN",9.8,"NM",39,0)
XWBTCP^^0^B52455677
"BLD",1515,"KRN",9.8,"NM",41,0)
XWBLIB^^0^B12517102
"BLD",1515,"KRN",9.8,"NM",42,0)
XWBTCPM^^0^B57009144
"BLD",1515,"KRN",9.8,"NM",43,0)
XWBTCPMT^^0^B11606585
"BLD",1515,"KRN",9.8,"NM",44,0)
XWBPRS^^0^B75191540
"BLD",1515,"KRN",9.8,"NM",45,0)
XWBTCPM1^^0^B7816209
"BLD",1515,"KRN",9.8,"NM",46,0)
XWBRM^^0^B17663584
"BLD",1515,"KRN",9.8,"NM",47,0)
XWBRW^^0^B9339344
"BLD",1515,"KRN",9.8,"NM",48,0)
XWBM2MC^^0^B58791461
"BLD",1515,"KRN",9.8,"NM","B","XWBLIB",41)

"BLD",1515,"KRN",9.8,"NM","B","XWBM2MC",48)

"BLD",1515,"KRN",9.8,"NM","B","XWBPRS",44)

"BLD",1515,"KRN",9.8,"NM","B","XWBRM",46)

"BLD",1515,"KRN",9.8,"NM","B","XWBRW",47)

"BLD",1515,"KRN",9.8,"NM","B","XWBSEC",38)

"BLD",1515,"KRN",9.8,"NM","B","XWBTCP",39)

"BLD",1515,"KRN",9.8,"NM","B","XWBTCPM",42)

"BLD",1515,"KRN",9.8,"NM","B","XWBTCPM1",45)

"BLD",1515,"KRN",9.8,"NM","B","XWBTCPMT",43)

"BLD",1515,"KRN",19,0)
19
"BLD",1515,"KRN",19,"NM",0)
^9.68A^^0
"BLD",1515,"KRN",19.1,0)
19.1
"BLD",1515,"KRN",101,0)
101
"BLD",1515,"KRN",101,"NM",0)
^9.68A^^0
"BLD",1515,"KRN",409.61,0)
409.61
"BLD",1515,"KRN",409.61,"NM",0)
^9.68A^^0
"BLD",1515,"KRN",771,0)
771
"BLD",1515,"KRN",771,"NM",0)
^9.68A^^0
"BLD",1515,"KRN",779.2,0)
779.2
"BLD",1515,"KRN",870,0)
870
"BLD",1515,"KRN",870,"NM",0)
^9.68A^^0
"BLD",1515,"KRN",8989.51,0)
8989.51
"BLD",1515,"KRN",8989.51,"NM",0)
^9.68A^^0
"BLD",1515,"KRN",8989.52,0)
8989.52
"BLD",1515,"KRN",8993,0)
8993
"BLD",1515,"KRN",8994,0)
8994
"BLD",1515,"KRN",8994,"NM",0)
^9.68A^4^4
"BLD",1515,"KRN",8994,"NM",1,0)
XWB ARE RPCS AVAILABLE^^0
"BLD",1515,"KRN",8994,"NM",2,0)
XWB GET VARIABLE VALUE^^0
"BLD",1515,"KRN",8994,"NM",3,0)
XWB IS RPC AVAILABLE^^0
"BLD",1515,"KRN",8994,"NM",4,0)
XWB CREATE CONTEXT^^0
"BLD",1515,"KRN",8994,"NM","B","XWB ARE RPCS AVAILABLE",1)

"BLD",1515,"KRN",8994,"NM","B","XWB CREATE CONTEXT",4)

"BLD",1515,"KRN",8994,"NM","B","XWB GET VARIABLE VALUE",2)

"BLD",1515,"KRN",8994,"NM","B","XWB IS RPC AVAILABLE",3)

"BLD",1515,"KRN",9002226,0)
9002226
"BLD",1515,"KRN","B",.4,.4)

"BLD",1515,"KRN","B",.401,.401)

"BLD",1515,"KRN","B",.402,.402)

"BLD",1515,"KRN","B",.403,.403)

"BLD",1515,"KRN","B",.5,.5)

"BLD",1515,"KRN","B",.84,.84)

"BLD",1515,"KRN","B",3.6,3.6)

"BLD",1515,"KRN","B",3.8,3.8)

"BLD",1515,"KRN","B",9.2,9.2)

"BLD",1515,"KRN","B",9.8,9.8)

"BLD",1515,"KRN","B",19,19)

"BLD",1515,"KRN","B",19.1,19.1)

"BLD",1515,"KRN","B",101,101)

"BLD",1515,"KRN","B",409.61,409.61)

"BLD",1515,"KRN","B",771,771)

"BLD",1515,"KRN","B",779.2,779.2)

"BLD",1515,"KRN","B",870,870)

"BLD",1515,"KRN","B",8989.51,8989.51)

"BLD",1515,"KRN","B",8989.52,8989.52)

"BLD",1515,"KRN","B",8993,8993)

"BLD",1515,"KRN","B",8994,8994)

"BLD",1515,"KRN","B",9002226,9002226)

"BLD",1515,"QUES",0)
^9.62^^
"BLD",1515,"REQB",0)
^9.611^5^5
"BLD",1515,"REQB",1,0)
XWB*1.1*53^1
"BLD",1515,"REQB",2,0)
XU*8.0*638^1
"BLD",1515,"REQB",3,0)
XU*8.0*655^1
"BLD",1515,"REQB",4,0)
XWB*1.1*57^1
"BLD",1515,"REQB",5,0)
XWB*1.1*62^1
"BLD",1515,"REQB","B","XU*8.0*638",2)

"BLD",1515,"REQB","B","XU*8.0*655",3)

"BLD",1515,"REQB","B","XWB*1.1*53",1)

"BLD",1515,"REQB","B","XWB*1.1*57",4)

"BLD",1515,"REQB","B","XWB*1.1*62",5)

"KRN",8994,9,-1)
0^2
"KRN",8994,9,0)
XWB GET VARIABLE VALUE^VARVAL^XWBLIB^1^S^0^^^1^^1
"KRN",8994,9,1,0)
^8994.01^10^10^3151217^^^
"KRN",8994,9,1,1,0)
This RPC accepts the name of a variable which will be evaluated and its
"KRN",8994,9,1,2,0)
value returned to the server.  For example, this RPC may be called with
"KRN",8994,9,1,3,0)
a parameter variable like DUZ which will be returned as 123456.
"KRN",8994,9,1,4,0)
 
"KRN",8994,9,1,5,0)
It should NOT be used to return the value of anything other than a 
"KRN",8994,9,1,6,0)
variable. For example, the RPC should not attempt to return the value of 
"KRN",8994,9,1,7,0)
a global or function call, as these are unsupported uses of the RPC and 
"KRN",8994,9,1,8,0)
are not guaranteed to work consistently.
"KRN",8994,9,1,9,0)
 
"KRN",8994,9,1,10,0)
Integration Agreement (IA) #1629
"KRN",8994,9,2,0)
^8994.02A^1^1
"KRN",8994,9,2,1,0)
VARIABLE^4^30^1^1
"KRN",8994,9,2,1,1,0)
^^1^1^3150528^
"KRN",8994,9,2,1,1,1,0)
Name of M environment variable whose value is to be returned.
"KRN",8994,9,2,"B","VARIABLE",1)

"KRN",8994,9,2,"PARAMSEQ",1,1)

"KRN",8994,10,-1)
0^4
"KRN",8994,10,0)
XWB CREATE CONTEXT^CRCONTXT^XWBSEC^1^S^0^^^1^^1
"KRN",8994,10,1,0)
^8994.01^20^20^3151217^^
"KRN",8994,10,1,1,0)
Establishes context on the server, which will be checked by the Broker before
"KRN",8994,10,1,2,0)
executing any other remote procedure.  Since context is nothing more than a
"KRN",8994,10,1,3,0)
client/server "B"-type option in the OPTION file (#19), standard MenuMan
"KRN",8994,10,1,4,0)
security is applied in establishing a context.  Therefore, a context option
"KRN",8994,10,1,5,0)
can be granted to user(s) exactly the same way as regular options are done
"KRN",8994,10,1,6,0)
using MenuMan.
"KRN",8994,10,1,7,0)
 
"KRN",8994,10,1,8,0)
A context can not be established for the following reasons:
"KRN",8994,10,1,9,0)
 
"KRN",8994,10,1,10,0)
       · The user has no access to that option
"KRN",8994,10,1,11,0)
 
"KRN",8994,10,1,12,0)
       · The option is temporarily out of order
"KRN",8994,10,1,13,0)
 
"KRN",8994,10,1,14,0)
An application can switch from one context to another as often as it needs to.
"KRN",8994,10,1,15,0)
Each time a context is created the previous context is overwritten.
"KRN",8994,10,1,16,0)
 
"KRN",8994,10,1,17,0)
For more information on creating a context and the overall Broker security
"KRN",8994,10,1,18,0)
see Broker on-line help documentation.
"KRN",8994,10,1,19,0)
 
"KRN",8994,10,1,20,0)
Integration Agreement (IA) #1751
"KRN",8994,39,-1)
0^3
"KRN",8994,39,0)
XWB IS RPC AVAILABLE^CKRPC^XWBLIB^1^S^0^^^1^^1
"KRN",8994,39,1,0)
^8994.01^5^5^3151217^^
"KRN",8994,39,1,1,0)
If RPC is installed, available in relevant context, and of proper version
"KRN",8994,39,1,2,0)
returns 1.  
"KRN",8994,39,1,3,0)
Otherwise, returns 0.
"KRN",8994,39,1,4,0)
 
"KRN",8994,39,1,5,0)
Integration Agreement (IA) #3011
"KRN",8994,39,2,0)
^8994.02A^3^3
"KRN",8994,39,2,1,0)
RPC^1^30^1^1
"KRN",8994,39,2,1,1,0)
^^1^1^2991013^^^^
"KRN",8994,39,2,1,1,1,0)
Name of the RPC to be tested.
"KRN",8994,39,2,2,0)
RUN CONTEXT^1^1^0^2
"KRN",8994,39,2,2,1,0)
^^8^8^2991013^^
"KRN",8994,39,2,2,1,1,0)
Specific context in which RPC will run.  Possible values are:
"KRN",8994,39,2,2,1,2,0)
     L  =  run Locally (on the server the user is logged on to)
"KRN",8994,39,2,2,1,3,0)
     R  =  run Remotely (on a server the user is not logged on to)
"KRN",8994,39,2,2,1,4,0)
If this parameter is not sent, RPC is checked for both local and
"KRN",8994,39,2,2,1,5,0)
remote.
"KRN",8994,39,2,2,1,6,0)
 
"KRN",8994,39,2,2,1,7,0)
The check is done against the value in the INACTIVE field in the 
"KRN",8994,39,2,2,1,8,0)
Remote Procedure file.  See that field's description for more details.
"KRN",8994,39,2,3,0)
VERSION NUMBER^1^11^0^3
"KRN",8994,39,2,3,1,0)
^8994.021^7^7^3150528^^^^
"KRN",8994,39,2,3,1,1,0)
Minimum version number of the RPC.
"KRN",8994,39,2,3,1,2,0)
 
"KRN",8994,39,2,3,1,3,0)
This parameter is only used if the RUN CONTEXT parameter = "R".  If a
"KRN",8994,39,2,3,1,4,0)
numeric value is in this parameter, the value must be less than or equal
"KRN",8994,39,2,3,1,5,0)
to the value in the VERSION field of the Remote Procedure file for the
"KRN",8994,39,2,3,1,6,0)
RPC is be marked available.  Note: if the VERSION field is null, the
"KRN",8994,39,2,3,1,7,0)
check will fail for any numeric value in this parameter.
"KRN",8994,39,2,"B","RPC",1)

"KRN",8994,39,2,"B","RUN CONTEXT",2)

"KRN",8994,39,2,"B","VERSION NUMBER",3)

"KRN",8994,39,2,"PARAMSEQ",1,1)

"KRN",8994,39,2,"PARAMSEQ",2,2)

"KRN",8994,39,2,"PARAMSEQ",3,3)

"KRN",8994,39,3,0)
^8994.03^2^2^3150528^^
"KRN",8994,39,3,1,0)
Boolean.  1 = RPC available.
"KRN",8994,39,3,2,0)
          0 = RPC not available.
"KRN",8994,48,-1)
0^1
"KRN",8994,48,0)
XWB ARE RPCS AVAILABLE^CKRPCS^XWBLIB^2^S^0^^^1^^1
"KRN",8994,48,1,0)
^8994.01^4^4^3151217^^
"KRN",8994,48,1,1,0)
If RPC in the passed array is installed, available in relevant context,
"KRN",8994,48,1,2,0)
and of proper version returns 1 for that RPC. Otherwise, returns 0.
"KRN",8994,48,1,3,0)
 
"KRN",8994,48,1,4,0)
Integration Agreement (IA) #3012
"KRN",8994,48,2,0)
^8994.02A^2^2
"KRN",8994,48,2,1,0)
RPC^2^40^1^2
"KRN",8994,48,2,1,1,0)
^^10^10^2991207^
"KRN",8994,48,2,1,1,1,0)
This 0-based array contains list of RPCs to be checked along with
"KRN",8994,48,2,1,1,2,0)
(optionally) a minimum acceptable version of the RPC.  The format is:
"KRN",8994,48,2,1,1,3,0)
 
"KRN",8994,48,2,1,1,4,0)
                RPCName^RPCVersionNumber
"KRN",8994,48,2,1,1,5,0)
 
"KRN",8994,48,2,1,1,6,0)
Th RPCVersionNumber is only used if the RUN CONTEXT parameter = "R".  If a
"KRN",8994,48,2,1,1,7,0)
numeric value is in the second ^-piece and the RUN CONTEXT ="R", the value
"KRN",8994,48,2,1,1,8,0)
must be less than or equal to the value in the VERSION field of the Remote
"KRN",8994,48,2,1,1,9,0)
Procedure file for the RPC to be marked available.  Note: if the VERSION
"KRN",8994,48,2,1,1,10,0)
field is null, the check will fail for any numeric value.
"KRN",8994,48,2,2,0)
RUN CONTEXT^1^1^0^1
"KRN",8994,48,2,2,1,0)
^8994.021^8^8^3150528^^^^
"KRN",8994,48,2,2,1,1,0)
Specific context in which RPCs will run.  Possible values are:
"KRN",8994,48,2,2,1,2,0)
      L  =  run Locally (on the server the user is logged on to)
"KRN",8994,48,2,2,1,3,0)
      R  =  run Remotely (on a server the user is not logged on to)
"KRN",8994,48,2,2,1,4,0)
If this parameter is not sent, RPC is checked for both local and
"KRN",8994,48,2,2,1,5,0)
remote.
"KRN",8994,48,2,2,1,6,0)
 
"KRN",8994,48,2,2,1,7,0)
The check is done against the value in the INACTIVE field in the 
"KRN",8994,48,2,2,1,8,0)
Remote Procedure file.  See that field's description for more details.
"KRN",8994,48,2,"B","RPC",1)

"KRN",8994,48,2,"B","RUN CONTEXT",2)

"KRN",8994,48,2,"PARAMSEQ",1,2)

"KRN",8994,48,2,"PARAMSEQ",2,1)

"KRN",8994,48,3,0)
^8994.03^3^3^3150528^^^^
"KRN",8994,48,3,1,0)
A 0-based array.  The index corresponds to the index of the RPC in the RPC
"KRN",8994,48,3,2,0)
Input Parameter.  A value of 1 means the corresponding RPC is available; a
"KRN",8994,48,3,3,0)
value of 0 means it is not available.
"MBREQ")
0
"ORD",16,8994)
8994;16;1;;;;;;;RPCDEL^XPDIA1
"ORD",16,8994,0)
REMOTE PROCEDURE
"PKG",8,-1)
1^1
"PKG",8,0)
RPC BROKER^XWB^Remote Procedure Call Broker^
"PKG",8,22,0)
^9.49I^1^1
"PKG",8,22,1,0)
1.1^2970918^2971120^7
"PKG",8,22,1,"PAH",1,0)
64^3160819
"PKG",8,22,1,"PAH",1,1,0)
^^3^3^3160819
"PKG",8,22,1,"PAH",1,1,1,0)
RPC Broker IPv6 and Security Updates
"PKG",8,22,1,"PAH",1,1,2,0)
 
"PKG",8,22,1,"PAH",1,1,3,0)
Please see full patch description of XWB*1.1*64 on FORUM.
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
NO
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
NO
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
NO
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
10
"RTN","XWBLIB")
0^41^B12517102^B10132147
"RTN","XWBLIB",1,0)
XWBLIB ;SFISC/VYD - Various remote procedure library ;05/28/15  09:43
"RTN","XWBLIB",2,0)
 ;;1.1;RPC BROKER;**6,10,26,35,64**;Mar 28, 1997;Build 12
"RTN","XWBLIB",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","XWBLIB",4,0)
 ;
"RTN","XWBLIB",5,0)
 Q
"RTN","XWBLIB",6,0)
 ;
"RTN","XWBLIB",7,0)
BROKER() ;EF. Running under the Broker or Vlink
"RTN","XWBLIB",8,0)
 ;Function to check for the existence of two environment variables
"RTN","XWBLIB",9,0)
 ;ZEXCEPT: XOBDATA,XWBOS ;Environment variables
"RTN","XWBLIB",10,0)
 Q $D(XWBOS)!$D(XOBDATA)
"RTN","XWBLIB",11,0)
 ;
"RTN","XWBLIB",12,0)
RTRNFMT(X,WRAP) ;EF. set the RPC return type and wrap flag
"RTN","XWBLIB",13,0)
 ;ZEXCEPT: XWBPTYPE,XWBWRAP ;Environment variables
"RTN","XWBLIB",14,0)
 N Y
"RTN","XWBLIB",15,0)
 S:$D(WRAP) XWBWRAP=+WRAP
"RTN","XWBLIB",16,0)
 S X=$G(X)
"RTN","XWBLIB",17,0)
 I X=+X,X>0,X<6 S XWBPTYPE=X Q X
"RTN","XWBLIB",18,0)
 S X=$$UP^XLFSTR(X)
"RTN","XWBLIB",19,0)
 S X=$S(X="SINGLE VALUE":1,X="ARRAY":2,X="WORD PROCESSING":3,X="GLOBAL ARRAY":4,X="GLOBAL INSTANCE":5,1:0)
"RTN","XWBLIB",20,0)
 I X=0 Q 0
"RTN","XWBLIB",21,0)
 S XWBPTYPE=X
"RTN","XWBLIB",22,0)
 Q X
"RTN","XWBLIB",23,0)
 ;
"RTN","XWBLIB",24,0)
VARVAL(RESULT,VARIABLE) ;RPC. XWB GET VARIABLE VALUE
"RTN","XWBLIB",25,0)
 ;Controlled subscription, IA#1629
"RTN","XWBLIB",26,0)
 N X
"RTN","XWBLIB",27,0)
 ;If sign-on Level of Assurance is low, deny access to data (OMB 04-04 and NIST SP 800-63-2)
"RTN","XWBLIB",28,0)
 I $G(DUZ("LOA"))<2 H 1 ;S RESULT="" Q  ;Not fully implemented on all interfaces
"RTN","XWBLIB",29,0)
 S X=$$UP^XLFSTR(VARIABLE)
"RTN","XWBLIB",30,0)
 I X["$G(^" H 1 ;S RESULT="" Q  ;Close security hole
"RTN","XWBLIB",31,0)
 I X["$GET(^" H 1 ;S RESULT="" Q  ;Close security hole
"RTN","XWBLIB",32,0)
 I X["$O(^" H 1 ;S RESULT="" Q  ;Close security hole
"RTN","XWBLIB",33,0)
 I X["$ORDER(^" H 1 ;S RESULT="" Q  ;Close security hole
"RTN","XWBLIB",34,0)
 S RESULT=VARIABLE
"RTN","XWBLIB",35,0)
 Q
"RTN","XWBLIB",36,0)
 ;
"RTN","XWBLIB",37,0)
IMHERE(RESULT) ;RPC. XWB IM HERE
"RTN","XWBLIB",38,0)
 ;Entry point for XWB IM HERE remote procedure
"RTN","XWBLIB",39,0)
 S RESULT=1
"RTN","XWBLIB",40,0)
 Q
"RTN","XWBLIB",41,0)
 ;
"RTN","XWBLIB",42,0)
BRKRINFO(RESULT) ;RPC. XWB GET BROKER INFO RPC
"RTN","XWBLIB",43,0)
 ;R(0) = Length of handler read timeout
"RTN","XWBLIB",44,0)
 S RESULT(0)=$$BAT^XUPARAM
"RTN","XWBLIB",45,0)
 Q
"RTN","XWBLIB",46,0)
 ;
"RTN","XWBLIB",47,0)
CKRPC(RESULT,RPCNAME,RPCUSE,VERNUM) ;RPC. XWB IS RPC AVAILABLE
"RTN","XWBLIB",48,0)
 ;Controlled subscription, IA#3011
"RTN","XWBLIB",49,0)
 ;RPCUSE("L" or "R") and VERNUM are optional.
"RTN","XWBLIB",50,0)
 ;Checks if RPC exists and if INACTIVE flag is set for specified use.
"RTN","XWBLIB",51,0)
 ;Also checks version number if passed.
"RTN","XWBLIB",52,0)
 ;Result = 1 for can be run; 0 for can't be run.
"RTN","XWBLIB",53,0)
 N RPCIEN
"RTN","XWBLIB",54,0)
 S RESULT=0
"RTN","XWBLIB",55,0)
 S RPCIEN=$$RPCIEN($G(RPCNAME))
"RTN","XWBLIB",56,0)
 I RPCIEN,$$RPCAVAIL(RPCIEN,$G(RPCUSE),$G(VERNUM)) S RESULT=1
"RTN","XWBLIB",57,0)
 Q
"RTN","XWBLIB",58,0)
 ;
"RTN","XWBLIB",59,0)
CKRPCS(RESULT,RPCUSE,RPC) ;RPC. XWB ARE RPCS AVAILABLE
"RTN","XWBLIB",60,0)
 ;Controlled subscription, IA#3012
"RTN","XWBLIB",61,0)
 ;RPCUSE("L" or "R") and VERNUM are optional.
"RTN","XWBLIB",62,0)
 ;RPC() array has format RPCName^RPCVersionNumber.
"RTN","XWBLIB",63,0)
 ;Checks if RPC exists and version number (if not null).
"RTN","XWBLIB",64,0)
 ;Check INACTIVE flag if set for specified use.
"RTN","XWBLIB",65,0)
 ;Result(I) = 1 for can be run; 0 for can't be run.
"RTN","XWBLIB",66,0)
 N I
"RTN","XWBLIB",67,0)
 S I=""
"RTN","XWBLIB",68,0)
 F  S I=$O(RPC(I)) Q:I=""  D
"RTN","XWBLIB",69,0)
 . N RPCNAME,VERNUM,RPCIEN
"RTN","XWBLIB",70,0)
 . S RESULT(I)=0
"RTN","XWBLIB",71,0)
 . S RPCNAME=$P(RPC(I),U)
"RTN","XWBLIB",72,0)
 . S VERNUM=$P(RPC(I),U,2)
"RTN","XWBLIB",73,0)
 . S RPCIEN=$$RPCIEN($G(RPCNAME))
"RTN","XWBLIB",74,0)
 . I RPCIEN,$$RPCAVAIL(RPCIEN,$G(RPCUSE),$G(VERNUM)) S RESULT(I)=1
"RTN","XWBLIB",75,0)
 Q
"RTN","XWBLIB",76,0)
 ;
"RTN","XWBLIB",77,0)
RPCIEN(RPCNAME) ;P10
"RTN","XWBLIB",78,0)
 ;Function that returns IEN of RPC based on name.
"RTN","XWBLIB",79,0)
 ;Returns 0 if RPC does not exist.
"RTN","XWBLIB",80,0)
 I RPCNAME="" Q 0
"RTN","XWBLIB",81,0)
 Q +$O(^XWB(8994,"B",RPCNAME,0))
"RTN","XWBLIB",82,0)
 ;
"RTN","XWBLIB",83,0)
RPCAVAIL(RPCIEN,RPCUSE,VERNUM) ;P10
"RTN","XWBLIB",84,0)
 ;Boolean function, identifies if RPC is active and correct version.
"RTN","XWBLIB",85,0)
 ;RPCUSE (optional) = L check local use; R check remote use.
"RTN","XWBLIB",86,0)
 ;VERNUM (optional) only checked for remote RPCs.
"RTN","XWBLIB",87,0)
 N RPC0,INACT
"RTN","XWBLIB",88,0)
 S RPC0=$G(^XWB(8994,+RPCIEN,0))
"RTN","XWBLIB",89,0)
 Q:RPC0="" 0
"RTN","XWBLIB",90,0)
 S INACT=+$P(RPC0,U,6)
"RTN","XWBLIB",91,0)
 I INACT=1 Q 0 ;RPC marked inactive.
"RTN","XWBLIB",92,0)
 S RPCUSE=$G(RPCUSE)
"RTN","XWBLIB",93,0)
 I RPCUSE="" Q 1 ;Local and remote check not needed.
"RTN","XWBLIB",94,0)
 I RPCUSE="L",INACT=2 Q 0 ;Local use, RPC is remote only.
"RTN","XWBLIB",95,0)
 I RPCUSE="R",INACT=3 Q 0 ;Remote use, RPC is local only.
"RTN","XWBLIB",96,0)
 I RPCUSE="R",+$G(VERNUM),'$$CKVERNUM(VERNUM,+$P(RPC0,U,9)) Q 0 ;Failed version # check.
"RTN","XWBLIB",97,0)
 Q 1 ;Must be ok.
"RTN","XWBLIB",98,0)
 ;
"RTN","XWBLIB",99,0)
CKVERNUM(VERNUM,RPCVER,RPCIEN) ;P10
"RTN","XWBLIB",100,0)
 ;Boolean function. Returns 1 if RPC verion is > or = version number to be checked.
"RTN","XWBLIB",101,0)
 ;VERNUM = version number passed in (i.e., from client ap) to be checked.
"RTN","XWBLIB",102,0)
 ;RPCVER = version number in Remote Procedure file. (optional)
"RTN","XWBLIB",103,0)
 ;RPCIEN of RPC being checked. Needed if RPCVER not sent.
"RTN","XWBLIB",104,0)
 I +$G(RPCIEN),'+$G(RPCVER) S RPCVER=$P($G(^XWB(8994,RPCIEN,0)),U,9)
"RTN","XWBLIB",105,0)
 I +RPCVER<+VERNUM Q 0
"RTN","XWBLIB",106,0)
 Q 1
"RTN","XWBLIB",107,0)
 ;
"RTN","XWBLIB",108,0)
VARLST ;;XWB,XWBAPVER,XWBCLMAN,XWBNULL,XWBODEV,XWBOS,XWBP,XWBPTYPE,XWBR,XWBSEC,XWBSTATE,XWBTBUF,XWBTDEV,XWBTIME,XWBTIP,XWBTOS,XWBTSKT,XWBVER,XWBWRAP,XWBY,DEBUG,XWBSHARE,XWBDEBUG,XWBT
"RTN","XWBLIB",109,0)
 ;P10.  Variable for exclusive NEW in KILL^XUSCLEAN
"RTN","XWBLIB",110,0)
 ;P26.  Added XWBSHARE
"RTN","XWBLIB",111,0)
 ;P35.  Added XWBDEBUG,XWBT
"RTN","XWBM2MC")
0^48^B58791461^B58578138
"RTN","XWBM2MC",1,0)
XWBM2MC ;OIFO-Oakland/REM - M2M Broker Client APIs  ;09/15/15  06:18
"RTN","XWBM2MC",2,0)
 ;;1.1;RPC BROKER;**28,34,64**;Mar 28, 1997;Build 12
"RTN","XWBM2MC",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","XWBM2MC",4,0)
 ;
"RTN","XWBM2MC",5,0)
 QUIT
"RTN","XWBM2MC",6,0)
 ;
"RTN","XWBM2MC",7,0)
 ;p34 -make sure RES is defined - CALLRPC.
"RTN","XWBM2MC",8,0)
 ;    -error exception if RPCNAM not defined - CALLRPC.
"RTN","XWBM2MC",9,0)
 ;    -kill XWBY before going to PARSE^XWBRPC - CALLRPC.
"RTN","XWBM2MC",10,0)
 ;    -return 0 when error occurs and XWBY=error msg - CALLRPC.
"RTN","XWBM2MC",11,0)
 ;    -new module to GET the division for a user - GETDIV.
"RTN","XWBM2MC",12,0)
 ;    -new module to SET the division for a user - SETDIV.
"RTN","XWBM2MC",13,0)
 ;    -kills entry for current context in ^TMP("XWBM2M",$J) - CLEAN.
"RTN","XWBM2MC",14,0)
 ;    -comment out line. Will do PRE in REQUEST^XWBRPCC - PARAM.
"RTN","XWBM2MC",15,0)
 ;    -send PORT;IP to ERROR so it's included in error msg - ERROR.
"RTN","XWBM2MC",16,0)
 ;    -add 2 more error msg for GETDIV and SETDIV - ERRMGS.
"RTN","XWBM2MC",17,0)
 ;
"RTN","XWBM2MC",18,0)
CONNECT(PORT,IP,AV) ;Establishes the connection to the server.
"RTN","XWBM2MC",19,0)
 ;CONNECT returns 1=successful, 0=failed
"RTN","XWBM2MC",20,0)
 ;PORT - PORT number where listener is running.
"RTN","XWBM2MC",21,0)
 ;IP - IP address where the listener is running.
"RTN","XWBM2MC",22,0)
 ;AV - Access and verify codes to sign on into VistA.
"RTN","XWBM2MC",23,0)
 ;DIV - User division.
"RTN","XWBM2MC",24,0)
 ;
"RTN","XWBM2MC",25,0)
 ;K XWBPARMS
"RTN","XWBM2MC",26,0)
 N XWBSTAT,XWBPARMS
"RTN","XWBM2MC",27,0)
 S XWBPARMS("ADDRESS")=IP,XWBPARMS("PORT")=PORT
"RTN","XWBM2MC",28,0)
 S XWBPARMS("RETRIES")=3 ;Retries 3 times to open
"RTN","XWBM2MC",29,0)
 ;
"RTN","XWBM2MC",30,0)
 ;p34-send PORT;IP to ERROR so it's included in error msg.
"RTN","XWBM2MC",31,0)
 I '$$OPEN^XWBRL(.XWBPARMS) D ERROR(1,PORT_";"_IP) Q 0
"RTN","XWBM2MC",32,0)
 D SAVDEV^%ZISUTL("XWBM2M PORT")
"RTN","XWBM2MC",33,0)
 ;
"RTN","XWBM2MC",34,0)
 ;XUS SIGNON SETUP RPC
"RTN","XWBM2MC",35,0)
 I '$$SIGNON() D ERROR(2) S X=$$CLOSE() Q 0
"RTN","XWBM2MC",36,0)
 ; Results from XUS Signon
"RTN","XWBM2MC",37,0)
 ; 1=server name, 2=volume, 3=uci, 4=device, 5=# attempts
"RTN","XWBM2MC",38,0)
 ; 6=skip signon-screen
"RTN","XWBM2MC",39,0)
 ;M ^TMP("XWBM2M",$J,"XUS SIGNON")=^TMP("XWBM2MRPC",$J,"RESULTS") ;Remove after testing **REM
"RTN","XWBM2MC",40,0)
 ;
"RTN","XWBM2MC",41,0)
 ;Validate AV codes
"RTN","XWBM2MC",42,0)
 ;S AV=$$CHARCHK^XWBUTL(AV) ;Convert and special char
"RTN","XWBM2MC",43,0)
 I '$$VALIDAV(AV) D ERROR(3) S X=$$CLOSE() Q 0
"RTN","XWBM2MC",44,0)
 ;
"RTN","XWBM2MC",45,0)
 I $G(^TMP("XWBM2MRPC",$J,"RESULTS",1))'>0 D ERROR(4) S X=$$CLOSE() Q 0
"RTN","XWBM2MC",46,0)
 ;M ^TMP("XWBM2M",$J,"XUS AV CODE")=^TMP("XWBM2MRPC",$J,"RESULTS") ;Remove after testing **REM
"RTN","XWBM2MC",47,0)
 ;
"RTN","XWBM2MC",48,0)
 D USE^%ZISUTL("XWBM2M CLIENT") U IO
"RTN","XWBM2MC",49,0)
 S ^TMP("XWBM2M",$J,"CONNECTED")=1
"RTN","XWBM2MC",50,0)
 Q 1
"RTN","XWBM2MC",51,0)
 ;
"RTN","XWBM2MC",52,0)
ISCONT() ;Function to check connection status. 1=connect, 0=not connect
"RTN","XWBM2MC",53,0)
 Q $G(^TMP("XWBM2M",$J,"CONNECTED"),0)
"RTN","XWBM2MC",54,0)
 ;
"RTN","XWBM2MC",55,0)
SETCONTX(CONTXNA) ;Set context and returns 1=successful or 0=failed
"RTN","XWBM2MC",56,0)
 N REQ,XWBPARMS,X
"RTN","XWBM2MC",57,0)
 S ^TMP("XWBM2M",$J,"CONTEXT")=""
"RTN","XWBM2MC",58,0)
 K ^TMP("XWBM2M",$J,"ERROR","SETCONTX")
"RTN","XWBM2MC",59,0)
 ;;D PRE,SETPARAM(1,"STRING",$$CHARCHK^XWBUTL($$ENCRYP^XUSRB1(CONTXNA)))
"RTN","XWBM2MC",60,0)
 D PRE,SETPARAM(1,"STRING",$$ENCRYP^XUSRB1(CONTXNA))
"RTN","XWBM2MC",61,0)
 S X=$$CALLRPC("XWB CREATE CONTEXT","REQ",1)
"RTN","XWBM2MC",62,0)
 S REQ=$G(REQ(1))
"RTN","XWBM2MC",63,0)
 I REQ'=1 S ^TMP("XWBM2ME",$J,"ERROR","SETCONTX")=REQ Q 0
"RTN","XWBM2MC",64,0)
 S ^TMP("XWBM2M",$J,"CONTEXT")=CONTXNA
"RTN","XWBM2MC",65,0)
 Q 1
"RTN","XWBM2MC",66,0)
 ;
"RTN","XWBM2MC",67,0)
GETCONTX(CONTEXT) ;Returns current context
"RTN","XWBM2MC",68,0)
 S CONTEXT=$G(^TMP("XWBM2M",$J,"CONTEXT"))
"RTN","XWBM2MC",69,0)
 I CONTEXT="" Q 0
"RTN","XWBM2MC",70,0)
 Q 1
"RTN","XWBM2MC",71,0)
 ;
"RTN","XWBM2MC",72,0)
SETPARAM(INDEX,TYPE,VALUE) ;Set a Params entry
"RTN","XWBM2MC",73,0)
 S XWBPARMS("PARAMS",INDEX,"TYPE")=TYPE
"RTN","XWBM2MC",74,0)
 S XWBPARMS("PARAMS",INDEX,"VALUE")=VALUE
"RTN","XWBM2MC",75,0)
 Q
"RTN","XWBM2MC",76,0)
 ;
"RTN","XWBM2MC",77,0)
PARAM(PARAMNUM,ROOT) ;Build the PARAM data structure
"RTN","XWBM2MC",78,0)
 ;p34-comment out line. Will do PRE in REQUEST^XWBRPCC
"RTN","XWBM2MC",79,0)
 ;
"RTN","XWBM2MC",80,0)
 I PARAMNUM=""!(ROOT="") Q 0
"RTN","XWBM2MC",81,0)
 ;D PRE ;*p34
"RTN","XWBM2MC",82,0)
 M XWBPARMS("PARAMS",PARAMNUM)=@ROOT
"RTN","XWBM2MC",83,0)
 Q 1
"RTN","XWBM2MC",84,0)
 ;
"RTN","XWBM2MC",85,0)
CALLRPC(RPCNAM,RES,CLRPARMS) ;Call to RPC and wraps RPC in XML
"RTN","XWBM2MC",86,0)
 ;RPCNAM -RPC name to run
"RTN","XWBM2MC",87,0)
 ;RES -location where to place results.  If no RES, then results will be
"RTN","XWBM2MC",88,0)
 ; placed in ^TMP("XWBM2M",$J,"RESULTS")
"RTN","XWBM2MC",89,0)
 ;CLRPARMS - 1=clear PARAMS, 0=do not clear PARAMS.  Default is 1.
"RTN","XWBM2MC",90,0)
 ;
"RTN","XWBM2MC",91,0)
 N ER,ERX,GL
"RTN","XWBM2MC",92,0)
 I '$D(RES) S RES="" ;*p34-make sure RES is defined.
"RTN","XWBM2MC",93,0)
 I '$D(RPCNAM) D  Q 0  ;*p34-error if RPCNAM not defined.
"RTN","XWBM2MC",94,0)
 .I $G(RES)'="" S @RES="Pass in NULL for RPCNAM."
"RTN","XWBM2MC",95,0)
 .I $G(RES)="" S ^TMP("XWBM2MRPC",$J,"RESULTS",1)="Pass in NULL for RPCNAM."
"RTN","XWBM2MC",96,0)
 K ^TMP("XWBM2MRPC",$J,"RESULTS") ;Clear before run new RPC
"RTN","XWBM2MC",97,0)
 K ^TMP("XWBM2ME",$J,"ERROR","CALLRPC")
"RTN","XWBM2MC",98,0)
 I '$$ISCONT() D ERROR(5) Q 0  ;Not connected so do not run RPC
"RTN","XWBM2MC",99,0)
 D SAVDEV^%ZISUTL("XWBM2M CLIENT")
"RTN","XWBM2MC",100,0)
 D USE^%ZISUTL("XWBM2M PORT") U IO
"RTN","XWBM2MC",101,0)
 S XWBPARMS("URI")=RPCNAM
"RTN","XWBM2MC",102,0)
 S XWBCRLFL=0
"RTN","XWBM2MC",103,0)
 D REQUEST^XWBRPCC(.XWBPARMS)
"RTN","XWBM2MC",104,0)
 I XWBCRLFL D  Q 0
"RTN","XWBM2MC",105,0)
 . I $G(CLRPARMS)'=0 K XWBPARMS("PARAMS")
"RTN","XWBM2MC",106,0)
 . K RES
"RTN","XWBM2MC",107,0)
 . D USE^%ZISUTL("XWBM2M CLIENT") U IO
"RTN","XWBM2MC",108,0)
 ;
"RTN","XWBM2MC",109,0)
 ;Check if needed!!  **REM
"RTN","XWBM2MC",110,0)
 ;;IF $G(XWBPARMS("RESULTS"))="" SET XWBPARMS("RESULTS")=$NA(^TMP("XWBRPC"))
"RTN","XWBM2MC",111,0)
 ;
"RTN","XWBM2MC",112,0)
 I '$$EXECUTE^XWBVLC(.XWBPARMS) D  Q 0  ;Run RPC and place raw XML results
"RTN","XWBM2MC",113,0)
 .D ERROR(6)
"RTN","XWBM2MC",114,0)
 .D USE^%ZISUTL("XWBM2M CLIENT") U IO
"RTN","XWBM2MC",115,0)
 ;
"RTN","XWBM2MC",116,0)
 S XWBY="" I RES'="" S XWBY=RES K @($G(XWBY)) ;*p34-kill XWBY before PARSE
"RTN","XWBM2MC",117,0)
 D PARSE^XWBRPC(.XWBPARMS,XWBY)
"RTN","XWBM2MC",118,0)
 ;
"RTN","XWBM2MC",119,0)
 ;*p34-return 0 when error occurs and XWBY=error msg.
"RTN","XWBM2MC",120,0)
 I ($G(RES))'="",($G(@XWBY))="",($G(@(XWBY_"("_1_")")))="" D  Q ERX
"RTN","XWBM2MC",121,0)
 .S ER=$G(^TMP("XWBM2MVLC",$J,"XML",2))
"RTN","XWBM2MC",122,0)
 .S ERX=$S(ER["ERROR":0,ER["ERRORS":0,ER["error":0,ER["errors":0,1:1)
"RTN","XWBM2MC",123,0)
 .I 'ERX S @XWBY=ER
"RTN","XWBM2MC",124,0)
 .D USE^%ZISUTL("XWBM2M CLIENT") U IO
"RTN","XWBM2MC",125,0)
 ;When RES in not defined.
"RTN","XWBM2MC",126,0)
 I ($G(RES))="",($G(^TMP("XWBM2MRPC",$J,"RESULTS")))="",($G(^TMP("XWBM2MRPC",$J,"RESULTS",1)))="" D  Q ERX
"RTN","XWBM2MC",127,0)
 .S ER=$G(^TMP("XWBM2MVLC",$J,"XML",2))
"RTN","XWBM2MC",128,0)
 .S ERX=$S(ER["ERROR":0,ER["ERRORS":0,ER["error":0,ER["errors":0,1:1)
"RTN","XWBM2MC",129,0)
 .I 'ERX S ^TMP("XWBM2MRPC",$J,"RESULTS",1)=ER
"RTN","XWBM2MC",130,0)
 .D USE^%ZISUTL("XWBM2M CLIENT") U IO
"RTN","XWBM2MC",131,0)
 ;
"RTN","XWBM2MC",132,0)
 I $G(CLRPARMS)'=0 K XWBPARMS("PARAMS") ;Default is to clear
"RTN","XWBM2MC",133,0)
 D USE^%ZISUTL("XWBM2M CLIENT") U IO
"RTN","XWBM2MC",134,0)
 Q 1
"RTN","XWBM2MC",135,0)
 ;
"RTN","XWBM2MC",136,0)
CLOSE() ;Close connection
"RTN","XWBM2MC",137,0)
 I '$$ISCONT() D ERROR(5) Q 0  ;Not connected
"RTN","XWBM2MC",138,0)
 D SAVDEV^%ZISUTL("XWBM2M CLIENT")
"RTN","XWBM2MC",139,0)
 D USE^%ZISUTL("XWBM2M PORT") U IO
"RTN","XWBM2MC",140,0)
 D CLOSE^XWBRL
"RTN","XWBM2MC",141,0)
 D RMDEV^%ZISUTL("XWBM2M PORT")
"RTN","XWBM2MC",142,0)
 D CLEAN
"RTN","XWBM2MC",143,0)
 S ^TMP("XWBM2M",$J,"CONNECTED")=0
"RTN","XWBM2MC",144,0)
 Q 1
"RTN","XWBM2MC",145,0)
 ;
"RTN","XWBM2MC",146,0)
CLEAN ;Clean up
"RTN","XWBM2MC",147,0)
 ;*p34-kills entry for current context in ^TMP("XWBM2M",$J)
"RTN","XWBM2MC",148,0)
 ;
"RTN","XWBM2MC",149,0)
 I '$G(XWBDBUG) K XWBPARMS
"RTN","XWBM2MC",150,0)
 K ^TMP("XWBM2M",$J),^TMP("XWBM2MRPC",$J),^TMP("XWBM2MVLC",$J)
"RTN","XWBM2MC",151,0)
 K ^TMP("XWBM2MRL"),^TMP("XWBM2ML",$J),^TMP("XWBVLL")
"RTN","XWBM2MC",152,0)
 K XWBTDEV,XWBTID,XWBVER,XWBCBK,XWBFIRST,XWBTO,XWBQUIT,XWBREAD
"RTN","XWBM2MC",153,0)
 K XWBRL,XWBROOT,XWBSTOP,XWBX,XWBY,XWBYX,XWBREQ,XWBCOK
"RTN","XWBM2MC",154,0)
 K XWBCLRFL
"RTN","XWBM2MC",155,0)
 Q
"RTN","XWBM2MC",156,0)
 ;
"RTN","XWBM2MC",157,0)
SIGNON() ;
"RTN","XWBM2MC",158,0)
 ;Encrpt AV before sending with RPC
"RTN","XWBM2MC",159,0)
 N XWBPARMS,XWBY
"RTN","XWBM2MC",160,0)
 K XWBPARMS
"RTN","XWBM2MC",161,0)
 S XWBPARMS("URI")="XUS SIGNON SETUP"
"RTN","XWBM2MC",162,0)
 S XWBCRLFL=0
"RTN","XWBM2MC",163,0)
 D REQUEST^XWBRPCC(.XWBPARMS)
"RTN","XWBM2MC",164,0)
 I XWBCRLFL Q 0
"RTN","XWBM2MC",165,0)
 ;
"RTN","XWBM2MC",166,0)
 ;Check if needed!!  **REM
"RTN","XWBM2MC",167,0)
 ;;IF $G(XWBPARMS("RESULTS"))="" SET XWBPARMS("RESULTS")=$NA(^TMP("XWBRPC",$J,"XML"))
"RTN","XWBM2MC",168,0)
 ;
"RTN","XWBM2MC",169,0)
 I '$$EXECUTE^XWBVLC(.XWBPARMS) Q 0 ;Run RPC and place raw XML results in ^TMP("XWBM2MVLC"
"RTN","XWBM2MC",170,0)
 S XWBY="" D PARSE^XWBRPC(.XWBPARMS,XWBY) ;Parse out raw XML and place results in ^TMP("XWBM2MRPC"
"RTN","XWBM2MC",171,0)
 Q 1
"RTN","XWBM2MC",172,0)
 ;
"RTN","XWBM2MC",173,0)
VALIDAV(AV) ;Check AV code
"RTN","XWBM2MC",174,0)
 K XWBPARMS
"RTN","XWBM2MC",175,0)
 S AV=$$ENCRYP^XUSRB1(AV) ;Encrypt access/verify codes
"RTN","XWBM2MC",176,0)
 D PRE
"RTN","XWBM2MC",177,0)
 ;
"RTN","XWBM2MC",178,0)
 ; -String parameter type
"RTN","XWBM2MC",179,0)
 S XWBPARMS("PARAMS",1,"TYPE")="STRING"
"RTN","XWBM2MC",180,0)
 ;;S XWBPARMS("PARAMS",1,"VALUE")=$$CHARCHK^XWBUTL(AV)
"RTN","XWBM2MC",181,0)
 S XWBPARMS("PARAMS",1,"VALUE")=AV
"RTN","XWBM2MC",182,0)
 S XWBPARMS("URI")="XUS AV CODE"
"RTN","XWBM2MC",183,0)
 S XWBCRLFL=0
"RTN","XWBM2MC",184,0)
 D REQUEST^XWBRPCC(.XWBPARMS)
"RTN","XWBM2MC",185,0)
 I XWBCRLFL Q 0
"RTN","XWBM2MC",186,0)
 ;
"RTN","XWBM2MC",187,0)
 ;Check if needed!!  **REM
"RTN","XWBM2MC",188,0)
 ;;IF $G(XWBPARMS("RESULTS"))="" SET XWBPARMS("RESULTS")=$NA(^TMP("XWBRPC",$J,"XML"))
"RTN","XWBM2MC",189,0)
 ;
"RTN","XWBM2MC",190,0)
 I '$$EXECUTE^XWBVLC(.XWBPARMS) Q 0 ;Run RPC and place raw XML results in ^TMP("XWBM2MVLC"
"RTN","XWBM2MC",191,0)
 S XWBY="" D PARSE^XWBRPC(.XWBPARMS,XWBY) ;Parse out raw XML and place results in ^TMP("XWBM2MRPC"
"RTN","XWBM2MC",192,0)
 K XWBPARMS
"RTN","XWBM2MC",193,0)
 Q 1
"RTN","XWBM2MC",194,0)
 ;
"RTN","XWBM2MC",195,0)
GETDIV(XWBDIVG) ;*p34-gets the division for a user.
"RTN","XWBM2MC",196,0)
 ;Returns 1-succuss, 0=fail
"RTN","XWBM2MC",197,0)
 ;XWBDIVG - where the division string will be places.
"RTN","XWBM2MC",198,0)
 ;Return value for XWBDIVG:
"RTN","XWBM2MC",199,0)
 ; XWBDIVG(1)=number of divisions
"RTN","XWBM2MC",200,0)
 ; XWBDIVG(#)='ien;station name;station#' delimitated with ";"
"RTN","XWBM2MC",201,0)
 ; If a user has only 1 divison, then XWBDIVG(1)=0 because Kernel
"RTN","XWBM2MC",202,0)
 ; will automatically assign that division as a default.  Use IEN to
"RTN","XWBM2MC",203,0)
 ; set division in $$SETDIV.
"RTN","XWBM2MC",204,0)
 N RPC,ROOT
"RTN","XWBM2MC",205,0)
 K XWBPARMS
"RTN","XWBM2MC",206,0)
 D PRE,SETPARAM(1,"STRING","DUMBY")
"RTN","XWBM2MC",207,0)
 I '$$CALLRPC^XWBM2MC("XUS DIVISION GET",XWBDIVG,0) D ERROR(10) Q 0
"RTN","XWBM2MC",208,0)
 K XWBPARMS
"RTN","XWBM2MC",209,0)
 Q 1
"RTN","XWBM2MC",210,0)
 ;
"RTN","XWBM2MC",211,0)
SETDIV(XWBDIVS) ;*p34-sets the division for a user.
"RTN","XWBM2MC",212,0)
 ;Returns 1-success, 0=fail
"RTN","XWBM2MC",213,0)
 ;XWBDIVS - Division to set. Use IEN from $$GETDIV.
"RTN","XWBM2MC",214,0)
 N REQ
"RTN","XWBM2MC",215,0)
 K XWBPARMS
"RTN","XWBM2MC",216,0)
 S REQ="RESULT"
"RTN","XWBM2MC",217,0)
 D PRE,SETPARAM(1,"STRING",XWBDIVS)
"RTN","XWBM2MC",218,0)
 I '$$CALLRPC^XWBM2MC("XUS DIVISION SET",REQ,0) D ERROR(11) Q 0
"RTN","XWBM2MC",219,0)
 K XWBPARMS
"RTN","XWBM2MC",220,0)
 Q 1
"RTN","XWBM2MC",221,0)
 ;
"RTN","XWBM2MC",222,0)
PRE ;Prepare the needed PARMS **REM might not need PRE
"RTN","XWBM2MC",223,0)
 ;S XWBCON="DSM" ;Check if needed!!  **REM
"RTN","XWBM2MC",224,0)
 ;
"RTN","XWBM2MC",225,0)
 S XWBPARMS("MODE")="RPCBroker"
"RTN","XWBM2MC",226,0)
 Q
"RTN","XWBM2MC",227,0)
 ;
"RTN","XWBM2MC",228,0)
ERROR(CODE,STR) ;Will write error msg and related API in TMP
"RTN","XWBM2MC",229,0)
 ;*p34-new STR to append to error msg.
"RTN","XWBM2MC",230,0)
 N API,X
"RTN","XWBM2MC",231,0)
 S API=$P($T(ERRMSG+CODE),";;",3)
"RTN","XWBM2MC",232,0)
 S X=$NA(^TMP("XWBM2ME",$J,"ERROR",API)),@X=$P($T(ERRMSG+CODE),";;",2)_$G(STR) ;*p34
"RTN","XWBM2MC",233,0)
 Q
"RTN","XWBM2MC",234,0)
 ;
"RTN","XWBM2MC",235,0)
ERRMSG ; Error messages *p34-add 2 more error msg for GETDIV and SETDIV.
"RTN","XWBM2MC",236,0)
 ;;Could not open connection;;CONNECT
"RTN","XWBM2MC",237,0)
 ;;XUS SIGNON SETUP RPC failed;;SIGNON
"RTN","XWBM2MC",238,0)
 ;;XUS AV CODE RPC failed;;SIGNON
"RTN","XWBM2MC",239,0)
 ;;Invalid user, no DUZ returned;;SIGNON
"RTN","XWBM2MC",240,0)
 ;;There is no connection;;CALLRPC
"RTN","XWBM2MC",241,0)
 ;;RPC could not be processed;;CALLRPC
"RTN","XWBM2MC",242,0)
 ;;Remote Procedure Unknown;;SERVER
"RTN","XWBM2MC",243,0)
 ;;Control Character Found;;CALLRPC
"RTN","XWBM2MC",244,0)
 ;;Error in division return;;CONNECT
"RTN","XWBM2MC",245,0)
 ;;Could not obtain list of valid divisions for current user;;GETDIV
"RTN","XWBM2MC",246,0)
 ;;Could not Set active Division for current user;;SETDIV
"RTN","XWBM2MC",247,0)
 Q
"RTN","XWBPRS")
0^44^B75191540^B75006565
"RTN","XWBPRS",1,0)
XWBPRS ;ISF/STAFF - VISTA BROKER MSG PARSER ;08/11/15  09:49
"RTN","XWBPRS",2,0)
 ;;1.1;RPC BROKER;**35,43,46,57,64**;Mar 28, 1997;Build 12
"RTN","XWBPRS",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","XWBPRS",4,0)
 ;
"RTN","XWBPRS",5,0)
 ;XWB holds info from the message used by the RPC
"RTN","XWBPRS",6,0)
CALLP(XWBP,XWBDEBUG) ;make API call using Protocol string
"RTN","XWBPRS",7,0)
 N ERR,S,XWBARY K XWB
"RTN","XWBPRS",8,0)
 S ERR=0
"RTN","XWBPRS",9,0)
 S ERR=$$PRSP("[XWB]") ;Read the rest of the protocol header
"RTN","XWBPRS",10,0)
 I '+ERR S ERR=$$PRSM ;Read and parse message
"RTN","XWBPRS",11,0)
 I $G(XWB(2,"RPC"))="XUS SET SHARED" S XWBSHARE=1 Q
"RTN","XWBPRS",12,0)
 I '+ERR S ERR=$$RPC ;Check the RPC
"RTN","XWBPRS",13,0)
 I +ERR S XWBSEC=$P(ERR,U,2) ;P10 -- dpc
"RTN","XWBPRS",14,0)
 I '+ERR D CHKPRMIT^XWBSEC($G(XWB(2,"RPC"))) ;checks if RPC allowed to run
"RTN","XWBPRS",15,0)
 S:$L($G(XWBSEC)) ERR="-1^"_XWBSEC
"RTN","XWBPRS",16,0)
 I '+ERR D
"RTN","XWBPRS",17,0)
 . D CAPI(.XWBP,XWB("PARAM"))
"RTN","XWBPRS",18,0)
 E  I ($G(XWBTCMD)'="#BYE#") D LOG^XWBTCPM("Bad Msg"_ERR),CLRBUF
"RTN","XWBPRS",19,0)
 I 'XWBDEBUG K XWB
"RTN","XWBPRS",20,0)
 I $D(XWBARY) K @XWBARY,XWBARY
"RTN","XWBPRS",21,0)
 Q
"RTN","XWBPRS",22,0)
 ;
"RTN","XWBPRS",23,0)
PRSP(P) ;ef, Parse Protocol
"RTN","XWBPRS",24,0)
 ;M Extrinsic Function
"RTN","XWBPRS",25,0)
 ;Outputs
"RTN","XWBPRS",26,0)
 ;ERR      0 for success, "-1^Text" if error
"RTN","XWBPRS",27,0)
 ;
"RTN","XWBPRS",28,0)
 N ERR,C,M,R,X
"RTN","XWBPRS",29,0)
 S R=0,C=";",ERR=0
"RTN","XWBPRS",30,0)
 S P=$$BREAD^XWBRW(4)
"RTN","XWBPRS",31,0)
 IF $L(P)'=4 S ERR="-1^Short Header info"
"RTN","XWBPRS",32,0)
 IF +ERR=0 D
"RTN","XWBPRS",33,0)
 . S XWB(R,"VER")=+$E(P,1)
"RTN","XWBPRS",34,0)
 . S XWB(R,"TYPE")=+$E(P,2)
"RTN","XWBPRS",35,0)
 . S (XWBENVL,XWB(R,"LENV"))=+$E(P,3)
"RTN","XWBPRS",36,0)
 . S (XWBPRT,XWB(R,"RT"))=+$E(P,4)
"RTN","XWBPRS",37,0)
 I XWBENVL<1 S (XWBENVL,XWB(R,"LENV"))=3
"RTN","XWBPRS",38,0)
 Q ERR
"RTN","XWBPRS",39,0)
 ;
"RTN","XWBPRS",40,0)
PRSM() ;ef, Parse message
"RTN","XWBPRS",41,0)
 ;M Extrinsic Function
"RTN","XWBPRS",42,0)
 ;See document on msg format
"RTN","XWBPRS",43,0)
 ;Outputs
"RTN","XWBPRS",44,0)
 ;ERR      0 for success, "-1^Text" if error
"RTN","XWBPRS",45,0)
 N C,EX1,ERR,R,X,CNK
"RTN","XWBPRS",46,0)
 S R=1,C=";",CNK=0,EX1=0 ;Max buffer
"RTN","XWBPRS",47,0)
 S ERR="-1^Invalid Chunk"
"RTN","XWBPRS",48,0)
 F  S CNK=$$BREAD^XWBRW(1) Q:("12345"'[CNK)  D  Q:EX1
"RTN","XWBPRS",49,0)
 . S EX1=(CNK=5),@("ERR=$$PRS"_CNK)
"RTN","XWBPRS",50,0)
 Q ERR
"RTN","XWBPRS",51,0)
 ;
"RTN","XWBPRS",52,0)
PRS1() ;Parse the HEADER chunk
"RTN","XWBPRS",53,0)
 N %,L,R
"RTN","XWBPRS",54,0)
 S R=1
"RTN","XWBPRS",55,0)
 S XWB(R,"VER")=$$SREAD
"RTN","XWBPRS",56,0)
 S XWB(R,"RETURN")=$$SREAD
"RTN","XWBPRS",57,0)
 Q 0
"RTN","XWBPRS",58,0)
 ;
"RTN","XWBPRS",59,0)
PRS2() ;Parse the RPC chunk
"RTN","XWBPRS",60,0)
 N L,R
"RTN","XWBPRS",61,0)
 S R=2
"RTN","XWBPRS",62,0)
 S (XWBAPVER,XWB(R,"VER"))=$$SREAD ;RPC version
"RTN","XWBPRS",63,0)
 S XWB(R,"RPC")=$$SREAD
"RTN","XWBPRS",64,0)
 I $G(XWBDEBUG)>1 D LOG^XWBTCPM("RPC: "_XWB(R,"RPC"))
"RTN","XWBPRS",65,0)
 Q 0
"RTN","XWBPRS",66,0)
PRS3() ;Parse the Security chunk
"RTN","XWBPRS",67,0)
 N L,R
"RTN","XWBPRS",68,0)
 S R=3
"RTN","XWBPRS",69,0)
 Q 0
"RTN","XWBPRS",70,0)
PRS4() ;Parse the Command chunk
"RTN","XWBPRS",71,0)
 N R
"RTN","XWBPRS",72,0)
 S R=4,XWBTCMD=$$SREAD,XWB(R,"CMD")=XWBTCMD
"RTN","XWBPRS",73,0)
 I $G(XWBDEBUG)>1 D LOG^XWBTCPM("CMD: "_XWBTCMD)
"RTN","XWBPRS",74,0)
 Q ("TCPConnect^#BYE#"[XWBTCMD)
"RTN","XWBPRS",75,0)
 ;
"RTN","XWBPRS",76,0)
PRS5() ;Parse Data Parameter chunk
"RTN","XWBPRS",77,0)
 ;M Extrinsic Function
"RTN","XWBPRS",78,0)
 ;Outputs
"RTN","XWBPRS",79,0)
 ;ERR      0 for success, "-1^Text" if error
"RTN","XWBPRS",80,0)
 ;
"RTN","XWBPRS",81,0)
 N CONT,DONE,ERR,F,FL,IX,K,L,MAXP,P1,P2,P3,P4,P5,R,TY,VA
"RTN","XWBPRS",82,0)
 S R=5,ERR=0,F=3,IX=0,DONE=0,CONT="f",XWB("PARAM")=""
"RTN","XWBPRS",83,0)
 F  S:CONT="f" TY=$$BREAD^XWBRW(1) D  Q:DONE  S CONT=$$BREAD^XWBRW(1) S:CONT'="t" IX=IX+1
"RTN","XWBPRS",84,0)
 . K VA,P1
"RTN","XWBPRS",85,0)
 . IF TY=$C(4) S DONE=1 Q  ;EOT
"RTN","XWBPRS",86,0)
 . IF TY=0 D  Q  ;literal
"RTN","XWBPRS",87,0)
 . . D LREAD("VA")
"RTN","XWBPRS",88,0)
 . . S XWB(R,"P",IX)=VA(1) D PARAM($NA(XWB(R,"P",IX)))
"RTN","XWBPRS",89,0)
 . . Q
"RTN","XWBPRS",90,0)
 . IF TY=1 D  Q  ;reference
"RTN","XWBPRS",91,0)
 . . D LREAD("VA")
"RTN","XWBPRS",92,0)
 . . S XWB(R,"P",IX)=$$GETV(VA(1)) D PARAM($NA(XWB(R,"P",IX)))
"RTN","XWBPRS",93,0)
 . . Q
"RTN","XWBPRS",94,0)
 . IF TY=2 D  Q  ;list
"RTN","XWBPRS",95,0)
 . . I CONT'="t" D
"RTN","XWBPRS",96,0)
 . . . S XWBARY=$$OARY,XWB(R,"P",IX)="."_XWBARY
"RTN","XWBPRS",97,0)
 . . . D PARAM(XWB(R,"P",IX))
"RTN","XWBPRS",98,0)
 . . D LREAD("P1") Q:P1(1)=""  D LREAD("VA")
"RTN","XWBPRS",99,0)
 . . D LINST(XWBARY,P1(1),VA(1))
"RTN","XWBPRS",100,0)
 . . Q
"RTN","XWBPRS",101,0)
 . IF TY=3 D  Q  ;global
"RTN","XWBPRS",102,0)
 . . I CONT'="t" D
"RTN","XWBPRS",103,0)
 . . . S XWBARY=$NA(^TMP("XWBA",$J,IX)),XWB(R,"P",IX)=XWBARY
"RTN","XWBPRS",104,0)
 . . . K @XWBARY S @XWBARY=""
"RTN","XWBPRS",105,0)
 . . . D PARAM(XWBARY)
"RTN","XWBPRS",106,0)
 . . D LREAD("P1") Q:P1(1)=""  D LREAD("VA")
"RTN","XWBPRS",107,0)
 . . D GINST(XWBARY,P1(1),VA(1))
"RTN","XWBPRS",108,0)
 . . Q
"RTN","XWBPRS",109,0)
 . IF TY=4 D  Q  ;empty - ,,
"RTN","XWBPRS",110,0)
 . . S XWB(R,"XWB",IX)=""
"RTN","XWBPRS",111,0)
 . . Q
"RTN","XWBPRS",112,0)
 . IF TY=5 D  Q
"RTN","XWBPRS",113,0)
 . . ;stream still to be done
"RTN","XWBPRS",114,0)
 . Q  ;End of loop
"RTN","XWBPRS",115,0)
 Q ERR
"RTN","XWBPRS",116,0)
PARAM(NA) ;Add a new parameter to the list
"RTN","XWBPRS",117,0)
 N A
"RTN","XWBPRS",118,0)
 S A=$G(XWB("PARAM")) S:'$L(NA) NA="""""" ;Empty
"RTN","XWBPRS",119,0)
 S A=A_$S($L(A):",",1:"")_$S(TY=3:"$NA(",1:"")_NA_$S(TY=3:")",1:"")
"RTN","XWBPRS",120,0)
 S XWB("PARAM")=A
"RTN","XWBPRS",121,0)
 Q
"RTN","XWBPRS",122,0)
 ;
"RTN","XWBPRS",123,0)
RPC() ;Check the rpc information.
"RTN","XWBPRS",124,0)
 ;M Extrinsic Function
"RTN","XWBPRS",125,0)
 ;Outputs
"RTN","XWBPRS",126,0)
 ;ERR      0 for success, "-1^Text" if error
"RTN","XWBPRS",127,0)
 ;
"RTN","XWBPRS",128,0)
 N C,DR,ERR,M,R,RPC,T,X
"RTN","XWBPRS",129,0)
 S R=2,C=";",ERR=0,M=512 ;Max buffer
"RTN","XWBPRS",130,0)
 S RPC=$G(XWB(R,"RPC")) I '$L(RPC) Q "-1^No RPC sent"
"RTN","XWBPRS",131,0)
 S T=$O(^XWB(8994,"B",RPC,0))
"RTN","XWBPRS",132,0)
 I '+T Q "-1^Remote Procedure '"_RPC_"' doesn't exist on the server."
"RTN","XWBPRS",133,0)
 S T(0)=$G(^XWB(8994,T,0))
"RTN","XWBPRS",134,0)
 I $P(T(0),U,6)=1!($P(T(0),U,6)=2) Q "-1^Remote Procedure '"_RPC_"' cannot be run at this time."
"RTN","XWBPRS",135,0)
 S XWB(R,"RTAG")=$P(T(0),"^",2)
"RTN","XWBPRS",136,0)
 S XWB(R,"RNAM")=$P(T(0),"^",3)
"RTN","XWBPRS",137,0)
 S XWBPTYPE=$P(T(0),"^",4)
"RTN","XWBPRS",138,0)
 S XWBWRAP=+$P(T(0),"^",8)
"RTN","XWBPRS",139,0)
 Q ERR
"RTN","XWBPRS",140,0)
 ;
"RTN","XWBPRS",141,0)
SREAD() ;Read a S_PACK
"RTN","XWBPRS",142,0)
 N L,V7
"RTN","XWBPRS",143,0)
 S L=$$BREAD^XWBRW(1),L=$A(L)
"RTN","XWBPRS",144,0)
 S V7=$$BREAD^XWBRW(L)
"RTN","XWBPRS",145,0)
 Q V7
"RTN","XWBPRS",146,0)
 ;
"RTN","XWBPRS",147,0)
LREAD(ROOT) ;Read a L_PACK
"RTN","XWBPRS",148,0)
 N L,V7,I ;p45 Remove limit on length of string.
"RTN","XWBPRS",149,0)
 S I=1,@ROOT@(I)=""
"RTN","XWBPRS",150,0)
 S L=$$BREAD^XWBRW(XWBENVL),L=+L
"RTN","XWBPRS",151,0)
 I L>0 S V7=$$BREAD^XWBRW(L),@ROOT@(I)=V7,I=I+1
"RTN","XWBPRS",152,0)
 Q
"RTN","XWBPRS",153,0)
 ;
"RTN","XWBPRS",154,0)
 ;X can be something like '"TEXT",1,0'.
"RTN","XWBPRS",155,0)
LINST(A,X,XWBY) ;instantiate local array
"RTN","XWBPRS",156,0)
 IF XWBY=$C(1) S XWBY=""
"RTN","XWBPRS",157,0)
 S X=A_"("_X_")"
"RTN","XWBPRS",158,0)
 S @X=XWBY
"RTN","XWBPRS",159,0)
 Q
"RTN","XWBPRS",160,0)
 ;
"RTN","XWBPRS",161,0)
 ;S can be something like '"TEXT",1,0'.
"RTN","XWBPRS",162,0)
GINST(R,S,V) ;instantiate global
"RTN","XWBPRS",163,0)
 N N
"RTN","XWBPRS",164,0)
 I V=$C(1) S V=""
"RTN","XWBPRS",165,0)
 S N=$P(R,")")_","_S_")"
"RTN","XWBPRS",166,0)
 S @N=V
"RTN","XWBPRS",167,0)
 Q
"RTN","XWBPRS",168,0)
 ;
"RTN","XWBPRS",169,0)
GETV(V) ;get value of V - reference parameter
"RTN","XWBPRS",170,0)
 N X
"RTN","XWBPRS",171,0)
 S X=V
"RTN","XWBPRS",172,0)
 IF $E(X,1,2)="$$" Q ""
"RTN","XWBPRS",173,0)
 IF $C(34,36)[$E(V) X "S V="_$$VCHK(V)
"RTN","XWBPRS",174,0)
 E  S V=@V
"RTN","XWBPRS",175,0)
 Q V
"RTN","XWBPRS",176,0)
 ;
"RTN","XWBPRS",177,0)
VCHK(S) ;Parse string for first argument
"RTN","XWBPRS",178,0)
 N C,I,P
"RTN","XWBPRS",179,0)
 F I=1:1 S C=$E(S,I) D VCHKP:C="(",VCHKQ:C=$C(34) Q:" ,"[C
"RTN","XWBPRS",180,0)
 Q $E(S,1,I-1)
"RTN","XWBPRS",181,0)
VCHKP S P=1 ;Find closing paren
"RTN","XWBPRS",182,0)
 F I=I+1:1 S C=$E(S,I) Q:P=0!(C="")  I "()"""[C D VCHKQ:C=$C(34) S P=P+$S("("[C:1,")"[C:-1,1:0)
"RTN","XWBPRS",183,0)
 Q
"RTN","XWBPRS",184,0)
VCHKQ ;Find closing quote
"RTN","XWBPRS",185,0)
 F I=I+1:1 S C=$E(S,I) Q:C=""!(C=$C(34))
"RTN","XWBPRS",186,0)
 Q
"RTN","XWBPRS",187,0)
CLRBUF ;Empties Input buffer
"RTN","XWBPRS",188,0)
 N %
"RTN","XWBPRS",189,0)
 F  R *%:2 Q:'$T!(%=4)  ;!(%=-1)
"RTN","XWBPRS",190,0)
 Q
"RTN","XWBPRS",191,0)
ZZZ(X) ;Convert
"RTN","XWBPRS",192,0)
 N I,J
"RTN","XWBPRS",193,0)
 F  S I=$F(X,"$C(") Q:'I  S J=$F(X,")",I),X=$E(X,1,I-4)_$C($E(X,I,J-2))_$E(X,J,999)
"RTN","XWBPRS",194,0)
 Q X
"RTN","XWBPRS",195,0)
 ;
"RTN","XWBPRS",196,0)
CAPI(XWBY,PAR) ;make API call
"RTN","XWBPRS",197,0)
 N XWBCALL,T,DX,DY
"RTN","XWBPRS",198,0)
 ; ZEXCEPT: XWBFGTIM - created here, will be killed in STRTCVR2 or ONECOVER
"RTN","XWBPRS",199,0)
 ; ZEXCEPT: XWBCSRPC - created here, will be killed in ONECOVER
"RTN","XWBPRS",200,0)
 ; JLI 110606 next line checks for start call to Coversheet Timing
"RTN","XWBPRS",201,0)
 I XWB(2,"RTAG")="START",XWB(2,"RNAM")="ORWCV" I +$G(^KMPTMP("KMPD-CPRS")) S XWBFGTIM=$H D STRTCVR1 I 1
"RTN","XWBPRS",202,0)
 E  I $G(XWBCOVER),$D(^TMP("XWBFGP",$J,"TODO",XWB(2,"RPC"))) S XWBFGTIM=$H,XWBCSRPC=XWB(2,"RPC")
"RTN","XWBPRS",203,0)
 S XWBCALL=XWB(2,"RTAG")_"^"_XWB(2,"RNAM")_"(.XWBY"_$S($L(PAR):","_PAR,1:"")_")",XWBCALL2=""
"RTN","XWBPRS",204,0)
 K PAR
"RTN","XWBPRS",205,0)
 O XWBNULL U XWBNULL ;p43 Make sure its open
"RTN","XWBPRS",206,0)
 ;
"RTN","XWBPRS",207,0)
 I $G(XWBDEBUG)>2 D LOG^XWBDLOG("Call: "_$E(XWBCALL,1,247))
"RTN","XWBPRS",208,0)
 ;start RUM for RPC
"RTN","XWBPRS",209,0)
 I $G(XWB(2,"CAPI"))]"" D LOGRSRC^%ZOSV(XWB(2,"CAPI"),2,1)
"RTN","XWBPRS",210,0)
 ;
"RTN","XWBPRS",211,0)
 D @XWBCALL S XWBCALL2=XWBCALL ;Save call for debug
"RTN","XWBPRS",212,0)
 ;
"RTN","XWBPRS",213,0)
 I $G(XWBCOVER),XWB(2,"RTAG")="START",XWB(2,"RNAM")="ORWCV" D STRTCVR2(XWBY) I 1
"RTN","XWBPRS",214,0)
 E  I $D(XWBCOVER),$D(XWBCSRPC) D ONECOVER ; JLI 110606
"RTN","XWBPRS",215,0)
 ;
"RTN","XWBPRS",216,0)
 ;restart RUM for handler
"RTN","XWBPRS",217,0)
 D LOGRSRC^%ZOSV("$BROKER HANDLER$",2,1)
"RTN","XWBPRS",218,0)
 ;
"RTN","XWBPRS",219,0)
 U XWBTDEV
"RTN","XWBPRS",220,0)
 Q
"RTN","XWBPRS",221,0)
 ;
"RTN","XWBPRS",222,0)
OARY() ;create storage array
"RTN","XWBPRS",223,0)
 N A,DONE,I
"RTN","XWBPRS",224,0)
 S I=1+$G(XWB("ARRAY")),XWB("ARRAY")=I
"RTN","XWBPRS",225,0)
 S A="XWBS"_I
"RTN","XWBPRS",226,0)
 K @A ;temp fix for single array
"RTN","XWBPRS",227,0)
 S @A="" ;set naked
"RTN","XWBPRS",228,0)
 Q A
"RTN","XWBPRS",229,0)
 ;
"RTN","XWBPRS",230,0)
CREF(R,P) ;Convert array contained in P to reference A
"RTN","XWBPRS",231,0)
 N I,X,DONE,F1,S
"RTN","XWBPRS",232,0)
 S DONE=0
"RTN","XWBPRS",233,0)
 S S=""
"RTN","XWBPRS",234,0)
 F I=1:1  D  Q:DONE
"RTN","XWBPRS",235,0)
 . IF $P(P,",",I)="" S DONE=1 Q
"RTN","XWBPRS",236,0)
 . S X(I)=$P(P,",",I)
"RTN","XWBPRS",237,0)
 . IF X(I)?1"."1A.E D
"RTN","XWBPRS",238,0)
 . . S F1=$F(X(I),".")
"RTN","XWBPRS",239,0)
 . . S X(I)="."_R
"RTN","XWBPRS",240,0)
 . S S=S_X(I)_","
"RTN","XWBPRS",241,0)
 Q $E(S,1,$L(S)-1)
"RTN","XWBPRS",242,0)
 ;
"RTN","XWBPRS",243,0)
STRTCVR1 ; JLI 110606
"RTN","XWBPRS",244,0)
 ; SET UP DATA FOR OBTAINING FOREGROUND PROCESSING TIMES FOR COVERSHEET LOADS
"RTN","XWBPRS",245,0)
 ; REQUESTED FOR TIMING ON COMMODITY SERVERS, ETC.
"RTN","XWBPRS",246,0)
 N DFN,IP,HWND,NODE
"RTN","XWBPRS",247,0)
 ; ZEXCEPT: XWBCOVER - created here, will be killed when foreground processing is complete
"RTN","XWBPRS",248,0)
 S XWBCOVER=1
"RTN","XWBPRS",249,0)
 K ^TMP("XWBFGP",$J)
"RTN","XWBPRS",250,0)
 S DFN=XWB(5,"P",0),IP=XWB(5,"P",1),HWND=XWB(5,"P",2)
"RTN","XWBPRS",251,0)
 S NODE="ORWCV "_IP_"-"_HWND_"-"_DFN
"RTN","XWBPRS",252,0)
 S ^TMP("XWBFGP",$J,"NODE")=NODE ; SO WE CAN GET IT EASILY EACH PASS
"RTN","XWBPRS",253,0)
 S ^KMPTMP("KMPDT","ORWCV-FT",NODE)=XWBFGTIM_"^^"_$G(DUZ)_"^"_$G(IO("CLNM"))
"RTN","XWBPRS",254,0)
 Q
"RTN","XWBPRS",255,0)
 ;
"RTN","XWBPRS",256,0)
STRTCVR2(RETRNVAL) ; JLI 110606 - setup after coming back from initial start for coversheets
"RTN","XWBPRS",257,0)
 N XWBFGDIF,I
"RTN","XWBPRS",258,0)
 ; the return value contains ids for coversheets to be handled in the foreground separated by commas
"RTN","XWBPRS",259,0)
 F I=1:1 S XWBCSID=$P(RETRNVAL,";",I) Q:XWBCSID=""  D SETCSID(XWBCSID)
"RTN","XWBPRS",260,0)
 K XWBFGTIM
"RTN","XWBPRS",261,0)
 Q
"RTN","XWBPRS",262,0)
 ;
"RTN","XWBPRS",263,0)
SETCSID(XWBCSID) ; Obtain and setup selected coversheet ids for foreground processing
"RTN","XWBPRS",264,0)
 N I,RPC
"RTN","XWBPRS",265,0)
 ; The coversheet ID value (XWBCSID) will be used for a look-up on the "AC" cross-reference of file 101.24.
"RTN","XWBPRS",266,0)
 ; It is possible to have multiple entries with the same ID value, so checking that the 8th piece of the zero node of the value is a "C" will be required.
"RTN","XWBPRS",267,0)
 F I=0:0 S I=$O(^ORD(101.24,"AC",XWBCSID,I)) Q:I'>0  I $P(^ORD(101.24,I,0),U,8)="C" S RPC=$P(^(0),U,13),RPC=$P(^XWB(8994,RPC,0),U),^TMP("XWBFGP",$J,"TODO",RPC)=I Q
"RTN","XWBPRS",268,0)
 I $D(^TMP("XWBFGP",$J,"TODO","ORQQPX REMINDERS LIST")) D
"RTN","XWBPRS",269,0)
 .N XWBCSIEN S XWBCSIEN=^TMP("XWBFGP",$J,"TODO","ORQQPX REMINDERS LIST")
"RTN","XWBPRS",270,0)
 .S ^TMP("XWBFGP",$J,"TODO","ORQQPXRM REMINDERS APPLICABLE")=XWBCSIEN
"RTN","XWBPRS",271,0)
 .S ^TMP("XWBFGP",$J,"TODO","ORQQPXRM REMINDERS UNEVALUATED")=XWBCSIEN
"RTN","XWBPRS",272,0)
 .S ^TMP("XWBFGP",$J,"TODO","ORQQPXRM REMINDER CATEGORIES")=XWBCSIEN
"RTN","XWBPRS",273,0)
 .Q
"RTN","XWBPRS",274,0)
 Q
"RTN","XWBPRS",275,0)
ONECOVER ; called after data is returned to client
"RTN","XWBPRS",276,0)
 I "^ORQQPXRM REMINDERS APPLICABLE^ORQQPXRM REMINDERS UNEVALUATED^ORQQPXRM REMINDER CATEGORIES^"[U_XWBCSRPC_U K ^TMP("XWBFGP",$J,"TODO","ORQQPX REMINDERS LIST")
"RTN","XWBPRS",277,0)
 I XWBCSRPC="ORQQPX REMINDERS LIST" D
"RTN","XWBPRS",278,0)
 .K ^TMP("XWBFGP",$J,"TODO","ORQQPXRM REMINDERS APPLICABLE")
"RTN","XWBPRS",279,0)
 .K ^TMP("XWBFGP",$J,"TODO","ORQQPXRM REMINDERS UNEVALUATED")
"RTN","XWBPRS",280,0)
 .K ^TMP("XWBFGP",$J,"TODO","ORQQPXRM REMINDER CATEGORIES")
"RTN","XWBPRS",281,0)
 .Q
"RTN","XWBPRS",282,0)
 ;
"RTN","XWBPRS",283,0)
 K ^TMP("XWBFGP",$J,"TODO",XWBCSRPC),XWBCSRPC,XWBFGTIM
"RTN","XWBPRS",284,0)
 I '$D(^TMP("XWBFGP",$J,"TODO")) D ENDCOVER
"RTN","XWBPRS",285,0)
 Q
"RTN","XWBPRS",286,0)
 ;
"RTN","XWBPRS",287,0)
ENDCOVER ; no more cover sheets to process, so set final values, clean up
"RTN","XWBPRS",288,0)
 N I,NODE,X
"RTN","XWBPRS",289,0)
 S NODE=^TMP("XWBFGP",$J,"NODE")
"RTN","XWBPRS",290,0)
 S $P(^KMPTMP("KMPDT","ORWCV-FT",NODE),U,2)=$H
"RTN","XWBPRS",291,0)
 K XWBCOVER,^TMP("XWBFGP",$J)
"RTN","XWBPRS",292,0)
 ;
"RTN","XWBRM")
0^46^B17663584^B16862663
"RTN","XWBRM",1,0)
XWBRM ;OIFO-Oakland/REM - M2M Broker Server Request Mgr  ;4/6/06  10:21
"RTN","XWBRM",2,0)
 ;;1.1;RPC BROKER;**28,45,62,64**;Mar 28, 1997;Build 12
"RTN","XWBRM",3,0)
 ;Per VHA Directive 6402, this routine should not be modified
"RTN","XWBRM",4,0)
 ;
"RTN","XWBRM",5,0)
 QUIT
"RTN","XWBRM",6,0)
 ;
"RTN","XWBRM",7,0)
 ; ---------------------------------------------------------------------
"RTN","XWBRM",8,0)
 ;                             Server Request Manager (SRM)
"RTN","XWBRM",9,0)
 ; ---------------------------------------------------------------------
"RTN","XWBRM",10,0)
 ;
"RTN","XWBRM",11,0)
EN(XWBROOT) ; -- main entry point for SRM
"RTN","XWBRM",12,0)
 NEW XWBOK,XWBOPT,XWBDATA,XWBMODE
"RTN","XWBRM",13,0)
 N XWBM2M ;Flag for M2M requests **M2M
"RTN","XWBRM",14,0)
 SET XWBOK=0,XWBM2M=0
"RTN","XWBRM",15,0)
 ;
"RTN","XWBRM",16,0)
 ; -- parse the xml
"RTN","XWBRM",17,0)
 SET XWBOPT=""
"RTN","XWBRM",18,0)
 DO EN^XWBRMX(XWBROOT,.XWBOPT,.XWBDATA)
"RTN","XWBRM",19,0)
 S XWBMODE=$G(XWBDATA("MODE"))
"RTN","XWBRM",20,0)
 ;access/verify RPC must be within first 2 calls (p62)
"RTN","XWBRM",21,0)
 ;Identity and Access Management (IAM) Secure Token Service (STS) SAML token may be provided as an alternative to
"RTN","XWBRM",22,0)
 ; Access and Verify codes (p64)
"RTN","XWBRM",23,0)
 I $G(XWBAVC) D  Q:XWBAVC>1 '(XWBAVC=3)
"RTN","XWBRM",24,0)
 . Q:$G(XWBDATA("URI"))="XUS SIGNON SETUP"
"RTN","XWBRM",25,0)
 . I $G(XWBDATA("URI"))="XUS AV CODE" D EN^XWBRPC(.XWBDATA) S XWBAVC=2 Q
"RTN","XWBRM",26,0)
 . I $G(XWBDATA("URI"))="XUS ESSO VALIDATE" D EN^XWBRPC(.XWBDATA) S XWBAVC=2 Q
"RTN","XWBRM",27,0)
 . S XWBCODES(2)="",XWBCODES=$G(XWBCODES)+1,XWBAVC=3
"RTN","XWBRM",28,0)
 . D SECERR(.XWBCODES)
"RTN","XWBRM",29,0)
 . Q
"RTN","XWBRM",30,0)
 ;removed in P62
"RTN","XWBRM",31,0)
 ;I $G(XWBDATA("URI"))="XUS GET VISITOR" D EN^XWBRPC(.XWBDATA) S XWBOK=1 S:'$D(DUZ) XWBSTOP=1 Q 1
"RTN","XWBRM",32,0)
 ;Break off to RCPBroker **M2M
"RTN","XWBRM",33,0)
 IF $G(XWBDATA("MODE"))="RPCBroker" D RPC^XWBM2MS(.XWBDATA) SET XWBSTOP=0
"RTN","XWBRM",34,0)
 ; -- single call processing
"RTN","XWBRM",35,0)
 IF $G(XWBDATA("MODE"),"single call")="single call" SET XWBSTOP=1
"RTN","XWBRM",36,0)
 ;
"RTN","XWBRM",37,0)
 ; -- check if app defined
"RTN","XWBRM",38,0)
 IF $G(XWBDATA("APP"))="" DO RMERR(1) SET XWBOK=0 GOTO ENQ
"RTN","XWBRM",39,0)
 ;
"RTN","XWBRM",40,0)
 ; -- process close request
"RTN","XWBRM",41,0)
 IF $G(XWBDATA("APP"))="CLOSE" DO  SET XWBOK=0 GOTO ENQ
"RTN","XWBRM",42,0)
 . D:$G(DUZ) LOGOUT^XUSRB ;**M2M -Logout user and cleanup
"RTN","XWBRM",43,0)
 . DO RESPONSE^XWBVL()
"RTN","XWBRM",44,0)
 . SET XWBSTOP=1
"RTN","XWBRM",45,0)
 ;
"RTN","XWBRM",46,0)
 ; -- do security checks
"RTN","XWBRM",47,0)
 IF $G(XWBDATA("MODE"))'="RPCBroker",'$$SECCHK() SET XWBOK=0 GOTO ENQ
"RTN","XWBRM",48,0)
 ;
"RTN","XWBRM",49,0)
 ; -- call app to write to socket
"RTN","XWBRM",50,0)
 IF $G(XWBDATA("APP"))="RPC" DO EN^XWBRPC(.XWBDATA) SET XWBOK=1
"RTN","XWBRM",51,0)
 ;
"RTN","XWBRM",52,0)
ENQ ;
"RTN","XWBRM",53,0)
 QUIT XWBOK
"RTN","XWBRM",54,0)
 ;
"RTN","XWBRM",55,0)
 ; ---------------------------------------------------------------------
"RTN","XWBRM",56,0)
 ;
"RTN","XWBRM",57,0)
SECCHK() ; -- do security checks  (no real checks at this time)
"RTN","XWBRM",58,0)
 NEW XWBCODES
"RTN","XWBRM",59,0)
 ;
"RTN","XWBRM",60,0)
 ; -- is token valid
"RTN","XWBRM",61,0)
 IF '$$CHKTOKEN($G(XWBDATA("SECTOKEN"))) SET XWBCODES(1)="",XWBCODES=$G(XWBCODES)+1
"RTN","XWBRM",62,0)
 ;
"RTN","XWBRM",63,0)
 ; -- is DUZ valid
"RTN","XWBRM",64,0)
 IF '$$CHKDUZ($G(XWBDATA("DUZ"))) SET XWBCODES(2)="",XWBCODES=$G(XWBCODES)+1
"RTN","XWBRM",65,0)
 ;
"RTN","XWBRM",66,0)
 ; -- if security errors then send error response
"RTN","XWBRM",67,0)
 IF $G(XWBCODES) D SECERR(.XWBCODES)
"RTN","XWBRM",68,0)
 ;
"RTN","XWBRM",69,0)
 QUIT '+$G(XWBCODES)
"RTN","XWBRM",70,0)
 ;
"RTN","XWBRM",71,0)
CHKTOKEN(XWBTOKEN) ; -- do check against token for validity
"RTN","XWBRM",72,0)
 ; -- // TODO: Need to check into how we might use XUS1B and related code in Kernel Sign-On (ESSO)
"RTN","XWBRM",73,0)
 NEW XWBINVAL
"RTN","XWBRM",74,0)
 SET XWBINVAL="#UNKNOWN#"
"RTN","XWBRM",75,0)
 IF $G(XWBTOKEN,XWBINVAL)=XWBINVAL QUIT 0
"RTN","XWBRM",76,0)
 QUIT 1
"RTN","XWBRM",77,0)
 ;
"RTN","XWBRM",78,0)
CHKDUZ(XWBDUZ) ; -- do check against DUZ for validity
"RTN","XWBRM",79,0)
 ; -- // TODO: Need to check into how we might use XUS1B and related code in Kernel Sign-On (ESSO)
"RTN","XWBRM",80,0)
 NEW XWBINVAL
"RTN","XWBRM",81,0)
 SET XWBINVAL="#UNKNOWN#"
"RTN","XWBRM",82,0)
 IF $G(XWBDUZ,XWBINVAL)=XWBINVAL QUIT 0
"RTN","XWBRM",83,0)
 IF '$D(^VA(200,+XWBDUZ,0)) QUIT 0
"RTN","XWBRM",84,0)
 QUIT 1
"RTN","XWBRM",85,0)
 ;
"RTN","XWBRM",86,0)
 ; ---------------------------------------------------------------------
"RTN","XWBRM",87,0)
 ;                 Request Manager and Security Error Handlers
"RTN","XWBRM",88,0)
 ; ---------------------------------------------------------------------
"RTN","XWBRM",89,0)
RMERR(XWBCODE) ; -- send request error message
"RTN","XWBRM",90,0)
 NEW XWBDAT,XWBMSG
"RTN","XWBRM",91,0)
 SET XWBMSG=$P($TEXT(RMERRS+XWBCODE),";;",2)
"RTN","XWBRM",92,0)
 SET XWBDAT("MESSAGE TYPE")="Gov.VA.Med.Foundations.Errors"
"RTN","XWBRM",93,0)
 SET XWBDAT("ERRORS",1,"CODE")=1
"RTN","XWBRM",94,0)
 SET XWBDAT("ERRORS",1,"ERROR TYPE")="request manager"
"RTN","XWBRM",95,0)
 SET XWBDAT("ERRORS",1,"CDATA")=1
"RTN","XWBRM",96,0)
 SET XWBDAT("ERRORS",1,"MESSAGE",1)="An Request Manager error occurred: "_XWBMSG
"RTN","XWBRM",97,0)
 DO ERROR^XWBUTL(.XWBDAT)
"RTN","XWBRM",98,0)
 QUIT
"RTN","XWBRM",99,0)
 ;
"RTN","XWBRM",100,0)
RMERRS ; -- application errors
"RTN","XWBRM",101,0)
 ;;No valid application specified
"RTN","XWBRM",102,0)
 ;;
"RTN","XWBRM",103,0)
 ;
"RTN","XWBRM",104,0)
SECERR(XWBCODES) ; -- send security error message and log
"RTN","XWBRM",105,0)
 NEW XWBDAT,XWBCNT,XWBCODE
"RTN","XWBRM",106,0)
 SET XWBCNT=0
"RTN","XWBRM",107,0)
 SET XWBDAT("MESSAGE TYPE")="Gov.VA.Med.Foundations.Security.Errors"
"RTN","XWBRM",108,0)
 SET XWBCODE=0 FOR  SET XWBCODE=$O(XWBCODES(XWBCODE)) Q:'XWBCODE  DO
"RTN","XWBRM",109,0)
 . SET XWBCNT=XWBCNT+1
"RTN","XWBRM",110,0)
 . SET XWBDAT("ERRORS",XWBCNT,"CODE")=XWBCODE
"RTN","XWBRM",111,0)
 . SET XWBDAT("ERRORS",XWBCNT,"ERROR TYPE")="security"
"RTN","XWBRM",112,0)
 . SET XWBDAT("ERRORS",XWBCNT,"MESSAGE",1)=$P($TEXT(SECERRS+XWBCODE),";;",2)
"RTN","XWBRM",113,0)
 . SET XWBDAT("ERRORS",XWBCNT,"CDATA")=0
"RTN","XWBRM",114,0)
 . D XTMP
"RTN","XWBRM",115,0)
 DO ERROR^XWBUTL(.XWBDAT)
"RTN","XWBRM",116,0)
 QUIT
"RTN","XWBRM",117,0)
 ;
"RTN","XWBRM",118,0)
SECERRS ; -- security errors
"RTN","XWBRM",119,0)
 ;;Security token is either invalid or was not passed.
"RTN","XWBRM",120,0)
 ;;DUZ is either invalid or was not passed.
"RTN","XWBRM",121,0)
 ;;
"RTN","XWBRM",122,0)
 ;
"RTN","XWBRM",123,0)
XTMP ;
"RTN","XWBRM",124,0)
 ;reset expiration date to T+7 on security log
"RTN","XWBRM",125,0)
 S:'$G(^XTMP("XWBSEC"_DT,0)) ^(0)=$$FMADD^XLFDT(DT,7)_U_DT_U_0
"RTN","XWBRM",126,0)
 S X=$P(^XTMP("XWBSEC"_DT,0),U,3)+1,$P(^(0),U,3)=X,^(X)=XWBCODE_U_$J_U_$G(IO("IP"))
"RTN","XWBRM",127,0)
 Q
"RTN","XWBRW")
0^47^B9339344^B9161692
"RTN","XWBRW",1,0)
XWBRW ;ISF/RWF - Read/Write for Broker TCP ;09/15/15  06:26
"RTN","XWBRW",2,0)
 ;;1.1;RPC BROKER;**35,49,64**;Mar 28, 1997;Build 12
"RTN","XWBRW",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","XWBRW",4,0)
 Q
"RTN","XWBRW",5,0)
 ;
"RTN","XWBRW",6,0)
 ;XWBRBUF is global
"RTN","XWBRW",7,0)
 ;SE is a flag to skip error for short read. From PRSB+41^XWBBRK
"RTN","XWBRW",8,0)
BREAD(L,TO,SE) ;read tcp buffer, L is length, TO is timeout
"RTN","XWBRW",9,0)
 N R,S,DONE,C,MODE
"RTN","XWBRW",10,0)
 I L'>0 Q ""
"RTN","XWBRW",11,0)
 I $L(XWBRBUF)'<L S R=$E(XWBRBUF,1,L),XWBRBUF=$E(XWBRBUF,L+1,999999) Q R
"RTN","XWBRW",12,0)
 S R="",DONE=0,L=+L,C=0
"RTN","XWBRW",13,0)
 S TO=$S($G(TO)>0:TO,$G(XWBTIME(1))>0:XWBTIME(1),1:60)/2+1,MODE=(XWBOS="GT.M")
"RTN","XWBRW",14,0)
 U XWBTDEV
"RTN","XWBRW",15,0)
 F  D  Q:DONE
"RTN","XWBRW",16,0)
 . S S=L-$L(R),R=R_$E(XWBRBUF,1,S),XWBRBUF=$E(XWBRBUF,S+1,999999)
"RTN","XWBRW",17,0)
 . I ($L(R)=L)!(R[$C(4))!(C>TO) S DONE=1 Q
"RTN","XWBRW",18,0)
 . I MODE R XWBRBUF#S:2 S:'$T C=C+1 ;p49
"RTN","XWBRW",19,0)
 . I 'MODE R XWBRBUF:2 S:'$T C=C+1 ;p49
"RTN","XWBRW",20,0)
 . S:$L(XWBRBUF) C=0 I $DEVICE S DONE=1 Q  ;p49
"RTN","XWBRW",21,0)
 . I $G(XWBDEBUG)>2,$L(XWBRBUF) D LOG^XWBDLOG("rd: "_$E(XWBRBUF,1,252))
"RTN","XWBRW",22,0)
 . Q
"RTN","XWBRW",23,0)
 I $L(R)<L,'$G(SE) S $ECODE=",U411," ;Throw Error, Did not read full length
"RTN","XWBRW",24,0)
 Q R
"RTN","XWBRW",25,0)
 ;
"RTN","XWBRW",26,0)
QSND(XWBR) ;Quick send
"RTN","XWBRW",27,0)
 S XWBPTYPE=1,XWBERROR="",XWBSEC="" D SND
"RTN","XWBRW",28,0)
 Q
"RTN","XWBRW",29,0)
 ;
"RTN","XWBRW",30,0)
ESND(XWBR) ;Send from ETRAP
"RTN","XWBRW",31,0)
 S XWBPTYPE=1 D SND
"RTN","XWBRW",32,0)
 Q
"RTN","XWBRW",33,0)
 ;
"RTN","XWBRW",34,0)
SND ; Send a response
"RTN","XWBRW",35,0)
 N XWBSBUF S XWBSBUF=""
"RTN","XWBRW",36,0)
 U XWBTDEV
"RTN","XWBRW",37,0)
 ;
"RTN","XWBRW",38,0)
 D SNDERR ;Send any error info
"RTN","XWBRW",39,0)
 D SNDDATA ;Send the data
"RTN","XWBRW",40,0)
 D WRITE($C(4)),WBF
"RTN","XWBRW",41,0)
 Q
"RTN","XWBRW",42,0)
 ;
"RTN","XWBRW",43,0)
SNDDATA ;Send the data part
"RTN","XWBRW",44,0)
 N I,D
"RTN","XWBRW",45,0)
 ; -- single value
"RTN","XWBRW",46,0)
 I XWBPTYPE=1 D WRITE($G(XWBR)) Q
"RTN","XWBRW",47,0)
 ; -- table delimited by CR+LF
"RTN","XWBRW",48,0)
 I XWBPTYPE=2 D  Q
"RTN","XWBRW",49,0)
 . S I="" F  S I=$O(XWBR(I)) Q:I=""  D WRITE(XWBR(I)),WRITE($C(13,10))
"RTN","XWBRW",50,0)
 ; -- word processing
"RTN","XWBRW",51,0)
 I XWBPTYPE=3 D  Q
"RTN","XWBRW",52,0)
 . S I="" F  S I=$O(XWBR(I)) Q:I=""  D WRITE(XWBR(I)) D:XWBWRAP WRITE($C(13,10))
"RTN","XWBRW",53,0)
 ; -- global array
"RTN","XWBRW",54,0)
 I XWBPTYPE=4 D  Q
"RTN","XWBRW",55,0)
 . I $E($G(XWBR))'="^" Q
"RTN","XWBRW",56,0)
 . S I=$G(XWBR) Q:I=""  S T=$E(I,1,$L(I)-1)
"RTN","XWBRW",57,0)
 . ;Only send root node if non-null.
"RTN","XWBRW",58,0)
 . I $D(@I)>10 S D=@I I $L(D) D WRITE(D),WRITE($C(13,10)):XWBWRAP&(D'=$C(13,10))
"RTN","XWBRW",59,0)
 . F  S I=$Q(@I) Q:I=""!(I'[T)  S D=@I D WRITE(D),WRITE($C(13,10)):XWBWRAP&(D'=$C(13,10))
"RTN","XWBRW",60,0)
 . I $D(@XWBR),XWBR'["^XTMP(" K @XWBR  ;p64
"RTN","XWBRW",61,0)
 ; -- global instance
"RTN","XWBRW",62,0)
 I XWBPTYPE=5 D  Q
"RTN","XWBRW",63,0)
 . I $E($G(XWBR))'="^" Q
"RTN","XWBRW",64,0)
 . S XWBR=$G(@XWBR) D WRITE(XWBR) Q
"RTN","XWBRW",65,0)
 ; -- variable length records only good upto 255 char)
"RTN","XWBRW",66,0)
 I XWBPTYPE=6 D
"RTN","XWBRW",67,0)
 . S I="" F  S I=$O(XWBR(I)) Q:I=""  D WRITE($C($L(XWBR(I)))),WRITE(XWBR(I))
"RTN","XWBRW",68,0)
 Q
"RTN","XWBRW",69,0)
 ;
"RTN","XWBRW",70,0)
SNDERR ;send error information
"RTN","XWBRW",71,0)
 ;XWBSEC is the security packet, XWBERROR is application packet
"RTN","XWBRW",72,0)
 N X
"RTN","XWBRW",73,0)
 S $X=0 ;Start with zero
"RTN","XWBRW",74,0)
 S X=$E($G(XWBSEC),1,255)
"RTN","XWBRW",75,0)
 D WRITE($C($L(X))_X)
"RTN","XWBRW",76,0)
 S X=$E($G(XWBERROR),1,255)
"RTN","XWBRW",77,0)
 D WRITE($C($L(X))_X)
"RTN","XWBRW",78,0)
 S XWBERROR="",XWBSEC="" ;clears parameters
"RTN","XWBRW",79,0)
 Q
"RTN","XWBRW",80,0)
 ;
"RTN","XWBRW",81,0)
WRITE(STR) ;Write a data string
"RTN","XWBRW",82,0)
 ; send data for DSM (requires buffer flush (!) every 511 chars)
"RTN","XWBRW",83,0)
 ;IF XWBOS="DSM"!(XWBOS="UNIX")!(XWBOS="OpenM) next line
"RTN","XWBRW",84,0)
 N MAX S MAX=255 ;p49
"RTN","XWBRW",85,0)
 F  Q:'$L(STR)  D
"RTN","XWBRW",86,0)
 . I $L(XWBSBUF)+$L(STR)>MAX D WBF
"RTN","XWBRW",87,0)
 . S XWBSBUF=XWBSBUF_$E(STR,1,MAX),STR=$E(STR,MAX+1,99999) ;p49
"RTN","XWBRW",88,0)
 Q
"RTN","XWBRW",89,0)
WBF ;Write Buffer Flush
"RTN","XWBRW",90,0)
 Q:'$L(XWBSBUF)
"RTN","XWBRW",91,0)
 I $G(XWBDEBUG)>2,$L(XWBSBUF) D LOG^XWBDLOG("wrt ("_$L(XWBSBUF)_"): "_$E(XWBSBUF,1,247))
"RTN","XWBRW",92,0)
 W XWBSBUF,@XWBT("BF")
"RTN","XWBRW",93,0)
 S XWBSBUF=""
"RTN","XWBRW",94,0)
 Q
"RTN","XWBSEC")
0^38^B7994154^B5680874
"RTN","XWBSEC",1,0)
XWBSEC ;ISF/VYD,ISD/HGW - RPC BROKER ; 7/21/16 4:34pm
"RTN","XWBSEC",2,0)
 ;;1.1;RPC BROKER;**3,6,10,35,53,64**;Mar 28, 1997;Build 12
"RTN","XWBSEC",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","XWBSEC",4,0)
 ;
"RTN","XWBSEC",5,0)
CHKPRMIT(XWBRP) ;checks to see if remote procedure is permitted to run
"RTN","XWBSEC",6,0)
 ;Input:  XWBRP  - Remote procedure to check
"RTN","XWBSEC",7,0)
 ;Output: XWBSEC - Error message if RPC cannot be run
"RTN","XWBSEC",8,0)
 ; ZEXCEPT: XQY0,XWBSEC - Kernel exemption for global variables
"RTN","XWBSEC",9,0)
 N ERR,XWBPRMIT,XWBALLOW
"RTN","XWBSEC",10,0)
 S U="^",XWBSEC="" ;Return XWBSEC="" if OK to run RPC
"RTN","XWBSEC",11,0)
 Q:$$KCHK^XUSRB("XUPROGMODE")
"RTN","XWBSEC",12,0)
 ;
"RTN","XWBSEC",13,0)
 ;In the beginning, when no DUZ is defined and no context exist, setup
"RTN","XWBSEC",14,0)
 ;default signon context
"RTN","XWBSEC",15,0)
 S:'$G(DUZ) DUZ=0,XQY0="XUS SIGNON"   ;set up default context
"RTN","XWBSEC",16,0)
 ;
"RTN","XWBSEC",17,0)
 ;These RPC's are allowed in any context, so we can just quit
"RTN","XWBSEC",18,0)
 I "^XWB IM HERE^XWB CREATE CONTEXT^XWB RPC LIST^XWB IS RPC AVAILABLE^XUS GET USER INFO^XUS GET TOKEN^XUS SET VISITOR^"[(U_XWBRP_U) Q  ;p53
"RTN","XWBSEC",19,0)
 I "^XUS IAM BIND USER^XUS CVC^XUS KEY CHECK^XUS BSE TOKEN^"[(U_XWBRP_U) Q  ;p64
"RTN","XWBSEC",20,0)
 ;VistAlink RPC's that are always allowed.
"RTN","XWBSEC",21,0)
 I "^XUS KAAJEE GET USER INFO^XUS KAAJEE LOGOUT^"[(U_XWBRP_U) Q
"RTN","XWBSEC",22,0)
 ;
"RTN","XWBSEC",23,0)
 ;If in Signon context, only allow XUS and XWB rpc's
"RTN","XWBSEC",24,0)
 I $G(XQY0)="XUS SIGNON","^XUS^XWB^"'[(U_$E(XWBRP,1,3)_U) S XWBSEC="Application context has not been created!" Q
"RTN","XWBSEC",25,0)
 ;XQCS allows all users access to the XUS SIGNON context.
"RTN","XWBSEC",26,0)
 ;Also to any context in the XUCOMMAND menu.
"RTN","XWBSEC",27,0)
 ;
"RTN","XWBSEC",28,0)
 I $G(XQY0)'="" D  ;1.1*6. XQY0="" after XUS SIGNON context deleted.
"RTN","XWBSEC",29,0)
 . S XWBALLOW=$$CHK^XQCS(DUZ,$P(XQY0,U),XWBRP)         ;do the check
"RTN","XWBSEC",30,0)
 . I 'XWBALLOW S XWBSEC=XWBALLOW                       ;no access to RPC
"RTN","XWBSEC",31,0)
 E  S XWBSEC="Application context has not been created!"
"RTN","XWBSEC",32,0)
 Q
"RTN","XWBSEC",33,0)
 ;
"RTN","XWBSEC",34,0)
CRCONTXT(RESULT,OPTION,APPLCODE) ;creates context for the passed in option
"RTN","XWBSEC",35,0)
 ; ZEXCEPT: XQY,XQY0,XWBSEC - Kernel exemption for global variables
"RTN","XWBSEC",36,0)
 K XQY0,XQY
"RTN","XWBSEC",37,0)
 N XWB1,XWB2,XABPGMOD,XWBPGMOD,XWBCODE
"RTN","XWBSEC",38,0)
 S RESULT=0
"RTN","XWBSEC",39,0)
 I $D(APPLCODE) D         ;Assign an optional secondary menu option for user (SSOi, SSOe)
"RTN","XWBSEC",40,0)
 . S XWBCODE=$$AESDECR^XUSHSH($$B64DECD^XUSHSH(APPLCODE),"tHiZZfnmYjkFinis")
"RTN","XWBSEC",41,0)
 . S XWB2=$$SETCNTXT^XUESSO2(DUZ,XWBCODE)
"RTN","XWBSEC",42,0)
 S OPTION=$$DECRYP^XUSRB1(OPTION)
"RTN","XWBSEC",43,0)
 I OPTION="" S XQY=0,XQY0="",RESULT=1 Q  ;delete context if "" passed in.
"RTN","XWBSEC",44,0)
 S XWB1=$$OPTLK^XQCS(OPTION)
"RTN","XWBSEC",45,0)
 I XWB1="" S (XWBSEC,RESULT)="The context '"_OPTION_"' does not exist on server." Q  ;P10
"RTN","XWBSEC",46,0)
 ;Check Access (User with XUPROGMODE security key always has access)
"RTN","XWBSEC",47,0)
 S RESULT=$$CHK^XQCS(DUZ,XWB1)
"RTN","XWBSEC",48,0)
 S XWBPGMOD=$$KCHK^XUSRB("XUPROGMODE")
"RTN","XWBSEC",49,0)
 I RESULT!XWBPGMOD S XQY0=OPTION,XQY=XWB1,RESULT=1
"RTN","XWBSEC",50,0)
 E  S XWBSEC=RESULT
"RTN","XWBSEC",51,0)
 Q
"RTN","XWBSEC",52,0)
 ;
"RTN","XWBSEC",53,0)
STATE(%) ;Return a state value
"RTN","XWBSEC",54,0)
 ; ZEXCEPT: XWBSTATE - Kernel exemption for global variable
"RTN","XWBSEC",55,0)
 Q:'$L($G(%)) $G(XWBSTATE)
"RTN","XWBSEC",56,0)
 Q $G(XWBSTATE(%))
"RTN","XWBSEC",57,0)
 ;
"RTN","XWBSEC",58,0)
SET(%,VALUE) ;Set the state variable
"RTN","XWBSEC",59,0)
 ; ZEXCEPT: XWBSTATE - Kernel exemption for global variable
"RTN","XWBSEC",60,0)
 I $G(%)="" S XWBSTATE=VALUE
"RTN","XWBSEC",61,0)
 S XWBSTATE(%)=VALUE
"RTN","XWBSEC",62,0)
 Q
"RTN","XWBSEC",63,0)
 ;
"RTN","XWBSEC",64,0)
KILL(%) ;Kill state variable
"RTN","XWBSEC",65,0)
 ; ZEXCEPT: XWBSTATE - Kernel exemption for global variable
"RTN","XWBSEC",66,0)
 I $L($G(%)) K XWBSTATE(%)
"RTN","XWBSEC",67,0)
 Q
"RTN","XWBTCP")
0^39^B52455677^B48888024
"RTN","XWBTCP",1,0)
XWBTCP ;ISF/EG,ISD/HGW - Control TCP listener ;10/22/14  11:32
"RTN","XWBTCP",2,0)
 ;;1.1;RPC BROKER;**1,9,35,64**;Mar 28, 1997;Build 12
"RTN","XWBTCP",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","XWBTCP",4,0)
 ;
"RTN","XWBTCP",5,0)
EN ; -- entry point for interactive use
"RTN","XWBTCP",6,0)
 N X1,X2,XWBTDBG,XWBIP
"RTN","XWBTCP",7,0)
 S XWBIP=""
"RTN","XWBTCP",8,0)
 S:$G(IO("IP"))]"" XWBIP=IO("IP")
"RTN","XWBTCP",9,0)
 W !,"Enter client address: "_XWBIP_"//" R X1:300 Q:'$T  Q:X1="^"
"RTN","XWBTCP",10,0)
 W !,"   Enter client port: " R X2:300 Q:'$T  Q:X2="^"
"RTN","XWBTCP",11,0)
 W ! S XWBTDBG=""
"RTN","XWBTCP",12,0)
 IF X1="" S X1=XWBIP
"RTN","XWBTCP",13,0)
 IF $L(X1),$L(X2) D EN^XWBTCPC(X1,X2,"","1.08")
"RTN","XWBTCP",14,0)
 Q
"RTN","XWBTCP",15,0)
 ;
"RTN","XWBTCP",16,0)
STATSCRN(XWBNEW) ;Port STATUS field screen
"RTN","XWBTCP",17,0)
 ;DA: FileMan DA array.  See STATCHG tag bellow for detailed descr.
"RTN","XWBTCP",18,0)
 ;XWBCUR: Current value of STATUS field
"RTN","XWBTCP",19,0)
 ;XWBNEW: New/requested value of STATUS field
"RTN","XWBTCP",20,0)
 ;        The domain for XWBCUR and XWBNEW is the same as for the
"RTN","XWBTCP",21,0)
 ;        ACTION variable, described at STATCHG tag bellow.
"RTN","XWBTCP",22,0)
 N C,XWBCUR,RESULT
"RTN","XWBTCP",23,0)
 S C=","
"RTN","XWBTCP",24,0)
 S XWBCUR=$$GET1^DIQ(8994.171,DA_C_DA(1)_C_DA(2)_C,"STATUS","I")
"RTN","XWBTCP",25,0)
 S RESULT=0
"RTN","XWBTCP",26,0)
 I XWBCUR=3,XWBNEW=4 S RESULT=1 ;if stopping a running listener
"RTN","XWBTCP",27,0)
 I XWBCUR=6,XWBNEW=1 S RESULT=1 ;if starting a stopped listener
"RTN","XWBTCP",28,0)
 ;    the next two cases are most usefull whenever some error occurs
"RTN","XWBTCP",29,0)
 ;    and the STATUS field is stuck in STARTING or RUNNING state
"RTN","XWBTCP",30,0)
 I XWBCUR=2,XWBNEW=3 S RESULT=1 ;change to RUNNING if it's starting
"RTN","XWBTCP",31,0)
 I XWBCUR=5,XWBNEW=6 S RESULT=1 ;change to STOPPED if it's stopping
"RTN","XWBTCP",32,0)
 Q RESULT
"RTN","XWBTCP",33,0)
 ;
"RTN","XWBTCP",34,0)
 ;
"RTN","XWBTCP",35,0)
STATCHG(DA,ACTION) ;STATUS field X-ref SET logic
"RTN","XWBTCP",36,0)
 ;DA: FileMan DA array
"RTN","XWBTCP",37,0)
 ;  DA    =IEN of the port
"RTN","XWBTCP",38,0)
 ;  DA(1) =IEN of the BOX-VOLUME
"RTN","XWBTCP",39,0)
 ;  DA(2) =IEN of site/domain
"RTN","XWBTCP",40,0)
 ;ACTION: Requested value for the STATUS field.  Possible values are:
"RTN","XWBTCP",41,0)
 ;  1 = START, 2 = STARTING, 3 = RUNNING,
"RTN","XWBTCP",42,0)
 ;  4 = STOP,  5 = STOPPING, 6 = STOPPED
"RTN","XWBTCP",43,0)
 N C,ZTCPU,TYPE,XWBPORT,XWBFDA
"RTN","XWBTCP",44,0)
 S C=","
"RTN","XWBTCP",45,0)
 ;
"RTN","XWBTCP",46,0)
 I ACTION=1!(ACTION=4) D
"RTN","XWBTCP",47,0)
 . S ZTCPU=$$GET1^DIQ(8994.17,DA(1)_C_DA(2)_C,"BOX-VOLUME PAIR")
"RTN","XWBTCP",48,0)
 . S XWBPORT=$$GET1^DIQ(8994.171,DA_C_DA(1)_C_DA(2)_C,"PORT")
"RTN","XWBTCP",49,0)
 . ;S TYPE=$$GET1^DIQ(8994.171,DA_C_DA(1)_C_DA(2)_C,"TYPE OF LISTENER","I")
"RTN","XWBTCP",50,0)
 . S TYPE=1 ; only start new-style listener, old-style listener is deprecated
"RTN","XWBTCP",51,0)
 . ;UCI is no longer derived from the file, but comes from current
"RTN","XWBTCP",52,0)
 . ;environment.  The reason for that is it makes no sense to start
"RTN","XWBTCP",53,0)
 . ;a listener in a UCI where ^XWB can't be reached to change status.
"RTN","XWBTCP",54,0)
 . D GETENV^%ZOSV
"RTN","XWBTCP",55,0)
 . S ZTUCI=$P(Y,U),ZTIO="",ZTREQ="@",ZTDTH=$H ;run it ASAP
"RTN","XWBTCP",56,0)
 . I ACTION=1 D    ; -- START listener
"RTN","XWBTCP",57,0)
 . . S ZTDESC="RPC Broker Listener START on "_ZTUCI_"-"_ZTCPU_", port "_XWBPORT
"RTN","XWBTCP",58,0)
 . . S ZTRTN=$S(TYPE=1:"ZISTCP^XWBTCPM1("_XWBPORT_")",1:"EN^XWBTCPL("_XWBPORT_")")
"RTN","XWBTCP",59,0)
 . E  D            ; -- STOP listener
"RTN","XWBTCP",60,0)
 . . S ZTDESC="RPC Broker Listener STOP on "_ZTUCI_"-"_ZTCPU_", port "_XWBPORT
"RTN","XWBTCP",61,0)
 . . S ZTRTN="STOP^XWBTCP("_XWBPORT_")"
"RTN","XWBTCP",62,0)
 . D EN^DDIOL("Task: "_ZTDESC,"","!?10") ;inform user
"RTN","XWBTCP",63,0)
 . D ^%ZTLOAD      ; queue it
"RTN","XWBTCP",64,0)
 . D EN^DDIOL("has been queued as task "_ZTSK,"","!?10") ;inform user
"RTN","XWBTCP",65,0)
 . ; --  change STATUS from START to STARTING or from STOP to STOPPING
"RTN","XWBTCP",66,0)
 . D FDA^DILF(8994.171,DA_C_DA(1)_C_DA(2)_C,1,"R",ACTION+1,"XWBFDA")
"RTN","XWBTCP",67,0)
 . D FILE^DIE("K","XWBFDA")
"RTN","XWBTCP",68,0)
 Q
"RTN","XWBTCP",69,0)
 ;
"RTN","XWBTCP",70,0)
 ;
"RTN","XWBTCP",71,0)
STRT(XWBTSKT) ;start TCP Listener.  Interactive entry point
"RTN","XWBTCP",72,0)
 N IP,REF,Y,%
"RTN","XWBTCP",73,0)
 S U="^" D HOME^%ZIS
"RTN","XWBTCP",74,0)
 W "Start TCP Listener...",!
"RTN","XWBTCP",75,0)
 X ^%ZOSF("UCI") S REF=Y
"RTN","XWBTCP",76,0)
 S IP=$$CONVERT^XLFIPV("::0") ;get server IP at some point, start with null address
"RTN","XWBTCP",77,0)
 IF $G(XWBTSKT)="" S XWBTSKT=9000 ;default service port is 9000
"RTN","XWBTCP",78,0)
 ;
"RTN","XWBTCP",79,0)
 ; -- see if 'running flag' for listener is set
"RTN","XWBTCP",80,0)
 I '$$SEMAPHOR^XWBTCPL(XWBTSKT,"LOCK") W "TCP Listener on port "_XWBTSKT_" appears to be running already.",! Q
"RTN","XWBTCP",81,0)
 S %=$$SEMAPHOR^XWBTCPL(XWBTSKT,"UNLOCK")
"RTN","XWBTCP",82,0)
 ;
"RTN","XWBTCP",83,0)
 D MARKER(XWBTSKT,1) ;record problem marker
"RTN","XWBTCP",84,0)
 ; -- start the listener
"RTN","XWBTCP",85,0)
 J EN^XWBTCPL(XWBTSKT)::5 ;Used in place of TaskMan, Need to start on any node.
"RTN","XWBTCP",86,0)
 I '$T W "Unable to run TCP Listener in background.",! Q
"RTN","XWBTCP",87,0)
 F %=1:1:5 D  Q:%=0
"RTN","XWBTCP",88,0)
 . W "Checking if TCP Listener has started...",!
"RTN","XWBTCP",89,0)
 . H 3
"RTN","XWBTCP",90,0)
 . S:'$$MARKER(XWBTSKT,0) %=0
"RTN","XWBTCP",91,0)
 I $$MARKER(XWBTSKT,0) D
"RTN","XWBTCP",92,0)
 . W !,"TCP Listener could not be started!",!
"RTN","XWBTCP",93,0)
 . W "Check if port "_XWBTSKT_" is busy on this CPU.",!
"RTN","XWBTCP",94,0)
 . D MARKER(XWBTSKT,-1) ;clear marker
"RTN","XWBTCP",95,0)
 E  W "TCP Listener started successfully."
"RTN","XWBTCP",96,0)
 Q
"RTN","XWBTCP",97,0)
 ;
"RTN","XWBTCP",98,0)
MARKER(PORT,MODE) ;Set/Test/Clear Problem Marker, Mode=0 is a function
"RTN","XWBTCP",99,0)
 N IP,Y,%,REF X ^%ZOSF("UCI") S REF=Y,IP=$$CONVERT^XLFIPV("::0"),%=0
"RTN","XWBTCP",100,0)
 L +^XWB(IP,REF,XWBTSKT,"PROBLEM MARKER")
"RTN","XWBTCP",101,0)
 I MODE=1 S ^XWB(IP,REF,XWBTSKT,"PROBLEM MARKER")=1
"RTN","XWBTCP",102,0)
 I MODE=0 S:$D(^XWB(IP,REF,XWBTSKT,"PROBLEM MARKER")) %=1
"RTN","XWBTCP",103,0)
 I MODE=-1 K ^XWB(IP,REF,XWBTSKT,"PROBLEM MARKER")
"RTN","XWBTCP",104,0)
 L -^XWB(IP,REF,XWBTSKT,"PROBLEM MARKER")
"RTN","XWBTCP",105,0)
 Q:MODE=0 % Q
"RTN","XWBTCP",106,0)
 ;
"RTN","XWBTCP",107,0)
STRTALL ;XWB LISTENER STARTER option entry point
"RTN","XWBTCP",108,0)
 ;here all listener entries in RPC Broker Site Parameters file that
"RTN","XWBTCP",109,0)
 ;have CONTROLLED BY LISTENER STARTER set to 1/Yes will be started.
"RTN","XWBTCP",110,0)
 N E,LSTN,LSTNID,LSTNIENS,PORTID,XWBSCR,XWBDA
"RTN","XWBTCP",111,0)
 ;XWBDA: Namespaced FileMan DA array
"RTN","XWBTCP",112,0)
 ;  XWBDA    =IEN of the port
"RTN","XWBTCP",113,0)
 ;  XWBDA(1) =IEN of the BOX-VOLUME
"RTN","XWBTCP",114,0)
 ;  XWBDA(2) =IEN of site/domain
"RTN","XWBTCP",115,0)
 S E=""
"RTN","XWBTCP",116,0)
 S XWBDA(2)=1 ;hard set IEN of site/domain
"RTN","XWBTCP",117,0)
 ; -- screen out RUNNING (STATUS=3) listeners and those that aren't controlled by XWB LISTENER STARTER option.
"RTN","XWBTCP",118,0)
 S XWBSCR="I $P(^(0),U,2)'=3,$P(^(0),U,4)"
"RTN","XWBTCP",119,0)
 ; -- get top level listners box-volume
"RTN","XWBTCP",120,0)
 D LIST^DIC(8994.17,",1,",E,E,E,E,E,E,E,E,$NA(LSTN("LSTNR")))
"RTN","XWBTCP",121,0)
 S LSTNID=""
"RTN","XWBTCP",122,0)
 F  S LSTNID=$O(LSTN("LSTNR","DILIST",1,LSTNID)) Q:LSTNID=""  D
"RTN","XWBTCP",123,0)
 . S XWBDA(1)=LSTN("LSTNR","DILIST",2,LSTNID) ;IEN of each listener
"RTN","XWBTCP",124,0)
 . S LSTNIENS=","_XWBDA(1)_","_XWBDA(2)_","
"RTN","XWBTCP",125,0)
 . D LIST^DIC(8994.171,LSTNIENS,E,"P",E,E,E,E,XWBSCR,E,$NA(LSTN("PORT")))
"RTN","XWBTCP",126,0)
 . S PORTID=0
"RTN","XWBTCP",127,0)
 . F  S PORTID=$O(LSTN("PORT","DILIST",PORTID)) Q:PORTID=""  D
"RTN","XWBTCP",128,0)
 . . S XWBDA=$P(LSTN("PORT","DILIST",PORTID,0),U,1)
"RTN","XWBTCP",129,0)
 . . D STATCHG(.XWBDA,1) ;use STATUS field X-ref SET logic to queue up start of a listener
"RTN","XWBTCP",130,0)
 Q
"RTN","XWBTCP",131,0)
 ;
"RTN","XWBTCP",132,0)
STOPALL ;XWB LISTENER STOP ALL entry point
"RTN","XWBTCP",133,0)
 ;here all listener entries in RPC Broker Site Parameters file that
"RTN","XWBTCP",134,0)
 ;have CONTROLLED BY LISTENER STARTER set to 1/Yes will be stopped.
"RTN","XWBTCP",135,0)
 N E,LSTN,LSTNID,LSTNIENS,PORTID,XWBSCR,XWBDA
"RTN","XWBTCP",136,0)
 ;XWBDA: Namespaced FileMan DA array
"RTN","XWBTCP",137,0)
 ;  XWBDA    =IEN of the port
"RTN","XWBTCP",138,0)
 ;  XWBDA(1) =IEN of the BOX-VOLUME
"RTN","XWBTCP",139,0)
 ;  XWBDA(2) =IEN of site/domain
"RTN","XWBTCP",140,0)
 S E=""
"RTN","XWBTCP",141,0)
 S XWBDA(2)=1 ;hard set IEN of site/domain
"RTN","XWBTCP",142,0)
 ; -- screen out STOPPED (STATUS=3) listeners and those that aren't controlled by XWB LISTENER STARTER option.
"RTN","XWBTCP",143,0)
 S XWBSCR="I $P(^(0),U,2)'=6,$P(^(0),U,4)"
"RTN","XWBTCP",144,0)
 ; -- get top level listners box-volume
"RTN","XWBTCP",145,0)
 D LIST^DIC(8994.17,",1,",E,E,E,E,E,E,E,E,$NA(LSTN("LSTNR")))
"RTN","XWBTCP",146,0)
 S LSTNID=""
"RTN","XWBTCP",147,0)
 F  S LSTNID=$O(LSTN("LSTNR","DILIST",1,LSTNID)) Q:LSTNID=""  D
"RTN","XWBTCP",148,0)
 . S XWBDA(1)=LSTN("LSTNR","DILIST",2,LSTNID) ;IEN of each listener
"RTN","XWBTCP",149,0)
 . S LSTNIENS=","_XWBDA(1)_","_XWBDA(2)_","
"RTN","XWBTCP",150,0)
 . D LIST^DIC(8994.171,LSTNIENS,E,"P",E,E,E,E,XWBSCR,E,$NA(LSTN("PORT")))
"RTN","XWBTCP",151,0)
 . S PORTID=0
"RTN","XWBTCP",152,0)
 . F  S PORTID=$O(LSTN("PORT","DILIST",PORTID)) Q:PORTID=""  D
"RTN","XWBTCP",153,0)
 . . S XWBDA=$P(LSTN("PORT","DILIST",PORTID,0),U,1)
"RTN","XWBTCP",154,0)
 . . D STATCHG(.XWBDA,4) ;use STATUS field X-ref SET logic to queue up stop of a listener
"RTN","XWBTCP",155,0)
 Q
"RTN","XWBTCP",156,0)
 ;
"RTN","XWBTCP",157,0)
RESTART ;Stop and then Start all listeners.
"RTN","XWBTCP",158,0)
 D STOPALL H 15 D STRTALL
"RTN","XWBTCP",159,0)
 Q
"RTN","XWBTCP",160,0)
 ;
"RTN","XWBTCP",161,0)
STOP(XWBTSKT) ;stop TCP Listener.  Interactive and TaskMan entry point
"RTN","XWBTCP",162,0)
 N IP,REF,X,DEV,XWBOS,XWBIP,XWBENV
"RTN","XWBTCP",163,0)
 S U="^" D HOME^%ZIS,GETENV^%ZOSV S XWBENV=Y
"RTN","XWBTCP",164,0)
 D EN^DDIOL("Stop TCP Listener...")
"RTN","XWBTCP",165,0)
 X ^%ZOSF("UCI") S REF=Y
"RTN","XWBTCP",166,0)
 S IP=$$CONVERT^XLFIPV("::0") ;get server IP, start with null address
"RTN","XWBTCP",167,0)
 IF $G(XWBTSKT)="" S XWBTSKT=9000 ;default service port is 9000
"RTN","XWBTCP",168,0)
 ;
"RTN","XWBTCP",169,0)
 S XWBOS=$S(^%ZOSF("OS")["DSM":"DSM",^("OS")["MSM":"MSM",^("OS")["OpenM":"OpenM",1:"") ;RWF
"RTN","XWBTCP",170,0)
 ;
"RTN","XWBTCP",171,0)
 ; -- make sure the listener is running
"RTN","XWBTCP",172,0)
 I $$SEMAPHOR^XWBTCPL(XWBTSKT,"LOCK") D  Q
"RTN","XWBTCP",173,0)
 . S %=$$SEMAPHOR^XWBTCPL(XWBTSKT,"UNLOCK")
"RTN","XWBTCP",174,0)
 . D EN^DDIOL("TCP Listener does not appear to be running.")
"RTN","XWBTCP",175,0)
 ;
"RTN","XWBTCP",176,0)
 S X=$$NODE^XWBTCPM1(XWBTSKT) ;Get node
"RTN","XWBTCP",177,0)
 I $P(X,"^",3)=1 D  Q
"RTN","XWBTCP",178,0)
 . D EN^DDIOL("New listener should stop on its own")
"RTN","XWBTCP",179,0)
 ;
"RTN","XWBTCP",180,0)
 ; -- send the shutdown message to the TCP Listener process
"RTN","XWBTCP",181,0)
 ;    using loopback address
"RTN","XWBTCP",182,0)
 S XWBIP=$$CONVERT^XLFIPV("::1") ; start with loopback address
"RTN","XWBTCP",183,0)
 D CALL^%ZISTCP(XWBIP,XWBTSKT) I POP D  Q
"RTN","XWBTCP",184,0)
 . S %=$$SEMAPHOR^XWBTCPL(XWBTSKT,"UNLOCK")
"RTN","XWBTCP",185,0)
 . D EN^DDIOL("TCP Listener does not appear to be running.")
"RTN","XWBTCP",186,0)
 U IO
"RTN","XWBTCP",187,0)
 ;
"RTN","XWBTCP",188,0)
 S X=$T(+2),X=$P(X,";;",2),X=$P(X,";")
"RTN","XWBTCP",189,0)
 IF X="" S X=0
"RTN","XWBTCP",190,0)
 S X=$C($L(X))_X
"RTN","XWBTCP",191,0)
 W "{XWB}00020|"_X_"00011TCPshutdown",!
"RTN","XWBTCP",192,0)
 R X:5
"RTN","XWBTCP",193,0)
 D CLOSE^%ZISTCP
"RTN","XWBTCP",194,0)
 IF X["ack" D EN^DDIOL("TCP Listener has been shutdown.")
"RTN","XWBTCP",195,0)
 ELSE  D EN^DDIOL("Shutdown Failed!")
"RTN","XWBTCP",196,0)
 Q
"RTN","XWBTCP",197,0)
 ;
"RTN","XWBTCP",198,0)
DEBUG ;Edit the debug parameter
"RTN","XWBTCP",199,0)
 W !!
"RTN","XWBTCP",200,0)
 D EDITPAR^XPAREDIT("XWBDEBUG")
"RTN","XWBTCP",201,0)
 W !!
"RTN","XWBTCP",202,0)
 Q
"RTN","XWBTCPM")
0^42^B57009144^B56306340
"RTN","XWBTCPM",1,0)
XWBTCPM ;ISF/RWF - BROKER TCP/IP PROCESS HANDLER ;05/27/15  14:40
"RTN","XWBTCPM",2,0)
 ;;1.1;RPC BROKER;**35,43,49,53,64**;Mar 28, 1997;Build 12
"RTN","XWBTCPM",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","XWBTCPM",4,0)
 ;
"RTN","XWBTCPM",5,0)
 ;Changed to be started by TCPIP service or %ZISTCPS
"RTN","XWBTCPM",6,0)
 ;
"RTN","XWBTCPM",7,0)
DSM ;DSM called from ucx, % passed in with device.
"RTN","XWBTCPM",8,0)
 D ESET
"RTN","XWBTCPM",9,0)
 ;Open the device
"RTN","XWBTCPM",10,0)
 S XWBTDEV=% X "O XWBTDEV:(TCPDEV):60" ;Special UCX/DSM open
"RTN","XWBTCPM",11,0)
 ;Go find the connection type
"RTN","XWBTCPM",12,0)
 U XWBTDEV
"RTN","XWBTCPM",13,0)
 G CONNTYPE
"RTN","XWBTCPM",14,0)
 ;
"RTN","XWBTCPM",15,0)
CACHEVMS ;Cache'/VMS tcpip entry point, called from XWBTCP_START.COM file
"RTN","XWBTCPM",16,0)
 D ESET
"RTN","XWBTCPM",17,0)
 S XWBTDEV=$S($ZV["VMS":"SYS$NET",1:$P) ;Support for both VMS/TCPIP and Linux/xinetd
"RTN","XWBTCPM",18,0)
 ; **Cache'/VMS specific code**
"RTN","XWBTCPM",19,0)
 O XWBTDEV::5
"RTN","XWBTCPM",20,0)
 X "U XWBTDEV:(::""-M"")" ;Packet mode like DSM
"RTN","XWBTCPM",21,0)
 G CONNTYPE
"RTN","XWBTCPM",22,0)
 ;
"RTN","XWBTCPM",23,0)
NT ;entry from ZISTCPS
"RTN","XWBTCPM",24,0)
 ;JOB LISTEN^%ZISTCPS("port","NT^XWBTCPM","stop code")
"RTN","XWBTCPM",25,0)
 D ESET
"RTN","XWBTCPM",26,0)
 S XWBTDEV=IO
"RTN","XWBTCPM",27,0)
 G CONNTYPE
"RTN","XWBTCPM",28,0)
 ;
"RTN","XWBTCPM",29,0)
GTMUCX(%) ;From ucx ZFOO
"RTN","XWBTCPM",30,0)
 ;If called from LISTEN^%ZISTCP(PORT,"GTM^XWBTCPM") S XWBTDEV=IO
"RTN","XWBTCPM",31,0)
 D ESET
"RTN","XWBTCPM",32,0)
 ;GTM specific code
"RTN","XWBTCPM",33,0)
 S @("$ZINTERRUPT=""I $$JOBEXAM^ZU($ZPOSITION)""")
"RTN","XWBTCPM",34,0)
 S XWBTDEV=% X "O %:(RECORDSIZE=512)"
"RTN","XWBTCPM",35,0)
 G CONNTYPE
"RTN","XWBTCPM",36,0)
 ;
"RTN","XWBTCPM",37,0)
GTMLNX ;From Linux xinetd script
"RTN","XWBTCPM",38,0)
 D ESET
"RTN","XWBTCPM",39,0)
 ;GTM specific code
"RTN","XWBTCPM",40,0)
 S @("$ZINTERRUPT=""I $$JOBEXAM^ZU($ZPOSITION)""")
"RTN","XWBTCPM",41,0)
 S XWBTDEV=$P X "U XWBTDEV:(nowrap:nodelimiter:ioerror=""TRAP"")"
"RTN","XWBTCPM",42,0)
 S %="",@("%=$ZTRNLNM(""REMOTE_HOST"")") S:$L(%) IO("GTM-IP")=%
"RTN","XWBTCPM",43,0)
 G CONNTYPE
"RTN","XWBTCPM",44,0)
 ;
"RTN","XWBTCPM",45,0)
ESET ;Set inital error trap
"RTN","XWBTCPM",46,0)
 S U="^",$ETRAP="D ^%ZTER H" ;Set up the error trap
"RTN","XWBTCPM",47,0)
 S X="",@("$ZT=X") ;Clear old trap
"RTN","XWBTCPM",48,0)
 Q
"RTN","XWBTCPM",49,0)
 ;Find the type of connection and jump to the processing routine.
"RTN","XWBTCPM",50,0)
CONNTYPE ;
"RTN","XWBTCPM",51,0)
 N XWBDEBUG,XWBAPVER,XWBCLMAN,XWBENVL,XWBLOG,XWBOS,XWBPTYPE
"RTN","XWBTCPM",52,0)
 N XWBTBUF,XWBTIP,XWBTSKT,XWBVER,XWBWRAP,XWBSHARE,XWBT
"RTN","XWBTCPM",53,0)
 N SOCK,TYPE
"RTN","XWBTCPM",54,0)
 D INIT
"RTN","XWBTCPM",55,0)
 S XWB=$$BREAD^XWBRW(5,XWBTIME)
"RTN","XWBTCPM",56,0)
 D LOG("MSG format is "_XWB_" type "_$S(XWB="[XWB]":"NEW",XWB="{XWB}":"OLD",XWB="<?xml":"M2M",XWB="~BSE~":"BSE",XWB="~EAC~":"EAC",XWB="~SVR~":"SVR",1:"Unk")) ; XWB*1.1*XX
"RTN","XWBTCPM",57,0)
 I XWB["<?xml" G M2M
"RTN","XWBTCPM",58,0)
 I XWB["[XWB]" G NEW
"RTN","XWBTCPM",59,0)
 I XWB["{XWB}" G OLD^XWBTCPM1 ;Deprecated in XWB*1.1*60, to be removed when no longer being used
"RTN","XWBTCPM",60,0)
 I $L($T(OTH^XWBTCPM2)) D OTH^XWBTCPM2 ;See if a special code.
"RTN","XWBTCPM",61,0)
 I '$L($T(OTH^XWBTCPM2)) D LOG("Prefix not known: "_XWB) ; XWB*1.1*XX
"RTN","XWBTCPM",62,0)
 Q
"RTN","XWBTCPM",63,0)
 ;
"RTN","XWBTCPM",64,0)
NEWJOB() ;Check if OK to start a new job, Return 1 if OK, 0 if not OK.
"RTN","XWBTCPM",65,0)
 N X,Y,J,XWBVOL
"RTN","XWBTCPM",66,0)
 D GETENV^%ZOSV S XWBVOL=$P(Y,"^",2)
"RTN","XWBTCPM",67,0)
 S X=$O(^XTV(8989.3,1,4,"B",XWBVOL,0)),J=$S(X>0:^XTV(8989.3,1,4,X,0),1:"ROU^y^1")
"RTN","XWBTCPM",68,0)
 I $G(^%ZIS(14.5,"LOGON",XWBVOL)) Q 0 ;Check INHIBIT LOGONS?
"RTN","XWBTCPM",69,0)
 I $D(^%ZOSF("ACTJ")) X ^("ACTJ") I $P(J,U,3),($P(J,U,3)'>Y) Q 0
"RTN","XWBTCPM",70,0)
 Q 1
"RTN","XWBTCPM",71,0)
 ;
"RTN","XWBTCPM",72,0)
M2M ;M2M Broker
"RTN","XWBTCPM",73,0)
 S XWBRBUF=XWB_XWBRBUF,(IO,IO(0))=XWBTDEV G SPAWN^XWBVLL
"RTN","XWBTCPM",74,0)
 Q
"RTN","XWBTCPM",75,0)
 ;
"RTN","XWBTCPM",76,0)
NEW ;New broker
"RTN","XWBTCPM",77,0)
 S U="^",DUZ=0,DUZ(0)="",XWBVER=1.108
"RTN","XWBTCPM",78,0)
 D SETTIME(1) ;Setup for sign-on timeout
"RTN","XWBTCPM",79,0)
 U XWBTDEV D
"RTN","XWBTCPM",80,0)
 . N XWB,ERR,NATIP,I
"RTN","XWBTCPM",81,0)
 . S ERR=$$PRSP^XWBPRS
"RTN","XWBTCPM",82,0)
 . S ERR=$$PRSM^XWBPRS
"RTN","XWBTCPM",83,0)
 . S MSG=$G(XWB(4,"CMD")) ;Build connect msg.
"RTN","XWBTCPM",84,0)
 . S I="" F  S I=$O(XWB(5,"P",I)) Q:I=""  S MSG=MSG_U_XWB(5,"P",I)
"RTN","XWBTCPM",85,0)
 . ;Get the peer and save that IP.
"RTN","XWBTCPM",86,0)
 . S NATIP=$$GETPEER^%ZOSV S:'$L(NATIP) NATIP=$P(MSG,"^",2)
"RTN","XWBTCPM",87,0)
 . I NATIP'=$P(MSG,"^",2) S $P(MSG,"^",2)=NATIP
"RTN","XWBTCPM",88,0)
 . Q
"RTN","XWBTCPM",89,0)
 S X=$$NEWJOB() D:'X LOG("No New Connects")
"RTN","XWBTCPM",90,0)
 I ($P(MSG,U)'="TCPConnect")!('X) D QSND^XWBRW("reject"),LOG("reject: "_MSG) Q
"RTN","XWBTCPM",91,0)
 D QSND^XWBRW("accept"),LOG("accept") ;Ack
"RTN","XWBTCPM",92,0)
 S IO("IP")=$P(MSG,U,2),XWBTSKT=$P(MSG,U,3),XWBCLMAN=$P(MSG,U,4)
"RTN","XWBTCPM",93,0)
 S XWBTIP=$G(IO("IP"))
"RTN","XWBTCPM",94,0)
 ;start RUM for Broker Handler XWB*1.1*5
"RTN","XWBTCPM",95,0)
 D LOGRSRC^%ZOSV("$BROKER HANDLER$",2,1)
"RTN","XWBTCPM",96,0)
 ;GTM
"RTN","XWBTCPM",97,0)
 I $G(XWBT("PCNT")) D
"RTN","XWBTCPM",98,0)
 . S X=$NA(^XUTL("XUSYS",$J,1)) L +@X:0
"RTN","XWBTCPM",99,0)
 . D COUNT^XUSCNT(1),SETLOCK^XUSCNT(X)
"RTN","XWBTCPM",100,0)
 ;We don't use a callback
"RTN","XWBTCPM",101,0)
 K XWB,CON,LEN,MSG ;Clean up
"RTN","XWBTCPM",102,0)
 ;Attempt to share license, Must have TCP port open first.
"RTN","XWBTCPM",103,0)
 U XWBTDEV ;D SHARELIC^%ZOSV(1)
"RTN","XWBTCPM",104,0)
 ;setup null device "NULL"
"RTN","XWBTCPM",105,0)
 S %ZIS="0H",IOP="NULL" D ^%ZIS S XWBNULL=IO I POP S XWBERROR="No NULL device" D LOG(XWBERROR),EXIT Q
"RTN","XWBTCPM",106,0)
 D SAVDEV^%ZISUTL("XWBNULL")
"RTN","XWBTCPM",107,0)
 ;change process name
"RTN","XWBTCPM",108,0)
 D CHPRN("ip"_$P(XWBTIP,".",3,4)_":"_XWBTDEV)
"RTN","XWBTCPM",109,0)
 ;
"RTN","XWBTCPM",110,0)
RESTART ;The error trap returns to here
"RTN","XWBTCPM",111,0)
 N $ESTACK S $ETRAP="D ETRAP^XWBTCPM(0)"
"RTN","XWBTCPM",112,0)
 S DT=$$DT^XLFDT,DTIME=30
"RTN","XWBTCPM",113,0)
 U XWBTDEV D MAIN
"RTN","XWBTCPM",114,0)
 D LOG("Exit: "_XWBTBUF)
"RTN","XWBTCPM",115,0)
 ;Turn off the error trap for the exit
"RTN","XWBTCPM",116,0)
 S $ETRAP=""
"RTN","XWBTCPM",117,0)
 D EXIT ;Logout
"RTN","XWBTCPM",118,0)
 K XWBR,XWBARY
"RTN","XWBTCPM",119,0)
 ;stop RUM for handler XWB*1.1*5
"RTN","XWBTCPM",120,0)
 D LOGRSRC^%ZOSV("$BROKER HANDLER$",2,2)
"RTN","XWBTCPM",121,0)
 D USE^%ZISUTL("XWBNULL"),CLOSE^%ZISUTL("XWBNULL")
"RTN","XWBTCPM",122,0)
 ;Close in the calling script
"RTN","XWBTCPM",123,0)
 K SOCK,TYPE,XWBSND,XWBTYPE,XWBRBUF
"RTN","XWBTCPM",124,0)
 Q
"RTN","XWBTCPM",125,0)
 ;
"RTN","XWBTCPM",126,0)
MAIN ; -- main message processing loop. debug at MAIN+1
"RTN","XWBTCPM",127,0)
 F  D  Q:XWBTBUF="#BYE#"
"RTN","XWBTCPM",128,0)
 . ;Setup
"RTN","XWBTCPM",129,0)
 . S XWBAPVER=0,XWBTBUF="",XWBTCMD="",XWBRBUF=""
"RTN","XWBTCPM",130,0)
 . K XWBR,XWBARY,XWBPRT
"RTN","XWBTCPM",131,0)
 . ; -- read client request
"RTN","XWBTCPM",132,0)
 . S XR=$$BREAD^XWBRW(1,XWBTIME,1)
"RTN","XWBTCPM",133,0)
 . I '$L(XR) D LOG("Timeout: "_XWBTIME) S XWBTBUF="#BYE#" Q
"RTN","XWBTCPM",134,0)
 . S XR=XR_$$BREAD^XWBRW(4)
"RTN","XWBTCPM",135,0)
 . I XR="#BYE#" D  Q  ;Check for exit
"RTN","XWBTCPM",136,0)
 . . D QSND^XWBRW("#BYE#"),LOG("BYE CMD") S XWBTBUF="#BYE#"
"RTN","XWBTCPM",137,0)
 . . Q
"RTN","XWBTCPM",138,0)
 . S TYPE=(XR="[XWB]")  ;check HDR
"RTN","XWBTCPM",139,0)
 . I 'TYPE D LOG("Bad Header: "_XR) Q
"RTN","XWBTCPM",140,0)
 . D CALLP^XWBPRS(.XWBR,$G(XWBDEBUG)) ;Read the NEW Msg parameters and call RPC
"RTN","XWBTCPM",141,0)
 . IF XWBTCMD="#BYE#" D  Q
"RTN","XWBTCPM",142,0)
 . . D QSND^XWBRW("#BYE#"),LOG("BYE CMD") S XWBTBUF=XWBTCMD
"RTN","XWBTCPM",143,0)
 . . Q
"RTN","XWBTCPM",144,0)
 . U XWBTDEV
"RTN","XWBTCPM",145,0)
 . S XWBPTYPE=$S('$D(XWBPTYPE):1,XWBPTYPE<1:1,XWBPTYPE>6:1,1:XWBPTYPE)
"RTN","XWBTCPM",146,0)
 . ;I $G(XWBPRT) D RETURN^XWBPRS2 Q  ;New msg return
"RTN","XWBTCPM",147,0)
 . I '$G(XWBPRT) D SND^XWBRW ;Return data,flush buffer
"RTN","XWBTCPM",148,0)
 Q  ;End Of Main
"RTN","XWBTCPM",149,0)
 ;
"RTN","XWBTCPM",150,0)
 ;
"RTN","XWBTCPM",151,0)
ETRAP(EXIT) ; -- on trapped error, send error info to client
"RTN","XWBTCPM",152,0)
 N XWBERC,XWBERR
"RTN","XWBTCPM",153,0)
 ;Change trapping during trap.
"RTN","XWBTCPM",154,0)
 S $ETRAP="D ^%ZTER,ETRAP^XWBTCPM(1)"
"RTN","XWBTCPM",155,0)
 S XWBERC=$E($$EC^%ZOSV,1,200),XWBERR="M  ERROR="_XWBERC_$C(13,10)_"LAST REF="_$$LGR^%ZOSV
"RTN","XWBTCPM",156,0)
 I $EC["U411" S XWBERROR="U411",XWBSEC="",XWBERR="Data Transfer Error to Server"
"RTN","XWBTCPM",157,0)
 D ^%ZTER ;%ZTER clears $ZE and $ZCODE
"RTN","XWBTCPM",158,0)
 D LOG("In ETRAP: "_XWBERC) ;Log
"RTN","XWBTCPM",159,0)
 I (XWBERC["READ")!(XWBERC["WRITE")!(XWBERC["SYSTEM-F")!(XWBERC["IOEOF") D EXIT X "HALT "
"RTN","XWBTCPM",160,0)
 U XWBTDEV
"RTN","XWBTCPM",161,0)
 I $G(XWBT("PCNT")) L +^XUTL("XUSYS",$J,0):99
"RTN","XWBTCPM",162,0)
 E  L  ;Clear Locks
"RTN","XWBTCPM",163,0)
 ;
"RTN","XWBTCPM",164,0)
 D ESND^XWBRW($C(24)_XWBERR_$C(4))
"RTN","XWBTCPM",165,0)
 I EXIT D EXIT X "HALT "
"RTN","XWBTCPM",166,0)
 S $ETRAP="Q:($ESTACK&'$QUIT)  Q:$ESTACK -9 S $ECODE="""" D CLEANP^XWBTCPM G RESTART^XWBTCPM",$ECODE=",U99,"
"RTN","XWBTCPM",167,0)
 Q
"RTN","XWBTCPM",168,0)
 ;
"RTN","XWBTCPM",169,0)
CLEANP ;Clean up the partion
"RTN","XWBTCPM",170,0)
 N XWBTDEV,XWBNULL D KILL^XUSCLEAN
"RTN","XWBTCPM",171,0)
 Q
"RTN","XWBTCPM",172,0)
 ;
"RTN","XWBTCPM",173,0)
STYPE(X,WRAP) ;For backward compatability only
"RTN","XWBTCPM",174,0)
 I $D(WRAP) Q $$RTRNFMT^XWBLIB($G(X),WRAP)
"RTN","XWBTCPM",175,0)
 Q $$RTRNFMT^XWBLIB(X)
"RTN","XWBTCPM",176,0)
 ;
"RTN","XWBTCPM",177,0)
BREAD(L,T) ;read tcp buffer, L is length
"RTN","XWBTCPM",178,0)
 Q $$BREAD^XWBRW(L,$G(T))
"RTN","XWBTCPM",179,0)
 ;
"RTN","XWBTCPM",180,0)
CHPRN(N) ;change process name
"RTN","XWBTCPM",181,0)
 ;Change process name to N
"RTN","XWBTCPM",182,0)
 D SETNM^%ZOSV($E(N,1,15))
"RTN","XWBTCPM",183,0)
 Q
"RTN","XWBTCPM",184,0)
 ;
"RTN","XWBTCPM",185,0)
SETTIME(%) ;Set the Read timeout 0=RPC, 1=sign-on
"RTN","XWBTCPM",186,0)
 ; Increased timeout period (%=1) during signon from 90 to 180 for accessibility reasons
"RTN","XWBTCPM",187,0)
 S XWBTIME=$S($G(%):180,$G(XWBVER)>1.1:$$BAT^XUPARAM,1:36000),XWBTIME(1)=5 ; (*p35)
"RTN","XWBTCPM",188,0)
 Q
"RTN","XWBTCPM",189,0)
TIMEOUT ;Do this on MAIN  loop timeout
"RTN","XWBTCPM",190,0)
 I $G(DUZ)>0 D QSND^XWBRW("#BYE#") Q
"RTN","XWBTCPM",191,0)
 ;Sign-on timeout
"RTN","XWBTCPM",192,0)
 S XWBR(0)=0,XWBR(1)=1,XWBR(2)="",XWBR(3)="TIME-OUT",XWBPTYPE=2
"RTN","XWBTCPM",193,0)
 D SND^XWBRW
"RTN","XWBTCPM",194,0)
 Q
"RTN","XWBTCPM",195,0)
 ;
"RTN","XWBTCPM",196,0)
OS() ;Return the OS
"RTN","XWBTCPM",197,0)
 Q $S(^%ZOSF("OS")["OpenM":"OpenM",^%ZOSF("OS")["GT.M":"GT.M",^("OS")["DSM":"DSM",1:"UNK")
"RTN","XWBTCPM",198,0)
 ;
"RTN","XWBTCPM",199,0)
INIT ;Setup
"RTN","XWBTCPM",200,0)
 S U="^",XWBTIME=10,XWBOS=$$OS,XWBDEBUG=0,XWBRBUF=""
"RTN","XWBTCPM",201,0)
 S XWBDEBUG=$$GET^XPAR("SYS","XWBDEBUG")
"RTN","XWBTCPM",202,0)
 S XWBT("BF")=$S(XWBOS="GT.M":"#",1:"!")
"RTN","XWBTCPM",203,0)
 S XWBT("PCNT")=0 I XWBOS="GT.M",$L($T(^XUSCNT)) S XWBT("PCNT")=1
"RTN","XWBTCPM",204,0)
 D LOGSTART^XWBDLOG("XWBTCPM")
"RTN","XWBTCPM",205,0)
 Q
"RTN","XWBTCPM",206,0)
 ;
"RTN","XWBTCPM",207,0)
DEBUG ;Entry point for debug, Build a server to get the connect
"RTN","XWBTCPM",208,0)
 ;Cache sample;ZB SERV+1^XWBTCPM:"L+" ZB ETRAP+1^XWBTCPM:"B"
"RTN","XWBTCPM",209,0)
 W !,"Before running this entry point set your debugger to stop at"
"RTN","XWBTCPM",210,0)
 W !,"the place you want to debug. Some spots to use:"
"RTN","XWBTCPM",211,0)
 W !,"'SERV+1^XWBTCPM', 'MAIN+1^XWBTCPM' or 'CAPI+1^XWBPRS.'",!
"RTN","XWBTCPM",212,0)
 W !,"or location of your choice.",!
"RTN","XWBTCPM",213,0)
 W !,"IP Socket to Listen on: " R SOCK:300,! Q:'$T!(SOCK["^")
"RTN","XWBTCPM",214,0)
 ;Use %ZISTCP to do a single server
"RTN","XWBTCPM",215,0)
 D LISTEN^%ZISTCP(SOCK,"SERV^XWBTCPM")
"RTN","XWBTCPM",216,0)
 U $P W !,"Done"
"RTN","XWBTCPM",217,0)
 Q
"RTN","XWBTCPM",218,0)
SERV ;Callback from the server
"RTN","XWBTCPM",219,0)
 S XWBTDEV=IO,XWBTIME(1)=3600 D INIT
"RTN","XWBTCPM",220,0)
 S XWBDEBUG=1,MSG=$$BREAD^XWBRW(5,60) ;R MSG#5
"RTN","XWBTCPM",221,0)
 D NEW
"RTN","XWBTCPM",222,0)
 S IO("C")=1 ;Cause the Listenr to stop
"RTN","XWBTCPM",223,0)
 Q
"RTN","XWBTCPM",224,0)
 ;
"RTN","XWBTCPM",225,0)
EXIT ;Close out
"RTN","XWBTCPM",226,0)
 I $G(DUZ) D LOGOUT^XUSRB
"RTN","XWBTCPM",227,0)
 I $G(XWBT("PCNT")) D COUNT^XUSCNT(-1)
"RTN","XWBTCPM",228,0)
 Q
"RTN","XWBTCPM",229,0)
 ;
"RTN","XWBTCPM",230,0)
LOG(MSG) ;Record Debug Info
"RTN","XWBTCPM",231,0)
 D:$G(XWBDEBUG) LOG^XWBDLOG(MSG)
"RTN","XWBTCPM",232,0)
 Q
"RTN","XWBTCPM",233,0)
 ;
"RTN","XWBTCPM1")
0^45^B7816209^B7265734
"RTN","XWBTCPM1",1,0)
XWBTCPM1 ;ISF/RWF - Support for XWBTCPM ;08/11/15  09:00
"RTN","XWBTCPM1",2,0)
 ;;1.1;RPC BROKER;**35,64**;Mar 28, 1997;Build 12
"RTN","XWBTCPM1",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","XWBTCPM1",4,0)
 Q
"RTN","XWBTCPM1",5,0)
ZISTCP(XWBTSKT) ;Start ZISTCPS listener
"RTN","XWBTCPM1",6,0)
 ;
"RTN","XWBTCPM1",7,0)
 N XWBENV,XWBVOL,Y
"RTN","XWBTCPM1",8,0)
 D GETENV^%ZOSV S XWBENV=Y,XWBVOL=$P(Y,"^",2)
"RTN","XWBTCPM1",9,0)
 Q:'$$SEMAPHOR^XWBTCPL(XWBTSKT,"LOCK")  ;quit if job is already running
"RTN","XWBTCPM1",10,0)
 D UPDTREC^XWBTCPL(XWBTSKT,3) ;updt RPC BROKER SITE PARAMETER record as RUNNING
"RTN","XWBTCPM1",11,0)
 D MARKER^XWBTCP(XWBTSKT,-1) ;Clear marker
"RTN","XWBTCPM1",12,0)
 ;
"RTN","XWBTCPM1",13,0)
 D LISTEN^%ZISTCPS(XWBTSKT,"NT^XWBTCPM","D STAT^XWBTCPM1("_XWBTSKT_")")
"RTN","XWBTCPM1",14,0)
 ;
"RTN","XWBTCPM1",15,0)
 S %=$$SEMAPHOR^XWBTCPL(XWBTSKT,"UNLOCK") ; destroy 'running flag'
"RTN","XWBTCPM1",16,0)
 D UPDTREC^XWBTCPL(XWBTSKT,6) ;updt RPC BROKER SITE PARAMETER record as STOPPED
"RTN","XWBTCPM1",17,0)
 Q
"RTN","XWBTCPM1",18,0)
 ;
"RTN","XWBTCPM1",19,0)
OLD ;Call the old style broker
"RTN","XWBTCPM1",20,0)
 ; Note: The old-style broker, which calls back to the RPC Client on a different port,
"RTN","XWBTCPM1",21,0)
 ; has been deprecated in XWB*1.1*60 and will not be supported in future patches. New
"RTN","XWBTCPM1",22,0)
 ; development should not use this broker, and legacy applications which use this
"RTN","XWBTCPM1",23,0)
 ; interface should be moved to the new-style broker at the earliest opportunity.
"RTN","XWBTCPM1",24,0)
 ;XWBRBUF setup in XWBTCPM
"RTN","XWBTCPM1",25,0)
 N XWBTCNT
"RTN","XWBTCPM1",26,0)
 S XWBTCNT=0
"RTN","XWBTCPM1",27,0)
 D READCONN ;Get the rest of the connect msg
"RTN","XWBTCPM1",28,0)
 ; -- msg should be:  action^client IP^client port^token
"RTN","XWBTCPM1",29,0)
 ;p64 - not sure if this works with IPv6, as I have no way to test
"RTN","XWBTCPM1",30,0)
 I $P(MSG,"^")="TCPconnect" D
"RTN","XWBTCPM1",31,0)
 . N DZ,%T,NATIP S DZ="",%T=0
"RTN","XWBTCPM1",32,0)
 . ;Get the peer and use that IP, Allow use thru a NAT box.
"RTN","XWBTCPM1",33,0)
 . S NATIP=$$GETPEER^%ZOSV S:'$L(NATIP) NATIP=$P(MSG,"^",2)
"RTN","XWBTCPM1",34,0)
 . I NATIP'=$P(MSG,"^",2) S $P(MSG,"^",2)=NATIP
"RTN","XWBTCPM1",35,0)
 . I '$$NEWJOB^XWBTCPM D LOG("No New Jobs"),QSND("reject") Q
"RTN","XWBTCPM1",36,0)
 . ;Keep the current job & Device.
"RTN","XWBTCPM1",37,0)
 . ;just call the old server code. Uses a extra socket.
"RTN","XWBTCPM1",38,0)
 . D QSND("accept"),LOG("accept")
"RTN","XWBTCPM1",39,0)
 . D EN^XWBTCPC($P(MSG,"^",2),$P(MSG,"^",3),$P(DZ,"^"),XWBVER,$P(MSG,"^",4))
"RTN","XWBTCPM1",40,0)
 Q
"RTN","XWBTCPM1",41,0)
 ;
"RTN","XWBTCPM1",42,0)
READCONN ;Read the rest of the connect message
"RTN","XWBTCPM1",43,0)
 N CON,VL,LEN,MSG2
"RTN","XWBTCPM1",44,0)
 S CON=$$BREAD(6,XWBTIME) I CON="" S CON="Timeout" D LOG(CON) Q
"RTN","XWBTCPM1",45,0)
 I $E(CON,6)="|" D
"RTN","XWBTCPM1",46,0)
 . S VL=$$BREAD(1),VL=$A(VL)
"RTN","XWBTCPM1",47,0)
 . S XWBVER=$$BREAD(VL)
"RTN","XWBTCPM1",48,0)
 . S LEN=$$BREAD(5)
"RTN","XWBTCPM1",49,0)
 . S MSG=$$BREAD(+LEN)
"RTN","XWBTCPM1",50,0)
 E  S X=$E(CON,6),LEN=$E(CON,1,5)-1,MSG2=$$BREAD(LEN),MSG=X_MSG2,XWBVER=0
"RTN","XWBTCPM1",51,0)
 D LOG("Connect: "_MSG)
"RTN","XWBTCPM1",52,0)
 Q
"RTN","XWBTCPM1",53,0)
 ;
"RTN","XWBTCPM1",54,0)
BREAD(L,TO) ;Buffer read
"RTN","XWBTCPM1",55,0)
 S XWBTIME(1)=$G(TO,5)
"RTN","XWBTCPM1",56,0)
 Q $$BREAD^XWBRW(L)
"RTN","XWBTCPM1",57,0)
 ;
"RTN","XWBTCPM1",58,0)
QSND(H) ;Quick send
"RTN","XWBTCPM1",59,0)
 D QSND^XWBRW(H)
"RTN","XWBTCPM1",60,0)
 Q
"RTN","XWBTCPM1",61,0)
LOG(H) ;
"RTN","XWBTCPM1",62,0)
 D:$G(XWBDEBUG) LOG^XWBDLOG(H)
"RTN","XWBTCPM1",63,0)
 Q
"RTN","XWBTCPM1",64,0)
 ;
"RTN","XWBTCPM1",65,0)
NODE(P) ;Get Listener node, XWBENV must be set first
"RTN","XWBTCPM1",66,0)
 N X,Y,BV
"RTN","XWBTCPM1",67,0)
 I '$D(XWBENV) D GETENV^%ZOSV S XWBENV=Y
"RTN","XWBTCPM1",68,0)
 S BV=$P(XWBENV,"^",4)
"RTN","XWBTCPM1",69,0)
 S IX1=$O(^%ZIS(14.7,"B",BV,0)) I IX1'>0 Q "Box-Vol 1"
"RTN","XWBTCPM1",70,0)
 S IX1=$O(^XWB(8994.1,1,7,"B",IX1,0)) I IX1'>0 Q "Box-Vol 2"
"RTN","XWBTCPM1",71,0)
 S IX2=$O(^XWB(8994.1,1,7,IX1,1,"B",P,0)) I IX2'>0 Q "Port"
"RTN","XWBTCPM1",72,0)
 S X=$G(^XWB(8994.1,1,7,IX1,1,IX2,0))
"RTN","XWBTCPM1",73,0)
 Q X
"RTN","XWBTCPM1",74,0)
 ;
"RTN","XWBTCPM1",75,0)
STAT(P) ;Check if should stop.
"RTN","XWBTCPM1",76,0)
 ;Called from ZRULE in %ZISTCPS
"RTN","XWBTCPM1",77,0)
 N X
"RTN","XWBTCPM1",78,0)
 S X=$$NODE(P)
"RTN","XWBTCPM1",79,0)
 S ZISQUIT=($P(X,"^",2)>3) ;Status Stop
"RTN","XWBTCPM1",80,0)
 Q
"RTN","XWBTCPMT")
0^43^B11606585^B11304181
"RTN","XWBTCPMT",1,0)
XWBTCPMT ;ISF/RWF - Routine to test a connection ;12/02/14  08:48
"RTN","XWBTCPMT",2,0)
 ;;1.1;RPC BROKER;**43,49,53,64**;Mar 28, 1997;Build 12
"RTN","XWBTCPMT",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","XWBTCPMT",4,0)
 ;
"RTN","XWBTCPMT",5,0)
CALL ;Interactive
"RTN","XWBTCPMT",6,0)
 N IP,PORT,STAT
"RTN","XWBTCPMT",7,0)
 D HOME^%ZIS
"RTN","XWBTCPMT",8,0)
 S U="^",DTIME=$$DTIME^XUP
"RTN","XWBTCPMT",9,0)
 W !,"Interactive Broker Test"
"RTN","XWBTCPMT",10,0)
 R !,"IP ADDRESS: ",IP:DTIME
"RTN","XWBTCPMT",11,0)
 I IP["^" Q
"RTN","XWBTCPMT",12,0)
 R !,"PORT: ",PORT:DTIME
"RTN","XWBTCPMT",13,0)
 I PORT["^" Q
"RTN","XWBTCPMT",14,0)
 S STAT=$$TEST(IP,PORT,1)
"RTN","XWBTCPMT",15,0)
 U $P
"RTN","XWBTCPMT",16,0)
 W !,$S(STAT>0:"Success, response: "_$P(STAT,U,2),1:"Failed: "_$P(STAT,U,2,9)),!
"RTN","XWBTCPMT",17,0)
 Q
"RTN","XWBTCPMT",18,0)
 ;
"RTN","XWBTCPMT",19,0)
TEST(IP,PORT,TALK) ;
"RTN","XWBTCPMT",20,0)
 N T1,T2,T3,T4,OS,RES,RES2,RES3
"RTN","XWBTCPMT",21,0)
 S OS=^%ZOSF("OS")
"RTN","XWBTCPMT",22,0)
 I '$$VALIDATE^XLFIPV(IP) S IP=$$ADDRESS^XLFNSLK(IP) ;p64
"RTN","XWBTCPMT",23,0)
 I '$$VALIDATE^XLFIPV(IP) Q "-1^BAD IP" ;p64
"RTN","XWBTCPMT",24,0)
 I OS["OpenM" X "S T1=$ZH"
"RTN","XWBTCPMT",25,0)
 D CALL^%ZISTCP(IP,PORT)
"RTN","XWBTCPMT",26,0)
 I OS["OpenM" X "S T2=$ZH"
"RTN","XWBTCPMT",27,0)
 I POP Q "-1^Failed to Connect"
"RTN","XWBTCPMT",28,0)
 U IO
"RTN","XWBTCPMT",29,0)
 N $ET S $ET="G ERR^XWBTCPMT"
"RTN","XWBTCPMT",30,0)
 ;TCPConnect
"RTN","XWBTCPMT",31,0)
 W "[XWB]10304"_$C(10)_"TCPConnect50010127.0.0.1f00010f0024ISF-FORTW.vha.domain.extf"_$C(4),@IOF
"RTN","XWBTCPMT",32,0)
 R RES:10 I '$T S RES="-1^TIMEOUT" G EXIT
"RTN","XWBTCPMT",33,0)
 I OS["OpenM" X "S T3=$ZH"
"RTN","XWBTCPMT",34,0)
 W "[XWB]11302"_$C(1)_"0"_$C(16)_"XUS SIGNON SETUP54f"_$C(4),@IOF
"RTN","XWBTCPMT",35,0)
 R RES2:10
"RTN","XWBTCPMT",36,0)
 I OS["OpenM" X "S T4=$ZH"
"RTN","XWBTCPMT",37,0)
 W "[XWB]10304"_$C(5)_"#BYE#"_$C(4),@IOF
"RTN","XWBTCPMT",38,0)
 R RES3:3 I '$T S RES="-1^TIMEOUT after accept" G EXIT
"RTN","XWBTCPMT",39,0)
 S RES="1^"_RES_U_($G(T2)-$G(T1))_U_($G(T3)-$G(T2))_U_($G(T4)-$G(T3))
"RTN","XWBTCPMT",40,0)
EXIT ;Close and Exit
"RTN","XWBTCPMT",41,0)
 D CLOSE^%ZISTCP
"RTN","XWBTCPMT",42,0)
 Q RES
"RTN","XWBTCPMT",43,0)
 ;
"RTN","XWBTCPMT",44,0)
ERR ;
"RTN","XWBTCPMT",45,0)
 D CLOSE^%ZISTCP
"RTN","XWBTCPMT",46,0)
 U $P
"RTN","XWBTCPMT",47,0)
 Q "-1^"_$$EC^%ZOSV
"RTN","XWBTCPMT",48,0)
 ;
"RTN","XWBTCPMT",49,0)
CHECK ;Check server setup
"RTN","XWBTCPMT",50,0)
 N XPARSYS,XWBDEBUG,XWBOS,XWBT,XWNRBUF,XWBTIME,NEWJOB,XWBVER
"RTN","XWBTCPMT",51,0)
 W !,"This will check for some of the errors that can"
"RTN","XWBTCPMT",52,0)
 W !,"prevent the Broker from getting started.",!
"RTN","XWBTCPMT",53,0)
 D HOME^%ZIS
"RTN","XWBTCPMT",54,0)
 S XWBVER=1.108
"RTN","XWBTCPMT",55,0)
 D INIT^XWBTCPM
"RTN","XWBTCPMT",56,0)
 W !,"Debugging is set to ",$S(XWBDEBUG=1:"On",XWBDEBUG=2:"Verbose",XWBDEBUG=3:"Very Verbose",1:"Off")
"RTN","XWBTCPMT",57,0)
 D SETTIME^XWBTCPM(0)
"RTN","XWBTCPMT",58,0)
 W !,"Broker activity timeout is set to ",XWBTIME
"RTN","XWBTCPMT",59,0)
 S %ZIS="M",IOP="NULL" D ^%ZIS
"RTN","XWBTCPMT",60,0)
 I POP W !,"The NULL device is not setup correctly."
"RTN","XWBTCPMT",61,0)
 I 'POP D
"RTN","XWBTCPMT",62,0)
 . W !,"Checking can Write to null device"
"RTN","XWBTCPMT",63,0)
 . U IO W !,"TEST",!
"RTN","XWBTCPMT",64,0)
 . D ^%ZISC U IO W !,"The NULL device is OK."
"RTN","XWBTCPMT",65,0)
 I $T(SHARELIC^%ZOSV)="" W !,"The routine %ZOSV is missing the entry point 'SHARELIC'."
"RTN","XWBTCPMT",66,0)
 I $T(GETPEER^%ZOSV)="" W !,"The routine %ZOSV is missing the entry point 'GETPEER'."
"RTN","XWBTCPMT",67,0)
 I $G(XWBT("PCNT")),$T(COUNT^XUSCNT)="" W !,"The routine XUSCNT is missing on a GT.M system."
"RTN","XWBTCPMT",68,0)
 W !,"Checking if new JOB's can start."
"RTN","XWBTCPMT",69,0)
 S ^TMP("XWB",$J)=1 X "J HOLD^XWBTCPMT($J) H 1"
"RTN","XWBTCPMT",70,0)
 I $G(^TMP("XWB",$J))=1 W !,"Doesn't look like a new JOB could start!",!
"RTN","XWBTCPMT",71,0)
 S NEWJOB=$$NEWJOB^XWBTCPM()
"RTN","XWBTCPMT",72,0)
 W !,"New jobs are "_$S('NEWJOB:"not ",1:"")_"allowed."
"RTN","XWBTCPMT",73,0)
 W !,"Done with the checks.",!
"RTN","XWBTCPMT",74,0)
 K ^TMP("XWB",$J)
"RTN","XWBTCPMT",75,0)
 Q
"RTN","XWBTCPMT",76,0)
 ;
"RTN","XWBTCPMT",77,0)
HOLD(MJ) ;Show that a new job is allowed.
"RTN","XWBTCPMT",78,0)
 S ^TMP("XWB",MJ)=5
"RTN","XWBTCPMT",79,0)
 HANG 5
"RTN","XWBTCPMT",80,0)
 Q
"VER")
8.0^22.0
"BLD",1515,6)
^50
**END**
**END**

