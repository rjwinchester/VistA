Released HL*1.6*163 SEQ #129
Extracted from mail message
**KIDS**:HL*1.6*163^

**INSTALL NAME**
HL*1.6*163
"BLD",9734,0)
HL*1.6*163^HEALTH LEVEL SEVEN^0^3150302^y
"BLD",9734,1,0)
^^2^2^3150211^
"BLD",9734,1,1,0)
In preparation for the VA's transition from IPv4 to IPv6 the HL7 package 
"BLD",9734,1,2,0)
will require modifications to make it IPv6 ready.
"BLD",9734,4,0)
^9.64PA^870^1
"BLD",9734,4,870,0)
870
"BLD",9734,4,870,2,0)
^9.641^870^1
"BLD",9734,4,870,2,870,0)
HL LOGICAL LINK  (File-top level)
"BLD",9734,4,870,2,870,1,0)
^9.6411^400.01^1
"BLD",9734,4,870,2,870,1,400.01,0)
TCP/IP ADDRESS
"BLD",9734,4,870,222)
y^y^p^^^^n^^n
"BLD",9734,4,870,224)

"BLD",9734,4,"APDD",870,870)

"BLD",9734,4,"APDD",870,870,400.01)

"BLD",9734,4,"B",870,870)

"BLD",9734,6.3)
3
"BLD",9734,"KRN",0)
^9.67PA^779.2^20
"BLD",9734,"KRN",.4,0)
.4
"BLD",9734,"KRN",.401,0)
.401
"BLD",9734,"KRN",.402,0)
.402
"BLD",9734,"KRN",.403,0)
.403
"BLD",9734,"KRN",.5,0)
.5
"BLD",9734,"KRN",.84,0)
.84
"BLD",9734,"KRN",3.6,0)
3.6
"BLD",9734,"KRN",3.8,0)
3.8
"BLD",9734,"KRN",9.2,0)
9.2
"BLD",9734,"KRN",9.8,0)
9.8
"BLD",9734,"KRN",9.8,"NM",0)
^9.68A^4^4
"BLD",9734,"KRN",9.8,"NM",1,0)
HLTP31^^0^B20366575
"BLD",9734,"KRN",9.8,"NM",2,0)
HLTP4^^0^B50343376
"BLD",9734,"KRN",9.8,"NM",3,0)
HLTPCK2B^^0^B82231520
"BLD",9734,"KRN",9.8,"NM",4,0)
HLOUSR^^0^B123556589
"BLD",9734,"KRN",9.8,"NM","B","HLOUSR",4)

"BLD",9734,"KRN",9.8,"NM","B","HLTP31",1)

"BLD",9734,"KRN",9.8,"NM","B","HLTP4",2)

"BLD",9734,"KRN",9.8,"NM","B","HLTPCK2B",3)

"BLD",9734,"KRN",19,0)
19
"BLD",9734,"KRN",19.1,0)
19.1
"BLD",9734,"KRN",101,0)
101
"BLD",9734,"KRN",409.61,0)
409.61
"BLD",9734,"KRN",771,0)
771
"BLD",9734,"KRN",779.2,0)
779.2
"BLD",9734,"KRN",870,0)
870
"BLD",9734,"KRN",8989.51,0)
8989.51
"BLD",9734,"KRN",8989.52,0)
8989.52
"BLD",9734,"KRN",8994,0)
8994
"BLD",9734,"KRN","B",.4,.4)

"BLD",9734,"KRN","B",.401,.401)

"BLD",9734,"KRN","B",.402,.402)

"BLD",9734,"KRN","B",.403,.403)

"BLD",9734,"KRN","B",.5,.5)

"BLD",9734,"KRN","B",.84,.84)

"BLD",9734,"KRN","B",3.6,3.6)

"BLD",9734,"KRN","B",3.8,3.8)

"BLD",9734,"KRN","B",9.2,9.2)

"BLD",9734,"KRN","B",9.8,9.8)

"BLD",9734,"KRN","B",19,19)

"BLD",9734,"KRN","B",19.1,19.1)

"BLD",9734,"KRN","B",101,101)

"BLD",9734,"KRN","B",409.61,409.61)

"BLD",9734,"KRN","B",771,771)

"BLD",9734,"KRN","B",779.2,779.2)

"BLD",9734,"KRN","B",870,870)

"BLD",9734,"KRN","B",8989.51,8989.51)

"BLD",9734,"KRN","B",8989.52,8989.52)

"BLD",9734,"KRN","B",8994,8994)

"BLD",9734,"QUES",0)
^9.62^^
"BLD",9734,"REQB",0)
^9.611^4^4
"BLD",9734,"REQB",1,0)
HL*1.6*145^1
"BLD",9734,"REQB",2,0)
HL*1.6*142^1
"BLD",9734,"REQB",3,0)
HL*1.6*148^1
"BLD",9734,"REQB",4,0)
HL*1.6*158^1
"BLD",9734,"REQB","B","HL*1.6*142",2)

"BLD",9734,"REQB","B","HL*1.6*145",1)

"BLD",9734,"REQB","B","HL*1.6*148",3)

"BLD",9734,"REQB","B","HL*1.6*158",4)

"FIA",870)
HL LOGICAL LINK
"FIA",870,0)
^HLCS(870,
"FIA",870,0,0)
870
"FIA",870,0,1)
y^y^p^^^^n^^n
"FIA",870,0,10)

"FIA",870,0,11)

"FIA",870,0,"RLRO")

"FIA",870,0,"VR")
1.6^HL
"FIA",870,870)
1
"FIA",870,870,400.01)

"IX",870,870,"IP",0)
870^IP^IP Address cross reference^R^^F^IR^I^870^^^^^LS
"IX",870,870,"IP",1)
S ^HLCS(870,"IP",$E(X,1,40),DA)=""
"IX",870,870,"IP",2)
K ^HLCS(870,"IP",$E(X,1,40),DA)
"IX",870,870,"IP",2.5)
K ^HLCS(870,"IP")
"IX",870,870,"IP",11.1,0)
^.114IA^1^1
"IX",870,870,"IP",11.1,1,0)
1^F^870^400.01^40^1^F
"IX",870,870,"IP",11.1,1,3)

"MBREQ")
0
"PKG",243,-1)
1^1
"PKG",243,0)
HEALTH LEVEL SEVEN^HL^DHCP IMPLEMENTATION OF HEALTH LEVEL SEVEN
"PKG",243,20,0)
^9.402P^^
"PKG",243,22,0)
^9.49I^1^1
"PKG",243,22,1,0)
1.6^2951013^2981102^66481
"PKG",243,22,1,"PAH",1,0)
163^3150302
"PKG",243,22,1,"PAH",1,1,0)
^^2^2^3150302
"PKG",243,22,1,"PAH",1,1,1,0)
In preparation for the VA's transition from IPv4 to IPv6 the HL7 package 
"PKG",243,22,1,"PAH",1,1,2,0)
will require modifications to make it IPv6 ready.
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
NO
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
NO
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
NO
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
4
"RTN","HLOUSR")
0^4^B123556589^B121713479
"RTN","HLOUSR",1,0)
HLOUSR ;ALB/CJM/OAK/PIJ/RBN -ListManager Screen for viewing system status;12 JUN 1997 10:00 am ;02/28/2012
"RTN","HLOUSR",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**126,130,134,137,138,139,146,147,153,158,163**;Oct 13, 1995;Build 3
"RTN","HLOUSR",3,0)
 ;;Per VA Directive 6402, this routine should not be modified.
"RTN","HLOUSR",4,0)
 ;
"RTN","HLOUSR",5,0)
EN ;
"RTN","HLOUSR",6,0)
 ;
"RTN","HLOUSR",7,0)
 N HLSCREEN,TESTOPEN,HLRFRSH,HLPARMS
"RTN","HLOUSR",8,0)
 D WAIT^DICD
"RTN","HLOUSR",9,0)
 D EN^VALM("HLO SYSTEM MONITOR")
"RTN","HLOUSR",10,0)
 Q
"RTN","HLOUSR",11,0)
 ;
"RTN","HLOUSR",12,0)
BRIEF ;
"RTN","HLOUSR",13,0)
 N COUNT,LINK,QUE,FROM,TIME,STATUS,TEMP,DIR,TODAY,LIST,LNKMSG,OS
"RTN","HLOUSR",14,0)
 S HLRFRSH="BRIEF^HLOUSR"
"RTN","HLOUSR",15,0)
 S (HLSCREEN,VALMSG)="Brief System Status"
"RTN","HLOUSR",16,0)
 S VALMCNT=16
"RTN","HLOUSR",17,0)
 ;K @VALMAR
"RTN","HLOUSR",18,0)
 S OS=$$OS^%ZOSV
"RTN","HLOUSR",19,0)
 ;
"RTN","HLOUSR",20,0)
 D CLEAN^VALM10
"RTN","HLOUSR",21,0)
 S VALMBG=1
"RTN","HLOUSR",22,0)
 S VALMBCK="R"
"RTN","HLOUSR",23,0)
 S VALMDDF("COL 1")="COL1^1^80^"
"RTN","HLOUSR",24,0)
 K VALMDDF("COL 2"),VALMDDF("COL 3"),VALMDDF("COL 4"),VALMDDF("COL 5")
"RTN","HLOUSR",25,0)
 D CHGCAP^VALM("COL 1"," Brief Operational Overview")
"RTN","HLOUSR",26,0)
 S @VALMAR@(1,0)="SYSTEM STATUS:             "_$S($$CHKSTOP^HLOPROC:"STOPPED",1:"RUNNING")
"RTN","HLOUSR",27,0)
 S @VALMAR@(2,0)="PROCESS MANAGER:           "_$S($$RUNNING:"RUNNING",1:"STOPPED")
"RTN","HLOUSR",28,0)
 ;
"RTN","HLOUSR",29,0)
 ;
"RTN","HLOUSR",30,0)
 I $$CHKSTOP^HLOPROC,OS'["VMS" S TESTOPEN("LISTENER")=""
"RTN","HLOUSR",31,0)
 S TIME=$P($G(TESTOPEN("LISTENER")),"^",2)
"RTN","HLOUSR",32,0)
 I TIME,$$FMDIFF^XLFDT($$NOW^XLFDT,TIME,2)<100 D
"RTN","HLOUSR",33,0)
 .S STATUS=+TESTOPEN("LISTENER")
"RTN","HLOUSR",34,0)
 E  D
"RTN","HLOUSR",35,0)
 .;** P147 START CJM
"RTN","HLOUSR",36,0)
 .;is the Kernel listener running under the HLO process manager?
"RTN","HLOUSR",37,0)
 .S STATUS=$$KLISTEN
"RTN","HLOUSR",38,0)
 .;
"RTN","HLOUSR",39,0)
 .;if the Kernel listner is NOT running, might check the listener via the OPEN command.  With loadbalancing, the IP address of the listener link sometimes fails, so also try 'loopback'.
"RTN","HLOUSR",40,0)
 .I 'STATUS,(OS["VMS")!('$$CHKSTOP^HLOPROC) D
"RTN","HLOUSR",41,0)
 ..N IP,LINK
"RTN","HLOUSR",42,0)
 ..S LINK=$P($G(^HLD(779.1,1,0)),"^",10)
"RTN","HLOUSR",43,0)
 ..I LINK,$$GET^HLOTLNK(LINK,.LINK) D
"RTN","HLOUSR",44,0)
 ...;ADD LOOPBACK FOR IPV6 - HL*1.6*163
"RTN","HLOUSR",45,0)
 ...;$$CONVERT^XLFIPV(IP) API (ICR #5844)
"RTN","HLOUSR",46,0)
 ...F IP=$$CONVERT^XLFIPV("127.0.0.1"),$$CONVERT^XLFIPV("0.0.0.0"),LINK("IP") D  Q:STATUS
"RTN","HLOUSR",47,0)
 ....N POP,IO,IOF,IOST
"RTN","HLOUSR",48,0)
 ....D CALL^%ZISTCP(IP,LINK("PORT"),5)
"RTN","HLOUSR",49,0)
 ....S STATUS='POP
"RTN","HLOUSR",50,0)
 ....C:STATUS IO
"RTN","HLOUSR",51,0)
 .;
"RTN","HLOUSR",52,0)
 .S:(('STATUS)&('$$CHKSTOP^HLOPROC)) LNKMSG=$S(OS["VMS":" Please start the HLO VMS TCPIP SERVICE",1:"Please start the HLO Listener")
"RTN","HLOUSR",53,0)
 .;
"RTN","HLOUSR",54,0)
 .;** P147 END CJM
"RTN","HLOUSR",55,0)
 .;
"RTN","HLOUSR",56,0)
 .D:'STATUS CNTRL^VALM10(3,38,85,IOINHI,IOINORM)
"RTN","HLOUSR",57,0)
 .S TESTOPEN("LISTENER")=STATUS_"^"_$$NOW^XLFDT
"RTN","HLOUSR",58,0)
 ;
"RTN","HLOUSR",59,0)
 S @VALMAR@(3,0)="STANDARD LISTENER:         "_$S(STATUS:"RUNNING",1:"STOPPED   ")_$G(LNKMSG)
"RTN","HLOUSR",60,0)
 ;** P139 end **
"RTN","HLOUSR",61,0)
 ;
"RTN","HLOUSR",62,0)
 S @VALMAR@(4,0)="TASKMAN:                   "_$S($$TM^%ZTLOAD:"RUNNING",1:"STOPPED")
"RTN","HLOUSR",63,0)
 ;
"RTN","HLOUSR",64,0)
 S (LIST,LINK)=""
"RTN","HLOUSR",65,0)
 F  S LINK=$O(^HLTMP("FAILING LINKS",LINK)) Q:LINK=""  D  I $L(LIST)>60 S LIST=LIST_",..." Q
"RTN","HLOUSR",66,0)
 .N TIME,QUE,LINKARY
"RTN","HLOUSR",67,0)
 .I $$GETLINK^HLOTLNK($P(LINK,":"),.LINKARY)
"RTN","HLOUSR",68,0)
 .S TIME=$G(^HLTMP("FAILING LINKS",LINK)) Q:TIME=""
"RTN","HLOUSR",69,0)
 .I '$G(LINKARY("SHUTDOWN")),TIME="" Q
"RTN","HLOUSR",70,0)
 .I '$G(LINKARY("SHUTDOWN")),($$HDIFF^XLFDT($H,TIME,2)<300) Q
"RTN","HLOUSR",71,0)
 .;;***patch HL*1.6*138 start
"RTN","HLOUSR",72,0)
 .S LIST=LIST_$S($L(LIST):", ",1:"")_LINK
"RTN","HLOUSR",73,0)
 .;;.S LIST=LIST_$S($L(LIST):", ",1:"")_$P(LINK,":")
"RTN","HLOUSR",74,0)
 .;; ***patch HL*1.6*138 end
"RTN","HLOUSR",75,0)
 S @VALMAR@(5,0)="DOWN LINKS: "_LIST
"RTN","HLOUSR",76,0)
 S @VALMAR@(6,0)="CLIENT LINK PROCESSES:     "_+$G(^HLC("HL7 PROCESS COUNTS","RUNNING","OUTGOING CLIENT LINK"))
"RTN","HLOUSR",77,0)
 S @VALMAR@(7,0)="IN-FILER PROCESSES:        "_+$G(^HLC("HL7 PROCESS COUNTS","RUNNING","INCOMING QUEUES"))
"RTN","HLOUSR",78,0)
 ; ***patch HL*1.6*146 START - RBN ***
"RTN","HLOUSR",79,0)
 ;S COUNT=0,LINK=""
"RTN","HLOUSR",80,0)
 ;F  S LINK=$O(^HLC("QUEUECOUNT","OUT",LINK)) Q:LINK=""  D
"RTN","HLOUSR",81,0)
 ;.S QUE=""
"RTN","HLOUSR",82,0)
 ;.F  S QUE=$O(^HLC("QUEUECOUNT","OUT",LINK,QUE)) Q:QUE=""  D
"RTN","HLOUSR",83,0)
 ;..S TEMP=$G(^HLC("QUEUECOUNT","OUT",LINK,QUE))
"RTN","HLOUSR",84,0)
 ;..S:TEMP>0 COUNT=COUNT+TEMP
"RTN","HLOUSR",85,0)
 N CNTARRAY
"RTN","HLOUSR",86,0)
 S COUNT=$$OUT^HLOQUE(.CNTARRAY)
"RTN","HLOUSR",87,0)
 ; ***patch HL*1.6*146 END - RBN ***
"RTN","HLOUSR",88,0)
 S @VALMAR@(8,0)="MESSAGES PENDING ON OUT QUEUES:    "_$$RJ(+COUNT,7)_"     ON SEQUENCE QUEUES:  "_$$RJ(+$G(^HLC("QUEUECOUNT","SEQUENCE")),7)
"RTN","HLOUSR",89,0)
 S TEMP="STOPPED OUTGOING QUEUES: "
"RTN","HLOUSR",90,0)
 S COUNT=0,QUE=""
"RTN","HLOUSR",91,0)
 F  S QUE=$O(^HLTMP("STOPPED QUEUES","OUT",QUE)) Q:QUE=""  S COUNT=COUNT+1 Q:COUNT>4  S:COUNT=1 TEMP=TEMP_QUE S:"23"[COUNT TEMP=TEMP_"; "_QUE S:COUNT=4 TEMP=TEMP_" ..."
"RTN","HLOUSR",92,0)
 S @VALMAR@(9,0)=TEMP
"RTN","HLOUSR",93,0)
 ; ***patch HL*1.6*146 START - RBN ***
"RTN","HLOUSR",94,0)
 ;S COUNT=0,QUE=""
"RTN","HLOUSR",95,0)
 ;F  S QUE=$O(^HLC("QUEUECOUNT","IN",QUE)) Q:QUE=""  D
"RTN","HLOUSR",96,0)
 ;.S FROM=""
"RTN","HLOUSR",97,0)
 ;.F  S FROM=$O(^HLC("QUEUECOUNT","IN",QUE,FROM)) Q:FROM=""  D
"RTN","HLOUSR",98,0)
 ;..S TEMP=$G(^HLC("QUEUECOUNT","IN",QUE,FROM))
"RTN","HLOUSR",99,0)
 ;..S:TEMP>0 COUNT=COUNT+TEMP
"RTN","HLOUSR",100,0)
 S COUNT=0
"RTN","HLOUSR",101,0)
 K CNTARRAY
"RTN","HLOUSR",102,0)
 S COUNT=$$IN^HLOQUE(.CNTARRAY)
"RTN","HLOUSR",103,0)
 ; ***patch HL*1.6*146 END - RBN ***
"RTN","HLOUSR",104,0)
 S @VALMAR@(10,0)="MESSAGES PENDING ON APPLICATIONS: "_$$RJ(+COUNT,7)
"RTN","HLOUSR",105,0)
 S TEMP="STOPPED INCOMING QUEUES: "
"RTN","HLOUSR",106,0)
 S COUNT=0,QUE=""
"RTN","HLOUSR",107,0)
 F  S QUE=$O(^HLTMP("STOPPED QUEUES","IN",QUE)) Q:QUE=""  S COUNT=COUNT+1 Q:COUNT>4  S:COUNT=1 TEMP=TEMP_QUE S:"23"[COUNT TEMP=TEMP_"; "_QUE S:COUNT=4 TEMP=TEMP_" ..."
"RTN","HLOUSR",108,0)
 S @VALMAR@(11,0)=TEMP
"RTN","HLOUSR",109,0)
 S @VALMAR@(12,0)="FILE 777 RECORD COUNT:         "_$$RJ($P($G(^HLTMP("FILE 777 RECORD COUNT")),"^"),10)_"     --> as of "_$$FMTE^XLFDT($P($G(^HLTMP("FILE 777 RECORD COUNT")),"^",2))
"RTN","HLOUSR",110,0)
 S @VALMAR@(13,0)="FILE 778 RECORD COUNT:         "_$$RJ($P($G(^HLTMP("FILE 778 RECORD COUNT")),"^"),10)_"     --> as of "_$$FMTE^XLFDT($P($G(^HLTMP("FILE 778 RECORD COUNT")),"^",2))
"RTN","HLOUSR",111,0)
 S TODAY=$$DT^XLFDT
"RTN","HLOUSR",112,0)
 S @VALMAR@(14,0)="MESSAGES SENT TODAY:           "_$$RJ($$ADD("OUT"),10)
"RTN","HLOUSR",113,0)
 S @VALMAR@(15,0)="MESSAGES RECEIVED TODAY:       "_$$RJ($$ADD("IN"),10)
"RTN","HLOUSR",114,0)
 S @VALMAR@(16,0)="MESSAGE ERRORS TODAY:          "_$$RJ($$ADD("EOUT")+$$ADD("EIN"),10)
"RTN","HLOUSR",115,0)
 Q
"RTN","HLOUSR",116,0)
 ;
"RTN","HLOUSR",117,0)
ADD(DIR) ;
"RTN","HLOUSR",118,0)
 N RAP,SAP,TIME,TOTAL,TYPE
"RTN","HLOUSR",119,0)
 S TOTAL=0
"RTN","HLOUSR",120,0)
 S TIME=TODAY-.0001
"RTN","HLOUSR",121,0)
 F  S TIME=$O(^HLSTATS(DIR,"HOURLY",TIME)) Q:'TIME  Q:((TIME\1)>TODAY)  D
"RTN","HLOUSR",122,0)
 .S SAP=""
"RTN","HLOUSR",123,0)
 .F  S SAP=$O(^HLSTATS(DIR,"HOURLY",TIME,SAP)) Q:SAP=""  D
"RTN","HLOUSR",124,0)
 ..Q:SAP="ACCEPT ACK"
"RTN","HLOUSR",125,0)
 ..S RAP=""
"RTN","HLOUSR",126,0)
 ..F  S RAP=$O(^HLSTATS(DIR,"HOURLY",TIME,SAP,RAP)) Q:RAP=""  D
"RTN","HLOUSR",127,0)
 ...S TYPE=""
"RTN","HLOUSR",128,0)
 ...F  S TYPE=$O(^HLSTATS(DIR,"HOURLY",TIME,SAP,RAP,TYPE)) Q:TYPE=""  D
"RTN","HLOUSR",129,0)
 ....S TOTAL=TOTAL+$G(^HLSTATS(DIR,"HOURLY",TIME,SAP,RAP,TYPE))
"RTN","HLOUSR",130,0)
 Q TOTAL
"RTN","HLOUSR",131,0)
 ;
"RTN","HLOUSR",132,0)
HELP ;
"RTN","HLOUSR",133,0)
 S X="?" D DISP^XQORM1 W !!
"RTN","HLOUSR",134,0)
 Q
"RTN","HLOUSR",135,0)
 ;
"RTN","HLOUSR",136,0)
EXIT ;
"RTN","HLOUSR",137,0)
 D CLEAN^VALM10
"RTN","HLOUSR",138,0)
 D CLEAR^VALM1
"RTN","HLOUSR",139,0)
 Q
"RTN","HLOUSR",140,0)
 ;
"RTN","HLOUSR",141,0)
EXPND ;
"RTN","HLOUSR",142,0)
 Q
"RTN","HLOUSR",143,0)
 ;
"RTN","HLOUSR",144,0)
PROCS ;
"RTN","HLOUSR",145,0)
 S HLRFRSH="PROCS^HLOUSR"
"RTN","HLOUSR",146,0)
 ;K @VALMAR
"RTN","HLOUSR",147,0)
 D CLEAN^VALM10
"RTN","HLOUSR",148,0)
 S VALMCNT=0
"RTN","HLOUSR",149,0)
 S VALMBCK="R"
"RTN","HLOUSR",150,0)
 S VALMDDF("COL 1")="COL 1^1^34^"
"RTN","HLOUSR",151,0)
 S VALMDDF("COL 2")="COL 2^35^10^MIN^H"
"RTN","HLOUSR",152,0)
 S VALMDDF("COL 3")="COL 3^47^10^MAX^H"
"RTN","HLOUSR",153,0)
 S VALMDDF("COL 4")="COL 4^59^10^#RUNNING^H"
"RTN","HLOUSR",154,0)
 S VALMDDF("COL 5")="COL 5^71^10^#QUEUED^IOBON"
"RTN","HLOUSR",155,0)
 D CHGCAP^VALM("COL 1"," Process Type")
"RTN","HLOUSR",156,0)
 N IEN
"RTN","HLOUSR",157,0)
 S IEN=0
"RTN","HLOUSR",158,0)
 F  S IEN=$O(^HLD(779.3,"C",1,IEN)) Q:'IEN  D
"RTN","HLOUSR",159,0)
 .N PROC
"RTN","HLOUSR",160,0)
 .Q:'$$GETPROC^HLOPROC1(IEN,.PROC)
"RTN","HLOUSR",161,0)
 .Q:PROC("NAME")="VMS TCP LISTENER"
"RTN","HLOUSR",162,0)
 .S VALMCNT=VALMCNT+1
"RTN","HLOUSR",163,0)
 .S @VALMAR@(VALMCNT,0)=$$LJ(PROC("NAME"),30)_$$RJ(PROC("MINIMUM"),6)_$$RJ(PROC("MAXIMUM"),12)_$$RJ(+$G(^HLC("HL7 PROCESS COUNTS","RUNNING",PROC("NAME"))),14)_$$RJ(+$G(^HLC("HL7 PROCESS COUNTS","QUEUED",PROC("NAME"))),12)
"RTN","HLOUSR",164,0)
 S VALMCNT=VALMCNT+1,@VALMAR@(VALMCNT,0)=""
"RTN","HLOUSR",165,0)
 S IEN=""
"RTN","HLOUSR",166,0)
 F  S IEN=$O(^HLTMP("HL7 RUNNING PROCESSES",IEN)) Q:IEN=""  D
"RTN","HLOUSR",167,0)
 .N NODE
"RTN","HLOUSR",168,0)
 .S NODE=$G(^HLTMP("HL7 RUNNING PROCESSES",IEN))
"RTN","HLOUSR",169,0)
 .Q:NODE=""
"RTN","HLOUSR",170,0)
 .S VALMCNT=VALMCNT+1
"RTN","HLOUSR",171,0)
 .S @VALMAR@(VALMCNT,0)="$J: "_$$LJ(IEN,9)_" ->"_$$CJ($P(NODE,"^",3),28)_"<- started at "_$$HTE^XLFDT($P(NODE,"^"))
"RTN","HLOUSR",172,0)
 Q
"RTN","HLOUSR",173,0)
 ;
"RTN","HLOUSR",174,0)
INQUEUE ;
"RTN","HLOUSR",175,0)
 N FROM
"RTN","HLOUSR",176,0)
 D CLEAN^VALM10
"RTN","HLOUSR",177,0)
 ;K @VALMAR
"RTN","HLOUSR",178,0)
 S HLRFRSH="INQUEUE^HLOUSR"
"RTN","HLOUSR",179,0)
 S (HLSCREEN,VALMSG)="Incoming Queues ('!' = stopped queues)"
"RTN","HLOUSR",180,0)
 S VALMCNT=0
"RTN","HLOUSR",181,0)
 S VALMBCK="R"
"RTN","HLOUSR",182,0)
 S VALMDDF("COL 1")="COL 1^1^40^ From^H"
"RTN","HLOUSR",183,0)
 S VALMDDF("COL 2")="COL 2^45^20^Queue^H"
"RTN","HLOUSR",184,0)
 S VALMDDF("COL 3")="COL 3^70^10^Count^H"
"RTN","HLOUSR",185,0)
 K VALMDDF("COL 4"),VALMDDF("COL 5")
"RTN","HLOUSR",186,0)
 D CHGCAP^VALM("COL 1"," From")
"RTN","HLOUSR",187,0)
 S FROM=""
"RTN","HLOUSR",188,0)
 F  S FROM=$O(^HLC("QUEUECOUNT","IN",FROM)) Q:FROM=""  D
"RTN","HLOUSR",189,0)
 .N COUNT,QUE,SHOW
"RTN","HLOUSR",190,0)
 .S SHOW=$$LJ(FROM,40)_"  "
"RTN","HLOUSR",191,0)
 .S QUE=""
"RTN","HLOUSR",192,0)
 .F  S QUE=$O(^HLC("QUEUECOUNT","IN",FROM,QUE)) Q:QUE=""  D
"RTN","HLOUSR",193,0)
 ..S COUNT=$G(^HLC("QUEUECOUNT","IN",FROM,QUE))
"RTN","HLOUSR",194,0)
 ..Q:COUNT<0
"RTN","HLOUSR",195,0)
 ..S VALMCNT=VALMCNT+1
"RTN","HLOUSR",196,0)
 ..S @VALMAR@(VALMCNT,0)=SHOW_$$LJ($S($$STOPPED^HLOQUE("IN",QUE):"!",1:"")_QUE,21)_" "_$$RJ(COUNT,10)
"RTN","HLOUSR",197,0)
 ..S SHOW=$$LJ("",40)_"  "
"RTN","HLOUSR",198,0)
 Q
"RTN","HLOUSR",199,0)
VIEWLINK ;
"RTN","HLOUSR",200,0)
 N C,QUIT,LINK,LINKARY,TEMP
"RTN","HLOUSR",201,0)
 S (QUIT,C,LINK)=""
"RTN","HLOUSR",202,0)
 S VALMBCK="R"
"RTN","HLOUSR",203,0)
 ;
"RTN","HLOUSR",204,0)
 ;currently HL7 (Optimized) only does TCP
"RTN","HLOUSR",205,0)
 S LINK=$$ASKLINK
"RTN","HLOUSR",206,0)
 Q:LINK=""
"RTN","HLOUSR",207,0)
 Q:'$$GETLINK^HLOTLNK(LINK,.LINKARY)
"RTN","HLOUSR",208,0)
 S LINK=LINK_":"_LINKARY("PORT")
"RTN","HLOUSR",209,0)
 W !,"Hit any key to stop...",!
"RTN","HLOUSR",210,0)
 F  D  Q:QUIT
"RTN","HLOUSR",211,0)
 .N COUNT,QUE
"RTN","HLOUSR",212,0)
 .S (COUNT,QUE)=""
"RTN","HLOUSR",213,0)
 .F  S QUE=$O(^HLC("QUEUECOUNT","OUT",LINK,QUE)) Q:QUE=""  S TEMP=$G(^HLC("QUEUECOUNT","OUT",LINK,QUE)) S:TEMP>0 COUNT=COUNT+TEMP
"RTN","HLOUSR",214,0)
 .W $C(13),"                             ",$C(13),"MESSAGES PENDING TRANSMISSION: ",IOBON,$$RJ(+COUNT,10),IOBOFF
"RTN","HLOUSR",215,0)
 .R *C:1 I $T S QUIT=1
"RTN","HLOUSR",216,0)
 Q
"RTN","HLOUSR",217,0)
 ;
"RTN","HLOUSR",218,0)
CJ(STRING,LEN) ;
"RTN","HLOUSR",219,0)
 Q $$CJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSR",220,0)
LJ(STRING,LEN) ;
"RTN","HLOUSR",221,0)
 Q $$LJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSR",222,0)
RJ(STRING,LEN) ;
"RTN","HLOUSR",223,0)
 Q $$RJ^XLFSTR($E(STRING,1,LEN),LEN)
"RTN","HLOUSR",224,0)
 ;
"RTN","HLOUSR",225,0)
RUNNING() ;Process Manager running?
"RTN","HLOUSR",226,0)
 N RUNNING
"RTN","HLOUSR",227,0)
 L +^HLTMP("PROCESS MANAGER"):0
"RTN","HLOUSR",228,0)
 S RUNNING='$T
"RTN","HLOUSR",229,0)
 I 'RUNNING L -^HLTMP("PROCESS MANAGER")
"RTN","HLOUSR",230,0)
 Q RUNNING
"RTN","HLOUSR",231,0)
 ;
"RTN","HLOUSR",232,0)
TESTLINK ;
"RTN","HLOUSR",233,0)
 N LINKNAME,OK,PORT,LINK
"RTN","HLOUSR",234,0)
 S VALMBCK="R"
"RTN","HLOUSR",235,0)
 S LINKNAME=$$ASKLINK
"RTN","HLOUSR",236,0)
 Q:LINKNAME=""
"RTN","HLOUSR",237,0)
 ;**P138 START
"RTN","HLOUSR",238,0)
 S PORT=$$ASKPORT^HLOUSRA(LINKNAME)
"RTN","HLOUSR",239,0)
 Q:'PORT
"RTN","HLOUSR",240,0)
 S LINK=LINKNAME_":"_PORT
"RTN","HLOUSR",241,0)
 ;S OK=$$IFOPEN^HLOUSR1(LINKNAME)
"RTN","HLOUSR",242,0)
 W !,"Testing...." ;P158
"RTN","HLOUSR",243,0)
 S OK=$$IFOPEN^HLOUSR1(LINK)
"RTN","HLOUSR",244,0)
 ;** P138 END
"RTN","HLOUSR",245,0)
 I OK W !,LINK_" IS operational..."
"RTN","HLOUSR",246,0)
 E  W !,LINK_" is NOT operational..."
"RTN","HLOUSR",247,0)
 W !,"Hit any key to continue..."
"RTN","HLOUSR",248,0)
 R *C:DTIME
"RTN","HLOUSR",249,0)
 Q
"RTN","HLOUSR",250,0)
 ;
"RTN","HLOUSR",251,0)
ASKLINK() ;
"RTN","HLOUSR",252,0)
 N DIC,TCP,X,Y,DTOUT,DUOUT
"RTN","HLOUSR",253,0)
 S DIC=870
"RTN","HLOUSR",254,0)
 S DIC(0)="AEMNQ"
"RTN","HLOUSR",255,0)
 S TCP=$O(^HLCS(869.1,"B","TCP",0))
"RTN","HLOUSR",256,0)
 S DIC("A")="Select a TCP link:"
"RTN","HLOUSR",257,0)
 S DIC("S")="I $P(^(0),U,3)=TCP"
"RTN","HLOUSR",258,0)
 D FULL^VALM1
"RTN","HLOUSR",259,0)
 D ^DIC
"RTN","HLOUSR",260,0)
 I +Y'=-1,'$D(DTOUT),'$D(DUOUT) Q $P(Y,"^",2)
"RTN","HLOUSR",261,0)
 Q ""
"RTN","HLOUSR",262,0)
 ;
"RTN","HLOUSR",263,0)
STOP ;
"RTN","HLOUSR",264,0)
 I '$$ASKYESNO^HLOUSR2("Are you SURE that you want to stop sending and receiving messages","NO") S VALMBCK="" Q
"RTN","HLOUSR",265,0)
 ;
"RTN","HLOUSR",266,0)
 D STOPHL7^HLOPROC1
"RTN","HLOUSR",267,0)
 S VALMBCK="R",VALMSG="HL7 (Optimized) has been stopped...."
"RTN","HLOUSR",268,0)
 H 5
"RTN","HLOUSR",269,0)
 D @HLRFRSH
"RTN","HLOUSR",270,0)
 ;D:HLSCREEN="Brief System Status" BRIEF^HLOUSR
"RTN","HLOUSR",271,0)
 ;D:HLSCREEN="Running Processes" PROCS^HLOUSR
"RTN","HLOUSR",272,0)
 Q
"RTN","HLOUSR",273,0)
 ;
"RTN","HLOUSR",274,0)
UPDMODE ;realtime
"RTN","HLOUSR",275,0)
 Q:'$L(HLRFRSH)
"RTN","HLOUSR",276,0)
 N TOP,BOTTOM,DX,DY,IOTM,IOBM,LINE,OLD,OLDCNT
"RTN","HLOUSR",277,0)
 S OLDCNT=VALMCNT
"RTN","HLOUSR",278,0)
 W !!!!!,IOINHI,"Hit any key to escape realtime display mode...",IOINORM
"RTN","HLOUSR",279,0)
 S IOTM=20,IOBM=23 W @IOSTBM
"RTN","HLOUSR",280,0)
 S TOP=VALMBG
"RTN","HLOUSR",281,0)
 S BOTTOM=TOP+20
"RTN","HLOUSR",282,0)
 F LINE=TOP:1:BOTTOM D
"RTN","HLOUSR",283,0)
 .I LINE>VALMCNT S @VALMAR@(LINE,0)=$$LJ(" ",80) Q
"RTN","HLOUSR",284,0)
 .S @VALMAR@(LINE,0)=$$LJ($G(@VALMAR@(LINE,0)),80)
"RTN","HLOUSR",285,0)
 F LINE=TOP:1:BOTTOM D
"RTN","HLOUSR",286,0)
 .S OLD(LINE)=$G(@VALMAR@(LINE,0))
"RTN","HLOUSR",287,0)
 F LINE=17:1:BOTTOM D
"RTN","HLOUSR",288,0)
 .S DX=50,DY=22 X IOXY W !
"RTN","HLOUSR",289,0)
 .D WRITE^VALM10(LINE)
"RTN","HLOUSR",290,0)
 D  F  R *C:4 Q:$T  D
"RTN","HLOUSR",291,0)
 .D @HLRFRSH
"RTN","HLOUSR",292,0)
 .;**START PATCH 138**
"RTN","HLOUSR",293,0)
 .S OLDCNT=VALMCNT
"RTN","HLOUSR",294,0)
 .;**END PATCH 138**
"RTN","HLOUSR",295,0)
 .F LINE=TOP:1:BOTTOM D
"RTN","HLOUSR",296,0)
 ..I LINE>VALMCNT S @VALMAR@(LINE,0)=$$LJ(" ",80) Q
"RTN","HLOUSR",297,0)
 ..S @VALMAR@(LINE,0)=$$LJ($G(@VALMAR@(LINE,0)),80)
"RTN","HLOUSR",298,0)
 .S VALMCNT=BOTTOM
"RTN","HLOUSR",299,0)
 .F LINE=TOP:1:BOTTOM IF OLD(LINE)'=$G(@VALMAR@(LINE,0)) D
"RTN","HLOUSR",300,0)
 ..S OLD(LINE)=$G(@VALMAR@(LINE,0))
"RTN","HLOUSR",301,0)
 ..S DX=50,DY=22 X IOXY W !
"RTN","HLOUSR",302,0)
 ..D WRITE^VALM10(LINE)
"RTN","HLOUSR",303,0)
 ;**START PATCH 138**
"RTN","HLOUSR",304,0)
 S VALMCNT=OLDCNT
"RTN","HLOUSR",305,0)
 I VALMCNT<VALMBG S VALMBG=VALMCNT
"RTN","HLOUSR",306,0)
 ;**END PATCH 138**
"RTN","HLOUSR",307,0)
 S VALMBCK="R"
"RTN","HLOUSR",308,0)
 Q
"RTN","HLOUSR",309,0)
 ;
"RTN","HLOUSR",310,0)
EDITSITE ;
"RTN","HLOUSR",311,0)
 ;edit HLO System Parameters
"RTN","HLOUSR",312,0)
 N DR,DA,DIE
"RTN","HLOUSR",313,0)
 S DA=$O(^HLD(779.1,0))
"RTN","HLOUSR",314,0)
 Q:'DA
"RTN","HLOUSR",315,0)
 S DIE="^HLD(779.1,"
"RTN","HLOUSR",316,0)
 S DR="[HLO EDIT SYSTEM PARAMETERS]"
"RTN","HLOUSR",317,0)
 D ^DIE
"RTN","HLOUSR",318,0)
 Q
"RTN","HLOUSR",319,0)
 ;
"RTN","HLOUSR",320,0)
LOGALL ;
"RTN","HLOUSR",321,0)
 N ON,CHANGE,DATA
"RTN","HLOUSR",322,0)
 ;Will turn on/off logging of all errors
"RTN","HLOUSR",323,0)
 S ON=$G(^HLTMP("LOG ALL ERRORS"))
"RTN","HLOUSR",324,0)
 W !!,"Logging of all HLO errors is turned ",$S(ON:"ON",1:"OFF"),"."
"RTN","HLOUSR",325,0)
 W !!,"Logging of all HLO errors, including READ and WRITE errors, should be turned",!,"on only for short periods for troubleshooting purposes.",!
"RTN","HLOUSR",326,0)
 S CHANGE=$$ASKYESNO^HLOUSR2("Do you want logging of all HLO errors turned "_$S(ON:"OFF",1:"ON"),$S(ON:"YES",1:"NO"))
"RTN","HLOUSR",327,0)
 Q:'CHANGE
"RTN","HLOUSR",328,0)
 S ON='ON
"RTN","HLOUSR",329,0)
 S ^HLTMP("LOG ALL ERRORS")=ON
"RTN","HLOUSR",330,0)
 W !,"Logging of all HLO errors is turned ",$S(ON:"ON",1:"OFF"),"."
"RTN","HLOUSR",331,0)
 Q
"RTN","HLOUSR",332,0)
 ;
"RTN","HLOUSR",333,0)
KLISTEN() ;
"RTN","HLOUSR",334,0)
 ;checks if the Kernel multi-listener is running
"RTN","HLOUSR",335,0)
 N DOLLARJ,FOUND
"RTN","HLOUSR",336,0)
 S DOLLARJ=""
"RTN","HLOUSR",337,0)
 S FOUND=0
"RTN","HLOUSR",338,0)
 F  S DOLLARJ=$O(^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ)) Q:DOLLARJ=""  I $P($G(^HLTMP("HL7 RUNNING PROCESSES",DOLLARJ)),"^",3)["TASKMAN MULTI-LISTENER" S FOUND=1 Q
"RTN","HLOUSR",339,0)
 Q FOUND
"RTN","HLTP31")
0^1^B20366575^B18539013
"RTN","HLTP31",1,0)
HLTP31 ;SFIRMFO/RSD - Cont. Transaction Processor for TCP ;07/08/2009  15:33
"RTN","HLTP31",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**57,58,66,109,120,145,163**;Oct 13, 1995;Build 3
"RTN","HLTP31",3,0)
 ;;Per VA Directive 6402, this routine should not be modified.
"RTN","HLTP31",4,0)
 ;
"RTN","HLTP31",5,0)
 Q
"RTN","HLTP31",6,0)
RSP(X,HLN) ;process response msg. X=ien in 773^msg. ien in 772
"RTN","HLTP31",7,0)
 ;HLN=HL array for original message
"RTN","HLTP31",8,0)
 ;HLMTIEN=ien in 772,  HLMTIENS=ien in 773
"RTN","HLTP31",9,0)
 ;returns - 0=resend msg, 1=commit ack, 3=app ack success, 4=error
"RTN","HLTP31",10,0)
 ;set error trap
"RTN","HLTP31",11,0)
 N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLTP3"
"RTN","HLTP31",12,0)
 N HLERR,HLHDR,HLMSA,HLMTIEN,HLMTIENS,HLQUIT,HLNODE,HLNEXT,HLRESLTA
"RTN","HLTP31",13,0)
 D INIT^HLTP3A  ;patch HL*1.6*109: hltp3 routine split
"RTN","HLTP31",14,0)
 ;Quit processing if error with header
"RTN","HLTP31",15,0)
 I $G(HLRESLT) D EXIT Q 0
"RTN","HLTP31",16,0)
 ;must have MSA segment
"RTN","HLTP31",17,0)
 I '$L(HLMSA) D RSPER(4,108,"Missing MSA segment") Q 0
"RTN","HLTP31",18,0)
 ;msg. id in MSA must match original msg. id, if not reject
"RTN","HLTP31",19,0)
 I $P(HLMSA,HL("FS"),2)'=HLN("MID") D RSPER(4,108,"Incorrect msg. Id") Q 0
"RTN","HLTP31",20,0)
 ;rec. app. must match sending app. of original message.
"RTN","HLTP31",21,0)
 I HL("RAN")'=HLN("SAN") D RSPER(4,108,"Incorrect sending app.") Q 0
"RTN","HLTP31",22,0)
 ;get ack code
"RTN","HLTP31",23,0)
 S HL("ACKCD")=$P(HLMSA,HL("FS"))
"RTN","HLTP31",24,0)
 ;update LL, rec. 1 msg
"RTN","HLTP31",25,0)
 D LLCNT^HLCSTCP(HLDP,1)
"RTN","HLTP31",26,0)
 ;commit ack
"RTN","HLTP31",27,0)
 I $E(HL("ACKCD"))="C" D  Q X
"RTN","HLTP31",28,0)
 . ;update LL, processed 1 msg
"RTN","HLTP31",29,0)
 . D LLCNT^HLCSTCP(HLDP,2)
"RTN","HLTP31",30,0)
 . ;received an error ack, return NAK
"RTN","HLTP31",31,0)
 . S:$E(HL("ACKCD"),2)'="A" HLRESLT=102_U_$P(HLMSA,HL("FS"),3)
"RTN","HLTP31",32,0)
 . D RSPER(3) S X=$S($E(HL("ACKCD"),2)="A":1,1:4)
"RTN","HLTP31",33,0)
 ;app. ack, received an error ack, NAK
"RTN","HLTP31",34,0)
 S:$E(HL("ACKCD"),2)'="A" HLRESLT=102_U_$P(HLMSA,HL("FS"),3)
"RTN","HLTP31",35,0)
 ;Set special HL variables
"RTN","HLTP31",36,0)
 S HLQUIT=0,HLNODE="",HLNEXT="D HLNEXT^HLCSUTL"
"RTN","HLTP31",37,0)
 ;HLORNOD=subscriber protocol for Fileman auditing, ien;global ref
"RTN","HLTP31",38,0)
 N HLORNODD S HLORNOD=HL("EIDS")_";ORD(101,"
"RTN","HLTP31",39,0)
 ;process ack
"RTN","HLTP31",40,0)
 D
"RTN","HLTP31",41,0)
 . N HLTCP ;Newed variable to update status in 772.
"RTN","HLTP31",42,0)
 . ; patch HL*1.6*145
"RTN","HLTP31",43,0)
 . ; time: starts to process the incoming message
"RTN","HLTP31",44,0)
 . I $G(HLMTIENS) S $P(^HLMA(+HLMTIENS,"S"),"^",6)=$$NOW^XLFDT
"RTN","HLTP31",45,0)
 . D PROCACK^HLTP2(HLMTIEN,HL("EID"),.HLRESLT,.HL)
"RTN","HLTP31",46,0)
 . ; time: ends processing the incoming message
"RTN","HLTP31",47,0)
 . I $G(HLMTIENS) S $P(^HLMA(+HLMTIENS,"S"),"^",7)=$$NOW^XLFDT
"RTN","HLTP31",48,0)
 ;update LL, processed 1 msg
"RTN","HLTP31",49,0)
 D LLCNT^HLCSTCP(HLDP,2)
"RTN","HLTP31",50,0)
 ;process ack successfully
"RTN","HLTP31",51,0)
 D RSPER(3)
"RTN","HLTP31",52,0)
 ;HLRESELT is defined for errors
"RTN","HLTP31",53,0)
 Q $S($G(HLRESLT):4,1:3)
"RTN","HLTP31",54,0)
 ;
"RTN","HLTP31",55,0)
RSPER(HLST,HLER,HLERM) ;HLST=status, HLER=error type, HLERM=error msg.
"RTN","HLTP31",56,0)
 D STATUS^HLTF0(HLMTIENS,HLST,$G(HLER),$G(HLERM),1)
"RTN","HLTP31",57,0)
 S:$G(HLER) HLRESLT=HLER_U_HLERM
"RTN","HLTP31",58,0)
 D EXIT
"RTN","HLTP31",59,0)
 Q
"RTN","HLTP31",60,0)
EXIT ;unlock
"RTN","HLTP31",61,0)
 ;**109**
"RTN","HLTP31",62,0)
 ;I $G(HLMTIENS) L -^HLMA(HLMTIENS)
"RTN","HLTP31",63,0)
 Q
"RTN","HLTP31",64,0)
 ;
"RTN","HLTP31",65,0)
SETINQUE ;
"RTN","HLTP31",66,0)
 ;**HL*1.6*109***
"RTN","HLTP31",67,0)
 ;Called from HLTP3 for message that utilize enhanced mode - NOT original mode
"RTN","HLTP31",68,0)
 ;Sets the incoming message on the in queue.
"RTN","HLTP31",69,0)
 ;Does not use the listener, instead, arranges multiple in-queues
"RTN","HLTP31",70,0)
 ;by using the sending link.
"RTN","HLTP31",71,0)
 ;
"RTN","HLTP31",72,0)
 N HLI,HLINST,HLDOMAIN,HLLINK
"RTN","HLTP31",73,0)
 ;
"RTN","HLTP31",74,0)
 ;Override value of logical link based on sending facility to create
"RTN","HLTP31",75,0)
 ;a queue (^HLMA("AC","I",llnk ien,msg ien)) different than that of the 
"RTN","HLTP31",76,0)
 ;listener
"RTN","HLTP31",77,0)
 S HLINST=$P(HL("SFN"),$E(HL("ECH")))
"RTN","HLTP31",78,0)
 S HLDOMAIN=$P(HL("SFN"),$E(HL("ECH")),2)
"RTN","HLTP31",79,0)
 ;
"RTN","HLTP31",80,0)
 ; patch HL*1.6*120 start
"RTN","HLTP31",81,0)
 ; assume the format is <domain>:<port #>
"RTN","HLTP31",82,0)
 ; patch HL*1.6*163 can no longer assume one format for <domain><port> with IPV6
"RTN","HLTP31",83,0)
 ; check for IPV6 address with delimiter of "]:" and process accordingly
"RTN","HLTP31",84,0)
 ;$$FORCEIP6^XLFIPV(IP) API (ICR #5844) 
"RTN","HLTP31",85,0)
 I HLDOMAIN["]" D
"RTN","HLTP31",86,0)
 . S HL("PORT")=$P(HLDOMAIN,"]:",2)
"RTN","HLTP31",87,0)
 . S HLDOMAIN=$E($P(HLDOMAIN,"]"),2,99)
"RTN","HLTP31",88,0)
 . S HLDOMAIN=$$FORCEIP6^XLFIPV(HLDOMAIN)
"RTN","HLTP31",89,0)
 E  I HLDOMAIN[":" D
"RTN","HLTP31",90,0)
 . S HL("PORT")=$P(HLDOMAIN,":",2)
"RTN","HLTP31",91,0)
 . S HLDOMAIN=$P(HLDOMAIN,":")
"RTN","HLTP31",92,0)
 S HL("DOMAIN")=HLDOMAIN
"RTN","HLTP31",93,0)
 ; change from lower case to upper case
"RTN","HLTP31",94,0)
 S HLDOMAIN=$$UP^XLFSTR(HLDOMAIN)
"RTN","HLTP31",95,0)
 ; if first piece of domain is "HL7." or "MPI.", remove it
"RTN","HLTP31",96,0)
 I ($E(HLDOMAIN,1,4)="HL7.")!($E(HLDOMAIN,1,4)="MPI.") D
"RTN","HLTP31",97,0)
 . S HLDOMAIN=$P(HLDOMAIN,".",2,99)
"RTN","HLTP31",98,0)
 ; patch HL*1.6*120 end
"RTN","HLTP31",99,0)
 ;
"RTN","HLTP31",100,0)
 I HLDOMAIN]"" D    ;logical link lookup by domain
"RTN","HLTP31",101,0)
 . D LINK^HLUTIL3(HLDOMAIN,.HLI,"D")
"RTN","HLTP31",102,0)
 . S HLLINK=$O(HLI(0)) ;client link for sending facility
"RTN","HLTP31",103,0)
 ;logical link lookup by station number
"RTN","HLTP31",104,0)
 I $G(HLLINK)']"",HLINST]"" D
"RTN","HLTP31",105,0)
 . D LINK^HLUTIL3(HLINST,.HLI,"I")
"RTN","HLTP31",106,0)
 . S HLLINK=$O(HLI(0)) ;client link for sending facility
"RTN","HLTP31",107,0)
 ;
"RTN","HLTP31",108,0)
 ; patch HL*1.6*120 start
"RTN","HLTP31",109,0)
 ;logical link lookup by DNS domain
"RTN","HLTP31",110,0)
 I $G(HLLINK)']"",HL("DOMAIN")]"" D
"RTN","HLTP31",111,0)
 . I $D(^HLCS(870,"DNS",HL("DOMAIN"))) D  Q
"RTN","HLTP31",112,0)
 .. S HLLINK=+$O(^HLCS(870,"DNS",HL("DOMAIN"),0))
"RTN","HLTP31",113,0)
 . I $D(^HLCS(870,"DNS",$$UP^XLFSTR(HL("DOMAIN")))) D  Q
"RTN","HLTP31",114,0)
 .. S HLLINK=+$O(^HLCS(870,"DNS",$$UP^XLFSTR(HL("DOMAIN")),0))
"RTN","HLTP31",115,0)
 . I $D(^HLCS(870,"DNS",$$LOW^XLFSTR(HL("DOMAIN")))) D
"RTN","HLTP31",116,0)
 .. S HLLINK=+$O(^HLCS(870,"DNS",$$LOW^XLFSTR(HL("DOMAIN")),0))
"RTN","HLTP31",117,0)
 ;
"RTN","HLTP31",118,0)
 ;logical link lookup by ip address
"RTN","HLTP31",119,0)
 I $G(HLLINK)']"",HL("DOMAIN") D
"RTN","HLTP31",120,0)
 . S HLLINK=$O(^HLCS(870,"IP",HL("DOMAIN"),0))
"RTN","HLTP31",121,0)
 ; patch HL*1.6*120 end
"RTN","HLTP31",122,0)
 ;
"RTN","HLTP31",123,0)
 ; find the logical link of the subscriber protocol
"RTN","HLTP31",124,0)
 ; then set the link field of this message to the link
"RTN","HLTP31",125,0)
 I $G(HL("EIDS")),$P(^ORD(101,HL("EIDS"),770),"^",7) S HLLINK=$P(^ORD(101,HL("EIDS"),770),"^",7)
"RTN","HLTP31",126,0)
 ;
"RTN","HLTP31",127,0)
 ; patch HL*1.6*145 start
"RTN","HLTP31",128,0)
 F  L +^HLMA(HLMTIENS,0):10 Q:$T  H 1
"RTN","HLTP31",129,0)
 N COUNT
"RTN","HLTP31",130,0)
 F COUNT=1:1:15 Q:($G(^HLMA(HLMTIENS,0))]"")  H COUNT
"RTN","HLTP31",131,0)
 I $L($G(HLLINK)) D
"RTN","HLTP31",132,0)
 .D ENQUE^HLCSREP(HLLINK,"I",HLMTIENS)
"RTN","HLTP31",133,0)
 .; move message from listener queue to client link queue
"RTN","HLTP31",134,0)
 .S HLDP("HLLINK")=HLLINK
"RTN","HLTP31",135,0)
 .D LLCNT^HLCSTCP(HLDP,1,1)
"RTN","HLTP31",136,0)
 .D LLCNT^HLCSTCP(HLLINK,1)
"RTN","HLTP31",137,0)
 .S $P(^HLMA(HLMTIENS,0),"^",17)=HLLINK
"RTN","HLTP31",138,0)
 E  D
"RTN","HLTP31",139,0)
 .D ENQUE^HLCSREP(HLDP,"I",HLMTIENS)
"RTN","HLTP31",140,0)
 .S $P(^HLMA(HLMTIENS,0),"^",17)=HLDP
"RTN","HLTP31",141,0)
 S HLDP("SETINQUE")=1
"RTN","HLTP31",142,0)
 L -^HLMA(HLMTIENS,0)
"RTN","HLTP31",143,0)
 ; patch HL*1.6*145 end
"RTN","HLTP31",144,0)
 Q
"RTN","HLTP4")
0^2^B50343376^B46055553
"RTN","HLTP4",1,0)
HLTP4 ;SFIRMFO/RSD - Transaction Processor for TCP ;06/24/2008  10:47
"RTN","HLTP4",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**19,57,59,91,109,116,117,125,120,142,163**;Oct 13, 1995;Build 3
"RTN","HLTP4",3,0)
 ;;Per VA Directive 6402, this routine should not be modified.
"RTN","HLTP4",4,0)
GENACK ;called from HLMA1
"RTN","HLTP4",5,0)
 ;Entry point to generate an acknowledgement message
"RTN","HLTP4",6,0)
 ;for TCP
"RTN","HLTP4",7,0)
 ;INPUT:
"RTN","HLTP4",8,0)
 ;   HLMTIENS=original msg. ien #773
"RTN","HLTP4",9,0)
 ;   HLEID=original msg. event protocol
"RTN","HLTP4",10,0)
 ;   HLEIDS=original msg. subscriber protocol
"RTN","HLTP4",11,0)
 ;   HLMTIENA=ien of ack in 772, for batch only
"RTN","HLTP4",12,0)
 ;   Note:  if the HLP(...) array exists, it will be "honored" by
"RTN","HLTP4",13,0)
 ;          UPDATE^HLTF0 below. This includes the HLP("NAMESPACE")
"RTN","HLTP4",14,0)
 ;          variable. - HL*1.6*91
"RTN","HLTP4",15,0)
 ;
"RTN","HLTP4",16,0)
 ;OUTPUT: HLTCP=ien of response
"RTN","HLTP4",17,0)
 N HLDT,HLDT1,HLQ,HLOGLINK,HLMIDA,HLMTIEN,HLREC,HLSAN,HLTYPE,X
"RTN","HLTP4",18,0)
 ;Extract data from original message and store in separate variables
"RTN","HLTP4",19,0)
 ;reverse sending and receiving application from original msg.
"RTN","HLTP4",20,0)
 S X=$G(^HLMA(HLMTIENS,0)),HLREC=$P(X,U,11),HLSAN=$P(X,U,12),HLOGLINK=$G(HLTCPO)
"RTN","HLTP4",21,0)
 ;HLMTIENA defined, create msg in 773
"RTN","HLTP4",22,0)
 I $G(HLMTIENA) S HLDT=+$G(^HL(772,HLMTIENA,0)),HLMTIENA=$$MA^HLTF(HLMTIENA,.HLMIDA)
"RTN","HLTP4",23,0)
 ;create message in 772 & 773, HLMTIENA=new msg ien #773
"RTN","HLTP4",24,0)
 I '$G(HLMTIENA) D TCP^HLTF(.HLMIDA,.HLMTIENA,.HLDT)
"RTN","HLTP4",25,0)
 ;
"RTN","HLTP4",26,0)
 ;**109**
"RTN","HLTP4",27,0)
 ;lock new record
"RTN","HLTP4",28,0)
 ;F  L +^HLMA(HLMTIENA):1 Q:$T  H 1
"RTN","HLTP4",29,0)
 ;
"RTN","HLTP4",30,0)
 ;HLMTIEN=ien in 772
"RTN","HLTP4",31,0)
 S HLTCP=HLMTIENA,HLMTIEN=+^HLMA(HLMTIENA,0),HLDT1=$$HLDATE^HLFNC(HLDT),(HLTYPE,HLP("MSGTYPE"))=$E(HLARYTYP,2)
"RTN","HLTP4",32,0)
 ;
"RTN","HLTP4",33,0)
 ;**** HL*1.6*116 ****
"RTN","HLTP4",34,0)
 ;no open link, check dynamic routing of ack
"RTN","HLTP4",35,0)
 S X=$G(^ORD(101,HLEIDS,770)),HLP("MTYPE")=$P(X,U,11),HLP("EVENT")=$P(X,U,4)
"RTN","HLTP4",36,0)
 ;
"RTN","HLTP4",37,0)
 ; patch HL*1.6*125- change from $G to $D
"RTN","HLTP4",38,0)
 I '$D(HLL("SET FOR APP ACK")) D  Q:'HLOGLINK
"RTN","HLTP4",39,0)
 .K HLL("LINKS")
"RTN","HLTP4",40,0)
 .I 'HLOGLINK D
"RTN","HLTP4",41,0)
 .. S HLOGLINK=$P(X,U,7)
"RTN","HLTP4",42,0)
 .. Q:HLOGLINK
"RTN","HLTP4",43,0)
 .. N DOMAIN,SFAC,MSH,FS,CS,HLI,INST
"RTN","HLTP4",44,0)
 .. S MSH=$G(^HLMA(HLMTIENS,"MSH",1,0))
"RTN","HLTP4",45,0)
 .. Q:'$L(MSH)
"RTN","HLTP4",46,0)
 .. S FS=$E(MSH,4)
"RTN","HLTP4",47,0)
 .. Q:'$L(FS)
"RTN","HLTP4",48,0)
 .. S CS=$E(MSH,5)
"RTN","HLTP4",49,0)
 .. Q:'$L(CS)
"RTN","HLTP4",50,0)
 .. S DOMAIN=$P($P(MSH,FS,4),CS,2)
"RTN","HLTP4",51,0)
 .. ;
"RTN","HLTP4",52,0)
 .. ; patch HL*1.6*120 start
"RTN","HLTP4",53,0)
 .. ; assume the format is <domain>:<port #>
"RTN","HLTP4",54,0)
 .. ; patch HL*1.6*163 can no longer assume one format for <domain><port> with IPV6
"RTN","HLTP4",55,0)
 .. ; check for IPV6 address with delimiter of "]:" and process accordingly
"RTN","HLTP4",56,0)
 .. ;$$FORCEIP6^XLFIPV(IP) API (ICR #5844)
"RTN","HLTP4",57,0)
 .. I DOMAIN["]" D 
"RTN","HLTP4",58,0)
 ... S HLP("PORT")=$P(DOMAIN,"]:",2)
"RTN","HLTP4",59,0)
 ... S DOMAIN=$E($P(DOMAIN,"]"),2,99)
"RTN","HLTP4",60,0)
 ... S DOMAIN=$$FORCEIP6^XLFIPV(DOMAIN)
"RTN","HLTP4",61,0)
 .. E  I DOMAIN[":" D
"RTN","HLTP4",62,0)
 ... S HLP("PORT")=$P(DOMAIN,":",2)
"RTN","HLTP4",63,0)
 ... S DOMAIN=$P(DOMAIN,":")
"RTN","HLTP4",64,0)
 .. S HLP("DNS-DOMAIN")=DOMAIN
"RTN","HLTP4",65,0)
 .. ;
"RTN","HLTP4",66,0)
 .. ; if first piece of domain is "HL7." or "MPI.", remove it
"RTN","HLTP4",67,0)
 .. I ($E(DOMAIN,1,4)="HL7.")!($E(DOMAIN,1,4)="MPI.") D
"RTN","HLTP4",68,0)
 ... S DOMAIN=$P(DOMAIN,".",2,99)
"RTN","HLTP4",69,0)
 .. ;
"RTN","HLTP4",70,0)
 .. ; lookup Mailman domain
"RTN","HLTP4",71,0)
 .. I $L(DOMAIN) D
"RTN","HLTP4",72,0)
 ... D LINK^HLUTIL3(DOMAIN,.HLI,"D")
"RTN","HLTP4",73,0)
 ... S HLOGLINK=$O(HLI(0))
"RTN","HLTP4",74,0)
 .. Q:HLOGLINK
"RTN","HLTP4",75,0)
 .. S INST=$P($P(MSH,FS,4),CS,1)
"RTN","HLTP4",76,0)
 .. I $L(INST) D
"RTN","HLTP4",77,0)
 .. .D LINK^HLUTIL3(INST,.HLI,"I")
"RTN","HLTP4",78,0)
 ... S HLOGLINK=$O(HLI(0))
"RTN","HLTP4",79,0)
 .. Q:HLOGLINK
"RTN","HLTP4",80,0)
 .. ;
"RTN","HLTP4",81,0)
 .. ; check DNS domain and ip address
"RTN","HLTP4",82,0)
 .. I $L(HLP("DNS-DOMAIN")) D
"RTN","HLTP4",83,0)
 ... ;
"RTN","HLTP4",84,0)
 ... ; match DNS domain
"RTN","HLTP4",85,0)
 ... I $D(^HLCS(870,"DNS",HLP("DNS-DOMAIN"))) D
"RTN","HLTP4",86,0)
 .... S HLOGLINK=+$O(^HLCS(870,"DNS",HLP("DNS-DOMAIN"),0))
"RTN","HLTP4",87,0)
 ... Q:HLOGLINK
"RTN","HLTP4",88,0)
 ... ;
"RTN","HLTP4",89,0)
 ... I $D(^HLCS(870,"DNS",$$UP^XLFSTR(HLP("DNS-DOMAIN")))) D
"RTN","HLTP4",90,0)
 .... S HLOGLINK=+$O(^HLCS(870,"DNS",$$UP^XLFSTR(HLP("DNS-DOMAIN")),0))
"RTN","HLTP4",91,0)
 ... Q:HLOGLINK
"RTN","HLTP4",92,0)
 ... ;
"RTN","HLTP4",93,0)
 ... I $D(^HLCS(870,"DNS",$$LOW^XLFSTR(HLP("DNS-DOMAIN")))) D
"RTN","HLTP4",94,0)
 .... S HLOGLINK=+$O(^HLCS(870,"DNS",$$LOW^XLFSTR(HLP("DNS-DOMAIN")),0))
"RTN","HLTP4",95,0)
 ... Q:HLOGLINK
"RTN","HLTP4",96,0)
 ... ;
"RTN","HLTP4",97,0)
 ... ; match ip address
"RTN","HLTP4",98,0)
 ... I $D(^HLCS(870,"IP",HLP("DNS-DOMAIN"))) D
"RTN","HLTP4",99,0)
 .... S HLOGLINK=+$O(^HLCS(870,"IP",HLP("DNS-DOMAIN"),0))
"RTN","HLTP4",100,0)
 .. ;
"RTN","HLTP4",101,0)
 ; patch HL*1.6*116 and patch HL*1.6*120 end
"RTN","HLTP4",102,0)
 ;
"RTN","HLTP4",103,0)
 ;** HL*1.6*117 **
"RTN","HLTP4",104,0)
 ; patch HL*1.6*125- change from $G to $D
"RTN","HLTP4",105,0)
 I $D(HLL("SET FOR APP ACK")) D  Q:'HLOGLINK
"RTN","HLTP4",106,0)
 .N I
"RTN","HLTP4",107,0)
 .S I=$O(HLL("LINKS",0))
"RTN","HLTP4",108,0)
 .I 'I S HLOGLINK="" Q
"RTN","HLTP4",109,0)
 .S HLOGLINK=$P(HLL("LINKS",I),"^",2) Q:HLOGLINK=""
"RTN","HLTP4",110,0)
 .I +HLOGLINK'=HLOGLINK S HLOGLINK=$O(^HLCS(870,"B",HLOGLINK,0))
"RTN","HLTP4",111,0)
 ;**END HL*1.6*117 **
"RTN","HLTP4",112,0)
 ;
"RTN","HLTP4",113,0)
 S:$P(X,U,5) HLP("MTYPE_EVENT")=$P(X,U,5)
"RTN","HLTP4",114,0)
 ;HLTCPI=initial message
"RTN","HLTP4",115,0)
 S:$G(HLTCPI) HLP("HLTCPI")=HLTCPI
"RTN","HLTP4",116,0)
 ;Update zero node of Message Admin file #773
"RTN","HLTP4",117,0)
 D UPDATE^HLTF0(HLTCP,,"O",HLEIDS,HLREC,HLSAN,"I",HLMTIENS,HLOGLINK,.HLP)
"RTN","HLTP4",118,0)
 ;
"RTN","HLTP4",119,0)
 ;Update status to Being Generated
"RTN","HLTP4",120,0)
 D STATUS^HLTF0(HLTCP,8)
"RTN","HLTP4",121,0)
 ;
"RTN","HLTP4",122,0)
 ;**109**
"RTN","HLTP4",123,0)
 ;tcp link is open, don't need x-ref, msg will be sent over link
"RTN","HLTP4",124,0)
 ;I $G(HLTCPO) K ^HLMA("AC","O",HLOGLINK,HLTCP)
"RTN","HLTP4",125,0)
 ;
"RTN","HLTP4",126,0)
 ;update zero node of Message Text file #772
"RTN","HLTP4",127,0)
 D
"RTN","HLTP4",128,0)
 . N HLTCP D UPDATE^HLTF0(HLMTIEN,,"O",HLEID)
"RTN","HLTP4",129,0)
 ;
"RTN","HLTP4",130,0)
 ;Execute entry action for subscriber protocol
"RTN","HLTP4",131,0)
 I HLENROU]"" X HLENROU
"RTN","HLTP4",132,0)
 S HLQ=""""
"RTN","HLTP4",133,0)
 ;Check that local/global array exists and store in Message Text file
"RTN","HLTP4",134,0)
 ; if pre-compiled
"RTN","HLTP4",135,0)
 I HLFORMAT D  I (+$G(HLRESLTA)) D STATUS^HLTF0(HLMTIENA,4,+HLRESLTA) G ERR
"RTN","HLTP4",136,0)
 . I $E(HLARYTYP)="G" D
"RTN","HLTP4",137,0)
 .. I $O(^TMP("HLA",$J,0))']"" S HLRESLTA="8^"_$G(^HL(771.7,8,0)) Q
"RTN","HLTP4",138,0)
 .. D MERGE^HLTF1("G",HLMTIEN,"HLA")
"RTN","HLTP4",139,0)
 . I $E(HLARYTYP)="L" D
"RTN","HLTP4",140,0)
 .. I $O(HLA("HLA",0))']"" S HLRESLTA="8^"_$G(^HL(771.7,8,0)) Q
"RTN","HLTP4",141,0)
 .. D MERGE^HLTF1("L",HLMTIEN,"HLA")
"RTN","HLTP4",142,0)
 ;If array is not pre-compiled, call message generation routine
"RTN","HLTP4",143,0)
 I 'HLFORMAT N HLERR D  I $D(HLERR) S HLRESLTA="9^"_HLERR D STATUS^HLTF0(HLMTIENA,4,9,HLERR) G ERR
"RTN","HLTP4",144,0)
 .S HLP("GROUTINE")=HLP("GROUTINE")_"("_HLMIDA_","_HLMTIENA_","_HLQ_HLARYTYP_HLQ_","_HLSAN_","_$P($G(^HL(771.2,$P(HLN(770),"^",3),0)),"^")_","_$P($G(^HL(779.001,$P(HLN(770),"^",4),0)),"^")_","_HLQ_$TR($P(HLN(770),"^",6),"id","ID")_HLQ_")"
"RTN","HLTP4",145,0)
 .X HLP("GROUTINE")
"RTN","HLTP4",146,0)
 ;
"RTN","HLTP4",147,0)
 ;create header for message in 773
"RTN","HLTP4",148,0)
 I (HLTYPE="M") D HEADER^HLCSHDR1(HLTCP,HLREC,.HLRESLT)
"RTN","HLTP4",149,0)
 I (HLTYPE'="M") D BHSHDR^HLCSHDR1(HLTCP,HLREC,.HLRESLT)
"RTN","HLTP4",150,0)
 ;if error set status to ERROR DURING TRANSMISSION
"RTN","HLTP4",151,0)
 I ($G(HLRESLT)'="") D STATUS^HLTF0(HLTCP,4,12,HLRESLT) G ERR
"RTN","HLTP4",152,0)
 ;set header, HLHDR in 773
"RTN","HLTP4",153,0)
 K HLQ S X=HLTCP_",",HLQ(773,X,200)="HLHDR"
"RTN","HLTP4",154,0)
 D FILE^HLDIE("","HLQ","","GENACK","HLTP4") ;HL*1.6*109
"RTN","HLTP4",155,0)
 ;D FILE^DIE("","HLQ")
"RTN","HLTP4",156,0)
 ;update status of 773 to PENDING TRANSMISSION
"RTN","HLTP4",157,0)
 D STATUS^HLTF0(HLTCP,1)
"RTN","HLTP4",158,0)
 ;Execute exit action for subscriber protocol
"RTN","HLTP4",159,0)
 X:HLEXROU]"" HLEXROU
"RTN","HLTP4",160,0)
 ;
"RTN","HLTP4",161,0)
 ;**109**
"RTN","HLTP4",162,0)
 ;tcp link is NOT open, need x-ref
"RTN","HLTP4",163,0)
 I '$G(HLTCPO) D ENQUE^HLCSREP(HLOGLINK,"O",HLTCP)
"RTN","HLTP4",164,0)
 ;
"RTN","HLTP4",165,0)
EXIT ;**109**
"RTN","HLTP4",166,0)
 ;L -^HLMA(HLMTIENA)
"RTN","HLTP4",167,0)
 Q
"RTN","HLTP4",168,0)
ERR D EXIT S HLTCP=""
"RTN","HLTP4",169,0)
 S:$G(HLRESLT) HLRESLTA=$G(HLRESLTA)_"^"_HLRESLT
"RTN","HLTP4",170,0)
 Q
"RTN","HLTP4",171,0)
ACK(HLTACK,HLMG) ;build response based on original msg header
"RTN","HLTP4",172,0)
 ;for Bi-directional TCP
"RTN","HLTP4",173,0)
 ;INPUT:
"RTN","HLTP4",174,0)
 ;   HLTACK=type of ack. CA,CR, or AR
"RTN","HLTP4",175,0)
 ;   HLMG=text for MSA segment
"RTN","HLTP4",176,0)
 ;   HLMTIENS=original msg. ien #773
"RTN","HLTP4",177,0)
 ;   HL(array) from original header
"RTN","HLTP4",178,0)
 ;RETURNS:  HLTCP=ien of response msg. in 773
"RTN","HLTP4",179,0)
 N HLDT,HLDT1,HLQ,HLFS,HLHDR,HLMIDA,HLMTIEN,HLMTIENA,HLP,HLREC,HLSAN,X
"RTN","HLTP4",180,0)
 ;quit if we don't have enough to make a msg.
"RTN","HLTP4",181,0)
 I $G(HL("ECH"))=""!($G(HL("FS"))="")!($G(HL("TYPE"))="") Q
"RTN","HLTP4",182,0)
 ;Extract data from original message and store in separate variables
"RTN","HLTP4",183,0)
 ;reverse sending and receiving application from original msg.
"RTN","HLTP4",184,0)
 S HLFS=HL("FS"),HLREC=$G(HL("SAN")),HLSAN=$G(HL("RAN"))
"RTN","HLTP4",185,0)
 ;create message in 772 & 773, HLMTIENA=new msg ien #773
"RTN","HLTP4",186,0)
 D TCP^HLTF(.HLMIDA,.HLMTIENA,.HLDT)
"RTN","HLTP4",187,0)
 ;lock new record
"RTN","HLTP4",188,0)
 ;**109**
"RTN","HLTP4",189,0)
 ;F  L +^HLMA(HLMTIENA):1 Q:$T  H 1
"RTN","HLTP4",190,0)
 ;
"RTN","HLTP4",191,0)
 ;HLMTIEN=ien in 772
"RTN","HLTP4",192,0)
 S HLTCP=HLMTIENA,HLMTIEN=+^HLMA(HLMTIENA,0),HLDT1=$$FMTHL7^XLFDT(HLDT)
"RTN","HLTP4",193,0)
 ;get 'msgtype'=B or M, message type and event type
"RTN","HLTP4",194,0)
 S HLP("MSGTYPE")=$E(HL("TYPE")),HLP("MTYPE")=$G(HL("MTP")),HLP("EVENT")=$G(HL("ETP")),HLP("HLTCPI")=HLMTIENS
"RTN","HLTP4",195,0)
 S:$G(HL("MTP_ETP")) HLP("MTYPE_EVENT")=$G(HL("MTP_ETP"))
"RTN","HLTP4",196,0)
 ; HL*1.6*117 start
"RTN","HLTP4",197,0)
 ; change the order of when updates are done on file 773
"RTN","HLTP4",198,0)
 ;Update zero node of Message Admin file #773
"RTN","HLTP4",199,0)
 ;D UPDATE^HLTF0(HLTCP,,"O",,HLREC,HLSAN,"I",HLMTIENS,HLDP,.HLP)
"RTN","HLTP4",200,0)
 ;
"RTN","HLTP4",201,0)
 ;don't need x-ref, msg will be sent back over open tcp link
"RTN","HLTP4",202,0)
 ;**109**
"RTN","HLTP4",203,0)
 ;D LLCNT^HLCSTCP(HLDP,3)
"RTN","HLTP4",204,0)
 ;K ^HLMA("AC","O",HLDP,HLTCP)
"RTN","HLTP4",205,0)
 ;
"RTN","HLTP4",206,0)
 ;Update status to Being Generated
"RTN","HLTP4",207,0)
 ;D STATUS^HLTF0(HLTCP,8)
"RTN","HLTP4",208,0)
 ; HL*1.6*117 end
"RTN","HLTP4",209,0)
 ;update zero node of Message Text file #772
"RTN","HLTP4",210,0)
 D
"RTN","HLTP4",211,0)
 . N HLTCP D UPDATE^HLTF0(HLMTIEN,,"O")
"RTN","HLTP4",212,0)
 ;
"RTN","HLTP4",213,0)
 ;build MSA segment
"RTN","HLTP4",214,0)
 K HLA
"RTN","HLTP4",215,0)
 S HLA("HLS",1)="MSA"_HLFS_HLTACK_HLFS_$G(HL("MID"))
"RTN","HLTP4",216,0)
 S:$G(HLMG)]"" HLA("HLS",1)=HLA("HLS",1)_HLFS_HLMG
"RTN","HLTP4",217,0)
 ;update file 772 with msg text
"RTN","HLTP4",218,0)
 D MERGE^HLTF1("L",HLMTIEN,"HLS")
"RTN","HLTP4",219,0)
 D HDR
"RTN","HLTP4",220,0)
 ;update file 773 with msg header
"RTN","HLTP4",221,0)
 K HLQ S HLQ(773,HLTCP_",",200)="HLHDR"
"RTN","HLTP4",222,0)
 D FILE^HLDIE("","HLQ","","ACK","HLTP4") ; HL*1.6*109
"RTN","HLTP4",223,0)
 ;D FILE^DIE("","HLQ")
"RTN","HLTP4",224,0)
 ; HL*1.6*117 start
"RTN","HLTP4",225,0)
 ; finally commit updates to 773 that will affect behavior of messaging
"RTN","HLTP4",226,0)
 ;Update status to Being Generated
"RTN","HLTP4",227,0)
 D STATUS^HLTF0(HLTCP,8)
"RTN","HLTP4",228,0)
 ;Update zero node of Message Admin file #773
"RTN","HLTP4",229,0)
 ; patch HL*1.6*142
"RTN","HLTP4",230,0)
 ; update ien of sending application (from HL("RAP") of the incoming msg),
"RTN","HLTP4",231,0)
 ; ien of receiving application (from HL("SAP") of the incoming msg),
"RTN","HLTP4",232,0)
 ; and subscriber protocol
"RTN","HLTP4",233,0)
 ; D UPDATE^HLTF0(HLTCP,,"O",,HLREC,HLSAN,"I",HLMTIENS,HLDP,.HLP)
"RTN","HLTP4",234,0)
 D UPDATE^HLTF0(HLTCP,,"O",$G(HL("EIDS")),$G(HL("SAP")),$G(HL("RAP")),"I",HLMTIENS,HLDP,.HLP)
"RTN","HLTP4",235,0)
 ; update message sent count
"RTN","HLTP4",236,0)
 D LLCNT^HLCSTCP(HLDP,3)
"RTN","HLTP4",237,0)
 ; HL*1.6*117 end
"RTN","HLTP4",238,0)
 G EXIT
"RTN","HLTP4",239,0)
 ;
"RTN","HLTP4",240,0)
HDR ; build header for commit ack
"RTN","HLTP4",241,0)
 K HLHDR
"RTN","HLTP4",242,0)
 S HLHDR(1)=HL("TYPE")_HLFS_HL("ECH")_HLFS_HLSAN_HLFS_$G(HL("RFN"))_HLFS_HLREC_HLFS_$G(HL("SFN"))_HLFS_HLDT1_HLFS_HLFS
"RTN","HLTP4",243,0)
 I HLP("MSGTYPE")="M" S HLHDR(1)=HLHDR(1)_"ACK"_HLFS_HLMIDA_HLFS_$G(HL("PID"))_HLFS_$G(HL("VER")) Q
"RTN","HLTP4",244,0)
 ;batch
"RTN","HLTP4",245,0)
 S X=$E(HL("ECH"))
"RTN","HLTP4",246,0)
 S HLHDR(1)=HLHDR(1)_X_$G(HL("PID"))_X_"ACK"_HLFS_HLTACK_HLFS_HLMIDA_HLFS_$G(HL("MID"))
"RTN","HLTP4",247,0)
 Q
"RTN","HLTPCK2B")
0^3^B82231520^B70829946
"RTN","HLTPCK2B",1,0)
HLTPCK2B ;OIFO-O/RJH - Message Header Validation (Con't) ; 09/22/2009  14:41
"RTN","HLTPCK2B",2,0)
 ;;1.6;HEALTH LEVEL SEVEN;**120,133,122,148,163**;Oct 13, 1995;Build 3
"RTN","HLTPCK2B",3,0)
 ;;Per VA Directive 6402, this routine should not be modified.
"RTN","HLTPCK2B",4,0)
 ;
"RTN","HLTPCK2B",5,0)
 ; splitted from HLTPCK2A
"RTN","HLTPCK2B",6,0)
 ; to be called from HLTPCK2A
"RTN","HLTPCK2B",7,0)
 ;
"RTN","HLTPCK2B",8,0)
MS ;Check for Message Structure Code
"RTN","HLTPCK2B",9,0)
 I $G(ARY("MTN_ETN"))'="" D
"RTN","HLTPCK2B",10,0)
 . S ARY("MTP_ETP")=0
"RTN","HLTPCK2B",11,0)
 . S ARY("MTP_ETP")=+$O(^HL(779.005,"B",ARY("MTN_ETN"),0))
"RTN","HLTPCK2B",12,0)
 . I ('ARY("MTP_ETP")) S:(ERR="") ERR="Invalid Message Structure Code" Q
"RTN","HLTPCK2B",13,0)
 ;
"RTN","HLTPCK2B",14,0)
 ;Get server and client Protocols
"RTN","HLTPCK2B",15,0)
MSA ;if ack, then get information and quit, we don't need to respond
"RTN","HLTPCK2B",16,0)
 I $G(MSA)]"" D  Q
"RTN","HLTPCK2B",17,0)
 . ;Message is an acknowledgement, find original message
"RTN","HLTPCK2B",18,0)
 . S ARY("MSAID")=$P(MSA,FS,2),ARY("MTIENS")=0
"RTN","HLTPCK2B",19,0)
 . I ARY("MSAID")="" S:(ERR="") ERR="Invalid Message Control ID in MSA Segment - No Message ID" Q
"RTN","HLTPCK2B",20,0)
 . F  S ARY("MTIENS")=+$O(^HLMA("AH",ARY("SAP"),ARY("MSAID"),ARY("MTIENS"))) Q:'ARY("MTIENS")!($P($G(^HLMA(ARY("MTIENS"),0)),U,3)="O")
"RTN","HLTPCK2B",21,0)
 . I 'ARY("MTIENS") S:(ERR="") ERR="Invalid Message Control ID in MSA Segment - No message IEN in ""AH"" x-ref" Q
"RTN","HLTPCK2B",22,0)
 . ;get subscriber protocol and ack. to (show if this is an ack to an ack)
"RTN","HLTPCK2B",23,0)
 . S X=$G(^HLMA(ARY("MTIENS"),0)),ARY("EIDS")=$P(X,U,8),ARY("ACK")=$P(X,U,10)
"RTN","HLTPCK2B",24,0)
 . ;if no subscriber protocol then response msg. is invalid
"RTN","HLTPCK2B",25,0)
 . ;
"RTN","HLTPCK2B",26,0)
 . ; patch HL*1.6*122 start
"RTN","HLTPCK2B",27,0)
 . ; comment out the following code: for patch 109- dynamic addressing
"RTN","HLTPCK2B",28,0)
 . ; I ('ARY("EIDS")) S:(ERR="") ERR="Invalid Message Control ID in MSA Segment - No Subscr. IEN in 773" Q
"RTN","HLTPCK2B",29,0)
 . ;get message text ien in file 772 and server protocol, 'EID'
"RTN","HLTPCK2B",30,0)
 . S ARY("MTIEN")=+X,X=$G(^HL(772,+X,0)),ARY("EID")=$P(X,U,10)
"RTN","HLTPCK2B",31,0)
 . I ('ARY("EID")) S:(ERR="") ERR="Event Protocol not found" Q
"RTN","HLTPCK2B",32,0)
 . ; D EVENT^HLUTIL1(ARY("EIDS"),"770,773",.HLN)
"RTN","HLTPCK2B",33,0)
 . I ARY("EIDS") D EVENT^HLUTIL1(ARY("EIDS"),"770,773",.HLN)
"RTN","HLTPCK2B",34,0)
 . ; patch HL*1.6*122 end
"RTN","HLTPCK2B",35,0)
 ;
"RTN","HLTPCK2B",36,0)
 ;Find Server Protocol - based on sending application, message type,
"RTN","HLTPCK2B",37,0)
 ;event type and version ID
"RTN","HLTPCK2B",38,0)
 I ARY("ETP") S ARY("EID")=+$O(^ORD(101,"AHL1",ARY("SAP"),ARY("MTP"),ARY("ETP"),ARY("VEP"),0))
"RTN","HLTPCK2B",39,0)
 ;
"RTN","HLTPCK2B",40,0)
 ;Find Server Protocol - based on sending application, message type,
"RTN","HLTPCK2B",41,0)
 ;and version ID
"RTN","HLTPCK2B",42,0)
 I 'ARY("ETP") S ARY("EID")=+$O(^ORD(101,"AHL21",ARY("SAP"),ARY("MTP"),ARY("VEP"),0))
"RTN","HLTPCK2B",43,0)
 ;
"RTN","HLTPCK2B",44,0)
 I ('ARY("EID")) S:(ERR="") ERR="Event Protocol not found" Q
"RTN","HLTPCK2B",45,0)
 ;Find Client Protocol - in ITEM multiple of Server Protocol
"RTN","HLTPCK2B",46,0)
 S ARY("EIDS")=0
"RTN","HLTPCK2B",47,0)
 F  S ARY("EIDS")=+$O(^ORD(101,ARY("EID"),775,"B",ARY("EIDS"))) Q:'ARY("EIDS")!($P($G(^ORD(101,ARY("EIDS"),770)),U,2)=ARY("RAP"))
"RTN","HLTPCK2B",48,0)
 I 'ARY("EIDS") S ERR="Invalid Receiving Application for this Event" Q
"RTN","HLTPCK2B",49,0)
 D EVENT^HLUTIL1(ARY("EIDS"),"770,773",.HLN)
"RTN","HLTPCK2B",50,0)
 ;
"RTN","HLTPCK2B",51,0)
LLP ;Get logical link pointer
"RTN","HLTPCK2B",52,0)
 S ARY("LL")=$P($G(HLN(770)),"^",7)
"RTN","HLTPCK2B",53,0)
 ;
"RTN","HLTPCK2B",54,0)
FAC ;Get sending/rec facility, validate if necessary
"RTN","HLTPCK2B",55,0)
 ;
"RTN","HLTPCK2B",56,0)
 S HLCS=$E(ECH,1) ;Get component separator
"RTN","HLTPCK2B",57,0)
 S ARY("RAF")=$$P^HLTPCK2(.HDR,6) ;Receiving Facility
"RTN","HLTPCK2B",58,0)
 S ARY("SAF")=$$P^HLTPCK2(.HDR,4) ;Sending Facility
"RTN","HLTPCK2B",59,0)
 ;Get sending/receiving facility from Application Parameter file(771)
"RTN","HLTPCK2B",60,0)
 S HL771SF=$P($G(^HL(771,ARY("SAP"),0)),U,3)
"RTN","HLTPCK2B",61,0)
 S HL771RF=$P($G(^HL(771,ARY("RAP"),0)),U,3)
"RTN","HLTPCK2B",62,0)
 ;Sending/Receiving facility required?
"RTN","HLTPCK2B",63,0)
 S X=$G(^ORD(101,ARY("EIDS"),773))
"RTN","HLTPCK2B",64,0)
 S HLSFREQ=+X,HLRFREQ=+$P(X,U,2)
"RTN","HLTPCK2B",65,0)
RF ;Validate Receiving Facility
"RTN","HLTPCK2B",66,0)
 I HLRFREQ D
"RTN","HLTPCK2B",67,0)
 .I ARY("RAF")="" S:ERR="" ERR="Missing required receiving facility"
"RTN","HLTPCK2B",68,0)
 .I HL771RF]"" D  Q
"RTN","HLTPCK2B",69,0)
 ..;Facility data in 771 overrides data in site paramter file
"RTN","HLTPCK2B",70,0)
 ..Q
"RTN","HLTPCK2B",71,0)
 .;Check against local default value (site parameters)
"RTN","HLTPCK2B",72,0)
 .Q:ARY("RAF")=(HLINSTN_HLCS_HLDOM_HLCS_"DNS")
"RTN","HLTPCK2B",73,0)
 .;
"RTN","HLTPCK2B",74,0)
 .; patch HL*1.6*120 start
"RTN","HLTPCK2B",75,0)
 .; I $P(ARY("RAF"),HLCS)=HLINSTN,$P(ARY("RAF"),HLCS,3)="DNS" D  Q
"RTN","HLTPCK2B",76,0)
 . I $P(ARY("RAF"),HLCS,3)="DNS" D  Q
"RTN","HLTPCK2B",77,0)
 .. N ERROR,HLDOMP1,HLDOMP2
"RTN","HLTPCK2B",78,0)
 .. ; S HLDOMP1=$P(ARY("RAF"),HLCS,2),HLDOMP1=$$FIND1^DIC(4.2,"","BMX",HLDOMP1,"B^C","","ERROR")
"RTN","HLTPCK2B",79,0)
 .. S HLDOMP1=$P(ARY("RAF"),HLCS,2)
"RTN","HLTPCK2B",80,0)
 .. ;
"RTN","HLTPCK2B",81,0)
 .. ; assume the format is <domain>:<port #>
"RTN","HLTPCK2B",82,0)
 .. ; patch HL*1.6*163 can no longer assume one format for <domain><port> with IPV6
"RTN","HLTPCK2B",83,0)
 .. ; check for IPV6 address with delimiter of "]:" and process accordingly
"RTN","HLTPCK2B",84,0)
 .. ; ;$$FORCEIP6^XLFIPV(IP) API (ICR #5844)
"RTN","HLTPCK2B",85,0)
 .. I HLDOMP1["]" D 
"RTN","HLTPCK2B",86,0)
 ... S ARY("RAF-PORT")=$P(HLDOMP1,"]:",2)
"RTN","HLTPCK2B",87,0)
 ... S HLDOMP1=$E($P(HLDOMP1,"]"),2,99)
"RTN","HLTPCK2B",88,0)
 ... S HLDOMP1=$$FORCEIP6^XLFIPV(HLDOMP1)
"RTN","HLTPCK2B",89,0)
 .. E  I HLDOMP1[":" D
"RTN","HLTPCK2B",90,0)
 ...S ARY("RAF-PORT")=$P(HLDOMP1,":",2)
"RTN","HLTPCK2B",91,0)
 ...S HLDOMP1=$P(HLDOMP1,":")
"RTN","HLTPCK2B",92,0)
 ..S ARY("RAF-DOMAIN")=HLDOMP1
"RTN","HLTPCK2B",93,0)
 .. ;
"RTN","HLTPCK2B",94,0)
 .. ; if first piece of domain is "HL7." or "MPI.", remove it
"RTN","HLTPCK2B",95,0)
 .. I ($E(HLDOMP1,1,4)="HL7.")!($E(HLDOMP1,1,4)="MPI.") D
"RTN","HLTPCK2B",96,0)
 ... S HLDOMP1=$P(HLDOMP1,".",2,99)
"RTN","HLTPCK2B",97,0)
 .. S HLDOMP1=$$FIND1^DIC(4.2,"","BMX",HLDOMP1,"B^C","","ERROR")
"RTN","HLTPCK2B",98,0)
 .. S HLDOMP2=HLDOM,HLDOMP2=$$FIND1^DIC(4.2,"","BMX",HLDOMP2,"B^C","","ERROR")
"RTN","HLTPCK2B",99,0)
 .. I HLDOMP1&HLDOMP2&(HLDOMP1=HLDOMP2) Q
"RTN","HLTPCK2B",100,0)
 .. ;
"RTN","HLTPCK2B",101,0)
 .. ; check DNS domain and ip address
"RTN","HLTPCK2B",102,0)
 .. ;initialize variable, HLDOMP("FLAG")
"RTN","HLTPCK2B",103,0)
 .. S HLDOMP("FLAG")=0
"RTN","HLTPCK2B",104,0)
 .. I ARY("RAF-DOMAIN")]"" D
"RTN","HLTPCK2B",105,0)
 ... ;
"RTN","HLTPCK2B",106,0)
 ... ; match DNS domain
"RTN","HLTPCK2B",107,0)
 ... I $D(^HLCS(870,"DNS",ARY("RAF-DOMAIN"))) D  Q
"RTN","HLTPCK2B",108,0)
 .... S HLDOMP("FLAG")=1
"RTN","HLTPCK2B",109,0)
 .... S ARY("RAF-LL")=+$O(^HLCS(870,"DNS",ARY("RAF-DOMAIN"),0))
"RTN","HLTPCK2B",110,0)
 ... I $D(^HLCS(870,"DNS",$$UP^XLFSTR(ARY("RAF-DOMAIN")))) D  Q
"RTN","HLTPCK2B",111,0)
 .... S HLDOMP("FLAG")=1
"RTN","HLTPCK2B",112,0)
 .... S ARY("RAF-LL")=+$O(^HLCS(870,"DNS",$$UP^XLFSTR(ARY("RAF-DOMAIN")),0))
"RTN","HLTPCK2B",113,0)
 ... I $D(^HLCS(870,"DNS",$$LOW^XLFSTR(ARY("RAF-DOMAIN")))) D  Q
"RTN","HLTPCK2B",114,0)
 .... S HLDOMP("FLAG")=1
"RTN","HLTPCK2B",115,0)
 .... S ARY("RAF-LL")=+$O(^HLCS(870,"DNS",$$LOW^XLFSTR(ARY("RAF-DOMAIN")),0))
"RTN","HLTPCK2B",116,0)
 ... ;
"RTN","HLTPCK2B",117,0)
 ... ; match ip address
"RTN","HLTPCK2B",118,0)
 ... I $D(^HLCS(870,"IP",ARY("RAF-DOMAIN"))) D  Q
"RTN","HLTPCK2B",119,0)
 .... S HLDOMP("FLAG")=1
"RTN","HLTPCK2B",120,0)
 .... S ARY("RAF-LL")=+$O(^HLCS(870,"IP",ARY("RAF-DOMAIN"),0))
"RTN","HLTPCK2B",121,0)
 .. Q:HLDOMP("FLAG")=1
"RTN","HLTPCK2B",122,0)
 .. I $P(ARY("RAF"),HLCS)=HLINSTN Q
"RTN","HLTPCK2B",123,0)
 .. ;
"RTN","HLTPCK2B",124,0)
 .. ; patch HL*1.6*148
"RTN","HLTPCK2B",125,0)
 .. ; S:ERR="" ERR="Receiving Facility mismatch."
"RTN","HLTPCK2B",126,0)
 .. S:ERR="" ERR="Receiving Facility Mismatch."
"RTN","HLTPCK2B",127,0)
 . I $P(ARY("RAF"),HLCS)=HLINSTN Q
"RTN","HLTPCK2B",128,0)
 . ; patch HL*1.6*148
"RTN","HLTPCK2B",129,0)
 . ; S:ERR="" ERR="Receiving Facility mismatch."
"RTN","HLTPCK2B",130,0)
 . S:ERR="" ERR="Receiving facility mismatch."
"RTN","HLTPCK2B",131,0)
 ; patch HL*1.6*120 end
"RTN","HLTPCK2B",132,0)
 ;
"RTN","HLTPCK2B",133,0)
SF ;Validate Sending Facility
"RTN","HLTPCK2B",134,0)
 I HLSFREQ D 
"RTN","HLTPCK2B",135,0)
 .I ARY("SAF")="" S:ERR="" ERR="Missing required sending facility"
"RTN","HLTPCK2B",136,0)
 .I HL771SF]"" D  Q
"RTN","HLTPCK2B",137,0)
 ..;Check for facility data in 771
"RTN","HLTPCK2B",138,0)
 ..Q
"RTN","HLTPCK2B",139,0)
 .;If default value was sent, validate that DOMAIN RESOLVES TO LOGICAL LINK
"RTN","HLTPCK2B",140,0)
 .;If so, use this instead of Protocol definition for return path
"RTN","HLTPCK2B",141,0)
 .;
"RTN","HLTPCK2B",142,0)
 .; patch HL*1.6*120 start
"RTN","HLTPCK2B",143,0)
 . N HLDOMP
"RTN","HLTPCK2B",144,0)
 . ; S HLDOMP=$P(ARY("SAF"),HLCS,2),HLDOMP=$$FIND1^DIC(4.2,"","BMX",HLDOMP,"B^C","","ERROR")
"RTN","HLTPCK2B",145,0)
 . S HLDOMP=$P(ARY("SAF"),HLCS,2)
"RTN","HLTPCK2B",146,0)
 . ;
"RTN","HLTPCK2B",147,0)
 . ; assume the format is <domain>:<port #>
"RTN","HLTPCK2B",148,0)
 . ; patch HL*1.6*163 can no longer assume one format for <domain><port> with IPV6
"RTN","HLTPCK2B",149,0)
 . ; check for IPV6 address with delimiter of "]:" and process accordingly
"RTN","HLTPCK2B",150,0)
 . ; ;$$FORCEIP6^XLFIPV(IP) API (ICR #5844)
"RTN","HLTPCK2B",151,0)
 . I HLDOMP["]" D 
"RTN","HLTPCK2B",152,0)
 .. S ARY("SAF-PORT")=$P(HLDOMP,"]:",2)
"RTN","HLTPCK2B",153,0)
 .. S HLDOMP=$E($P(HLDOMP,"]"),2,99)
"RTN","HLTPCK2B",154,0)
 .. S HLDOMP=$$FORCEIP6^XLFIPV(HLDOMP)
"RTN","HLTPCK2B",155,0)
 . E  I HLDOMP[":" D 
"RTN","HLTPCK2B",156,0)
 .. S ARY("SAF-PORT")=$P(HLDOMP,":",2)
"RTN","HLTPCK2B",157,0)
 .. S HLDOMP=$P(HLDOMP,":")
"RTN","HLTPCK2B",158,0)
 . S ARY("SAF-DOMAIN")=HLDOMP
"RTN","HLTPCK2B",159,0)
 . ;
"RTN","HLTPCK2B",160,0)
 . ; if first piece of domain is "HL7." or "MPI.", remove it
"RTN","HLTPCK2B",161,0)
 . I ($E(HLDOMP,1,4)="HL7.")!($E(HLDOMP,1,4)="MPI.") D
"RTN","HLTPCK2B",162,0)
 .. S HLDOMP=$P(HLDOMP,".",2,99)
"RTN","HLTPCK2B",163,0)
 . S HLDOMP=$$FIND1^DIC(4.2,"","BMX",HLDOMP,"B^C","","ERROR")
"RTN","HLTPCK2B",164,0)
 .;Note: This expects a unique domain in domain file. Multiple entries will fail
"RTN","HLTPCK2B",165,0)
 . ; I 'HLDOMP S:ERR="" ERR="Unrecognized/ambiguous domain in sending facility"
"RTN","HLTPCK2B",166,0)
 . ;
"RTN","HLTPCK2B",167,0)
 . ; check DNS domain and ip address
"RTN","HLTPCK2B",168,0)
 . I 'HLDOMP D
"RTN","HLTPCK2B",169,0)
 .. ;
"RTN","HLTPCK2B",170,0)
 .. ;initialize variable, HLDOMP("FLAG")
"RTN","HLTPCK2B",171,0)
 .. S HLDOMP("FLAG")=0
"RTN","HLTPCK2B",172,0)
 .. I ARY("SAF-DOMAIN")]"" D
"RTN","HLTPCK2B",173,0)
 ... ;
"RTN","HLTPCK2B",174,0)
 ... ; match DNS domain
"RTN","HLTPCK2B",175,0)
 ... I $D(^HLCS(870,"DNS",ARY("SAF-DOMAIN"))) D  Q
"RTN","HLTPCK2B",176,0)
 .... S HLDOMP("FLAG")=1
"RTN","HLTPCK2B",177,0)
 .... S ARY("SAF-LL")=+$O(^HLCS(870,"DNS",ARY("SAF-DOMAIN"),0))
"RTN","HLTPCK2B",178,0)
 ... I $D(^HLCS(870,"DNS",$$UP^XLFSTR(ARY("SAF-DOMAIN")))) D  Q
"RTN","HLTPCK2B",179,0)
 .... S HLDOMP("FLAG")=1
"RTN","HLTPCK2B",180,0)
 .... S ARY("SAF-LL")=+$O(^HLCS(870,"DNS",$$UP^XLFSTR(ARY("SAF-DOMAIN")),0))
"RTN","HLTPCK2B",181,0)
 ... I $D(^HLCS(870,"DNS",$$LOW^XLFSTR(ARY("SAF-DOMAIN")))) D  Q
"RTN","HLTPCK2B",182,0)
 .... S HLDOMP("FLAG")=1
"RTN","HLTPCK2B",183,0)
 .... S ARY("SAF-LL")=+$O(^HLCS(870,"DNS",$$LOW^XLFSTR(ARY("SAF-DOMAIN")),0))
"RTN","HLTPCK2B",184,0)
 ... ;
"RTN","HLTPCK2B",185,0)
 ... ; match ip address
"RTN","HLTPCK2B",186,0)
 ... I $D(^HLCS(870,"IP",ARY("SAF-DOMAIN"))) D  Q
"RTN","HLTPCK2B",187,0)
 .... S HLDOMP("FLAG")=1
"RTN","HLTPCK2B",188,0)
 .... S ARY("SAF-LL")=+$O(^HLCS(870,"IP",ARY("SAF-DOMAIN"),0))
"RTN","HLTPCK2B",189,0)
 .. Q:HLDOMP("FLAG")=1
"RTN","HLTPCK2B",190,0)
 .. ; quit if 1st component defined
"RTN","HLTPCK2B",191,0)
 .. S ARY("SAF-COMPONENT1")=$P(ARY("SAF"),HLCS,1)
"RTN","HLTPCK2B",192,0)
 .. Q:ARY("SAF-COMPONENT1")]""
"RTN","HLTPCK2B",193,0)
 .. ; patch HL*1.6*148
"RTN","HLTPCK2B",194,0)
 .. ; S:ERR="" ERR="Receiving Facility mismatch."
"RTN","HLTPCK2B",195,0)
 .. S:ERR="" ERR="Sending Facility mismatch."
"RTN","HLTPCK2B",196,0)
 . ; patch HL*1.6*120 end
"RTN","HLTPCK2B",197,0)
 . ;
"RTN","HLTPCK2B",198,0)
 .Q:HLDOMP=$P(HLPARAM,U)  ;This is local app to app
"RTN","HLTPCK2B",199,0)
 .I HLDOMP N HLNK S HLNK=+$O(^HLCS(870,"D",HLDOMP,0))
"RTN","HLTPCK2B",200,0)
 .I $G(HLNK) S ARY("LL")=HLNK
"RTN","HLTPCK2B",201,0)
 ;
"RTN","HLTPCK2B",202,0)
PID ;Validate processing ID
"RTN","HLTPCK2B",203,0)
 I ("DTP"'[ARY("PID")) S:(ERR="") ERR="Invalid HL7 Processing ID"
"RTN","HLTPCK2B",204,0)
 S HLPID=$P(HLPARAM,U,3) ;site param
"RTN","HLTPCK2B",205,0)
 S X=$G(^ORD(101,ARY("EID"),770)),X=$P(X,U,6) ;event driver
"RTN","HLTPCK2B",206,0)
 ;If message is 'debug' then event driver must be 'debug.'
"RTN","HLTPCK2B",207,0)
 ;If message is 'test' or 'production', then site param must match
"RTN","HLTPCK2B",208,0)
 I ARY("PID")="D"&(X'="D") S:ERR="" ERR="Processing ID Mismatch with Event Driver"
"RTN","HLTPCK2B",209,0)
 I ARY("PID")'="D"&(HLPID'=ARY("PID")) S:ERR="" ERR="Processing ID Mismatch with Site Parameters"
"RTN","HLTPCK2B",210,0)
 ;
"RTN","HLTPCK2B",211,0)
SEC ;Validate security field - access code and electronic signature
"RTN","HLTPCK2B",212,0)
 I ($P($G(HLN(773)),"^",3)) D
"RTN","HLTPCK2B",213,0)
 .S X=$P($$P^HLTPCK2(.HDR,8),$E(ECH))
"RTN","HLTPCK2B",214,0)
 .S X=$$UPPER^HLFNC(X)
"RTN","HLTPCK2B",215,0)
 .D ^XUSHSH
"RTN","HLTPCK2B",216,0)
 .I X="",(MSA="") S:(ERR="") ERR="Invalid access code" Q
"RTN","HLTPCK2B",217,0)
 .S ARY("DUZ")=0
"RTN","HLTPCK2B",218,0)
 .S:(X'="") ARY("DUZ")=+$O(^VA(200,"A",X,0))
"RTN","HLTPCK2B",219,0)
 .I ('ARY("DUZ")) S:(ERR="") ERR="Invalid access code" Q
"RTN","HLTPCK2B",220,0)
 .I (($P($G(^VA(200,ARY("DUZ"),.1)),"^")="")&('$D(MSA))) S ARY("DUZ")=0 S:(ERR="") ERR="Invalid access code" Q
"RTN","HLTPCK2B",221,0)
 .S X=$P($$P^HLTPCK2(.HDR,8),$E(ECH),3) I (X'="") D
"RTN","HLTPCK2B",222,0)
 ..S X1=$G(^VA(200,ARY("DUZ"),20))
"RTN","HLTPCK2B",223,0)
 ..I (X1="") S:(ERR="") ERR="No Signature Code on File" Q
"RTN","HLTPCK2B",224,0)
 ..S X=$$UPPER^HLFNC(X)
"RTN","HLTPCK2B",225,0)
 ..D HASH^XUSHSHP
"RTN","HLTPCK2B",226,0)
 ..I ((X'=$P(X1,"^",4))!($P(X1,"^",2)="")) S:(ERR="") ERR="Invalid Electronic Signature Code" Q
"RTN","HLTPCK2B",227,0)
 ..S ARY("ESIG")=$P(X1,"^",2)
"RTN","HLTPCK2B",228,0)
 I $D(ARY) M HLREC=ARY
"RTN","HLTPCK2B",229,0)
 Q
"VER")
8.0^22.0
"^DD",870,870,400.01,0)
TCP/IP ADDRESS^F^^400;1^K:$L(X)>40!($L(X)<7) X
"^DD",870,870,400.01,3)
Answer must be 7-40 characters in length.
"^DD",870,870,400.01,21,0)
^^2^2^3150302^
"^DD",870,870,400.01,21,1,0)
Enter the IP address of the remote site using the syntax, 
"^DD",870,870,400.01,21,2,0)
nn.nn.nn.nn (IPV4) or hhhh:hhhh:hhhh:hhhh:hhhh:hhhh:hhhh:hhhh (IPV6)
"^DD",870,870,400.01,"DT")
3150302
"BLD",9734,6)
^129
**END**
**END**

