Released DG*5.3*975 SEQ #856
Extracted from mail message
**KIDS**:DG*5.3*975^

**INSTALL NAME**
DG*5.3*975
"BLD",11321,0)
DG*5.3*975^REGISTRATION^0^3181218^y
"BLD",11321,1,0)
^^3^3^3181218^
"BLD",11321,1,1,0)
Patch DG*5.3*975 fixes an issue where the old MSE (Military Service
"BLD",11321,1,2,0)
Episode) data is being deleted from an incoming ORFZ11 and new MSE data
"BLD",11321,1,3,0)
is not being stored.
"BLD",11321,4,0)
^9.64PA^^
"BLD",11321,6.3)
3
"BLD",11321,"ABPKG")
n
"BLD",11321,"KRN",0)
^9.67PA^1.61^23
"BLD",11321,"KRN",.4,0)
.4
"BLD",11321,"KRN",.401,0)
.401
"BLD",11321,"KRN",.402,0)
.402
"BLD",11321,"KRN",.403,0)
.403
"BLD",11321,"KRN",.5,0)
.5
"BLD",11321,"KRN",.84,0)
.84
"BLD",11321,"KRN",1.6,0)
1.6
"BLD",11321,"KRN",1.61,0)
1.61
"BLD",11321,"KRN",1.62,0)
1.62
"BLD",11321,"KRN",3.6,0)
3.6
"BLD",11321,"KRN",3.8,0)
3.8
"BLD",11321,"KRN",9.2,0)
9.2
"BLD",11321,"KRN",9.8,0)
9.8
"BLD",11321,"KRN",9.8,"NM",0)
^9.68A^1^1
"BLD",11321,"KRN",9.8,"NM",1,0)
DGENUPL1^^0^B62726769
"BLD",11321,"KRN",9.8,"NM","B","DGENUPL1",1)

"BLD",11321,"KRN",19,0)
19
"BLD",11321,"KRN",19.1,0)
19.1
"BLD",11321,"KRN",101,0)
101
"BLD",11321,"KRN",409.61,0)
409.61
"BLD",11321,"KRN",771,0)
771
"BLD",11321,"KRN",779.2,0)
779.2
"BLD",11321,"KRN",870,0)
870
"BLD",11321,"KRN",8989.51,0)
8989.51
"BLD",11321,"KRN",8989.52,0)
8989.52
"BLD",11321,"KRN",8994,0)
8994
"BLD",11321,"KRN","B",.4,.4)

"BLD",11321,"KRN","B",.401,.401)

"BLD",11321,"KRN","B",.402,.402)

"BLD",11321,"KRN","B",.403,.403)

"BLD",11321,"KRN","B",.5,.5)

"BLD",11321,"KRN","B",.84,.84)

"BLD",11321,"KRN","B",1.6,1.6)

"BLD",11321,"KRN","B",1.61,1.61)

"BLD",11321,"KRN","B",1.62,1.62)

"BLD",11321,"KRN","B",3.6,3.6)

"BLD",11321,"KRN","B",3.8,3.8)

"BLD",11321,"KRN","B",9.2,9.2)

"BLD",11321,"KRN","B",9.8,9.8)

"BLD",11321,"KRN","B",19,19)

"BLD",11321,"KRN","B",19.1,19.1)

"BLD",11321,"KRN","B",101,101)

"BLD",11321,"KRN","B",409.61,409.61)

"BLD",11321,"KRN","B",771,771)

"BLD",11321,"KRN","B",779.2,779.2)

"BLD",11321,"KRN","B",870,870)

"BLD",11321,"KRN","B",8989.51,8989.51)

"BLD",11321,"KRN","B",8989.52,8989.52)

"BLD",11321,"KRN","B",8994,8994)

"BLD",11321,"QDEF")
^^^^^^^^^^NO
"BLD",11321,"QUES",0)
^9.62^^
"BLD",11321,"REQB",0)
^9.611^1^1
"BLD",11321,"REQB",1,0)
DG*5.3*959^1
"BLD",11321,"REQB","B","DG*5.3*959",1)

"MBREQ")
0
"PKG",5,-1)
1^1
"PKG",5,0)
REGISTRATION^DG^PATIENT REGISTRATION, ADMISSION, DISCHARGE, EMBOSSER 
"PKG",5,22,0)
^9.49I^1^1
"PKG",5,22,1,0)
5.3^2930813
"PKG",5,22,1,"PAH",1,0)
975^3181218
"PKG",5,22,1,"PAH",1,1,0)
^^3^3^3181218
"PKG",5,22,1,"PAH",1,1,1,0)
Patch DG*5.3*975 fixes an issue where the old MSE (Military Service
"PKG",5,22,1,"PAH",1,1,2,0)
Episode) data is being deleted from an incoming ORFZ11 and new MSE data
"PKG",5,22,1,"PAH",1,1,3,0)
is not being stored.
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
NO
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
NO
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
NO
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
1
"RTN","DGENUPL1")
0^1^B62726769^B62801103
"RTN","DGENUPL1",1,0)
DGENUPL1 ;ALB/CJM,ISA,KWP,CKN,LBD,LMD,TDM,TGH,DJS - PROCESS INCOMING (Z11 EVENT TYPE) HL7 MESSAGES ;30 Oct 2017  7:32PM
"RTN","DGENUPL1",2,0)
 ;;5.3;REGISTRATION;**147,222,232,314,397,379,407,363,673,653,688,797,842,894,871,935,959,975**;Aug 13,1993;Build 3
"RTN","DGENUPL1",3,0)
 ;
"RTN","DGENUPL1",4,0)
PARSE(MSGIEN,MSGID,CURLINE,ERRCOUNT,DGPAT,DGELG,DGENR,DGCDIS,DGOEIF,DGSEC,DGNTR,DGMST,DGNMSE,DGHBP) ;
"RTN","DGENUPL1",5,0)
 ;
"RTN","DGENUPL1",6,0)
 ;Description:  This function parses the HL7 segments.  It creates arrays
"RTN","DGENUPL1",7,0)
 ;defined by the PATIENT, ENROLLMENT, ELIGIBILY, CATASTROPHIC DISABILITY,
"RTN","DGENUPL1",8,0)
 ;OEF/OIF CONFLICT objects.
"RTN","DGENUPL1",9,0)
 ;Field values are put in DHCP format and the validity at the
"RTN","DGENUPL1",10,0)
 ;field level is tested.  Fields to be deleted are set to "@".
"RTN","DGENUPL1",11,0)
 ;
"RTN","DGENUPL1",12,0)
 ;Input:
"RTN","DGENUPL1",13,0)
 ;  MSGIEN - the ien of the HL7 message in the HL7 MESSAGE TEXT file (772)
"RTN","DGENUPL1",14,0)
 ;  MSGID -message control id of HL7 msg in the MSH segment
"RTN","DGENUPL1",15,0)
 ;  CURLINE - the subscript of the PID segment of the current message (pass by reference)
"RTN","DGENUPL1",16,0)
 ;  ERRCOUNT - is a count of the number of messages in the batch that can not be processed (pass by ref)
"RTN","DGENUPL1",17,0)
 ;
"RTN","DGENUPL1",18,0)
 ;Output:
"RTN","DGENUPL1",19,0)
 ;  Function Value: Returns 1 on success, 0 on failure.
"RTN","DGENUPL1",20,0)
 ;  CURLINE - upon leaving the procedure this parameter should be set to the end of the current message.
"RTN","DGENUPL1",21,0)
 ;  ERRCOUNT - set to count of messages that were not processed due to errors encountered. (pass by ref)
"RTN","DGENUPL1",22,0)
 ;  DGPAT - array defined by the PATIENT object. (pass by ref)
"RTN","DGENUPL1",23,0)
 ;  DGENR - array defined by the PATIENT ENROLLMENT object. (pass by ref)
"RTN","DGENUPL1",24,0)
 ;  DGELG - array defined by the PATIENT ELIGIBILITY object. (pass by ref)
"RTN","DGENUPL1",25,0)
 ;  DGCDIS - array defined by the CATASTROPHIC DISABILITY object. (pass by ref)
"RTN","DGENUPL1",26,0)
 ;  DGSEC - array defined by the PATIENT SECURITY object. (pass by ref)
"RTN","DGENUPL1",27,0)
 ;  DGOEIF - array defined by the OEF/OIF CONFLICT object.  (pass by ref)
"RTN","DGENUPL1",28,0)
 ;  DGNTR - array defined for NTR data.
"RTN","DGENUPL1",29,0)
 ;  DGMST - array defined for MST data.
"RTN","DGENUPL1",30,0)
 ;  DGNMSE - array define for MILITARY SERVICE EPISODE data (pass by ref)
"RTN","DGENUPL1",31,0)
 ;  DGHBP - array define for HEALTH BENEFIT PLAN data (pass by ref) DG*5.3*871
"RTN","DGENUPL1",32,0)
 ;
"RTN","DGENUPL1",33,0)
 N SEG,ERROR,COUNT,QFLG,NFLG
"RTN","DGENUPL1",34,0)
 ;
"RTN","DGENUPL1",35,0)
 ;DJS, Set TMP global to track the presence of ZMH segment; DG*5.3*935
"RTN","DGENUPL1",36,0)
 K ^TMP($J,"DGENUPL") S ^TMP($J,"DGENUPL","ZMH",0)=0
"RTN","DGENUPL1",37,0)
 ;
"RTN","DGENUPL1",38,0)
 K DGEN,DGPAT,DGELG,DGCDIS,DGNTR,DGMST
"RTN","DGENUPL1",39,0)
 ;
"RTN","DGENUPL1",40,0)
 S ERROR=0,NFLG=1
"RTN","DGENUPL1",41,0)
 F SEG="PID","ZPD","ZIE","ZIO","ZEL"  D  Q:ERROR
"RTN","DGENUPL1",42,0)
 .D:NFLG NXTSEG^DGENUPL(MSGIEN,.CURLINE,.SEG)
"RTN","DGENUPL1",43,0)
 .I SEG="ZIO",SEG("TYPE")'="ZIO" S NFLG=0 Q
"RTN","DGENUPL1",44,0)
 .I SEG("TYPE")=SEG D  Q
"RTN","DGENUPL1",45,0)
 ..I SEG'="ZEL" N DGRTN S DGRTN=SEG_"^DGENUPL2" D @DGRTN      ; DG*5.3*894
"RTN","DGENUPL1",46,0)
 ..D:(SEG="ZEL") ZEL^DGENUPL2(1)
"RTN","DGENUPL1",47,0)
 ..S NFLG=1
"RTN","DGENUPL1",48,0)
 .D ADDERROR^DGENUPL(MSGID,$G(DGPAT("SSN")),SEG_" SEGMENT MISSING OR OUT OF ORDER",.ERRCOUNT)
"RTN","DGENUPL1",49,0)
 .S ERROR=1
"RTN","DGENUPL1",50,0)
 .;
"RTN","DGENUPL1",51,0)
 .;possible that in a bad message we are now past the end
"RTN","DGENUPL1",52,0)
 .S CURLINE=CURLINE-1
"RTN","DGENUPL1",53,0)
 ;
"RTN","DGENUPL1",54,0)
 ;DJS, Set segment before processing possible multiple segments; DG*5.3*935
"RTN","DGENUPL1",55,0)
 I 'ERROR S SEG="ZEL" F COUNT=2:1 D NXTSEG^DGENUPL(MSGIEN,CURLINE,.SEG) Q:(SEG("TYPE")'="ZEL")  D  Q:ERROR
"RTN","DGENUPL1",56,0)
 .S CURLINE=CURLINE+1
"RTN","DGENUPL1",57,0)
 .D ZEL^DGENUPL2(COUNT)
"RTN","DGENUPL1",58,0)
 ;
"RTN","DGENUPL1",59,0)
 ;ZE2 is optional, If no ZE2 segment delete pension data
"RTN","DGENUPL1",60,0)
 I 'ERROR D
"RTN","DGENUPL1",61,0)
 .I SEG("TYPE")="ZE2" D ZE2^DGENUPLB S CURLINE=CURLINE+1 Q
"RTN","DGENUPL1",62,0)
 .I SEG("TYPE")'="ZE2" D
"RTN","DGENUPL1",63,0)
 ..Q:$$GET1^DIQ(2,DFN,.3852,"I")=$O(^DG(27.18,"C","00",""))
"RTN","DGENUPL1",64,0)
 ..N PSUB
"RTN","DGENUPL1",65,0)
 ..F PSUB="PENAEFDT","PENTRMDT","PENAREAS","PENTRMR1","PENTRMR2","PENTRMR3","PENTRMR4" S DGPAT(PSUB)="@"
"RTN","DGENUPL1",66,0)
 ;
"RTN","DGENUPL1",67,0)
 ;ZHP is optional & can repeat. DG*5.3*871
"RTN","DGENUPL1",68,0)
 K DGHBP
"RTN","DGENUPL1",69,0)
 ;DJS, Added call to extrinsic function to determine if multiple segments are present ; DG*5.3*935
"RTN","DGENUPL1",70,0)
 I 'ERROR S SEG="ZHP" I $$CHKNXT(CURLINE+1,SEG) D  Q:ERROR $S(ERROR:0,1:1)
"RTN","DGENUPL1",71,0)
 . D NXTSEG^DGENUPL(MSGIEN,.CURLINE,.SEG)
"RTN","DGENUPL1",72,0)
 . S QFLG=0 F  D  Q:QFLG
"RTN","DGENUPL1",73,0)
 . . I SEG("TYPE")'="ZHP" S QFLG=1,CURLINE=CURLINE-1 Q
"RTN","DGENUPL1",74,0)
 . . D ZHP^DGENUPLB
"RTN","DGENUPL1",75,0)
 . . D NXTSEG^DGENUPL(MSGIEN,.CURLINE,.SEG)
"RTN","DGENUPL1",76,0)
 ;
"RTN","DGENUPL1",77,0)
 ;Phase II Add the capability to accept more than 1 ZCD
"RTN","DGENUPL1",78,0)
 I 'ERROR F SEG="ZEN","ZMT","ZCD" D  Q:ERROR
"RTN","DGENUPL1",79,0)
 .D NXTSEG^DGENUPL(MSGIEN,.CURLINE,.SEG)
"RTN","DGENUPL1",80,0)
 .I SEG("TYPE")=SEG D
"RTN","DGENUPL1",81,0)
 ..N DGRTN S DGRTN=SEG_"^DGENUPL2" D @DGRTN     ; DG*5.3*894
"RTN","DGENUPL1",82,0)
 .E  D
"RTN","DGENUPL1",83,0)
 ..D ADDERROR^DGENUPL(MSGID,$G(DGPAT("SSN")),SEG_" SEGMENT MISSING OR OUT OF ORDER",.ERRCOUNT)
"RTN","DGENUPL1",84,0)
 ..S ERROR=1
"RTN","DGENUPL1",85,0)
 ..;
"RTN","DGENUPL1",86,0)
 ..;possible that in a bad message we are now past the end
"RTN","DGENUPL1",87,0)
 ..S CURLINE=CURLINE-1
"RTN","DGENUPL1",88,0)
 ;
"RTN","DGENUPL1",89,0)
 ;DJS, Added call to extrinsic function to determine if multiple segments are present ; DG*5.3*935
"RTN","DGENUPL1",90,0)
 I 'ERROR S SEG="ZCD" I $$CHKNXT(CURLINE+1,SEG) F COUNT=2:1 D NXTSEG^DGENUPL(MSGIEN,CURLINE,.SEG) Q:(SEG("TYPE")'="ZCD")  D  Q:ERROR
"RTN","DGENUPL1",91,0)
 .S CURLINE=CURLINE+1
"RTN","DGENUPL1",92,0)
 .D ZCD^DGENUPL2
"RTN","DGENUPL1",93,0)
 ;
"RTN","DGENUPL1",94,0)
 ; Purple Heart/OEF-OIF  Addition of optional ZMH segment
"RTN","DGENUPL1",95,0)
 ;              Modified handling of ZSP and ZRD to accomodate ZMH
"RTN","DGENUPL1",96,0)
 ;
"RTN","DGENUPL1",97,0)
 ;DJS, Added call to extrinsic function to determine if multiple segments are present ; DG*5.3*935
"RTN","DGENUPL1",98,0)
 I 'ERROR S SEG="ZSP" I $$CHKNXT(CURLINE+1,SEG) D  Q:ERROR $S(ERROR:0,1:1)
"RTN","DGENUPL1",99,0)
 .D NXTSEG^DGENUPL(MSGIEN,.CURLINE,.SEG)
"RTN","DGENUPL1",100,0)
 .I SEG("TYPE")="ZSP" D ZSP^DGENUPL2 Q
"RTN","DGENUPL1",101,0)
 .D ADDERROR^DGENUPL(MSGID,$G(DGPAT("SSN")),SEG_" SEGMENT MISSING OR OUT OF ORDER",.ERRCOUNT)
"RTN","DGENUPL1",102,0)
 .S ERROR=1
"RTN","DGENUPL1",103,0)
 .;possible that in a bad message we are now past the end
"RTN","DGENUPL1",104,0)
 .S CURLINE=CURLINE-1
"RTN","DGENUPL1",105,0)
 ;
"RTN","DGENUPL1",106,0)
 ;Modified following code to receive multiple ZMH segment for
"RTN","DGENUPL1",107,0)
 ;Military service information - DG*5.3*653
"RTN","DGENUPL1",108,0)
 ;
"RTN","DGENUPL1",109,0)
 ;DJS, Check for no MSE ZMH segments present and non-MSE ZMH segments ; DG*5.3*959
"RTN","DGENUPL1",110,0)
 I 'ERROR S SEG="ZMH" D  Q:ERROR
"RTN","DGENUPL1",111,0)
 .N SEGNAM,MSECNT,CURLN,MHSTYP,NONMSE,SGMNT S SEGNAM="",(MSECNT,NONMSE)=0,CURLN=CURLINE
"RTN","DGENUPL1",112,0)
 .F  S CURLN=$O(^TMP($J,IVMRTN,CURLN)) Q:'CURLN  D
"RTN","DGENUPL1",113,0)
 ..S SGMNT=$G(^TMP($J,IVMRTN,CURLN,0)),SEGNAM=$P($G(SGMNT),U) Q:SEGNAM'="ZMH"  S MHSTYP=$P($G(SGMNT),U,3)
"RTN","DGENUPL1",114,0)
 ..I "^SL^SNL^SNNL^MSD^FDD^"[("^"_MHSTYP_"^") S MSECNT=MSECNT+1 Q
"RTN","DGENUPL1",115,0)
 ..E  S NONMSE=NONMSE+1 Q  ;ZMH segment present, but not an MSE
"RTN","DGENUPL1",116,0)
 .;DJS, No MSE-type ZMH segment present, so branch to DGNOZMH to kill HEC-owned MSEs; DG*5.3*935
"RTN","DGENUPL1",117,0)
 .I MSECNT=0 I ^TMP($J,"DGENUPL","ZMH",0)=0 D EN^DGNOZMH(DFN) K ^TMP($J,"DGENUPL")
"RTN","DGENUPL1",118,0)
 .Q:('NONMSE&('MSECNT))
"RTN","DGENUPL1",119,0)
 .;DJS, Added call to extrinsic function to determine if multiple segments are present ; DG*5.3*935
"RTN","DGENUPL1",120,0)
 .S QFLG=0 F  D  Q:QFLG!(ERROR)
"RTN","DGENUPL1",121,0)
 ..I '$$CHKNXT(CURLINE+1,SEG) S QFLG=1 Q
"RTN","DGENUPL1",122,0)
 ..D NXTSEG^DGENUPL(MSGIEN,.CURLINE,.SEG) ;process any ZMH segments that are present in Z11
"RTN","DGENUPL1",123,0)
 ..D ZMH^DGENUPL2
"RTN","DGENUPL1",124,0)
 ;
"RTN","DGENUPL1",125,0)
 ;DJS, Added call to extrinsic function to determine if multiple segments are present ; DG*5.3*935
"RTN","DGENUPL1",126,0)
 I 'ERROR S SEG="ZRD" I $$CHKNXT(CURLINE+1,SEG) F COUNT=2:1 D NXTSEG^DGENUPL(MSGIEN,CURLINE,.SEG) Q:(SEG("TYPE")'="ZRD")  D  Q:ERROR
"RTN","DGENUPL1",127,0)
 .S CURLINE=CURLINE+1
"RTN","DGENUPL1",128,0)
 .D ZRD^DGENUPL2
"RTN","DGENUPL1",129,0)
 ;
"RTN","DGENUPL1",130,0)
 ;DJS, Added call to extrinsic function to determine if multiple segments are present ; DG*5.3*935
"RTN","DGENUPL1",131,0)
 I 'ERROR S SEG="OBX" F  D  Q:(ERROR!('$$CHKNXT(CURLINE+1,SEG)))
"RTN","DGENUPL1",132,0)
 .;possible if OBX segment not present that we are now past the end
"RTN","DGENUPL1",133,0)
 .Q:'$$CHKNXT(CURLINE+1,SEG)
"RTN","DGENUPL1",134,0)
 .D NXTSEG^DGENUPL(MSGIEN,.CURLINE,.SEG)
"RTN","DGENUPL1",135,0)
 .D OBX^DGENUPL2
"RTN","DGENUPL1",136,0)
 .Q
"RTN","DGENUPL1",137,0)
 ;
"RTN","DGENUPL1",138,0)
 K ^TMP($J,"DGENUPL")
"RTN","DGENUPL1",139,0)
 Q $S(ERROR:0,1:1)
"RTN","DGENUPL1",140,0)
 ;
"RTN","DGENUPL1",141,0)
CONVERT(VAL,DATATYPE,ERROR) ;
"RTN","DGENUPL1",142,0)
 ;Description: Converts the value found in the HL7 segment to DHCP format
"RTN","DGENUPL1",143,0)
 ;
"RTN","DGENUPL1",144,0)
 ;Input:
"RTN","DGENUPL1",145,0)
 ;  VAL - value parsed from the HL7 segment
"RTN","DGENUPL1",146,0)
 ;  DATATYPE: indicates the type of conversion necessary
"RTN","DGENUPL1",147,0)
 ;      "DATE" - needs to be converted to FM format
"RTN","DGENUPL1",148,0)
 ;      "TS" - time stamp, needs to be converted to FM format
"RTN","DGENUPL1",149,0)
 ;      "Y/N" - 0->"N",1->"Y"
"RTN","DGENUPL1",150,0)
 ;      "1/0" - "Y"->1,"N"->0
"RTN","DGENUPL1",151,0)
 ;      "INSTITUTION" - needs to convert the station number with suffix to a point to the INSTITUTION file
"RTN","DGENUPL1",152,0)
 ;      "ELIGIBILITY" - VAL is a pointer to the national eligibility code file (#8.1), needs to be converted to a local eligibility code (file #8)
"RTN","DGENUPL1",153,0)
 ;
"RTN","DGENUPL1",154,0)
 ;      "MT" - VAL  is a Means Test Status code, it needs to be converted
"RTN","DGENUPL1",155,0)
 ;             to a pointer to the Means Test Status file
"RTN","DGENUPL1",156,0)
 ;       Phase II convert code to RSN IEN for DGCDIS object
"RTN","DGENUPL1",157,0)
 ;       "CDRSN" data type converts the codes diagnosis,procedure,condition to RSN IEN. (HL7TORSN^DGENA5)
"RTN","DGENUPL1",158,0)
 ;       "CDDSCR" data type converts the codes descriptor(s) to DSCR IEN. (HL7TODSC^DGENA5)   DG*5.3*894
"RTN","DGENUPL1",159,0)
 ;       "EXT" convert from code to abbreviation
"RTN","DGENUPL1",160,0)
 ;       "POS" convert from Period of Service code to a point to Period of Service file
"RTN","DGENUPL1",161,0)
 ;       "AGENCY" convert Agency/Allied Country code from file 35
"RTN","DGENUPL1",162,0)
 ;       "PENSIONCD" convert Pension Award/Termination Reason code from file 27.18
"RTN","DGENUPL1",163,0)
 ;       "HBP" convert from code to file 25.11 ien DG*5.3*871
"RTN","DGENUPL1",164,0)
 ;OUTPUT:
"RTN","DGENUPL1",165,0)
 ;  Function Value - the result of the conversion
"RTN","DGENUPL1",166,0)
 ;  ERROR - set to 1 if an error is detected, 0 otherwise (optional,pass by ref)
"RTN","DGENUPL1",167,0)
 S ERROR=0
"RTN","DGENUPL1",168,0)
 D
"RTN","DGENUPL1",169,0)
 .I VAL="" Q
"RTN","DGENUPL1",170,0)
 .I VAL="""""" S VAL="@" Q
"RTN","DGENUPL1",171,0)
 .I $G(DATATYPE)="EXT" D  Q
"RTN","DGENUPL1",172,0)
 ..S VAL=$$HLTOLIMB^DGENA5(VAL)
"RTN","DGENUPL1",173,0)
 .I $G(DATATYPE)="CDRSN" D  Q
"RTN","DGENUPL1",174,0)
 ..S VAL=$$HL7TORSN^DGENA5(VAL)
"RTN","DGENUPL1",175,0)
 .; * check the new DESCRIPTOR seq  -  DG*5.3*894
"RTN","DGENUPL1",176,0)
 .I $G(DATATYPE)="CDDSCR" D  Q
"RTN","DGENUPL1",177,0)
 ..S VAL=$$HL7TODSC^DGENA5(VAL)
"RTN","DGENUPL1",178,0)
 .I ($G(DATATYPE)="MT") D  Q
"RTN","DGENUPL1",179,0)
 ..S VAL=$O(^DG(408.32,"AC",1,VAL,0))
"RTN","DGENUPL1",180,0)
 ..I 'VAL S ERROR=1
"RTN","DGENUPL1",181,0)
 .I ($G(DATATYPE)="DATE") D  Q
"RTN","DGENUPL1",182,0)
 ..I $L(VAL)'=8 S ERROR=1 Q
"RTN","DGENUPL1",183,0)
 ..S VAL=$$FMDATE^HLFNC(VAL)
"RTN","DGENUPL1",184,0)
 ..I ((VAL'=+VAL)!($L($P(VAL,"."))<7)) S ERROR=1
"RTN","DGENUPL1",185,0)
 .I ($G(DATATYPE)="TS") D  Q
"RTN","DGENUPL1",186,0)
 ..I $L(VAL)<8 S ERROR=1 Q
"RTN","DGENUPL1",187,0)
 ..S VAL=$$FMDATE^HLFNC(VAL)
"RTN","DGENUPL1",188,0)
 ..I ((VAL'=+VAL)!($L($P(VAL,"."))<7)) S ERROR=1
"RTN","DGENUPL1",189,0)
 .I ($G(DATATYPE)="Y/N") D  Q
"RTN","DGENUPL1",190,0)
 ..I VAL=0 S VAL="N" Q
"RTN","DGENUPL1",191,0)
 ..I VAL=1 S VAL="Y" Q
"RTN","DGENUPL1",192,0)
 ..S ERROR=1
"RTN","DGENUPL1",193,0)
 .I ($G(DATATYPE)="1/0") D  Q
"RTN","DGENUPL1",194,0)
 ..I VAL="N" S VAL=0 Q
"RTN","DGENUPL1",195,0)
 ..I VAL="Y" S VAL=1 Q
"RTN","DGENUPL1",196,0)
 ..S ERROR=1
"RTN","DGENUPL1",197,0)
 .I ($G(DATATYPE)="ELIGIBILITY") D  Q
"RTN","DGENUPL1",198,0)
 ..S VAL=$$MAP(VAL)
"RTN","DGENUPL1",199,0)
 ..I 'VAL S ERROR=1
"RTN","DGENUPL1",200,0)
 .I ($G(DATATYPE)="INSTITUTION") D  Q
"RTN","DGENUPL1",201,0)
 ..N OLDVAL
"RTN","DGENUPL1",202,0)
 ..S OLDVAL=VAL
"RTN","DGENUPL1",203,0)
 ..S VAL=$O(^DIC(4,"D",OLDVAL,0))
"RTN","DGENUPL1",204,0)
 ..I 'VAL S VAL=$O(^DIC(4,"D",(+OLDVAL),0))
"RTN","DGENUPL1",205,0)
 ..I 'VAL S ERROR=1
"RTN","DGENUPL1",206,0)
 .I ($G(DATATYPE)="POS") D  Q
"RTN","DGENUPL1",207,0)
 ..N OLDVAL
"RTN","DGENUPL1",208,0)
 ..S OLDVAL=VAL
"RTN","DGENUPL1",209,0)
 ..S VAL=$O(^DIC(21,"D",OLDVAL,0))
"RTN","DGENUPL1",210,0)
 ..I 'VAL S ERROR=1
"RTN","DGENUPL1",211,0)
 .I ($G(DATATYPE)="AGENCY") D  Q
"RTN","DGENUPL1",212,0)
 ..N OLDVAL
"RTN","DGENUPL1",213,0)
 ..S OLDVAL=VAL
"RTN","DGENUPL1",214,0)
 ..S VAL=$O(^DIC(35,"C",OLDVAL,0))
"RTN","DGENUPL1",215,0)
 ..I 'VAL S ERROR=1
"RTN","DGENUPL1",216,0)
 .I ($G(DATATYPE)="PENSIONCD") D  Q
"RTN","DGENUPL1",217,0)
 ..N OLDVAL
"RTN","DGENUPL1",218,0)
 ..S OLDVAL=VAL
"RTN","DGENUPL1",219,0)
 ..S VAL=$O(^DG(27.18,"C",OLDVAL,0))
"RTN","DGENUPL1",220,0)
 ..I 'VAL S ERROR=1
"RTN","DGENUPL1",221,0)
 .I ($G(DATATYPE)="HBP") D  Q    ; DG*5.3*871
"RTN","DGENUPL1",222,0)
 ..N OLDVAL
"RTN","DGENUPL1",223,0)
 ..S OLDVAL=VAL
"RTN","DGENUPL1",224,0)
 ..S VAL=$O(^DGHBP(25.11,"C",OLDVAL,0))
"RTN","DGENUPL1",225,0)
 ..I 'VAL S ERROR=1
"RTN","DGENUPL1",226,0)
 Q VAL
"RTN","DGENUPL1",227,0)
 ;
"RTN","DGENUPL1",228,0)
MAP(VALUE) ;
"RTN","DGENUPL1",229,0)
 ;Description: Tries to map an eligibility code from file #8.1 (the national MAS ELIGIBILITY CODE file) to file #8 (the local ELIGIBILITY CODE file)
"RTN","DGENUPL1",230,0)
 ;
"RTN","DGENUPL1",231,0)
 ;Input: VALUE - ien of an entry in file #8.1
"RTN","DGENUPL1",232,0)
 ;
"RTN","DGENUPL1",233,0)
 ;Output: Function value - NULL if mapping is not found, otherwise returns an ien of entry in file #8
"RTN","DGENUPL1",234,0)
 ;
"RTN","DGENUPL1",235,0)
 N ECODE,NODE,COUNT,NAME
"RTN","DGENUPL1",236,0)
 ;try to choose a code from file 8 to use that is appropriate
"RTN","DGENUPL1",237,0)
 S (COUNT,ECODE)=0
"RTN","DGENUPL1",238,0)
 ;
"RTN","DGENUPL1",239,0)
 F  S ECODE=$O(^DIC(8,"D",VALUE,ECODE)) Q:'ECODE  D
"RTN","DGENUPL1",240,0)
 .S NODE=$G(^DIC(8,ECODE,0))
"RTN","DGENUPL1",241,0)
 .;put code on list if active
"RTN","DGENUPL1",242,0)
 .I (NODE'=""),'$P(NODE,"^",7) S ECODE(ECODE)=$P(NODE,"^"),COUNT=COUNT+1
"RTN","DGENUPL1",243,0)
 ;
"RTN","DGENUPL1",244,0)
 ;only one match found, so use it
"RTN","DGENUPL1",245,0)
 Q:COUNT=1 $O(ECODE(0))
"RTN","DGENUPL1",246,0)
 ;
"RTN","DGENUPL1",247,0)
 ;no match found
"RTN","DGENUPL1",248,0)
 Q:'COUNT ""
"RTN","DGENUPL1",249,0)
 ;
"RTN","DGENUPL1",250,0)
 ;multiple matches found, try to match by name
"RTN","DGENUPL1",251,0)
 I COUNT>1 D
"RTN","DGENUPL1",252,0)
 .S ECODE=0
"RTN","DGENUPL1",253,0)
 .S NAME=$P($G(^DIC(8.1,VALUE,0)),"^")
"RTN","DGENUPL1",254,0)
 .F  S ECODE=$O(ECODE(ECODE)) Q:'ECODE  Q:ECODE(ECODE)=NAME
"RTN","DGENUPL1",255,0)
 Q ECODE
"RTN","DGENUPL1",256,0)
 ;
"RTN","DGENUPL1",257,0)
ACCEPT(MSGID) ;
"RTN","DGENUPL1",258,0)
 ;Description: Writes an ack (AA) to a global to be transmitted later.
"RTN","DGENUPL1",259,0)
 ;
"RTN","DGENUPL1",260,0)
 ;Inputs:
"RTN","DGENUPL1",261,0)
 ;  MSGID -message control id of HL7 msg in the MSH segment
"RTN","DGENUPL1",262,0)
 ;
"RTN","DGENUPL1",263,0)
 ;Outputs: none
"RTN","DGENUPL1",264,0)
 ;
"RTN","DGENUPL1",265,0)
 K HL,HLMID,HLMTIEN,HLDT,HLDT1
"RTN","DGENUPL1",266,0)
 D INIT^HLFNC2(HLEID,.HL)
"RTN","DGENUPL1",267,0)
 D CREATE^HLTF(.HLMID,.HLMTIEN,.HLDT,.HLDT1)
"RTN","DGENUPL1",268,0)
 S HLEVN=1
"RTN","DGENUPL1",269,0)
 S MID=HLMID_"-"_HLEVN
"RTN","DGENUPL1",270,0)
 D MSH^HLFNC2(.HL,MID,.HLRES)
"RTN","DGENUPL1",271,0)
 S ^TMP("HLS",$J,1)=HLRES
"RTN","DGENUPL1",272,0)
 ;
"RTN","DGENUPL1",273,0)
 ;it seems HLFS sometimes disappears upon reaching this point
"RTN","DGENUPL1",274,0)
 I $G(HLFS)="" S HLFS="^"
"RTN","DGENUPL1",275,0)
 ;
"RTN","DGENUPL1",276,0)
 S ^TMP("HLS",$J,2)="MSA"_HLFS_"AA"_HLFS_MSGID
"RTN","DGENUPL1",277,0)
 Q
"RTN","DGENUPL1",278,0)
 ;
"RTN","DGENUPL1",279,0)
MVERRORS ;
"RTN","DGENUPL1",280,0)
 ;Error messages were being deleted from ^TMP("HLS",$J by another package
"RTN","DGENUPL1",281,0)
 ;during the upload.  To fix this, errors are written to another
"RTN","DGENUPL1",282,0)
 ;subscript, then moved when the error list is complete.
"RTN","DGENUPL1",283,0)
 ;
"RTN","DGENUPL1",284,0)
 M ^TMP("HLS",$J)=^TMP("IVM","HLS",$J)
"RTN","DGENUPL1",285,0)
 K ^TMP("IVM","HLS",$J)
"RTN","DGENUPL1",286,0)
 Q
"RTN","DGENUPL1",287,0)
 ;
"RTN","DGENUPL1",288,0)
 ;DJS, Added Extrinsic Function to determine if multiple segments are present ; DG*5.3*935
"RTN","DGENUPL1",289,0)
CHKNXT(DGNVAL,DGNSEG) ; Check the SEG in the next segment manually
"RTN","DGENUPL1",290,0)
 ; DGNVAL = CURLINE or CURLINE+1
"RTN","DGENUPL1",291,0)
 ; DGNSEG = SEG (3 character SEG)
"RTN","DGENUPL1",292,0)
 ; Returns 1 if there is a match or 0 if there is no match
"RTN","DGENUPL1",293,0)
 ;
"RTN","DGENUPL1",294,0)
 Q $S($E($G(^TMP($J,IVMRTN,+DGNVAL,0)),1,3)=DGNSEG:1,1:0)
"VER")
8.0^22.2
"BLD",11321,6)
^856
**END**
**END**

