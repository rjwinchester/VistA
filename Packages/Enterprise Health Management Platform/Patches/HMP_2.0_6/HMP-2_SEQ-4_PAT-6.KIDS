EMERGENCY Released HMP*2*6 SEQ #4
Extracted from mail message
**KIDS**:HMP*2.0*6^

**INSTALL NAME**
HMP*2.0*6
"BLD",9710,0)
HMP*2.0*6^HEALTH MANAGEMENT PLATFORM^0^3160915^y
"BLD",9710,4,0)
^9.64PA^^
"BLD",9710,6.3)
3
"BLD",9710,"ABPKG")
n
"BLD",9710,"KRN",0)
^9.67PA^779.2^20
"BLD",9710,"KRN",.4,0)
.4
"BLD",9710,"KRN",.401,0)
.401
"BLD",9710,"KRN",.402,0)
.402
"BLD",9710,"KRN",.403,0)
.403
"BLD",9710,"KRN",.5,0)
.5
"BLD",9710,"KRN",.84,0)
.84
"BLD",9710,"KRN",3.6,0)
3.6
"BLD",9710,"KRN",3.8,0)
3.8
"BLD",9710,"KRN",9.2,0)
9.2
"BLD",9710,"KRN",9.8,0)
9.8
"BLD",9710,"KRN",9.8,"NM",0)
^9.68A^1^1
"BLD",9710,"KRN",9.8,"NM",1,0)
HMPUTIL1^^0^B46959310
"BLD",9710,"KRN",9.8,"NM","B","HMPUTIL1",1)

"BLD",9710,"KRN",19,0)
19
"BLD",9710,"KRN",19.1,0)
19.1
"BLD",9710,"KRN",101,0)
101
"BLD",9710,"KRN",409.61,0)
409.61
"BLD",9710,"KRN",771,0)
771
"BLD",9710,"KRN",779.2,0)
779.2
"BLD",9710,"KRN",870,0)
870
"BLD",9710,"KRN",8989.51,0)
8989.51
"BLD",9710,"KRN",8989.52,0)
8989.52
"BLD",9710,"KRN",8994,0)
8994
"BLD",9710,"KRN","B",.4,.4)

"BLD",9710,"KRN","B",.401,.401)

"BLD",9710,"KRN","B",.402,.402)

"BLD",9710,"KRN","B",.403,.403)

"BLD",9710,"KRN","B",.5,.5)

"BLD",9710,"KRN","B",.84,.84)

"BLD",9710,"KRN","B",3.6,3.6)

"BLD",9710,"KRN","B",3.8,3.8)

"BLD",9710,"KRN","B",9.2,9.2)

"BLD",9710,"KRN","B",9.8,9.8)

"BLD",9710,"KRN","B",19,19)

"BLD",9710,"KRN","B",19.1,19.1)

"BLD",9710,"KRN","B",101,101)

"BLD",9710,"KRN","B",409.61,409.61)

"BLD",9710,"KRN","B",771,771)

"BLD",9710,"KRN","B",779.2,779.2)

"BLD",9710,"KRN","B",870,870)

"BLD",9710,"KRN","B",8989.51,8989.51)

"BLD",9710,"KRN","B",8989.52,8989.52)

"BLD",9710,"KRN","B",8994,8994)

"BLD",9710,"QDEF")
^^^^NO^^^^NO^^NO
"BLD",9710,"QUES",0)
^9.62^^
"BLD",9710,"REQB",0)
^9.611^1^1
"BLD",9710,"REQB",1,0)
HMP*2.0*1^2
"BLD",9710,"REQB","B","HMP*2.0*1",1)

"MBREQ")
0
"PKG",578,-1)
1^1
"PKG",578,0)
HEALTH MANAGEMENT PLATFORM^HMP^Access patient medical records from all VistA's
"PKG",578,20,0)
^9.402P^^
"PKG",578,22,0)
^9.49I^1^1
"PKG",578,22,1,0)
2.0^3160223^3160909^1
"PKG",578,22,1,"PAH",1,0)
6^3160915
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
NO
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
NO
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
NO
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
1
"RTN","HMPUTIL1")
0^1^B46959310^B46934983
"RTN","HMPUTIL1",1,0)
HMPUTIL1 ;SLC/AGP,ASMR/RRB,CPC - HMP utilities routine ;May 15, 2016 14:15
"RTN","HMPUTIL1",2,0)
 ;;2.0;ENTERPRISE HEALTH MANAGEMENT PLATFORM;**1,6**;May 15, 2016;Build 3
"RTN","HMPUTIL1",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","HMPUTIL1",4,0)
 ;
"RTN","HMPUTIL1",5,0)
 Q
"RTN","HMPUTIL1",6,0)
 ;
"RTN","HMPUTIL1",7,0)
 ; ADHOC subroutine refactored for DE1788
"RTN","HMPUTIL1",8,0)
ADHOC(HMPDMINP,HMPFCNT,DFN) ; Add syncStart metastamp and syncStatus to unsolicited updates
"RTN","HMPUTIL1",9,0)
 Q:($G(HMPDMINP)="")!($G(DFN)="")  ; domain and DFN required
"RTN","HMPUTIL1",10,0)
 ; HMPFCNT = count of objects, passed by ref.
"RTN","HMPUTIL1",11,0)
 ; expects HMPFSTR (set in HMPDJFSG) is ^XTMP freshness stream subscript 
"RTN","HMPUTIL1",12,0)
 ; the heading from APIHDR^HMPDJFSG is in ^TMP("HMPF",$J) already
"RTN","HMPUTIL1",13,0)
 ; the JSON built here is placed inside a JSON array, with a '[' after the heading
"RTN","HMPUTIL1",14,0)
 ;
"RTN","HMPUTIL1",15,0)
 N HMPA4JSN,HMPDAT,HMPDMTOT,HMPDOM,HMPID,HMPJSERR,HMPJSON,HMPSUB,I,J,LSTLN,QTE,SUB,X,Y,DELJSON
"RTN","HMPUTIL1",16,0)
 N HMPJSNSY
"RTN","HMPUTIL1",17,0)
 ; HMPA4JSN, HMPJSON, HMPJSERR - used for JSON encoder
"RTN","HMPUTIL1",18,0)
 ; HMPA4JSN - array to encode
"RTN","HMPUTIL1",19,0)
 ; HMPJSON - JSON result
"RTN","HMPUTIL1",20,0)
 ; HMPJSERR - error text from encoder
"RTN","HMPUTIL1",21,0)
 ; QTE - " character
"RTN","HMPUTIL1",22,0)
 ; HMPJSNSY - The system id value for the JSON Encoder, If fully numeric it needs a " prepended
"RTN","HMPUTIL1",23,0)
 S HMPDAT("DELDATE")="",QTE=$C(34)
"RTN","HMPUTIL1",24,0)
 S HMPDMTOT=0  ; domain total
"RTN","HMPUTIL1",25,0)
 ; Save delete date/time for later use.
"RTN","HMPUTIL1",26,0)
 I $G(ACT)="@" D
"RTN","HMPUTIL1",27,0)
 . D  ;DE4307 get from freshness save if available
"RTN","HMPUTIL1",28,0)
 ..  I +$G(FILTER("freshnessDateTime")) S HMPDAT("DELDATE")=$$JSONDT^HMPUTILS(FILTER("freshnessDateTime")) Q
"RTN","HMPUTIL1",29,0)
 ..  S Y=$$FMTH^XLFDT($P(HMPFSTRM,"~",3))  ; Get the date from fresh stream (HMPFS~<server>~<date>)
"RTN","HMPUTIL1",30,0)
 ..  S Y=$$HTFM^XLFDT($P(Y,",")_","_$G(ARGS("hmp-fst"),0))  ; Add delete time stored in ARGS("hmp-fst")
"RTN","HMPUTIL1",31,0)
 ..  S HMPDAT("DELDATE")=$$JSONDT^HMPUTILS(Y)  ; delete date/time into JSON format
"RTN","HMPUTIL1",32,0)
 . S DELJSON="{""pid"":"""_$$PID^HMPDJFS(DFN)_""",""removed"":""true"",""stampTime"":"_HMPDAT("DELDATE")_",""uid"":"""_$G(HMP97)_"""}"
"RTN","HMPUTIL1",33,0)
 ;
"RTN","HMPUTIL1",34,0)
 S HMPA4JSN=$NA(^TMP($J,"ARRAY4JSON")) K @HMPA4JSN ; data array for JSON
"RTN","HMPUTIL1",35,0)
 S HMPJSON=$NA(^TMP($J,"JSONRESULT")) K @HMPJSON  ; JSON result
"RTN","HMPUTIL1",36,0)
 ;
"RTN","HMPUTIL1",37,0)
 S HMPDAT("STAMPTIME")=$$EN^HMPSTMP("NOW"),HMPID=$$SYS^HMPUTILS,HMPJSNSY=$S(+HMPID=HMPID:""""_HMPID,1:HMPID)
"RTN","HMPUTIL1",38,0)
 ;
"RTN","HMPUTIL1",39,0)
 D:DFN'="OPD"  ; get PID data for patient
"RTN","HMPUTIL1",40,0)
 .N ITM,VAL  ; $$PIDS returns: ,"pid":"9E4B;3","systemId":"9E4B","localId":"3","icn":"10207V420718"
"RTN","HMPUTIL1",41,0)
 .S Y=$$PIDS^HMPDJFS(DFN)  ; parse Y, remove quotes save values in HMPID('item')
"RTN","HMPUTIL1",42,0)
 .F J=2:1:$L(Y,",") S X=$P(Y,",",J),ITM=$TR($P(X,":"),QTE),VAL=$TR($P(X,":",2),QTE) S:ITM]"" HMPID(ITM)=VAL
"RTN","HMPUTIL1",43,0)
 ;
"RTN","HMPUTIL1",44,0)
 ; transform domain name for quick orders to match the uid
"RTN","HMPUTIL1",45,0)
 S HMPDOM=HMPDMINP I HMPDOM="quick" S HMPDOM="qo"
"RTN","HMPUTIL1",46,0)
 ;
"RTN","HMPUTIL1",47,0)
 ; stamp time put into HMPDAT("STAMPTIME")
"RTN","HMPUTIL1",48,0)
 S HMPSUB=""
"RTN","HMPUTIL1",49,0)
 S HMPDAT("STAMPTIME")=""
"RTN","HMPUTIL1",50,0)
 F  S HMPSUB=$O(^TMP("HMP",$J,HMPSUB)) Q:'HMPSUB  D
"RTN","HMPUTIL1",51,0)
 .N DONE,HMPN,NEXT,SRCH,HMPDATP ;cpc 2015/10/21
"RTN","HMPUTIL1",52,0)
 .S SRCH="""uid"""_":"_""""_"urn:va:"_HMPDOM_":"
"RTN","HMPUTIL1",53,0)
 .; Search back from last record - but include start of next to cover crossovers
"RTN","HMPUTIL1",54,0)
 .S HMPDAT="" ;cpc 2015/10/21
"RTN","HMPUTIL1",55,0)
 .S HMPN="",HMPDAT("UID")="",DONE=""
"RTN","HMPUTIL1",56,0)
 .F  S HMPN=$O(^TMP("HMP",$J,HMPSUB,HMPN),-1) Q:'HMPN  D  Q:DONE
"RTN","HMPUTIL1",57,0)
 ..S HMPDATP=$E(HMPDAT,1,100) ;cpc 2015/10/21
"RTN","HMPUTIL1",58,0)
 ..S HMPDAT=$G(^TMP("HMP",$J,HMPSUB,HMPN)) Q:HMPDAT="null"!'$L(HMPDAT)
"RTN","HMPUTIL1",59,0)
 ..S HMPDAT=HMPDAT_HMPDATP ;cpc 2015/10/21 - look for crossover data
"RTN","HMPUTIL1",60,0)
 ..;Search for last occurrence of uid in record (this will be parent)
"RTN","HMPUTIL1",61,0)
 ..I $G(HMPDAT(HMPSUB,"UID"))="",$F(HMPDAT,SRCH) F I=2:1 S NEXT=$P($P(HMPDAT,SRCH,I),QTE) Q:NEXT=""  S HMPDAT(HMPSUB,"UID")=NEXT ;cpc 2016/09/16
"RTN","HMPUTIL1",62,0)
 ..;BL;CPC Extract stamptime if present (patient data ONLY)
"RTN","HMPUTIL1",63,0)
 ..;cpc 2015/10/09 - conditionalize tests
"RTN","HMPUTIL1",64,0)
 ..I '$G(HMPDAT(HMPSUB,"STAMPTIME")),$F(HMPDAT,"stampTime") D  ;cpc 2015/10/21
"RTN","HMPUTIL1",65,0)
 ...S HMPDAT(HMPSUB,"STAMPTIME")=$P($P(HMPDAT,"""stampTime"":",2),",")
"RTN","HMPUTIL1",66,0)
 ...;Keep the latest stamptime so that we can use it for the overall metastamp
"RTN","HMPUTIL1",67,0)
 ...I HMPDAT(HMPSUB,"STAMPTIME")>HMPDAT("STAMPTIME") S HMPDAT("STAMPTIME")=HMPDAT(HMPSUB,"STAMPTIME")
"RTN","HMPUTIL1",68,0)
 ..;Patient data requires both UID and stampTime to be complete
"RTN","HMPUTIL1",69,0)
 ..S:$G(HMPDAT(HMPSUB,"UID"))&$G(HMPDAT(HMPSUB,"STAMPTIME")) DONE=1
"RTN","HMPUTIL1",70,0)
 ..;cpc 2015/10/09 - end
"RTN","HMPUTIL1",71,0)
 ;
"RTN","HMPUTIL1",72,0)
 ; HMP97 is uid, SET in FRESHITM^HMPDJFSG
"RTN","HMPUTIL1",73,0)
 I $G(ACT)="@" S HMPDAT("UID")=$P($G(HMP97),":",4,99)
"RTN","HMPUTIL1",74,0)
 ;
"RTN","HMPUTIL1",75,0)
 S @HMPA4JSN@("collection")=$S(DFN="OPD":"OPDsyncStart",1:"syncStart")
"RTN","HMPUTIL1",76,0)
 I DFN="OPD" S @HMPA4JSN@("systemId")=$P(HMPID,";") ; set systemId for OPD
"RTN","HMPUTIL1",77,0)
 S X="" F  S X=$O(HMPID(X)) Q:X=""  S @HMPA4JSN@(X)=HMPID(X)  ; add pid, systemId, localId, icn
"RTN","HMPUTIL1",78,0)
 ;
"RTN","HMPUTIL1",79,0)
 ;DE4307 - if stamptime still doesn't exist then get from freshness
"RTN","HMPUTIL1",80,0)
 I '+HMPDAT("STAMPTIME"),+$G(FILTER("freshnessDateTime")) S HMPDAT("STAMPTIME")=$$JSONDT^HMPUTILS(FILTER("freshnessDateTime"))
"RTN","HMPUTIL1",81,0)
 ; build metastamp components
"RTN","HMPUTIL1",82,0)
 S SUB="metaStamp"
"RTN","HMPUTIL1",83,0)
 S X="" F  S X=$O(HMPID(X)) Q:X=""  S @HMPA4JSN@(SUB,X)=HMPID(X)  ; add pid, systemId, localId, icn
"RTN","HMPUTIL1",84,0)
 S @HMPA4JSN@(SUB,"stampTime")=HMPDAT("STAMPTIME")
"RTN","HMPUTIL1",85,0)
 ;
"RTN","HMPUTIL1",86,0)
 S SUB(1)="sourceMetaStamp",X=""
"RTN","HMPUTIL1",87,0)
 F  S X=$O(HMPID(X)) Q:X=""  S @HMPA4JSN@(SUB,SUB(1),HMPJSNSY,X)=HMPID(X)  ; add pid, systemId, localId, icn ;de4757 use stringed version of system
"RTN","HMPUTIL1",88,0)
 S @HMPA4JSN@(SUB,SUB(1),HMPJSNSY,"stampTime")=HMPDAT("STAMPTIME")
"RTN","HMPUTIL1",89,0)
 ;
"RTN","HMPUTIL1",90,0)
 S SUB(2)="domainMetaStamp"
"RTN","HMPUTIL1",91,0)
 S @HMPA4JSN@(SUB,SUB(1),HMPJSNSY,SUB(2),HMPDOM,"domain")=HMPDOM
"RTN","HMPUTIL1",92,0)
 S @HMPA4JSN@(SUB,SUB(1),HMPJSNSY,SUB(2),HMPDOM,"stampTime")=$S($L($G(HMPDAT("DELDATE"))):HMPDAT("DELDATE"),1:HMPDAT("STAMPTIME"))
"RTN","HMPUTIL1",93,0)
 ;
"RTN","HMPUTIL1",94,0)
 ; Loop through HMPSUB to generate the eventMetastamp
"RTN","HMPUTIL1",95,0)
 S SUB(3)=$S(DFN="OPD":"itemMetaStamp",1:"eventMetaStamp"),HMPSUB="" ;cpc 2015/10/22
"RTN","HMPUTIL1",96,0)
 F  S HMPSUB=$O(HMPDAT(HMPSUB)) Q:'HMPSUB  D
"RTN","HMPUTIL1",97,0)
 .S SUB(4)="urn:va:"_HMPDOM_":"_$S($G(ACT)="@":HMPDAT("UID"),1:HMPDAT(HMPSUB,"UID")) ;CPC won't exist for deletion
"RTN","HMPUTIL1",98,0)
 .S @HMPA4JSN@(SUB,SUB(1),HMPJSNSY,SUB(2),HMPDOM,SUB(3),SUB(4),"stampTime")=$S($L($G(HMPDAT("DELDATE"))):HMPDAT("DELDATE"),1:HMPDAT(HMPSUB,"STAMPTIME"))
"RTN","HMPUTIL1",99,0)
 ;
"RTN","HMPUTIL1",100,0)
 D ENCODE^HMPJSON(HMPA4JSN,HMPJSON,"HMPJSERR")
"RTN","HMPUTIL1",101,0)
 I $D(HMPJSERR) S $EC=",JSON encode error in unsolicited update," Q
"RTN","HMPUTIL1",102,0)
 ; find last line of JSON
"RTN","HMPUTIL1",103,0)
 S LSTLN=0 F J=1:1 Q:'$D(@HMPJSON@(J))  S LSTLN=J
"RTN","HMPUTIL1",104,0)
 ; Merge in data section from FRESHITM^HMPDJFSG
"RTN","HMPUTIL1",105,0)
 ; Add a comma after the syncStart Message for the actual data
"RTN","HMPUTIL1",106,0)
 S @HMPJSON@(LSTLN,.3)=","
"RTN","HMPUTIL1",107,0)
 S HMPSUB=""
"RTN","HMPUTIL1",108,0)
 ;
"RTN","HMPUTIL1",109,0)
 ; do the merge
"RTN","HMPUTIL1",110,0)
 F  S HMPSUB=$O(^TMP("HMP",$J,HMPSUB)) Q:'HMPSUB  D
"RTN","HMPUTIL1",111,0)
 .N HMPX,HMPDATA
"RTN","HMPUTIL1",112,0)
 .S LSTLN=LSTLN+1
"RTN","HMPUTIL1",113,0)
 .; If it is patient data add the wrapper with pid
"RTN","HMPUTIL1",114,0)
 .I DFN'="OPD" S @HMPJSON@(LSTLN,.4)="{""collection"":"""_HMPDOM_""""_$$PIDS^HMPDJFS(DFN)_",""seq"":1,""total"":1,""object"":"_$S($G(ACT)="@":DELJSON,1:"")
"RTN","HMPUTIL1",115,0)
 .; If it is operational data add the wrapper without pid
"RTN","HMPUTIL1",116,0)
 .I DFN="OPD",$G(ACT)="@" S @HMPJSON@(LSTLN,.4)="{""collection"":"""_HMPDOM_""",""seq"":1,""total"":1,""object"":"_DELJSON ;;US5647
"RTN","HMPUTIL1",117,0)
 .; If it is operational data and to be deleted
"RTN","HMPUTIL1",118,0)
 .I DFN="OPD",$G(ACT)'="@"  D  ;US5859
"RTN","HMPUTIL1",119,0)
 ..S @HMPJSON@(LSTLN,.4)="{""collection"":"""_HMPDOM_""",""seq"":1,""total"":1,""object"":"
"RTN","HMPUTIL1",120,0)
 ..S HMPX="""stampTime"":"_QTE_$S($L($G(HMPDAT("DELDATE"))):HMPDAT("DELDATE"),1:HMPDAT("STAMPTIME"))_QTE_","
"RTN","HMPUTIL1",121,0)
 ..S HMPDATA=^TMP("HMP",$J,HMPSUB,1)
"RTN","HMPUTIL1",122,0)
 ..S ^TMP("HMP",$J,HMPSUB,1)="{"_HMPX_$P(HMPDATA,"{",2,999)
"RTN","HMPUTIL1",123,0)
 .M @HMPJSON@(LSTLN)=^TMP("HMP",$J,HMPSUB)
"RTN","HMPUTIL1",124,0)
 .; Close the wrapper
"RTN","HMPUTIL1",125,0)
 .S HMPCLFLG=1
"RTN","HMPUTIL1",126,0)
 .; Add the closing brace for the wrapper
"RTN","HMPUTIL1",127,0)
 .S @HMPJSON@(LSTLN+1,.1)="}"
"RTN","HMPUTIL1",128,0)
 .; Increment the domain total
"RTN","HMPUTIL1",129,0)
 .S HMPDMTOT=HMPDMTOT+1
"RTN","HMPUTIL1",130,0)
 ;
"RTN","HMPUTIL1",131,0)
 S HMPFCNT=$G(HMPFCNT)+1
"RTN","HMPUTIL1",132,0)
 M ^TMP("HMPF",$J,HMPFCNT)=@HMPJSON
"RTN","HMPUTIL1",133,0)
 ; need a comma if more than one item
"RTN","HMPUTIL1",134,0)
 I HMPFCNT>1 S ^TMP("HMPF",$J,HMPFCNT,.3)=$S(HMPLITEM="SYNC":"},",1:",") S HMPLITEM="FRESH" ; DE3502
"RTN","HMPUTIL1",135,0)
 ;
"RTN","HMPUTIL1",136,0)
 ; clean up residual data in ^TMP($J), may be quite a lot
"RTN","HMPUTIL1",137,0)
 K @HMPA4JSN,@HMPJSON
"RTN","HMPUTIL1",138,0)
 Q
"RTN","HMPUTIL1",139,0)
 ;
"VER")
8.0^22.0
"BLD",9710,6)
^4
**END**
**END**

