KIDS Distribution saved on Jun 06, 2018@14:00:44
T7 - Cache Windows/GT.M Darwin support
**KIDS**:XU*8.0*10001^XU*8.0*10002^

**INSTALL NAME**
XU*8.0*10001
"BLD",10872,0)
XU*8.0*10001^KERNEL^0^3180606^y
"BLD",10872,1,0)
^^2^2^3171129^^^^
"BLD",10872,1,1,0)
Kernel Enhancements for better GT.M support. See full release notes 
"BLD",10872,1,2,0)
accompanying this patch.
"BLD",10872,4,0)
^9.64PA^^
"BLD",10872,6.3)
21
"BLD",10872,"INI")
PRE^XU810001
"BLD",10872,"INIT")
POST^XU810001
"BLD",10872,"KRN",0)
^9.67PA^779.2^20
"BLD",10872,"KRN",.4,0)
.4
"BLD",10872,"KRN",.4,"NM",0)
^9.68A^^
"BLD",10872,"KRN",.401,0)
.401
"BLD",10872,"KRN",.401,"NM",0)
^9.68A^^
"BLD",10872,"KRN",.402,0)
.402
"BLD",10872,"KRN",.403,0)
.403
"BLD",10872,"KRN",.5,0)
.5
"BLD",10872,"KRN",.84,0)
.84
"BLD",10872,"KRN",3.6,0)
3.6
"BLD",10872,"KRN",3.8,0)
3.8
"BLD",10872,"KRN",9.2,0)
9.2
"BLD",10872,"KRN",9.8,0)
9.8
"BLD",10872,"KRN",9.8,"NM",0)
^9.68A^16^16
"BLD",10872,"KRN",9.8,"NM",1,0)
ZOSVGUX^^0^B45533042
"BLD",10872,"KRN",9.8,"NM",2,0)
ZOSV2GTM^^0^B12432300
"BLD",10872,"KRN",9.8,"NM",3,0)
ZUGTM^^0^B8549914
"BLD",10872,"KRN",9.8,"NM",4,0)
XLFNSLK^^0^B45784089
"BLD",10872,"KRN",9.8,"NM",5,0)
XLFIPV^^0^B99408781
"BLD",10872,"KRN",9.8,"NM",6,0)
XQ82^^0^B15534691
"BLD",10872,"KRN",9.8,"NM",7,0)
ZISHGUX^^0^B84538989
"BLD",10872,"KRN",9.8,"NM",8,0)
ZISTCPS^^0^B17029601
"BLD",10872,"KRN",9.8,"NM",9,0)
XUSHSH^^0^B42153441
"BLD",10872,"KRN",9.8,"NM",10,0)
ZTMGRSET^^0^B56546290
"BLD",10872,"KRN",9.8,"NM",11,0)
ZSY^^0^B420055711
"BLD",10872,"KRN",9.8,"NM",12,0)
ZTLOAD1^^0^B24616598
"BLD",10872,"KRN",9.8,"NM",13,0)
ZTM6^^0^B9150597
"BLD",10872,"KRN",9.8,"NM",14,0)
ZOSVGUT1^^0^B130237275
"BLD",10872,"KRN",9.8,"NM",15,0)
ZOSVGUT2^^0^B42570307
"BLD",10872,"KRN",9.8,"NM",16,0)
ZOSVONUT^^0^B31454787
"BLD",10872,"KRN",9.8,"NM","B","XLFIPV",5)

"BLD",10872,"KRN",9.8,"NM","B","XLFNSLK",4)

"BLD",10872,"KRN",9.8,"NM","B","XQ82",6)

"BLD",10872,"KRN",9.8,"NM","B","XUSHSH",9)

"BLD",10872,"KRN",9.8,"NM","B","ZISHGUX",7)

"BLD",10872,"KRN",9.8,"NM","B","ZISTCPS",8)

"BLD",10872,"KRN",9.8,"NM","B","ZOSV2GTM",2)

"BLD",10872,"KRN",9.8,"NM","B","ZOSVGUT1",14)

"BLD",10872,"KRN",9.8,"NM","B","ZOSVGUT2",15)

"BLD",10872,"KRN",9.8,"NM","B","ZOSVGUX",1)

"BLD",10872,"KRN",9.8,"NM","B","ZOSVONUT",16)

"BLD",10872,"KRN",9.8,"NM","B","ZSY",11)

"BLD",10872,"KRN",9.8,"NM","B","ZTLOAD1",12)

"BLD",10872,"KRN",9.8,"NM","B","ZTM6",13)

"BLD",10872,"KRN",9.8,"NM","B","ZTMGRSET",10)

"BLD",10872,"KRN",9.8,"NM","B","ZUGTM",3)

"BLD",10872,"KRN",19,0)
19
"BLD",10872,"KRN",19.1,0)
19.1
"BLD",10872,"KRN",101,0)
101
"BLD",10872,"KRN",409.61,0)
409.61
"BLD",10872,"KRN",771,0)
771
"BLD",10872,"KRN",779.2,0)
779.2
"BLD",10872,"KRN",870,0)
870
"BLD",10872,"KRN",8989.51,0)
8989.51
"BLD",10872,"KRN",8989.52,0)
8989.52
"BLD",10872,"KRN",8994,0)
8994
"BLD",10872,"KRN","B",.4,.4)

"BLD",10872,"KRN","B",.401,.401)

"BLD",10872,"KRN","B",.402,.402)

"BLD",10872,"KRN","B",.403,.403)

"BLD",10872,"KRN","B",.5,.5)

"BLD",10872,"KRN","B",.84,.84)

"BLD",10872,"KRN","B",3.6,3.6)

"BLD",10872,"KRN","B",3.8,3.8)

"BLD",10872,"KRN","B",9.2,9.2)

"BLD",10872,"KRN","B",9.8,9.8)

"BLD",10872,"KRN","B",19,19)

"BLD",10872,"KRN","B",19.1,19.1)

"BLD",10872,"KRN","B",101,101)

"BLD",10872,"KRN","B",409.61,409.61)

"BLD",10872,"KRN","B",771,771)

"BLD",10872,"KRN","B",779.2,779.2)

"BLD",10872,"KRN","B",870,870)

"BLD",10872,"KRN","B",8989.51,8989.51)

"BLD",10872,"KRN","B",8989.52,8989.52)

"BLD",10872,"KRN","B",8994,8994)

"BLD",10872,"QUES",0)
^9.62^^
"INI")
PRE^XU810001
"INIT")
POST^XU810001
"MBREQ")
0
"PKG",3,-1)
1^1
"PKG",3,0)
KERNEL^XU^SIGN-ON, SECURITY, MENU DRIVER, DEVICES, TASKMAN^
"PKG",3,20,0)
^9.402P^2^2
"PKG",3,20,1,0)
200^^XDRM200N
"PKG",3,20,1,1)

"PKG",3,20,2,0)
2^^RGDRM03
"PKG",3,20,2,1)

"PKG",3,20,"B",2,2)

"PKG",3,20,"B",200,1)

"PKG",3,22,0)
^9.49I^1^1
"PKG",3,22,1,0)
8.0^3051119^2960606^1
"PKG",3,22,1,"PAH",1,0)
10001^3180606^0
"PKG",3,22,1,"PAH",1,1,0)
^^2^2^3180606
"PKG",3,22,1,"PAH",1,1,1,0)
Kernel Enhancements for better GT.M support. See full release notes 
"PKG",3,22,1,"PAH",1,1,2,0)
accompanying this patch.
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
NO
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
NO
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
NO
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
17
"RTN","XLFIPV")
0^5^B99408781
"RTN","XLFIPV",1,0)
XLFIPV ;ISD/HGW - IPv4 and IPv6 Utilities ;2017-01-09  3:29 PM
"RTN","XLFIPV",2,0)
 ;;8.0;KERNEL;**605,638,10001**;Aug 6, 2012;Build 21
"RTN","XLFIPV",3,0)
 ; Submitted to OSEHRA in 2017 by Sam Habiel for OSEHRA
"RTN","XLFIPV",4,0)
 ; Original Routine authored by Department of Veterans Affairs
"RTN","XLFIPV",5,0)
 ; EP VERSION GT.M Support authored by Christopher Edwards 2016.
"RTN","XLFIPV",6,0)
 Q
"RTN","XLFIPV",7,0)
 ;
"RTN","XLFIPV",8,0)
VALIDATE(IP) ; EXTRINSIC. ICR #5844 (supported)
"RTN","XLFIPV",9,0)
 ; Validate the format of an IP address (either IPv4 or IPv6).
"RTN","XLFIPV",10,0)
 ; Usage:  S Y=$$VALIDATE^XLFIPV(IP)
"RTN","XLFIPV",11,0)
 ; Input:  IP (string) - IPv4 or IPv6 Address to be validated.
"RTN","XLFIPV",12,0)
 ; Output: returns:
"RTN","XLFIPV",13,0)
 ;           1 - if the IP address is in a valid format.
"RTN","XLFIPV",14,0)
 ;           0 - if the format is invalid or null input.
"RTN","XLFIPV",15,0)
 ;
"RTN","XLFIPV",16,0)
 N I,J,X,XLFIELD
"RTN","XLFIPV",17,0)
 S X=1
"RTN","XLFIPV",18,0)
 I '$D(IP) Q 0
"RTN","XLFIPV",19,0)
 I IP?1.3N1P1.3N1P1.3N1P1.3N1P.N S IP=$P(IP,":",1) ;p638 Strip off port information from IPv4 address
"RTN","XLFIPV",20,0)
 ; If IP address contains both ":" and "." delimiters, then check IPv4 embedded in IPv6.
"RTN","XLFIPV",21,0)
 I (IP[":")&(IP[".") D  Q X  ; IPv4-Mapped.
"RTN","XLFIPV",22,0)
 . S IP=$$EXPAND6(IP,6) I IP="" S X=0 Q  ; Change the format of the first six high-order bytes
"RTN","XLFIPV",23,0)
 . F I=1:1:6 Q:X=0  D  ; Examine field by field, first six bytes
"RTN","XLFIPV",24,0)
 . . S X=$$EXAMINE6($P(IP,":",I))
"RTN","XLFIPV",25,0)
 . S XLFIELD=$P(IP,":",7) ; Get last two bytes, IPv4 format
"RTN","XLFIPV",26,0)
 . F I=1:1:4 Q:X=0  D  ; Examine field by field, last two bytes
"RTN","XLFIPV",27,0)
 . . S X=$$EXAMINE4($P(XLFIELD,".",I))
"RTN","XLFIPV",28,0)
 ; If IP address contains ":" delimiter, then IPv6. Otherwise IPv4.
"RTN","XLFIPV",29,0)
 I IP[":" D  Q X  ; IPv6 address
"RTN","XLFIPV",30,0)
 . S IP=$$EXPAND6(IP,7) I IP="" S X=0 Q  ; Change to a common format
"RTN","XLFIPV",31,0)
 . F I=1:1:8 Q:X=0  D  ; Examine field by field
"RTN","XLFIPV",32,0)
 . . S X=$$EXAMINE6($P(IP,":",I))
"RTN","XLFIPV",33,0)
 I IP'[":" D  Q X  ; IPv4 address
"RTN","XLFIPV",34,0)
 . S IP=$$EXPAND4(IP) ; Change to a common format
"RTN","XLFIPV",35,0)
 . F I=1:1:4 Q:X=0  D  ; Examine field by field
"RTN","XLFIPV",36,0)
 . . S X=$$EXAMINE4($P(IP,".",I))
"RTN","XLFIPV",37,0)
 Q 0
"RTN","XLFIPV",38,0)
 ;
"RTN","XLFIPV",39,0)
FORCEIP4(IP) ; EXTRINSIC. ICR #5844 (supported)
"RTN","XLFIPV",40,0)
 ; Convert an IP address (either IPv4 or IPv6) into an IPv4 address in a standardized format: "127.0.0.1".
"RTN","XLFIPV",41,0)
 ; Usage:  S Y=$$FORCEIP4^XLFIPV(IP)
"RTN","XLFIPV",42,0)
 ; Input:  IP (string) IPv4 or IPv6 Address to be converted.
"RTN","XLFIPV",43,0)
 ; Output: returns:  An IPv4 address in "ddd.ddd.ddd.ddd" notation if the input address is valid and has an
"RTN","XLFIPV",44,0)
 ;           IPv4 equivalent, or the null address "0.0.0.0" if the input address is invalid, or the null address
"RTN","XLFIPV",45,0)
 ;           "0.0.0.0" if an IPv6 address is input which does not have an IPv4 equivalent.
"RTN","XLFIPV",46,0)
 ;
"RTN","XLFIPV",47,0)
 N I,XLFIELD,XLMAP
"RTN","XLFIPV",48,0)
 ; Return null address "0.0.0.0" if address is invalid
"RTN","XLFIPV",49,0)
 Q:'$$VALIDATE(IP) "0.0.0.0"
"RTN","XLFIPV",50,0)
 I IP?1.3N1P1.3N1P1.3N1P1.3N1P.N S IP=$P(IP,":") ;p638 Strip off port information from IPv4 address
"RTN","XLFIPV",51,0)
 S XLMAP="0000:0000:0000:0000:0000:FFFF:"
"RTN","XLFIPV",52,0)
 ; If IP address contains both ":" and "." delimiters, then IPv4-Mapped IPv6 address.
"RTN","XLFIPV",53,0)
 I (IP[":")&(IP[".") D  Q IP  ; IPv4-Mapped.
"RTN","XLFIPV",54,0)
 . S IP=$$EXPAND6(IP,6) I IP="" S IP="0.0.0.0" Q  ; Change the format of the first six high-order bytes
"RTN","XLFIPV",55,0)
 . S IP=$$EXPAND4($E(IP,31,49)) ; Get last two bytes, IPv4 format (not interested in first six bytes)
"RTN","XLFIPV",56,0)
 I IP[":" D  Q IP  ; IPv6 address (last two bytes might be IPv4-Mapped)
"RTN","XLFIPV",57,0)
 . S IP=$$EXPAND6(IP,7) I IP="" S IP="0.0.0.0" Q  ; Change the format to standardized
"RTN","XLFIPV",58,0)
 . I IP="0000:0000:0000:0000:0000:0000:0000:0001" S IP="127.0.0.1" Q  ; Loopback address
"RTN","XLFIPV",59,0)
 . I $E(IP,1,30)'=XLMAP S IP="0.0.0.0" Q  ; Invalid IPv4-Mapped address
"RTN","XLFIPV",60,0)
 . S IP=$$DEC^XLFUTL($E(IP,31,32),16)_"."_$$DEC^XLFUTL($E(IP,33,34),16)_"."_$$DEC^XLFUTL($E(IP,36,37),16)_"."_$$DEC^XLFUTL($E(IP,38,39),16)
"RTN","XLFIPV",61,0)
 I IP'[":" D  Q IP  ; IPv4 address
"RTN","XLFIPV",62,0)
 . S IP=$$EXPAND4(IP) ; Change to a common format
"RTN","XLFIPV",63,0)
 Q "0.0.0.0"
"RTN","XLFIPV",64,0)
 ;
"RTN","XLFIPV",65,0)
FORCEIP6(IP) ; EXTRINSIC. ICR #5844 (supported)
"RTN","XLFIPV",66,0)
 ; Convert an IP address (either IPv4 or IPv6) into an IPv6 address in a standardized format: "2001:0DB8:0000:0000:0000:8A2E:0370:7334".
"RTN","XLFIPV",67,0)
 ; Usage:  S Y=$$FORCEIP6^XLFIPV(IP)
"RTN","XLFIPV",68,0)
 ; Input:  IP (string) IPv4 or IPv6 Address to be converted.
"RTN","XLFIPV",69,0)
 ; Output: returns:  An IPv6 address in "hhhh:hhhh:hhhh:hhhh:hhhh:hhhh:hhhh:hhhh" notation if the
"RTN","XLFIPV",70,0)
 ;           input address is valid, or the null address "::0" if the input address is invalid.
"RTN","XLFIPV",71,0)
 ;
"RTN","XLFIPV",72,0)
 N XLMAP
"RTN","XLFIPV",73,0)
 ; Return expanded null address "0000:0000:0000:0000:0000:0000:0000:0000" if address is invalid
"RTN","XLFIPV",74,0)
 Q:'$$VALIDATE(IP) "0000:0000:0000:0000:0000:0000:0000:0000"
"RTN","XLFIPV",75,0)
 S XLMAP="0000:0000:0000:0000:0000:FFFF:"
"RTN","XLFIPV",76,0)
 I IP?1.3N1P1.3N1P1.3N1P1.3N1P.N S IP=$P(IP,":") ;p638 Strip off port information from IPv4 address
"RTN","XLFIPV",77,0)
 ; If IP address contains both ":" and "." delimiters, then IPv4 embedded in IPv6.
"RTN","XLFIPV",78,0)
 I (IP[":")&(IP[".") D  Q IP  ; IPv4-Mapped address.
"RTN","XLFIPV",79,0)
 . S IP=$$EXPAND6(IP,6) I IP="" S IP="0.0.0.0" Q  ; Change the format of the first six high-order bytes
"RTN","XLFIPV",80,0)
 . S IP=$E(IP,1,30)_$$CNVF($$EXPAND4($E(IP,31,49))) ; Get last two bytes, IPv4 format -> IPv4-Mapped Address
"RTN","XLFIPV",81,0)
 ; If IP address contains ":" delimiter, then IPv6. Otherwise IPv4.
"RTN","XLFIPV",82,0)
 I IP[":" D  Q IP  ; IPv6 address
"RTN","XLFIPV",83,0)
 . S IP=$$EXPAND6(IP,7) I IP="" S IP="0000:0000:0000:0000:0000:0000:0000:0000" Q  ; Change to a common format
"RTN","XLFIPV",84,0)
 I IP'[":" D  Q IP  ; IPv4 address
"RTN","XLFIPV",85,0)
 . S IP=XLMAP_$$CNVF($$EXPAND4(IP)) ; IPv4-Mapped IPv6 Address
"RTN","XLFIPV",86,0)
 . I IP="0000:0000:0000:0000:0000:FFFF:0000:0000" S IP="0000:0000:0000:0000:0000:0000:0000:0000" Q  ; Null address
"RTN","XLFIPV",87,0)
 . I IP="0000:0000:0000:0000:0000:FFFF:7F00:0001" S IP="0000:0000:0000:0000:0000:0000:0000:0001" Q  ; Loopback address
"RTN","XLFIPV",88,0)
 Q IP
"RTN","XLFIPV",89,0)
 ;
"RTN","XLFIPV",90,0)
CONVERT(IP) ; EXTRINSIC. ICR #5844 (supported)
"RTN","XLFIPV",91,0)
 ; Convert an IP address (either IPv4 or IPv6) into an IPv6 address in a standardized format, either IPv4 or IPv6 depending
"RTN","XLFIPV",92,0)
 ;   upon the Cache system settings.
"RTN","XLFIPV",93,0)
 ; Usage:  S Y=$$CONVERT^XLFIPV(IP)
"RTN","XLFIPV",94,0)
 ; Input:  IP (string) IPv4 or IPv6 Address to be converted.
"RTN","XLFIPV",95,0)
 ; Output: returns:
"RTN","XLFIPV",96,0)
 ;           - An IPv4 address if IPv6 is disabled on the system.
"RTN","XLFIPV",97,0)
 ;           - An IPv6 address if IPv6 is enabled on the system.
"RTN","XLFIPV",98,0)
 ;           - An IPv4 or IPv6 null address if the input cannot be converted.
"RTN","XLFIPV",99,0)
 ;
"RTN","XLFIPV",100,0)
 N XLV6
"RTN","XLFIPV",101,0)
 S XLV6=$$VERSION() ; Is IPv6 enabled on this system?
"RTN","XLFIPV",102,0)
 I XLV6=1 S IP=$$FORCEIP6(IP) ; Yes
"RTN","XLFIPV",103,0)
 I XLV6=0 S IP=$$FORCEIP4(IP) ; No
"RTN","XLFIPV",104,0)
 Q IP
"RTN","XLFIPV",105,0)
 ;
"RTN","XLFIPV",106,0)
VERSION() ; EXTRINSIC. ICR #5844 (supported)
"RTN","XLFIPV",107,0)
 ; Determine the Cache system settings for IPv6.
"RTN","XLFIPV",108,0)
 ; Usage:  S Y=$$VERSION^XLFIPV()
"RTN","XLFIPV",109,0)
 ; Input:  None.
"RTN","XLFIPV",110,0)
 ; Output: returns:
"RTN","XLFIPV",111,0)
 ;           1 - if IPv6 is enabled.
"RTN","XLFIPV",112,0)
 ;           0 - if IPv6 is disabled.
"RTN","XLFIPV",113,0)
 ;
"RTN","XLFIPV",114,0)
 N %
"RTN","XLFIPV",115,0)
 S %=0
"RTN","XLFIPV",116,0)
 I $$VERSION^%ZOSV(1)["Cache" I +$$VERSION^%ZOSV()>2009 S %=$SYSTEM.Process.IPv6Format()
"RTN","XLFIPV",117,0)
 I +$SY=47 D  ; GT.M
"RTN","XLFIPV",118,0)
 . I $TR($$VERSION^%ZOSV(),"-")<6.0003 QUIT  ; GT.M supports IPV6 starting in 6.0-003
"RTN","XLFIPV",119,0)
 . I $ZTRNLNM("gtm_ipv4_only") QUIT
"RTN","XLFIPV",120,0)
 . S %=1
"RTN","XLFIPV",121,0)
 Q %
"RTN","XLFIPV",122,0)
 ;
"RTN","XLFIPV",123,0)
VAL ; OPTION. "Validate IPv4 and IPv6 address" [XLFIPV VALIDATE]
"RTN","XLFIPV",124,0)
 N DIR,X,XLFX
"RTN","XLFIPV",125,0)
 S DIR(0)="F^3:60",DIR("A")="Enter an IP address to be validated",DIR("B")="127.0.0.1"
"RTN","XLFIPV",126,0)
 S DIR("?")="   Validate the format of an IP address."
"RTN","XLFIPV",127,0)
 S DIR("??")="^D VALH^XLFIPV"
"RTN","XLFIPV",128,0)
 D ^DIR S XLFX=$$VALIDATE(X)
"RTN","XLFIPV",129,0)
 I XLFX=0 W !!,?3,X," is NOT a valid address."
"RTN","XLFIPV",130,0)
 I XLFX=1 W !!,?3,X," is a valid address."
"RTN","XLFIPV",131,0)
 Q
"RTN","XLFIPV",132,0)
 ;
"RTN","XLFIPV",133,0)
VALH ; Extended help for VAL^XLFIPV
"RTN","XLFIPV",134,0)
 W !!,"   This option will validate the format of an IP address (either IPv4 or IPv6)"
"RTN","XLFIPV",135,0)
 W !,"   and return ""IP is NOT a valid address"" if the address is in an invalid"
"RTN","XLFIPV",136,0)
 W !,"   format, or return ""IP is a valid address"" if the format is correct."
"RTN","XLFIPV",137,0)
 Q
"RTN","XLFIPV",138,0)
 ;
"RTN","XLFIPV",139,0)
IP4 ; OPTION. "Convert any IP address to IPv4" [XLFIPV FORCEIP4]
"RTN","XLFIPV",140,0)
 N DIR,X
"RTN","XLFIPV",141,0)
 S DIR(0)="F^3:60",DIR("A")="Enter an IP address to be converted to IPv4",DIR("B")="127.0.0.1"
"RTN","XLFIPV",142,0)
 S DIR("?")="   Convert an IP address into an IPv4 address in a standardized format."
"RTN","XLFIPV",143,0)
 S DIR("??")="^D IP4H^XLFIPV"
"RTN","XLFIPV",144,0)
 D ^DIR W !!,?3,$$FORCEIP4(X)
"RTN","XLFIPV",145,0)
 Q
"RTN","XLFIPV",146,0)
 ;
"RTN","XLFIPV",147,0)
IP4H ; Extended help for IP4^XLFIPV
"RTN","XLFIPV",148,0)
 W !!,"   This option will take an IP address (either IPv4 or IPv6) and return an"
"RTN","XLFIPV",149,0)
 W !,"   IPv4 address in a standardized format.  It will return the null address"
"RTN","XLFIPV",150,0)
 W !,"   0.0.0.0 if the passed IP address is invalid.  If an IPv6 address is input"
"RTN","XLFIPV",151,0)
 W !,"   which does not have a valid IPv4 equivalent, the null address will be"
"RTN","XLFIPV",152,0)
 W !,"   returned."
"RTN","XLFIPV",153,0)
 Q
"RTN","XLFIPV",154,0)
 ;
"RTN","XLFIPV",155,0)
IP6 ; OPTION. "Convert any IP address to IPv6" [XLFIPV FORCEIP6]
"RTN","XLFIPV",156,0)
 N DIR,X
"RTN","XLFIPV",157,0)
 S DIR(0)="F^3:60",DIR("A")="Enter an IP address to be converted to IPv6",DIR("B")="127.0.0.1"
"RTN","XLFIPV",158,0)
 S DIR("?")="   Convert an IP address into an IPv6 address in a standardized format."
"RTN","XLFIPV",159,0)
 S DIR("??")="^D IP6H^XLFIPV"
"RTN","XLFIPV",160,0)
 D ^DIR W !!,?3,$$FORCEIP6(X)
"RTN","XLFIPV",161,0)
 Q
"RTN","XLFIPV",162,0)
IP6H ; Extended help for IP6^XLFIPV
"RTN","XLFIPV",163,0)
 W !!,"   This option will take an IP address (either IPv4 or IPv6) and return an"
"RTN","XLFIPV",164,0)
 W !,"   IPv6 address in a standardized format.  It will return the null address"
"RTN","XLFIPV",165,0)
 W !,"   ::0 if the passed IP address is invalid."
"RTN","XLFIPV",166,0)
 Q
"RTN","XLFIPV",167,0)
 ;
"RTN","XLFIPV",168,0)
CON ; OPTION. "Convert any IP address per system settings" [XLFIPV CONVERT]
"RTN","XLFIPV",169,0)
 N DIR,X
"RTN","XLFIPV",170,0)
 S DIR(0)="F^3:60",DIR("A")="Enter an IP address to be converted",DIR("B")="127.0.0.1"
"RTN","XLFIPV",171,0)
 S DIR("?")="   Convert an IP address depending upon system settings."
"RTN","XLFIPV",172,0)
 S DIR("??")="^D CONH^XLFIPV"
"RTN","XLFIPV",173,0)
 D ^DIR W !!,?3,$$CONVERT(X)
"RTN","XLFIPV",174,0)
 Q
"RTN","XLFIPV",175,0)
CONH ; Extended help for CON^XLFIPV
"RTN","XLFIPV",176,0)
 W !!,"   This option will take an IP address (either IPv4 or IPv6) and return an"
"RTN","XLFIPV",177,0)
 W !,"   IP address in a standardized format, depending on system settings.  If"
"RTN","XLFIPV",178,0)
 W !,"   IPv6 is disabled on the system, an IPv4 address will be returned.  If"
"RTN","XLFIPV",179,0)
 W !,"   IPv6 is enabled on the system, an IPv6 address will be returned.  If an"
"RTN","XLFIPV",180,0)
 W !,"   invalid address is entered, a null address will be returned.  If an IPv6"
"RTN","XLFIPV",181,0)
 W !,"   is entered, IPv6 is not enabled, and the input address does not have an"
"RTN","XLFIPV",182,0)
 W !,"   IPv4 equivalent, a null address will be returned."
"RTN","XLFIPV",183,0)
 Q
"RTN","XLFIPV",184,0)
 ;
"RTN","XLFIPV",185,0)
VER ; OPTION. "Show system settings for IPv6" [XLFIPV VERSION]
"RTN","XLFIPV",186,0)
 N X,XLSYS,XLVER
"RTN","XLFIPV",187,0)
 S X=$$VERSION,XLSYS=$$VERSION^%ZOSV(1),XLVER=+$$VERSION^%ZOSV()
"RTN","XLFIPV",188,0)
 W !!,?3,XLSYS," ",XLVER
"RTN","XLFIPV",189,0)
 I X=0 D  Q
"RTN","XLFIPV",190,0)
 . I XLSYS["Cache" D  Q
"RTN","XLFIPV",191,0)
 . . I XLVER>2009 W !!,"   IPv6 is available but is disabled on this system." Q
"RTN","XLFIPV",192,0)
 . . W !!,"   IPv6 is not available on this version of Cache."
"RTN","XLFIPV",193,0)
 . W !!,"   IPv6 is not available on this system."
"RTN","XLFIPV",194,0)
 I X=1 W !!,"   IPv6 is enabled on this system."
"RTN","XLFIPV",195,0)
 Q
"RTN","XLFIPV",196,0)
 ;
"RTN","XLFIPV",197,0)
EXPAND4(IP) ; INTRINSIC.
"RTN","XLFIPV",198,0)
 ; Changes the format of an IPv4 address to a common format that can be validated
"RTN","XLFIPV",199,0)
 ; Usage:  S Y=$$EXPAND4^XLFIPV(IP)
"RTN","XLFIPV",200,0)
 ; Input:  IP (string) IPv4 address to be reformatted.
"RTN","XLFIPV",201,0)
 ; Output: returns:  An IPv4 address in the format "nnn.nnn.nnn.nnn".
"RTN","XLFIPV",202,0)
 ;
"RTN","XLFIPV",203,0)
 N I,XLFIELD
"RTN","XLFIPV",204,0)
 ; Expand hexadecimal address to IPv4 dotted hexadecimal: "0xc0a8010a" -> "0xc0.0xa8.0x10.0x0a"
"RTN","XLFIPV",205,0)
 I ($E(IP,1,2)="0x")&(IP'[".") D
"RTN","XLFIPV",206,0)
 . S IP="0x"_$E(IP,3,4)_".0x"_$E(IP,5,6)_".0x"_$E(IP,7,8)_".0x"_$E(IP,9,10)
"RTN","XLFIPV",207,0)
 F I=1:1:4 D  ; Examine field by field
"RTN","XLFIPV",208,0)
 . S XLFIELD=$P(IP,".",I)
"RTN","XLFIPV",209,0)
 . ; Convert dotted hexadecimal address to IPv4 dotted decimal: "0xc0.0xa8.0x10.0x0a" -> "192.168.16.10"
"RTN","XLFIPV",210,0)
 . I $E(XLFIELD,1,2)="0x" S XLFIELD=$$DEC^XLFUTL($$UP^XLFSTR($E(XLFIELD,3,4)),16) ; Convert HEX field to DEC
"RTN","XLFIPV",211,0)
 . S $P(IP,".",I)=XLFIELD
"RTN","XLFIPV",212,0)
 ; Convert dotted octal address to IPv4 dotted decimal: "0300.0000.0002.0353" -> "192.0.2.235"
"RTN","XLFIPV",213,0)
 I IP?4N1"."4N1"."4N1"."4N D
"RTN","XLFIPV",214,0)
 . S IP=$$DEC^XLFUTL($E(IP,1,4),8)_"."_$$DEC^XLFUTL($E(IP,6,9),8)_"."_$$DEC^XLFUTL($E(IP,11,14),8)_"."_$$DEC^XLFUTL($E(IP,16,19),8)
"RTN","XLFIPV",215,0)
 Q IP
"RTN","XLFIPV",216,0)
 ;
"RTN","XLFIPV",217,0)
EXPAND6(IP,ZNUM) ; INTRINSIC.
"RTN","XLFIPV",218,0)
 ; Changes the format of an IPv6 address to a common format that can be validated
"RTN","XLFIPV",219,0)
 ; Usage:  S Y=$$EXPAND6^XLFIPV(IP)
"RTN","XLFIPV",220,0)
 ; Input:  IP (string) IPv6 address to be reformatted.
"RTN","XLFIPV",221,0)
 ;         ZNUM The number of expected colons
"RTN","XLFIPV",222,0)
 ; Output: returns:  An IPv6 address in the format "hhhh:hhhh:hhhh:hhhh:hhhh:hhhh:hhhh:hhhh".
"RTN","XLFIPV",223,0)
 ;
"RTN","XLFIPV",224,0)
 N I,XLBLANK,XLCNT,XLFIELD
"RTN","XLFIPV",225,0)
 S IP=$P($G(IP),"%") ;p638 Remove routing information
"RTN","XLFIPV",226,0)
 I IP[":::" S IP="" Q IP  ; Cannot contain :::
"RTN","XLFIPV",227,0)
 I $E(IP,1)="[" S IP=$P($P(IP,"[",2),"]") ; Strip brackets [] from around an address string
"RTN","XLFIPV",228,0)
 S XLCNT=ZNUM-($L(IP)-$L($TR(IP,":",""))) ; Count the number of colons needed to be added in short form address
"RTN","XLFIPV",229,0)
 I (XLCNT>0)&(IP'["::") S IP="" Q IP  ; If missing a colon, but no "::", then return "" for invalid address
"RTN","XLFIPV",230,0)
 I XLCNT>0 S XLBLANK="" S IP=$P(IP,"::",1)_$TR($JUSTIFY(XLBLANK,XLCNT+2)," ",":")_$P(IP,"::",2) ; Expand ::
"RTN","XLFIPV",231,0)
 F I=1:1:(ZNUM+1) D  ; Examine field by field
"RTN","XLFIPV",232,0)
 . S XLFIELD=$$UP^XLFSTR($P(IP,":",I))
"RTN","XLFIPV",233,0)
 . S XLFIELD=$TR($JUSTIFY(XLFIELD,4)," ","0") ; Add leading zeros
"RTN","XLFIPV",234,0)
 . S $P(IP,":",I)=XLFIELD
"RTN","XLFIPV",235,0)
 Q IP
"RTN","XLFIPV",236,0)
 ;
"RTN","XLFIPV",237,0)
EXAMINE4(XLFIELD) ; INTRINSIC.
"RTN","XLFIPV",238,0)
 ; Examine a single field of an IPv4 address for a valid format
"RTN","XLFIPV",239,0)
 ; Usage:  S Y=$$EXAMINE4^XLFIPV(XLFIELD)
"RTN","XLFIPV",240,0)
 ; Input:  XLFIELD (string) Field to be examined.
"RTN","XLFIPV",241,0)
 ; Output: returns:
"RTN","XLFIPV",242,0)
 ;           1 - if the field is valid.
"RTN","XLFIPV",243,0)
 ;           0 - if the field is invalid.
"RTN","XLFIPV",244,0)
 ;
"RTN","XLFIPV",245,0)
 I XLFIELD'?1.3N Q 0  ; Test format NNN
"RTN","XLFIPV",246,0)
 I (XLFIELD>255)!(XLFIELD<0) Q 0  ; Test address range
"RTN","XLFIPV",247,0)
 Q 1
"RTN","XLFIPV",248,0)
 ;
"RTN","XLFIPV",249,0)
EXAMINE6(XLFIELD) ; INTRINSIC.
"RTN","XLFIPV",250,0)
 ; Examine a single field of an IPv6 address for a valid format
"RTN","XLFIPV",251,0)
 ; Usage:  S Y=$$EXAMINE6^XLFIPV(XLFIELD)
"RTN","XLFIPV",252,0)
 ; Input:  XLFIELD (string) Field to be examined.
"RTN","XLFIPV",253,0)
 ; Output: returns:
"RTN","XLFIPV",254,0)
 ;           1 - if the field is valid.
"RTN","XLFIPV",255,0)
 ;           0 - if the field is invalid.
"RTN","XLFIPV",256,0)
 ;
"RTN","XLFIPV",257,0)
 N I,X
"RTN","XLFIPV",258,0)
 S XLFIELD=$$UP^XLFSTR(XLFIELD) I XLFIELD'?4E Q 0  ; Test format EEEE
"RTN","XLFIPV",259,0)
 S X=1 F I=1:1:4 D
"RTN","XLFIPV",260,0)
 . I "0123456789ABCDEF"'[$E(XLFIELD,I) S X=0  ; Test address range, contains 0 through F characters only
"RTN","XLFIPV",261,0)
 Q X
"RTN","XLFIPV",262,0)
 ;
"RTN","XLFIPV",263,0)
CNVF(IP) ; INTRINSIC.
"RTN","XLFIPV",264,0)
 ; Expands a decimal IP address "ddd.ddd.ddd.ddd" to hexadecimal fields
"RTN","XLFIPV",265,0)
 ; Usage:  S Y=$$CNVF^XLFIPV(IP)
"RTN","XLFIPV",266,0)
 ; Input:  IP (string) IPv4 address to be reformatted.
"RTN","XLFIPV",267,0)
 ; Output: returns:  The last two bytes of an IPv6 address in the format "hhhh:hhhh".
"RTN","XLFIPV",268,0)
 ;
"RTN","XLFIPV",269,0)
 N I,XLFIELD,XLOUT
"RTN","XLFIPV",270,0)
 S XLOUT=""
"RTN","XLFIPV",271,0)
 F I=1:1:4 D  ; Examine field by field
"RTN","XLFIPV",272,0)
 . S XLFIELD=$$CNV^XLFUTL($P(IP,".",I),16)
"RTN","XLFIPV",273,0)
 . S XLOUT=XLOUT_$TR($JUSTIFY(XLFIELD,2)," ","0") ; Add leading zeros
"RTN","XLFIPV",274,0)
 . I I=2 S XLOUT=XLOUT_":"
"RTN","XLFIPV",275,0)
 Q XLOUT
"RTN","XLFIPV",276,0)
 ;
"RTN","XLFNSLK")
0^4^B45784089
"RTN","XLFNSLK",1,0)
XLFNSLK ;ISF/RWF,ISD/HGW - Calling a DNS server for name lookup ;2017-01-09  3:28 PM
"RTN","XLFNSLK",2,0)
 ;;8.0;KERNEL;**142,151,425,638,659,10001**;Jul 10, 1995;Build 21
"RTN","XLFNSLK",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","XLFNSLK",4,0)
 ; Submitted to OSEHRA in 2017 by Sam Habiel for OSEHRA
"RTN","XLFNSLK",5,0)
 ; Original Routine authored by Department of Veterans Affairs
"RTN","XLFNSLK",6,0)
 ; EPs HOST and ADDRESS GT.M Support by Christopher Edwards 2016.
"RTN","XLFNSLK",7,0)
 ;
"RTN","XLFNSLK",8,0)
 Q
"RTN","XLFNSLK",9,0)
TEST ;Test entry
"RTN","XLFNSLK",10,0)
 N XNAME
"RTN","XLFNSLK",11,0)
 R !,"Enter an IP address to lookup: www.domain//",XNAME:DTIME S:XNAME="" XNAME="www.domain" Q:XNAME["^"
"RTN","XLFNSLK",12,0)
 W !!,"Looking up IPv4 address: ",XNAME
"RTN","XLFNSLK",13,0)
 W !,?5,XNAME,". > ",$$ADDRESS(XNAME,"A")
"RTN","XLFNSLK",14,0)
 W !!,"Looking up IPv6 address: ",XNAME
"RTN","XLFNSLK",15,0)
 W !,?5,XNAME,". > ",$$ADDRESS(XNAME,"AAAA")
"RTN","XLFNSLK",16,0)
 W !
"RTN","XLFNSLK",17,0)
 Q
"RTN","XLFNSLK",18,0)
 ;
"RTN","XLFNSLK",19,0)
HOST(IP) ;Get a host name from an IP address
"RTN","XLFNSLK",20,0)
 ;ZEXCEPT: AddrToHostName,INetInfo,TextAddrToBinary ;Kernel exemption for Cache Objects
"RTN","XLFNSLK",21,0)
 N X,Y
"RTN","XLFNSLK",22,0)
 I $$VERSION^%ZOSV(1)["Cache" D  Q Y
"RTN","XLFNSLK",23,0)
 . S X=$SYSTEM.INetInfo.TextAddrToBinary(IP)
"RTN","XLFNSLK",24,0)
 . S Y=$SYSTEM.INetInfo.AddrToHostName(X)
"RTN","XLFNSLK",25,0)
 ;Enter code for non-Cache systems here:
"RTN","XLFNSLK",26,0)
 I +$SY=47 N RESULT D  Q RESULT
"RTN","XLFNSLK",27,0)
 . S RESULT=$$RETURN^%ZOSV("dig -x "_IP_" +noall +answer +short") ; reverse DNS. MUST HAVE A REVERSE DNS RECORD
"RTN","XLFNSLK",28,0)
 . S $E(RESULT,$L(RESULT))="" ; Strip Last Character
"RTN","XLFNSLK",29,0)
 Q ""
"RTN","XLFNSLK",30,0)
 ;
"RTN","XLFNSLK",31,0)
ADDRESS(N,T) ;Get a IP address from a name
"RTN","XLFNSLK",32,0)
 ;ZEXCEPT: HostNameToAddr,INetInfo ;Kernel exemption for Cache Objects
"RTN","XLFNSLK",33,0)
 N X,XLF,Y,I S XLF="",Y=0
"RTN","XLFNSLK",34,0)
 I $$VERSION^XLFIPV S T=$G(T,"AAAA")
"RTN","XLFNSLK",35,0)
 E  S T=$G(T,"A") ; change default to "A" if VistA has IPv6 disabled
"RTN","XLFNSLK",36,0)
 I ($$VERSION^%ZOSV(1)["Cache")&((T="A")!(T="AAAA")) D  Q Y
"RTN","XLFNSLK",37,0)
 . I T="AAAA" D
"RTN","XLFNSLK",38,0)
 . . S X=$SYSTEM.INetInfo.HostNameToAddr(N,2,0) ;Get IPv6 address
"RTN","XLFNSLK",39,0)
 . . S Y=$$FORCEIP6^XLFIPV(X) ;Format IPv6 address
"RTN","XLFNSLK",40,0)
 . I ($P(Y,":")="0000")!(T="A") S Y=$SYSTEM.INetInfo.HostNameToAddr(N,1,0) ;Get IPv4 address
"RTN","XLFNSLK",41,0)
 I +$SY=47 D  Q Y
"RTN","XLFNSLK",42,0)
 . I (T="AAAA") S Y=$$FORCEIP6^XLFIPV($$RETURN^%ZOSV("dig "_T_" "_N_" +noall +answer +short")) QUIT  ; return the last ip address in the list
"RTN","XLFNSLK",43,0)
 . I (T="A") S Y=$$FORCEIP4^XLFIPV($$RETURN^%ZOSV("dig "_T_" "_N_" +noall +answer +short")) QUIT  ; return the last ip address in the list
"RTN","XLFNSLK",44,0)
 ;Non-cache/GT.M systems and lookups other than "A" or "AAAA"
"RTN","XLFNSLK",45,0)
 D NS(.XLF,N,T)
"RTN","XLFNSLK",46,0)
 S Y="" F I=1:1:XLF("ANCOUNT") S:$D(XLF("AN"_I_"DATA")) Y=Y_XLF("AN"_I_"DATA")_","
"RTN","XLFNSLK",47,0)
 Q $E(Y,1,$L(Y)-1)
"RTN","XLFNSLK",48,0)
 ;
"RTN","XLFNSLK",49,0)
MAIL(RET,N) ;Get the MX address for a domain
"RTN","XLFNSLK",50,0)
 ;RET is the return array
"RTN","XLFNSLK",51,0)
 N XLF,Y,I,T S XLF="",T="MX"
"RTN","XLFNSLK",52,0)
 D NS(.XLF,N,T)
"RTN","XLFNSLK",53,0)
 S RET=0,I=0 F  S I=$O(XLF("P",I)) Q:I'>0  D
"RTN","XLFNSLK",54,0)
 . S N=XLF("P",I),RET(I)=N_"^"_$G(XLF("B",N)),RET=RET+1
"RTN","XLFNSLK",55,0)
 Q
"RTN","XLFNSLK",56,0)
 ;
"RTN","XLFNSLK",57,0)
NS(XL,NAME,QTYPE,XLFLOG) ;NAME LOOKUP
"RTN","XLFNSLK",58,0)
 ;XL is the return array, NAME is the name to lookup,
"RTN","XLFNSLK",59,0)
 ;QTYPE is type of lookup, XLFLOG is a debug array returned.
"RTN","XLFNSLK",60,0)
 N RI,DNS,CNT,POP N:'$D(XLFLOG) XLFLOG S XL("ANCOUNT")=0,CNT=1
"RTN","XLFNSLK",61,0)
 D SAVEDEV
"RTN","XLFNSLK",62,0)
NS2 ;
"RTN","XLFNSLK",63,0)
 S DNS=$$GETDNS(CNT) I DNS="" G EXIT
"RTN","XLFNSLK",64,0)
 D LOG("Call server: "_DNS)
"RTN","XLFNSLK",65,0)
 D CALL^%ZISTCP(DNS,53) I POP S CNT=CNT+1 G NS2
"RTN","XLFNSLK",66,0)
 D LOG("Got connection, Send message")
"RTN","XLFNSLK",67,0)
 D BUILD(NAME,$G(QTYPE,"AAAA")),LOG("Wait for reply")  ; Uses "AAAA" type for IPv6 if QTYPE is not defined
"RTN","XLFNSLK",68,0)
 ;Close part of READ
"RTN","XLFNSLK",69,0)
 D READ,DECODE
"RTN","XLFNSLK",70,0)
 D RESDEV,LOG("Returned question: "_$G(XL("QD1NAME")))
"RTN","XLFNSLK",71,0)
 Q
"RTN","XLFNSLK",72,0)
EXIT D RESDEV
"RTN","XLFNSLK",73,0)
 Q
"RTN","XLFNSLK",74,0)
 ;
"RTN","XLFNSLK",75,0)
BUILD(Y,T) ;BUILD A QUERY
"RTN","XLFNSLK",76,0)
 ; ID,PARAM,#of?, #ofA, #of Auth, #of add,
"RTN","XLFNSLK",77,0)
 N X,%,MSG,I
"RTN","XLFNSLK",78,0)
 S X=" M"_$C(1,0)_$C(0,1)_$C(0,0)_$C(0,0)_$C(0,0) ;Header
"RTN","XLFNSLK",79,0)
 I $E(Y,$L(Y))'="." S:$E(Y,$L(Y))'="." Y=Y_"."
"RTN","XLFNSLK",80,0)
 F I=1:1:$L(Y,".") S %=$P(Y,".",I) S:$L(%) X=X_$C($L(%))_% ;FQDN Address
"RTN","XLFNSLK",81,0)
 S X=X_$C(0) ;End of FQDN address
"RTN","XLFNSLK",82,0)
 ;Type A=1, NS=2, CNAME=5, MX=15, AAAA=28
"RTN","XLFNSLK",83,0)
 S MSG=X_$C(0,$$TYPECODE(T))_$C(0,1) ;type and class
"RTN","XLFNSLK",84,0)
 D LOG("msg: "_MSG)
"RTN","XLFNSLK",85,0)
 U IO S %=$L(MSG) W $C(%\256,%#256)_MSG,!
"RTN","XLFNSLK",86,0)
 Q
"RTN","XLFNSLK",87,0)
READ ;
"RTN","XLFNSLK",88,0)
 ;ZEXCEPT: I,RI,XL ;Global variables within this routine
"RTN","XLFNSLK",89,0)
 N L1,L2,X,$ET S $ET="G RDERR" K RI S RI=0
"RTN","XLFNSLK",90,0)
 U IO R L1#2:20 I '$T D LOG("Time-out") G RDERR
"RTN","XLFNSLK",91,0)
 S RI=$A(L1,1)*256+$A(L1,2) ;get msg length
"RTN","XLFNSLK",92,0)
 F I=1:1:6 R L2#2:20 Q:'$T  S XL($P("ID^CODE^QDCOUNT^ANCOUNT^NSCOUNT^ARCOUNT","^",I))=$S(I>2:$$WBN(L2),I=2:$$BIN16(L2),1:L2)
"RTN","XLFNSLK",93,0)
 I '$T D LOG("Time-out") G RDERR
"RTN","XLFNSLK",94,0)
 D LOG("Return msg length: "_RI)
"RTN","XLFNSLK",95,0)
 F I=13:1:RI U IO R *X:20 Q:'$T  S RI(I)=X ;or use X#1 and $A(X)
"RTN","XLFNSLK",96,0)
RDERR ;End of read
"RTN","XLFNSLK",97,0)
 D CLOSE^%ZISTCP
"RTN","XLFNSLK",98,0)
 Q
"RTN","XLFNSLK",99,0)
DECODE ;
"RTN","XLFNSLK",100,0)
 ;ZEXCEPT: XL ;Global variable within this routine
"RTN","XLFNSLK",101,0)
 N I,IX,X,Y,Z,NN,NN2 Q:RI'>7
"RTN","XLFNSLK",102,0)
 I $G(XL("ID"))'=" M" S XL("ERR")="Bad Response" D LOG(XL("ERR")) Q
"RTN","XLFNSLK",103,0)
 ;Decode the header
"RTN","XLFNSLK",104,0)
 S Z=XL("CODE"),XL("QR")=$E(Z,1),XL("Opcode")=$E(Z,2,5),XL("AA")=$E(Z,6),XL("TC")=$E(Z,7),XL("RD")=$E(Z,8),XL("RA")=$E(Z,9),XL("RCODE")=$E(Z,13,16)
"RTN","XLFNSLK",105,0)
 ;The Question section
"RTN","XLFNSLK",106,0)
 S IX=13
"RTN","XLFNSLK",107,0)
 F NN2=1:1:XL("QDCOUNT") D QD("QD"_NN2)
"RTN","XLFNSLK",108,0)
 F NN="AN","NS","AR" I $G(XL(NN_"COUNT")) F NN2=1:1:XL(NN_"COUNT") D RR(NN_NN2)
"RTN","XLFNSLK",109,0)
 Q
"RTN","XLFNSLK",110,0)
 ;
"RTN","XLFNSLK",111,0)
QD(NSP) ;Decode the Question section
"RTN","XLFNSLK",112,0)
 ;ZEXCEPT: IX,RI,XL ;Global variables within this routine
"RTN","XLFNSLK",113,0)
 N Y
"RTN","XLFNSLK",114,0)
 S Y="",IX=IX+$$NAME(IX,.Y,1),XL(NSP_"NAME")=Y
"RTN","XLFNSLK",115,0)
 S XL(NSP_"TYPE")=$$BN(RI(IX),RI(IX+1)),IX=IX+2
"RTN","XLFNSLK",116,0)
 S XL(NSP_"CLASS")=$$BN(RI(IX),RI(IX+1)),IX=IX+2
"RTN","XLFNSLK",117,0)
 Q
"RTN","XLFNSLK",118,0)
RR(NSP) ;
"RTN","XLFNSLK",119,0)
 ;ZEXCEPT: IX,RI,X,XL ;Global variables within this routine
"RTN","XLFNSLK",120,0)
 N Y,NA
"RTN","XLFNSLK",121,0)
 S Y="",IX=IX+$$NAME(IX,.Y,1),XL(NSP_"NAME")=Y,NA=Y
"RTN","XLFNSLK",122,0)
 S XL(NSP_"TYPE")=$$BN(RI(IX),RI(IX+1)),IX=IX+2
"RTN","XLFNSLK",123,0)
 S XL(NSP_"CLASS")=$$BN(RI(IX),RI(IX+1)),IX=IX+2
"RTN","XLFNSLK",124,0)
 S Y=RI(IX)*256+RI(IX+1),Y=Y*256+RI(IX+2),Y=Y*256+RI(IX+3)
"RTN","XLFNSLK",125,0)
 S XL(NSP_"TTL")=Y,IX=IX+4
"RTN","XLFNSLK",126,0)
 S (X,XL(NSP_"LENGTH"))=$$BN(RI(IX),RI(IX+1)),IX=IX+2 Q:X=0
"RTN","XLFNSLK",127,0)
 I XL(NSP_"TYPE")=1 D                                                                       ; IPv4 address
"RTN","XLFNSLK",128,0)
 . S XL(NSP_"DATA")=RI(IX)_"."_RI(IX+1)_"."_RI(IX+2)_"."_RI(IX+3),XL("B",NA)=XL(NSP_"DATA")
"RTN","XLFNSLK",129,0)
 I XL(NSP_"TYPE")=28 D                                                                      ; IPv6 address
"RTN","XLFNSLK",130,0)
 . S XL(NSP_"DATA")=$$H1(RI(IX))_$$H1(RI(IX+1))_":"_$$H1(RI(IX+2))_$$H1(RI(IX+3))_":"
"RTN","XLFNSLK",131,0)
 . S XL(NSP_"DATA")=XL(NSP_"DATA")_$$H1(RI(IX+4))_$$H1(RI(IX+5))_":"_$$H1(RI(IX+6))_$$H1(RI(IX+7))_":"
"RTN","XLFNSLK",132,0)
 . S XL(NSP_"DATA")=XL(NSP_"DATA")_$$H1(RI(IX+8))_$$H1(RI(IX+9))_":"_$$H1(RI(IX+10))_$$H1(RI(IX+11))_":"
"RTN","XLFNSLK",133,0)
 . S XL(NSP_"DATA")=XL(NSP_"DATA")_$$H1(RI(IX+12))_$$H1(RI(IX+13))_":"_$$H1(RI(IX+14))_$$H1(RI(IX+15))
"RTN","XLFNSLK",134,0)
 . S XL("B",NA)=XL(NSP_"DATA")
"RTN","XLFNSLK",135,0)
 I XL(NSP_"TYPE")=15 D MX(IX)                                                               ; MX entry
"RTN","XLFNSLK",136,0)
 S IX=IX+XL(NSP_"LENGTH")
"RTN","XLFNSLK",137,0)
 Q
"RTN","XLFNSLK",138,0)
NAME(I,NM,F) ;Decode a NAME section
"RTN","XLFNSLK",139,0)
 ;ZEXCEPT: RI ;Global variable within this routine
"RTN","XLFNSLK",140,0)
 N P,T,Y,X S NM=$G(NM) S:F T=0
"RTN","XLFNSLK",141,0)
 F  S X=RI(I) S:(X=0)&F T=T+1 Q:X=0  D  Q:X=0  ;Use X as flag to escape recursion.
"RTN","XLFNSLK",142,0)
 . I (X\64)=3 S X=$$NAME((X#64)*256+RI(I+1)+1,.NM,0),X=0 S:F T=T+2 Q
"RTN","XLFNSLK",143,0)
 . S NM=NM_$$PART(I+1,X),I=I+X+1 S:F T=T+X+1
"RTN","XLFNSLK",144,0)
 Q $G(T)
"RTN","XLFNSLK",145,0)
 ;
"RTN","XLFNSLK",146,0)
MX(IX) ;Hide IX changes
"RTN","XLFNSLK",147,0)
 ;ZEXCEPT: NSP,RI,XL ;Global variables within this routine
"RTN","XLFNSLK",148,0)
 N Y S Y=$$BN(RI(IX),RI(IX+1))
"RTN","XLFNSLK",149,0)
 F  Q:'$D(XL("P",Y))  S Y=Y+1
"RTN","XLFNSLK",150,0)
 S XL(NSP_"PREF")=Y,IX=IX+2
"RTN","XLFNSLK",151,0)
 S Y="",IX=IX+$$NAME(IX,.Y,1),XL(NSP_"NAME")=Y,XL("P",XL(NSP_"PREF"))=Y
"RTN","XLFNSLK",152,0)
 Q
"RTN","XLFNSLK",153,0)
 ;
"RTN","XLFNSLK",154,0)
BN(Z1,Z2) ;Convert two binary char 16 bit number into ASCII number
"RTN","XLFNSLK",155,0)
 Q Z1*256+Z2
"RTN","XLFNSLK",156,0)
 ;
"RTN","XLFNSLK",157,0)
WBN(Z1) ;Convert two byte string to a ASCII number
"RTN","XLFNSLK",158,0)
 Q $A(Z1,1)*256+$A(Z1,2)
"RTN","XLFNSLK",159,0)
 ;
"RTN","XLFNSLK",160,0)
H2(Z2) ;Convert 2 byte string to HEX
"RTN","XLFNSLK",161,0)
 N B S B=$A(Z2,1)*256+$A(Z2,2)
"RTN","XLFNSLK",162,0)
 Q $$H(B)
"RTN","XLFNSLK",163,0)
 ;
"RTN","XLFNSLK",164,0)
H1(Z1) ;Convert decimal number <= 256 to two digit HEX number
"RTN","XLFNSLK",165,0)
 N Y S Y=$$CNV^XLFUTL(Z1,16)
"RTN","XLFNSLK",166,0)
 Q $$RJ^XLFSTR(Y,2,"0")
"RTN","XLFNSLK",167,0)
 ;
"RTN","XLFNSLK",168,0)
H(Z1) Q $$BASE^XLFUTL(Z1,10,16)
"RTN","XLFNSLK",169,0)
 ;
"RTN","XLFNSLK",170,0)
BIN16(S) ;Convert two byte string to 16 bit binary
"RTN","XLFNSLK",171,0)
 N K,Y S S=$A(S,1)*256+$A(S,2),Y=""
"RTN","XLFNSLK",172,0)
 F K=0:1:15 S Y=(S\(2**K)#2)_Y
"RTN","XLFNSLK",173,0)
 Q Y
"RTN","XLFNSLK",174,0)
 ;
"RTN","XLFNSLK",175,0)
PART(S,L) ;
"RTN","XLFNSLK",176,0)
 ;ZEXCEPT: RI ;Global variable within this routine
"RTN","XLFNSLK",177,0)
 N R,A S R="" F A=S:1:S+L-1 S R=R_$C(RI(A))
"RTN","XLFNSLK",178,0)
 Q R_"."
"RTN","XLFNSLK",179,0)
 ;
"RTN","XLFNSLK",180,0)
TYPECODE(T) ;
"RTN","XLFNSLK",181,0)
 ;1=A:IPv4 address,2=NS:nameserver,5=CNAME,15=MX:mail exchange,28=AAAA:IPv6 address
"RTN","XLFNSLK",182,0)
 I +T Q $S(T=1:"A",T=2:"NS",T=5:"CNAME",T=15:"MX",T=28:"AAAA",1:"ZZ")
"RTN","XLFNSLK",183,0)
 Q $S(T="A":1,T="NS":2,T="CNAME":5,T="MX":15,T="AAAA":28,1:1)
"RTN","XLFNSLK",184,0)
 ;
"RTN","XLFNSLK",185,0)
CLASS(T) ;
"RTN","XLFNSLK",186,0)
 Q $S(T=1:"IN",1:"ZZ")
"RTN","XLFNSLK",187,0)
 ;
"RTN","XLFNSLK",188,0)
GETDNS(I) ;Get the address of our DNS
"RTN","XLFNSLK",189,0)
 N L S L=$G(^XTV(8989.3,1,"DNS"))
"RTN","XLFNSLK",190,0)
 Q $P(L,",",I)
"RTN","XLFNSLK",191,0)
 ;
"RTN","XLFNSLK",192,0)
SW(T,H,V) ;
"RTN","XLFNSLK",193,0)
 W ?T,$J(H,8),V
"RTN","XLFNSLK",194,0)
 Q
"RTN","XLFNSLK",195,0)
SAVEDEV ;Save calling device
"RTN","XLFNSLK",196,0)
 D:'$D(IO(0)) HOME^%ZIS D SAVDEV^%ZISUTL("XLFNSLK")
"RTN","XLFNSLK",197,0)
 Q
"RTN","XLFNSLK",198,0)
RESDEV ;Restore calling device
"RTN","XLFNSLK",199,0)
 D USE^%ZISUTL("XLFNSLK"),RMDEV^%ZISUTL("XLFNSLK")
"RTN","XLFNSLK",200,0)
 K IO("CLOSE")
"RTN","XLFNSLK",201,0)
 Q
"RTN","XLFNSLK",202,0)
LOG(M,XLFLOG) ;Log Debug messages
"RTN","XLFNSLK",203,0)
 ;ZEXCEPT: XLFLOG ;Global variable within this routine
"RTN","XLFNSLK",204,0)
 S XLFLOG=$G(XLFLOG)+1,XLFLOG(XLFLOG)=M
"RTN","XLFNSLK",205,0)
 Q
"RTN","XLFNSLK",206,0)
 ;
"RTN","XQ82")
0^6^B15534691
"RTN","XQ82",1,0)
XQ82 ;SF-ISC.SEA/JLI - CLEAN OLD $JOB DATA OUT OF XUTL("XQ", & OTHERS ;2017-01-09  3:27 PM
"RTN","XQ82",2,0)
 ;;8.0;KERNEL;**59,67,157,258,312,353,542,554,638,10001**;Jul 10, 1995;Build 21
"RTN","XQ82",3,0)
 ; Submitted to OSEHRA in 2017 by Sam Habiel for OSEHRA
"RTN","XQ82",4,0)
 ; Original Routine authored by Department of Veterans Affairs
"RTN","XQ82",5,0)
 ; EPs DEAD and CHECK GT.M support by Sam Habiel 2016.
"RTN","XQ82",6,0)
 ;
"RTN","XQ82",7,0)
 ;Make sure that can run from a DCL script
"RTN","XQ82",8,0)
 N A,X,%DT,Y,J,K,DDATE,HDATE,HJOB,HPID3,XQOS,XQVND
"RTN","XQ82",9,0)
 S U="^",DT=$$DT^XLFDT
"RTN","XQ82",10,0)
 S HDATE=$H-7 ;Get seven days ago in $H days
"RTN","XQ82",11,0)
 S DDATE=$$HTFM^XLFDT(HDATE) ;Get seven days ago in FM format
"RTN","XQ82",12,0)
 S XQVND=^%ZOSF("OS"),XQOS=$$OS^%ZOSV,HPID3=$$CNV^XLFUTL($J,16)
"RTN","XQ82",13,0)
 S HJOB=$J,DILOCKTM=$G(DILOCKTM,+$G(^DD("DILOCKTM"),1))
"RTN","XQ82",14,0)
 ;Do work as a set of sub routines
"RTN","XQ82",15,0)
 D L0,L1,L2,L3,L4,L5,L6,L7,L8
"RTN","XQ82",16,0)
EXIT ;
"RTN","XQ82",17,0)
 Q
"RTN","XQ82",18,0)
L0 ;We keep track of jobs by putting data in ^XUTL("XQ",$J).
"RTN","XQ82",19,0)
 ;Sign-on time is in ^($J,0) points to sign-on log.
"RTN","XQ82",20,0)
 ;Holds the Menu stack.
"RTN","XQ82",21,0)
 ;For any entry in user stack '^XUTL("XQ",$J)' w/ date older than 7 days or w/o zero node
"RTN","XQ82",22,0)
 ;kill XUTL("XQ",n) and corresponding UTILITY(n), TMP(n), & XUTL(n) nodes.
"RTN","XQ82",23,0)
 ;Long running jobs should call TOUCH^XUSCLEAN once a day to update KEEPALIVE.
"RTN","XQ82",24,0)
 N %T S J=0
"RTN","XQ82",25,0)
 F  S J=$O(^XUTL("XQ",J)) Q:J'>0  I $S('$D(^(J,0)):1,1:^(0)<DDATE) D
"RTN","XQ82",26,0)
 . I '$D(^XUTL("XQ",J,0)) K ^XUTL("XQ",J) Q  ;Missing zero node
"RTN","XQ82",27,0)
 . I $G(^XUTL("XQ",J,"KEEPALIVE"))>HDATE Q  ;For long running jobs
"RTN","XQ82",28,0)
 . I $D(^XUTL("XQ",J,"ZTSKNUM")) L +^%ZTSCH("TASK",^XUTL("XQ",J,"ZTSKNUM")):DILOCKTM Q:'$T  L -^%ZTSCH("TASK",^XUTL("XQ",J,"ZTSKNUM"))
"RTN","XQ82",29,0)
 . K ^XUTL("XQ",J),^UTILITY(J),^TMP(J),^XUTL(J)
"RTN","XQ82",30,0)
 . Q
"RTN","XQ82",31,0)
 Q:'$$CHECK  ;Check if we should skip pass 2.
"RTN","XQ82",32,0)
 ;Now to check again for DEAD jobs on local node
"RTN","XQ82",33,0)
 F J=0:0 S J=$O(^XUTL("XQ",J)) Q:J'>0  D
"RTN","XQ82",34,0)
 . I $$DEAD(J) K ^XUTL("XQ",J),^UTILITY(J),^TMP(J),^XUTL(J)
"RTN","XQ82",35,0)
 Q
"RTN","XQ82",36,0)
 ;
"RTN","XQ82",37,0)
L1 ;Loop thru UTILITY and look for nodes w/o corresponding XUTL("XQ",n)
"RTN","XQ82",38,0)
 N A,J
"RTN","XQ82",39,0)
 S A="" F  S A=$O(^UTILITY(A)) Q:A=""  D
"RTN","XQ82",40,0)
 . I A>0,'$D(^XUTL("XQ",A)) K ^UTILITY(A) Q  ;UTILITY($J) w/o XUTL("XQ",$J) node.
"RTN","XQ82",41,0)
 . Q:A>0  Q:"^ROU^GLO^LRLTR^"[("^"_A_"^")
"RTN","XQ82",42,0)
 . F J=0:0 S J=$O(^UTILITY(A,J)) Q:J'>0  I '$D(^XUTL("XQ",J)) K ^UTILITY(A,J) ;Remove UTILITY(namespace,$J) w/o XUTL("XQ",$J)
"RTN","XQ82",43,0)
 . Q
"RTN","XQ82",44,0)
 Q
"RTN","XQ82",45,0)
 ;
"RTN","XQ82",46,0)
L2 ;Loop thru TMP and look for nodes w/o corresponding XUTL("XQ",n)
"RTN","XQ82",47,0)
 N A,J
"RTN","XQ82",48,0)
 S A="" F  S A=$O(^TMP(A)) Q:A=""  D
"RTN","XQ82",49,0)
 . I A>0,'$D(^XUTL("XQ",A)) K ^TMP(A) Q  ;TMP($J) w/o XUTL("XQ",$J) node.
"RTN","XQ82",50,0)
 . Q:A>0  ;Q:"^ROU^GLO^LRLTR^"[("^"_A_"^")
"RTN","XQ82",51,0)
 . F J=0:0 S J=$O(^TMP(A,J)) Q:J'>0  I '$D(^XUTL("XQ",J)) K ^TMP(A,J) ;Remove TMP(namespace,$J) w/o XUTL("XQ",$J)
"RTN","XQ82",52,0)
 . Q
"RTN","XQ82",53,0)
 Q
"RTN","XQ82",54,0)
 ;
"RTN","XQ82",55,0)
L3 ;Now to cleanup the XTMP global w/ XTMP(namespace,0)<DT
"RTN","XQ82",56,0)
 N A,J
"RTN","XQ82",57,0)
 S A="" F  S A=$O(^XTMP(A)) Q:A=""  S J=$G(^XTMP(A,0)) I J<DT K ^XTMP(A)
"RTN","XQ82",58,0)
 Q
"RTN","XQ82",59,0)
 ;
"RTN","XQ82",60,0)
L4 ;Now go thru and clean old ^XUSEC(0,"CUR",duz,sign-on) nodes.
"RTN","XQ82",61,0)
 D L51("CUR")
"RTN","XQ82",62,0)
 Q
"RTN","XQ82",63,0)
 ;
"RTN","XQ82",64,0)
L5 ;Now go through and clean old ^XUSEC(0,"AS*" nodes.
"RTN","XQ82",65,0)
 D L51("AS1"),L51("AS2"),L51("AS4")
"RTN","XQ82",66,0)
 Q
"RTN","XQ82",67,0)
 ;
"RTN","XQ82",68,0)
L6 ;Clean out old build nodes from ^XUTL
"RTN","XQ82",69,0)
 N K
"RTN","XQ82",70,0)
 S K=""
"RTN","XQ82",71,0)
 F  S K=$O(^XUTL("XQO",K)) Q:K=""  D
"RTN","XQ82",72,0)
 . I $D(^XUTL("XQO",K,"^BUILD")),($P($H,",",2)-^("^BUILD")>1800)!(^("^BUILD")>$P($H,",",2)) K ^("^BUILD")
"RTN","XQ82",73,0)
 Q
"RTN","XQ82",74,0)
 ;
"RTN","XQ82",75,0)
L7 ;Kill ^DISV for TERMINATED or DISUSER Users.
"RTN","XQ82",76,0)
 N DA,USER
"RTN","XQ82",77,0)
 S DA="",U="^"
"RTN","XQ82",78,0)
 F  S DA=$O(^DISV(DA)) Q:DA=""  S USER=$$ACTIVE^XUSER(DA) I '(+USER) K ^DISV(DA)
"RTN","XQ82",79,0)
 Q
"RTN","XQ82",80,0)
 ;
"RTN","XQ82",81,0)
L8 ;Loop top level of ^XUTL
"RTN","XQ82",82,0)
 N A
"RTN","XQ82",83,0)
 S A=0
"RTN","XQ82",84,0)
 F  S A=$O(^XUTL(A)) Q:'A  I '$D(^XUTL("XQ",A)) K ^XUTL(A)
"RTN","XQ82",85,0)
 Q
"RTN","XQ82",86,0)
 ;
"RTN","XQ82",87,0)
L51(NDX) ;Clean old Sign-on log entries from X-ref
"RTN","XQ82",88,0)
 N I,J,FDA,NOW,ERR,IEN
"RTN","XQ82",89,0)
 S I="",NOW=$$NOW^XLFDT
"RTN","XQ82",90,0)
 F  S I=$O(^XUSEC(0,NDX,I)) Q:I=""  F J=0:0 S J=$O(^XUSEC(0,NDX,I,J)) Q:(J'>0)  D
"RTN","XQ82",91,0)
 . ;Look at every entry in the X-ref, check for data record
"RTN","XQ82",92,0)
 . I $D(^XUSEC(0,J,0))[0 K ^XUSEC(0,NDX,I,J) Q  ;No data record.
"RTN","XQ82",93,0)
 . Q:J'<DDATE  ;Keep for now
"RTN","XQ82",94,0)
 . S FDA(3.081,J_",",3)=NOW,FDA(3.081,J_",",16)=1 D UPDATE^DIE("","FDA","IEN","ERR")
"RTN","XQ82",95,0)
 . K FDA,IEN,ERR
"RTN","XQ82",96,0)
 . Q
"RTN","XQ82",97,0)
 Q
"RTN","XQ82",98,0)
 ;
"RTN","XQ82",99,0)
DEAD(X1) ;Check if X1 is a PID and DEAD
"RTN","XQ82",100,0)
 ;Return 1 if should clean, 0 to skip
"RTN","XQ82",101,0)
 I X1\1'=X1 Q 0
"RTN","XQ82",102,0)
 ;a PID on VMS has a part that is fixed, not so under Linux so the following line was dropped.
"RTN","XQ82",103,0)
 I XQOS="VMS",$E($$CNV^XLFUTL(X1,16),1,3)'=$E(HPID3,1,3) Q 0
"RTN","XQ82",104,0)
 ;We should only come here
"RTN","XQ82",105,0)
 ;is X1 a PID on this node and is PID active?..
"RTN","XQ82",106,0)
 I $ZV["GT.M" Q $ZGETJPI(X1,"ISPROCALIVE") ; OSEHRA/SMH - GT.M replacement for ^$J
"RTN","XQ82",107,0)
 I $D(^$JOB(X1))=0 Q 1 ; Job is DEAD
"RTN","XQ82",108,0)
 Q 0
"RTN","XQ82",109,0)
 ;
"RTN","XQ82",110,0)
CHECK() ;Check that we have the right enviroment to do pass 2
"RTN","XQ82",111,0)
 ;GTM must be on one big box.
"RTN","XQ82",112,0)
 I XQVND["GT.M" Q 1 ; OSEHRA/SMH - GT.M allows you to check if a job exists.
"RTN","XQ82",113,0)
 ;Are we on Cache, ^$JOB is supported.
"RTN","XQ82",114,0)
 ;Get value of LOCAL TMP (.07) to see if ^TMP, ^UTILITY and ^XUTL("XQ" are local.
"RTN","XQ82",115,0)
 I XQVND["OpenM" Q +$P($G(^XTV(8989.3,1,0)),"^",7) ;p554
"RTN","XQ82",116,0)
 Q 0
"RTN","XQ82",117,0)
 ;
"RTN","XU810001")
0^^B1808494
"RTN","XU810001",1,0)
XU810001 ; VEN/SMH - XU*8.0*10001 Pre/Post Install;2017-01-09  3:36 PM
"RTN","XU810001",2,0)
 ;;8.0;KERNEL;**10001**;;Build 21
"RTN","XU810001",3,0)
 ; Submitted to OSEHRA in 2017 by Sam Habiel for OSEHRA
"RTN","XU810001",4,0)
 ; Authored by Sam Habiel 2016.
"RTN","XU810001",5,0)
PRE ; [KIDS PEP]
"RTN","XU810001",6,0)
 D MES^XPDUTL("Stopping Taskman...")
"RTN","XU810001",7,0)
 D GROUP^ZTMKU("SSUB(NODE)")
"RTN","XU810001",8,0)
 D GROUP^ZTMKU("SMAN(NODE)")
"RTN","XU810001",9,0)
 D MES^XPDUTL("Waiting around until Taskman reports it's stopped")
"RTN","XU810001",10,0)
 F  W "." Q:($$TM^%ZTLOAD=0)  H 1
"RTN","XU810001",11,0)
 QUIT
"RTN","XU810001",12,0)
 ;
"RTN","XU810001",13,0)
POST ; [KIDS PEP]
"RTN","XU810001",14,0)
 D PATCH^ZTMGRSET(10001)
"RTN","XU810001",15,0)
 ;
"RTN","XU810001",16,0)
 D MES^XPDUTL("Renaming ZUGTM...")
"RTN","XU810001",17,0)
 D DO^ZUSET("ZUGTM")
"RTN","XU810001",18,0)
 ;
"RTN","XU810001",19,0)
 N Y D GETENV^%ZOSV
"RTN","XU810001",20,0)
 N UCIBOX S UCIBOX=$P(Y,U,4)
"RTN","XU810001",21,0)
 N IEN14P7 S IEN14P7=$O(^%ZIS(14.7," "),-1)
"RTN","XU810001",22,0)
 N FDA S FDA(14.7,IEN14P7_",",.01)=UCIBOX
"RTN","XU810001",23,0)
 N DIERR
"RTN","XU810001",24,0)
 D FILE^DIE(,$NA(FDA))
"RTN","XU810001",25,0)
 I $D(DIERR) D MES^XPDUTL("Failed to updated Taskman Site Parameters. You need to update manually.")
"RTN","XU810001",26,0)
 D MES^XPDUTL("Starting Taskman...")
"RTN","XU810001",27,0)
 D ^ZTMB
"RTN","XU810001",28,0)
 QUIT
"RTN","XUSHSH")
0^9^B42153441
"RTN","XUSHSH",1,0)
XUSHSH ;ISF/STAFF - ENCRYPTION/DECRYPTION UTILITIES ; 10/30/17 5:28pm
"RTN","XUSHSH",2,0)
 ;;8.0;KERNEL;**655,659,10001**;Jul 10, 1995;Build 21
"RTN","XUSHSH",3,0)
 ;Per VA Directive 6402, this routine should not be modified.
"RTN","XUSHSH",4,0)
 ; Submitted to OSEHRA in 2017 by Sam Habiel for OSEHRA
"RTN","XUSHSH",5,0)
 ; Original Routine authored by Department of Veterans Affairs but completely redacted.
"RTN","XUSHSH",6,0)
 ; All EPs authored by Sam Habiel 2016.
"RTN","XUSHSH",7,0)
 ;
"RTN","XUSHSH",8,0)
 ; Written by VEN/SMH - Verified against Cache code to return same result.
"RTN","XUSHSH",9,0)
 ;;
"RTN","XUSHSH",10,0)
 ;ZEXCEPT: X ;Returned global value when called as an extrinsic subroutine.
"RTN","XUSHSH",11,0)
 S X=$$EN(X)
"RTN","XUSHSH",12,0)
 Q
"RTN","XUSHSH",13,0)
 ;
"RTN","XUSHSH",14,0)
EN(X) ;Extrinsic function $$EN^XUSHSH(X), IA #4758
"RTN","XUSHSH",15,0)
 N XUA,XUI,XUJ,XUL,XUR,XUX,XUY,XUY1,XUZ D KE Q X
"RTN","XUSHSH",16,0)
 ;
"RTN","XUSHSH",17,0)
KE ;Intrinsic subroutine.
"RTN","XUSHSH",18,0)
 ;
"RTN","XUSHSH",19,0)
 ;
"RTN","XUSHSH",20,0)
 ;
"RTN","XUSHSH",21,0)
 Q
"RTN","XUSHSH",22,0)
 ;
"RTN","XUSHSH",23,0)
B ;Intrinsic subroutine.
"RTN","XUSHSH",24,0)
 ;
"RTN","XUSHSH",25,0)
 ;
"RTN","XUSHSH",26,0)
 ;
"RTN","XUSHSH",27,0)
 ;
"RTN","XUSHSH",28,0)
 ;
"RTN","XUSHSH",29,0)
C ;Intrinsic subroutine.
"RTN","XUSHSH",30,0)
 ;
"RTN","XUSHSH",31,0)
 ;
"RTN","XUSHSH",32,0)
 ;
"RTN","XUSHSH",33,0)
 ;
"RTN","XUSHSH",34,0)
 ;
"RTN","XUSHSH",35,0)
 ;
"RTN","XUSHSH",36,0)
 ;
"RTN","XUSHSH",37,0)
CL ;Intrinsic subroutine.
"RTN","XUSHSH",38,0)
 ;
"RTN","XUSHSH",39,0)
 ;
"RTN","XUSHSH",40,0)
 ;
"RTN","XUSHSH",41,0)
SHAHASH(N,X,FLAG) ;One-Way Hash Utility, IA #6189
"RTN","XUSHSH",42,0)
 ; N -> (Required) Length in bits of the desired hash:
"RTN","XUSHSH",43,0)
 ; 160 (SHA-1), 224 (SHA-224), 256 (SHA-256), 384 (SHA-384), or 512 (SHA-512)
"RTN","XUSHSH",44,0)
 ; X -> (Required) String to be hashed.
"RTN","XUSHSH",45,0)
 ; FLAG -> (Optional) Flag to control format of hash:
"RTN","XUSHSH",46,0)
 ; - "H" = Hexadecimal (default)
"RTN","XUSHSH",47,0)
 ; - "B" = Base64 Encoded
"RTN","XUSHSH",48,0)
 S FLAG=$G(FLAG,"H")
"RTN","XUSHSH",49,0)
 ;
"RTN","XUSHSH",50,0)
 ; Capital HASH is return
"RTN","XUSHSH",51,0)
 I $G(^%ZOSF("OS"))["OpenM" N HASH D  Q HASH
"RTN","XUSHSH",52,0)
 . n hash s hash=$system.Encryption.SHAHash(N,X)
"RTN","XUSHSH",53,0)
 . I FLAG="H" S HASH=##class(%xsd.hexBinary).LogicalToXSD(hash)
"RTN","XUSHSH",54,0)
 . E  S HASH=$$B64ENCD(hash)
"RTN","XUSHSH",55,0)
 ;
"RTN","XUSHSH",56,0)
 ; shasum has the -a argument:
"RTN","XUSHSH",57,0)
 ; -a, --algorithm   1 (default), 224, 256, 384, 512, 512224, 512256
"RTN","XUSHSH",58,0)
 N ALGO S ALGO=$S(N=160:1,1:N) ; Translate for shasum command
"RTN","XUSHSH",59,0)
 N %COMMAND,Y
"RTN","XUSHSH",60,0)
 S %COMMAND="shasum -t -a "_ALGO ; -t = --text
"RTN","XUSHSH",61,0)
 O "COMM":(SHELL="/bin/sh":COMM=%COMMAND)::"pipe"
"RTN","XUSHSH",62,0)
 U "COMM" W X S $X=0 W /EOF ; $X of 0 prevents the code from writing LF to the stream
"RTN","XUSHSH",63,0)
 F  R Y:0 Q:$L(Y)  Q:$ZEOF
"RTN","XUSHSH",64,0)
 U IO C "COMM"
"RTN","XUSHSH",65,0)
 S Y=$P(Y," ") ; shasum appends '  *-' to output.
"RTN","XUSHSH",66,0)
 N UPY S UPY=$$UP^XLFSTR(Y) ; uppercase to be in M friendly mode
"RTN","XUSHSH",67,0)
 I $G(FLAG)'="B" Q UPY      ; we are done if we don't need base64
"RTN","XUSHSH",68,0)
 ;
"RTN","XUSHSH",69,0)
 S %COMMAND="xxd -r -p | base64" ; convert to binary, then base64 encode
"RTN","XUSHSH",70,0)
 O "COMM":(SHELL="/bin/sh":COMM=%COMMAND)::"pipe"
"RTN","XUSHSH",71,0)
 U "COMM" W Y S $X=0 W /EOF ; $X of 0 prevents the code from writing LF to the stream
"RTN","XUSHSH",72,0)
 N B F  R B:0 Q:$L(B)  Q:$ZEOF
"RTN","XUSHSH",73,0)
 U IO C "COMM"
"RTN","XUSHSH",74,0)
 Q B
"RTN","XUSHSH",75,0)
 ;
"RTN","XUSHSH",76,0)
B64ENCD(X) ;Base 64 Encode, IA #6189
"RTN","XUSHSH",77,0)
 I $G(^%ZOSF("OS"))["OpenM" Q $System.Encryption.Base64Encode(X)
"RTN","XUSHSH",78,0)
 N %COMMAND,Y
"RTN","XUSHSH",79,0)
 S %COMMAND="base64"
"RTN","XUSHSH",80,0)
 O "COMM":(SHELL="/bin/sh":COMM=%COMMAND)::"pipe"
"RTN","XUSHSH",81,0)
 U "COMM" W X S $X=0 W /EOF ; $X of 0 prevents the code from writing LF to the stream
"RTN","XUSHSH",82,0)
 F  R Y:0 Q:$L(Y)  Q:$ZEOF
"RTN","XUSHSH",83,0)
 U IO C "COMM"
"RTN","XUSHSH",84,0)
 Q Y
"RTN","XUSHSH",85,0)
 ;
"RTN","XUSHSH",86,0)
B64DECD(X) ;Base 64 Decode, IA #6189
"RTN","XUSHSH",87,0)
 I $G(^%ZOSF("OS"))["OpenM" Q $System.Encryption.Base64Decode(X)
"RTN","XUSHSH",88,0)
 N %COMMAND,Y
"RTN","XUSHSH",89,0)
 S %COMMAND="base64 -d"
"RTN","XUSHSH",90,0)
 I $G(^%ZOSF("OS"))["GT.M",$$VERSION^%ZOSV(1)["Darwin" S %COMMAND="base64 -D"
"RTN","XUSHSH",91,0)
 O "COMM":(SHELL="/bin/sh":COMM=%COMMAND)::"pipe"
"RTN","XUSHSH",92,0)
 U "COMM" W X S $X=0 W /EOF ; $X of 0 prevents the code from writing LF to the stream
"RTN","XUSHSH",93,0)
 F  R Y:0 Q:$L(Y)  Q:$ZEOF
"RTN","XUSHSH",94,0)
 U IO C "COMM"
"RTN","XUSHSH",95,0)
 Q Y
"RTN","XUSHSH",96,0)
 ;
"RTN","XUSHSH",97,0)
RSAENCR(TEXT,CERT,CAFILE,CRLFILE,ENC) ;RSA Encrypt, IA #6189
"RTN","XUSHSH",98,0)
 ; TEXT (Required) Plaintext string to be encrypted
"RTN","XUSHSH",99,0)
 ; CERT (Required) An X.509 certificate containing the RSA 
"RTN","XUSHSH",100,0)
 ;  public key to be used for encryption, in PEM encoded or binary DER format.
"RTN","XUSHSH",101,0)
 ;  Note that the length of the plaintext can not be greater than the length of
"RTN","XUSHSH",102,0)
 ;  the modulus of the RSA public key contained in the certificate minus 42 bytes.
"RTN","XUSHSH",103,0)
 ; NB: OSE/SMH - This version takes a filename for the cert, not the cert itself!!!!
"RTN","XUSHSH",104,0)
 ; - Needed so that both GT.M/YDB and Cache will work the same way
"RTN","XUSHSH",105,0)
 ; CAFILE (Optional) The name of a file containing trusted
"RTN","XUSHSH",106,0)
 ;  Certificate Authority X.509 Certificates in PEM-encoded format, one of which
"RTN","XUSHSH",107,0)
 ;  was used to sign the Certificate.
"RTN","XUSHSH",108,0)
 ; CRLFILE (Optional) The name of a file containing X.509
"RTN","XUSHSH",109,0)
 ;  Certificate Revocation Lists in PEM-encoded format that should be checked to
"RTN","XUSHSH",110,0)
 ;  verify the status of the Certificate.
"RTN","XUSHSH",111,0)
 ; ENC (Optional) Encoding - PKCS #1 v2.1 encoding method:
"RTN","XUSHSH",112,0)
 ;  1 = OAEP (default)
"RTN","XUSHSH",113,0)
 ;  2 = PKCS1-v1_5
"RTN","XUSHSH",114,0)
 N RESULT S RESULT=""
"RTN","XUSHSH",115,0)
 I $G(^%ZOSF("OS"))["OpenM" D  Q RESULT
"RTN","XUSHSH",116,0)
 . S ENC=$G(ENC,1)
"RTN","XUSHSH",117,0)
 . N FILE S FILE=CERT
"RTN","XUSHSH",118,0)
 . S CERT=""
"RTN","XUSHSH",119,0)
 . N POP
"RTN","XUSHSH",120,0)
 . N D ; delimiter
"RTN","XUSHSH",121,0)
 . I FILE["/" S D="/"
"RTN","XUSHSH",122,0)
 . E  S D="\"
"RTN","XUSHSH",123,0)
 . N PATH S PATH=$P(FILE,D,1,$L(FILE,D)-1)_D
"RTN","XUSHSH",124,0)
 . N FN S FN=$P(FILE,D,$L(FILE,D))
"RTN","XUSHSH",125,0)
 . D OPEN^%ZISH("XUSHSH",PATH,FN,"R")
"RTN","XUSHSH",126,0)
 . I POP Q
"RTN","XUSHSH",127,0)
 . D USE^%ZISUTL("XUSHSH")
"RTN","XUSHSH",128,0)
 . N % F  R %:2  Q:$$STATUS^%ZISH()  S CERT=CERT_%_$C(10)
"RTN","XUSHSH",129,0)
 . D CLOSE^%ZISUTL("XUSHSH")
"RTN","XUSHSH",130,0)
 . S RESULT=$system.Encryption.RSAEncrypt(TEXT,CERT,$G(CAFILE),$G(CRLFILE),ENC)
"RTN","XUSHSH",131,0)
 ;
"RTN","XUSHSH",132,0)
 ; VEN/SMH:
"RTN","XUSHSH",133,0)
 ; 1. CAFILE and CRLFILE are used for revocation, which is hard to implement.
"RTN","XUSHSH",134,0)
 ; I didn't do it. You need to concatenate the PEM files into a single file
"RTN","XUSHSH",135,0)
 ; and then run openssl -verify -crl_check. This is just a bit too much for
"RTN","XUSHSH",136,0)
 ; what we want to do; but I think Harlan was just following the API.
"RTN","XUSHSH",137,0)
 ; See: https://raymii.org/s/articles/OpenSSL_manually_verify_a_certificate_against_a_CRL.html
"RTN","XUSHSH",138,0)
 ; 2. OpenSSL has deprecated rsautl, and pkeyutl doesn't have encoding options
"RTN","XUSHSH",139,0)
 N %CMD S %CMD="openssl pkeyutl -encrypt -certin -inkey "_CERT
"RTN","XUSHSH",140,0)
 O "COMM":(SHELL="/bin/sh":COMM=%CMD:FIXED:WRAP:CHSET="M")::"pipe" ; THESE PARAMETERS ARE IMPORTANT! I kept fiddling until I got them.
"RTN","XUSHSH",141,0)
 U "COMM" W TEXT S $X=0 W /EOF
"RTN","XUSHSH",142,0)
 N OUT
"RTN","XUSHSH",143,0)
 N Y
"RTN","XUSHSH",144,0)
 F  R Y:1 S OUT=$G(OUT)_Y Q:$ZEOF
"RTN","XUSHSH",145,0)
 U IO C "COMM"
"RTN","XUSHSH",146,0)
 Q OUT
"RTN","XUSHSH",147,0)
 ;
"RTN","XUSHSH",148,0)
RSADECR(TEXT,KEY,PWD,ENC) ;RSA Decrypt, IA #6189
"RTN","XUSHSH",149,0)
 ; TEXT (Required) Ciphertext string to be decrypted.
"RTN","XUSHSH",150,0)
 ; KEY  (Required) RSA private key corresponding to the RSA
"RTN","XUSHSH",151,0)
 ;  public key that was used for encryption, PEM encoded.
"RTN","XUSHSH",152,0)
 ; NB: OSE/SMH - This version takes a filename for the cert, not the cert itself!!!!
"RTN","XUSHSH",153,0)
 ; - Needed so that both GT.M/YDB and Cache will work the same way
"RTN","XUSHSH",154,0)
 ; PWD  (Optional) Private key password.
"RTN","XUSHSH",155,0)
 ; ENC  (Optional) Encoding - PKCS #1 v2.1 encoding method:
"RTN","XUSHSH",156,0)
 ;  1 = OAEP (default)
"RTN","XUSHSH",157,0)
 ;  2 = PKCS1-v1_5
"RTN","XUSHSH",158,0)
 ;
"RTN","XUSHSH",159,0)
 N RESULT S RESULT=""
"RTN","XUSHSH",160,0)
 I $G(^%ZOSF("OS"))["OpenM" D  Q RESULT
"RTN","XUSHSH",161,0)
 . S ENC=$G(ENC,1)
"RTN","XUSHSH",162,0)
 . N FILE S FILE=KEY
"RTN","XUSHSH",163,0)
 . S KEY=""
"RTN","XUSHSH",164,0)
 . N POP
"RTN","XUSHSH",165,0)
 . N D ; delimiter
"RTN","XUSHSH",166,0)
 . I FILE["/" S D="/"
"RTN","XUSHSH",167,0)
 . E  S D="\"
"RTN","XUSHSH",168,0)
 . N PATH S PATH=$P(FILE,D,1,$L(FILE,D)-1)_D
"RTN","XUSHSH",169,0)
 . N FN S FN=$P(FILE,D,$L(FILE,D))
"RTN","XUSHSH",170,0)
 . D OPEN^%ZISH("XUSHSH",PATH,FN,"R")
"RTN","XUSHSH",171,0)
 . I POP Q
"RTN","XUSHSH",172,0)
 . D USE^%ZISUTL("XUSHSH")
"RTN","XUSHSH",173,0)
 . N % F  R %:2  Q:$$STATUS^%ZISH()  S KEY=KEY_%_$C(10)
"RTN","XUSHSH",174,0)
 . D CLOSE^%ZISUTL("XUSHSH")
"RTN","XUSHSH",175,0)
 . S RESULT=$system.Encryption.RSADecrypt(TEXT,KEY,$G(PWD),ENC)
"RTN","XUSHSH",176,0)
 ;
"RTN","XUSHSH",177,0)
 ; VEN/SMH:
"RTN","XUSHSH",178,0)
 ; 1. See note above on why I don't support ENC
"RTN","XUSHSH",179,0)
 ;
"RTN","XUSHSH",180,0)
 N %CMD S %CMD="openssl pkeyutl -decrypt -inkey "_KEY_" "
"RTN","XUSHSH",181,0)
 I $G(PWD)'="" S %CMD=%CMD_"-passin pass:"_PWD
"RTN","XUSHSH",182,0)
 O "COMM":(SHELL="/bin/sh":COMM=%CMD:FIXED:WRAP:CHSET="M")::"pipe"
"RTN","XUSHSH",183,0)
 U "COMM" W TEXT S $X=0 W /EOF ; $X of 0 prevents the code from writing LF to the stream
"RTN","XUSHSH",184,0)
 N OUT
"RTN","XUSHSH",185,0)
 N Y
"RTN","XUSHSH",186,0)
 F  R Y:1 S OUT=$G(OUT)_Y Q:$ZEOF
"RTN","XUSHSH",187,0)
 U IO C "COMM"
"RTN","XUSHSH",188,0)
 Q OUT
"RTN","XUSHSH",189,0)
 ;
"RTN","XUSHSH",190,0)
AESENCR(TEXT,KEY,IV) ;AES Encrypt, IA #6189
"RTN","XUSHSH",191,0)
 ; TEXT (Required) Plaintext string to be encrypted
"RTN","XUSHSH",192,0)
 ; KEY  (Required) Input key material 16, 24, or 32
"RTN","XUSHSH",193,0)
 ; IV   (Required) Initialization vector. If this argument is present it must 
"RTN","XUSHSH",194,0)
 ;  be 16 characters long.
"RTN","XUSHSH",195,0)
 I $G(^%ZOSF("OS"))["OpenM" Q $system.Encryption.AESCBCEncrypt(TEXT,KEY,IV)
"RTN","XUSHSH",196,0)
 ;
"RTN","XUSHSH",197,0)
 N %CMD S %CMD="openssl enc -e -aes-256-cbc -K "_KEY_" -iv "_IV
"RTN","XUSHSH",198,0)
 O "COMM":(SHELL="/bin/sh":COMM=%CMD:FIXED:WRAP:CHSET="M")::"pipe"
"RTN","XUSHSH",199,0)
 U "COMM" W TEXT S $X=0 W /EOF
"RTN","XUSHSH",200,0)
 N OUT
"RTN","XUSHSH",201,0)
 N Y
"RTN","XUSHSH",202,0)
 F  R Y:1 S OUT=$G(OUT)_Y Q:$ZEOF
"RTN","XUSHSH",203,0)
 U IO C "COMM"
"RTN","XUSHSH",204,0)
 Q OUT
"RTN","XUSHSH",205,0)
 ;
"RTN","XUSHSH",206,0)
AESDECR(TEXT,KEY,IV) ;AES Decrypt, IA #6189
"RTN","XUSHSH",207,0)
 I $G(^%ZOSF("OS"))["OpenM" Q $system.Encryption.AESCBCDecrypt(TEXT,KEY,IV)
"RTN","XUSHSH",208,0)
 ;
"RTN","XUSHSH",209,0)
 N %CMD S %CMD="openssl enc -d -aes-256-cbc -K "_KEY_" -iv "_IV
"RTN","XUSHSH",210,0)
 O "COMM":(SHELL="/bin/sh":COMM=%CMD:FIXED:WRAP:CHSET="M")::"pipe"
"RTN","XUSHSH",211,0)
 U "COMM" W TEXT S $X=0 W /EOF
"RTN","XUSHSH",212,0)
 N OUT
"RTN","XUSHSH",213,0)
 N Y
"RTN","XUSHSH",214,0)
 F  R Y:1 S OUT=$G(OUT)_Y Q:$ZEOF
"RTN","XUSHSH",215,0)
 U IO C "COMM"
"RTN","XUSHSH",216,0)
 Q OUT
"RTN","XUSHSH",217,0)
 ;
"RTN","XUSHSH",218,0)
Z ;;
"RTN","XUSHSH",219,0)
 ;;
"RTN","XUSHSH",220,0)
 ;;
"RTN","XUSHSH",221,0)
 ;;
"RTN","XUSHSH",222,0)
 ;;
"RTN","XUSHSH",223,0)
 ;;
"RTN","XUSHSH",224,0)
 ;;
"RTN","XUSHSH",225,0)
 ;;
"RTN","XUSHSH",226,0)
 ;;
"RTN","XUSHSH",227,0)
 ;;
"RTN","XUSHSH",228,0)
 ;;
"RTN","XUSHSH",229,0)
 ;;
"RTN","XUSHSH",230,0)
 ;;
"RTN","XUSHSH",231,0)
 ;;
"RTN","XUSHSH",232,0)
 ;;
"RTN","XUSHSH",233,0)
 ;;
"RTN","XUSHSH",234,0)
 ;;
"RTN","XUSHSH",235,0)
 ;;
"RTN","XUSHSH",236,0)
 ;;
"RTN","XUSHSH",237,0)
 ;;
"RTN","XUSHSH",238,0)
 ;;
"RTN","XUSHSH",239,0)
 ;;
"RTN","ZISHGUX")
0^7^B84538989
"RTN","ZISHGUX",1,0)
%ZISH ;ISF/AC,RWF,VEN/SMH - GT.M for Unix Host file Control ;2018-06-06  1:47 PM
"RTN","ZISHGUX",2,0)
 ;;8.0;KERNEL;**275,306,385,524,10001,10002**;Jul 10, 1995;Build 21
"RTN","ZISHGUX",3,0)
 ; Submitted to OSEHRA in 2017 by Sam Habiel for OSEHRA
"RTN","ZISHGUX",4,0)
 ; Original Routine authored by Department of Veterans Affairs
"RTN","ZISHGUX",5,0)
 ; EPs OPEN,DEL1,CD,PWD,MAXREC,MKDIR,SIZE,WGETSYNC,DF,SEND,SENDTO1 
"RTN","ZISHGUX",6,0)
 ; --> authored by Sam Habiel 2016-2018.
"RTN","ZISHGUX",7,0)
 ; EPs MV,DEFDIR,FTG,READNXT,MGTF have bugs fixed by Sam Habiel 2016.
"RTN","ZISHGUX",8,0)
 ; 
"RTN","ZISHGUX",9,0)
 ;
"RTN","ZISHGUX",10,0)
OPEN(X1,X2,X3,X4,X5,X6) ;SR. Open file
"RTN","ZISHGUX",11,0)
 ;D OPEN^%ZISH([handlename],[directory],filename,[accessmode],[recsize])
"RTN","ZISHGUX",12,0)
 ;X1=handle name
"RTN","ZISHGUX",13,0)
 ;X2=directory, X3=filename, X4=access mode
"RTN","ZISHGUX",14,0)
 ;X5=new file max record size, X6=Subtype
"RTN","ZISHGUX",15,0)
 ; ZEXCEPT: IOM,IOSL,IOT,POP
"RTN","ZISHGUX",16,0)
 ;
"RTN","ZISHGUX",17,0)
 ; RPMS has a 3 parameter version (directory, file, access mode)
"RTN","ZISHGUX",18,0)
 ; If we only have 3 parameters, move them over from X1,X2,X3 ->
"RTN","ZISHGUX",19,0)
 ; X2,X3,X4
"RTN","ZISHGUX",20,0)
 ; RPMS's OPENI also quits with a value, unlike the VistA call.
"RTN","ZISHGUX",21,0)
 ; So I added $Q to check for that.
"RTN","ZISHGUX",22,0)
 I '$D(X4) S X4=X3,X3=X2,X2=X1 K X1
"RTN","ZISHGUX",23,0)
 ;
"RTN","ZISHGUX",24,0)
 N %,%1,%2,%IO,%I2,%P,%T,X,Y,$ETRAP
"RTN","ZISHGUX",25,0)
 S $ETRAP="G OPNERR^%ZISH"
"RTN","ZISHGUX",26,0)
 ; If X2 isn't supplied, get default directory; or resolve it if supplied
"RTN","ZISHGUX",27,0)
 S U="^",X2=$$DEFDIR($G(X2)),X4=$$UP^XLFSTR(X4)
"RTN","ZISHGUX",28,0)
 ;
"RTN","ZISHGUX",29,0)
 ; These are common sense
"RTN","ZISHGUX",30,0)
 S Y=$S(X4["A":"append",X4["R":"readonly",X4["W":"newversion",1:"readonly")
"RTN","ZISHGUX",31,0)
 ;
"RTN","ZISHGUX",32,0)
 ; Binary mode. ! and # have no effect.
"RTN","ZISHGUX",33,0)
 ; NB: Reads are in record size; writes pad out to record size
"RTN","ZISHGUX",34,0)
 N RECSIZE S RECSIZE=$G(X5,"512")
"RTN","ZISHGUX",35,0)
 I X4["B" S Y=Y_":fixed:nowrap:recordsize="_RECSIZE ; Binary Mode
"RTN","ZISHGUX",36,0)
 ;
"RTN","ZISHGUX",37,0)
 ; Streaming Mode (almost everybody wants this all of the time)
"RTN","ZISHGUX",38,0)
 I X4'["B",'$G(X5) S Y=Y_":nowrap:stream" ; Streaming Mode (default)
"RTN","ZISHGUX",39,0)
 ;
"RTN","ZISHGUX",40,0)
 ; Variable records mode. Records are TRUNCATED at a specific width,
"RTN","ZISHGUX",41,0)
 ; but, unlike fixed records, you can end them early with a !.
"RTN","ZISHGUX",42,0)
 I X4'["B",$G(X5)  S Y=Y_":variable:nowrap:recordsize="_+X5
"RTN","ZISHGUX",43,0)
 ;
"RTN","ZISHGUX",44,0)
 S:$E(Y)=":" $E(Y)=""
"RTN","ZISHGUX",45,0)
 S %IO=X2_X3,%I2="%IO:"_$S($L(Y):"("_Y_")",1:"")_":0"
"RTN","ZISHGUX",46,0)
 O @%I2 E  S POP=1 Q:$Q 1 Q
"RTN","ZISHGUX",47,0)
 ;
"RTN","ZISHGUX",48,0)
 S IO=%IO,IO(1,IO)="",IOT="HFS",IOM=80,IOSL=60,POP=0 D SUBTYPE^%ZIS3($G(X6))
"RTN","ZISHGUX",49,0)
 I $G(X1)]"" D SAVDEV^%ZISUTL(X1)
"RTN","ZISHGUX",50,0)
 Q:$Q 0 Q
"RTN","ZISHGUX",51,0)
OPNERR ;error on open
"RTN","ZISHGUX",52,0)
 ; ZEXCEPT: POP
"RTN","ZISHGUX",53,0)
 S POP=1,$ECODE=""
"RTN","ZISHGUX",54,0)
 ;U:$G(%P)]"" %P
"RTN","ZISHGUX",55,0)
 Q:$Q 1 Q
"RTN","ZISHGUX",56,0)
 ;
"RTN","ZISHGUX",57,0)
CLOSE(X) ;SR. Close HFS device not opened by %ZIS.
"RTN","ZISHGUX",58,0)
 ;X1=Handle name, IO=device
"RTN","ZISHGUX",59,0)
 I IO]"" C IO K IO(1,IO)
"RTN","ZISHGUX",60,0)
 I $G(X)]"" D RMDEV^%ZISUTL(X)
"RTN","ZISHGUX",61,0)
 I $D(IO("HOME"))!$D(^XUTL("XQ",$J,"IOS")) D HOME^%ZIS
"RTN","ZISHGUX",62,0)
 Q
"RTN","ZISHGUX",63,0)
DEL(%ZX1,%ZX2) ;ef,SR. Del fl(s)
"RTN","ZISHGUX",64,0)
 ;S Y=$$DEL^%ZISH("dir path",$NA(array))
"RTN","ZISHGUX",65,0)
 N %ZISH,%ZISHLGR,%ZX,X,%ZXDEL
"RTN","ZISHGUX",66,0)
 S %ZX1=$$DEFDIR($G(%ZX1)),%ZXDEL=1,%ZISH=""
"RTN","ZISHGUX",67,0)
 ;
"RTN","ZISHGUX",68,0)
 ; Error trap is for $D(@%ZX2)
"RTN","ZISHGUX",69,0)
 N $ET S $ET="S $EC="""" G DELVAL^%ZISH"
"RTN","ZISHGUX",70,0)
 I $D(@%ZX2)<10 G DELVAL  ; RPMS format
"RTN","ZISHGUX",71,0)
 E  G DELNAME ; VISTA format
"RTN","ZISHGUX",72,0)
 ;
"RTN","ZISHGUX",73,0)
DELVAL ; [Internal] Delete by Val
"RTN","ZISHGUX",74,0)
 ; RPMS allows you to pass %ZX2 by value -- so handle that here
"RTN","ZISHGUX",75,0)
 ; Also, in the RPMS format, 0 = success and 1 = failure
"RTN","ZISHGUX",76,0)
 ; (b/c that's the return value of the unix rm command)
"RTN","ZISHGUX",77,0)
 ;
"RTN","ZISHGUX",78,0)
 S $ET="S $EC="""" Q 1"
"RTN","ZISHGUX",79,0)
 S %ZXDEL=0
"RTN","ZISHGUX",80,0)
 S %ZISH=%ZX2
"RTN","ZISHGUX",81,0)
 S %ZX=$S(%ZISH[%ZX1:%ZISH,1:%ZX1_%ZISH)
"RTN","ZISHGUX",82,0)
 O %ZX:READONLY:0
"RTN","ZISHGUX",83,0)
 E  S %ZXDEL=1 Q  ; Can't open it.
"RTN","ZISHGUX",84,0)
 C %ZX:DELETE
"RTN","ZISHGUX",85,0)
 I $ZSEARCH(%ZX)]"" S %ZXDEL=1 ; Delete was not successful.
"RTN","ZISHGUX",86,0)
 Q %ZXDEL
"RTN","ZISHGUX",87,0)
 ; /end RPMS implementation
"RTN","ZISHGUX",88,0)
 ;
"RTN","ZISHGUX",89,0)
DELNAME ; [Internal] Delete by Name
"RTN","ZISHGUX",90,0)
 ; ZEXCEPT: %ZISH,%ZISHLGR,%ZX,X,%ZXDEL,%ZX1,%ZX2
"RTN","ZISHGUX",91,0)
 ; %ZX2 is a named array (VistA format)
"RTN","ZISHGUX",92,0)
 F  S %ZISH=$O(@%ZX2@(%ZISH)) Q:%ZISH=""  D
"RTN","ZISHGUX",93,0)
 . N $ETRAP S $ETRAP="D DELERR^%ZISH"
"RTN","ZISHGUX",94,0)
 . I %ZISH["*" S %ZXDEL=0 Q  ; Wild card not allowed.
"RTN","ZISHGUX",95,0)
 . S %ZX=$ZSEARCH(%ZX1_%ZISH)
"RTN","ZISHGUX",96,0)
 . Q:%ZX=""           ; File doesn't exist - not an error, just quit.
"RTN","ZISHGUX",97,0)
 . O %ZX:READONLY:0
"RTN","ZISHGUX",98,0)
 . E  S %ZXDEL=0 Q  ; Can't open it.
"RTN","ZISHGUX",99,0)
 . C %ZX:DELETE
"RTN","ZISHGUX",100,0)
 . I $ZSEARCH(%ZX)]"" S %ZXDEL=0 ; Delete was not successful.
"RTN","ZISHGUX",101,0)
 Q %ZXDEL
"RTN","ZISHGUX",102,0)
 ;
"RTN","ZISHGUX",103,0)
DELERR ;Trap any $ETRAP error, unwind and return.
"RTN","ZISHGUX",104,0)
 ; ZEXCEPT: %ZXDEL
"RTN","ZISHGUX",105,0)
 S $ETRAP="D UNWIND^%ZTER"
"RTN","ZISHGUX",106,0)
 S %ZXDEL=0
"RTN","ZISHGUX",107,0)
 D UNWIND^%ZTER Q
"RTN","ZISHGUX",108,0)
 ;
"RTN","ZISHGUX",109,0)
DEL1(%ZX3) ;ef,SR. Delete one file
"RTN","ZISHGUX",110,0)
 N %ZI1,%ZI2
"RTN","ZISHGUX",111,0)
 D SPLIT(%ZX3,.%ZI1,.%ZI2) S %ZI2(%ZI2)=""
"RTN","ZISHGUX",112,0)
 Q $$DEL(%ZI1,$NA(%ZI2))
"RTN","ZISHGUX",113,0)
 ;
"RTN","ZISHGUX",114,0)
SPLIT(%I,%O1,%O2) ;[Public] Split to path,file
"RTN","ZISHGUX",115,0)
 N %D,D
"RTN","ZISHGUX",116,0)
 S %D="/",%O1="",%O2=""
"RTN","ZISHGUX",117,0)
 S D=$L(%I,%D),%O1=$P(%I,%D,1,D-1),%O2=$P(%I,%D,D)
"RTN","ZISHGUX",118,0)
 Q
"RTN","ZISHGUX",119,0)
LIST(%ZX1,%ZX2,%ZX3) ;ef,SR. Set local array holding fl names
"RTN","ZISHGUX",120,0)
 ;S Y=$$LIST^ZISH("/dir/","list_root","return_root")
"RTN","ZISHGUX",121,0)
 ;list_root can have XX("A*"), XX("test.com")...
"RTN","ZISHGUX",122,0)
 ;Both arrays passed as $NA values (closed roots).
"RTN","ZISHGUX",123,0)
 N %ZISH,%ZIX,%ZIY,POP,X
"RTN","ZISHGUX",124,0)
 N $ETRAP,$ESTACK
"RTN","ZISHGUX",125,0)
 S $ETRAP="G LSTX^%ZISH" ; for the next line
"RTN","ZISHGUX",126,0)
 S %ZX1=$$DEFDIR($G(%ZX1))
"RTN","ZISHGUX",127,0)
 ;
"RTN","ZISHGUX",128,0)
 ; RPMS allows %ZX2 to be passed by value and %ZX3 to be passed by reference
"RTN","ZISHGUX",129,0)
 ; Next line's error trap applies only to $D(@%ZX2)
"RTN","ZISHGUX",130,0)
 S $ETRAP="S $EC="""" Q $$LISTI()"
"RTN","ZISHGUX",131,0)
 I $D(@%ZX2)<10 Q $$LISTI()
"RTN","ZISHGUX",132,0)
 ;Get fls, Build listing in %ZISHDL1 with ls
"RTN","ZISHGUX",133,0)
 S $ETRAP="G LSTX^%ZISH"
"RTN","ZISHGUX",134,0)
 S %ZISH=""
"RTN","ZISHGUX",135,0)
 F  S %ZISH=$O(@%ZX2@(%ZISH)) Q:%ZISH=""  D
"RTN","ZISHGUX",136,0)
 . S %ZIX=$ZPARSE(%ZX1_%ZISH) Q:%ZIX=""
"RTN","ZISHGUX",137,0)
 . F  S %ZIY=$ZSEARCH(%ZIX) Q:%ZIY=""  S %ZIY=$ZPARSE(%ZIY,"NAME")_$ZPARSE(%ZIY,"TYPE"),@%ZX3@(%ZIY)=""
"RTN","ZISHGUX",138,0)
LSTX ;
"RTN","ZISHGUX",139,0)
 S $ECODE=""
"RTN","ZISHGUX",140,0)
 S $ETRAP="G LISTIX^%ZISH" ; This is in case $$DEFDIR fails but 2nd par is passed by reference (So @ on it will crash)
"RTN","ZISHGUX",141,0)
 Q ($Q(@%ZX3)]"")
"RTN","ZISHGUX",142,0)
 ;
"RTN","ZISHGUX",143,0)
LISTI() ; [Internal] RPMS implementation of directory lister
"RTN","ZISHGUX",144,0)
 ; %ZX1 by value; %ZX2 by value; %ZX3 by reference
"RTN","ZISHGUX",145,0)
 ; ZEXCEPT: %ZX1,%ZX2,%ZX3
"RTN","ZISHGUX",146,0)
 ; ZEXCEPT: %ZIX,%ZIY
"RTN","ZISHGUX",147,0)
 S $ETRAP="G LSTIX^%ZISH"
"RTN","ZISHGUX",148,0)
 I $G(%ZX1)']""!($G(%ZX2)']"") Q 0
"RTN","ZISHGUX",149,0)
 S %ZIX=$ZPARSE(%ZX1_%ZX2) Q:%ZIX="" 0
"RTN","ZISHGUX",150,0)
 N %ZISHN F %ZISHN=1:1 S %ZIY=$ZSEARCH(%ZIX) Q:%ZIY=""  D
"RTN","ZISHGUX",151,0)
 . S %ZIY=$ZPARSE(%ZIY,"NAME")_$ZPARSE(%ZIY,"TYPE")
"RTN","ZISHGUX",152,0)
 . S %ZX3(%ZISHN)=%ZIY
"RTN","ZISHGUX",153,0)
LISTIX ; [Internal] Error Trap target for LISTI; Fallthrough
"RTN","ZISHGUX",154,0)
 S $ECODE=""
"RTN","ZISHGUX",155,0)
 Q '$D(%ZX3)
"RTN","ZISHGUX",156,0)
 ;
"RTN","ZISHGUX",157,0)
MV(X1,X2,Y1,Y2) ;ef,SR. Rename a fl
"RTN","ZISHGUX",158,0)
 ;S Y=$$MV^ZISH("/dir/","fl","/dir/","fl")
"RTN","ZISHGUX",159,0)
 N %Z,%C
"RTN","ZISHGUX",160,0)
 S X1=$$DEFDIR($G(X1)),Y1=$$DEFDIR($G(Y1))
"RTN","ZISHGUX",161,0)
 S %C="mv "
"RTN","ZISHGUX",162,0)
 ;Pbv or qit
"RTN","ZISHGUX",163,0)
 I (X2="")!(Y2="") Q 0
"RTN","ZISHGUX",164,0)
 N % S %=$$RETURN^%ZOSV(%C_X1_X2_" "_Y1_Y2)
"RTN","ZISHGUX",165,0)
 S %Z=$ZSEARCH(Y1_Y2)
"RTN","ZISHGUX",166,0)
 Q $L(%Z)>0
"RTN","ZISHGUX",167,0)
 ;
"RTN","ZISHGUX",168,0)
CD(D) ; [Public] Change Directory
"RTN","ZISHGUX",169,0)
 S $ZD=D
"RTN","ZISHGUX",170,0)
 QUIT
"RTN","ZISHGUX",171,0)
 ;
"RTN","ZISHGUX",172,0)
PWD() ;ef,SR. Print working directory
"RTN","ZISHGUX",173,0)
 Q $ZDIRECTORY
"RTN","ZISHGUX",174,0)
 ;
"RTN","ZISHGUX",175,0)
DEFDIR(DF) ;ef. Default Dir and frmt
"RTN","ZISHGUX",176,0)
 S DF=$G(DF)
"RTN","ZISHGUX",177,0)
 S:DF="" DF=$P($G(^XTV(8989.3,1,"DEV")),"^",1)
"RTN","ZISHGUX",178,0)
 ;
"RTN","ZISHGUX",179,0)
 ; $ZPARSE is file specific; we need to tell it that we are looking for a DIRECTORY!
"RTN","ZISHGUX",180,0)
 ; Otherwise, we will get a false positive
"RTN","ZISHGUX",181,0)
 I $E(DF,$L(DF))'="/" S DF=DF_"/"
"RTN","ZISHGUX",182,0)
 ;
"RTN","ZISHGUX",183,0)
 S DF=$ZPARSE(DF)
"RTN","ZISHGUX",184,0)
 I DF="" S $EC=",U-INVALID-DIRECTORY,"
"RTN","ZISHGUX",185,0)
 ;
"RTN","ZISHGUX",186,0)
 Q DF
"RTN","ZISHGUX",187,0)
 ;
"RTN","ZISHGUX",188,0)
MKDIR(DIR) ; ef,SR. *10002* Make directory
"RTN","ZISHGUX",189,0)
 N % S %=$$RETURN^%ZOSV("mkdir -p "_DIR,1)
"RTN","ZISHGUX",190,0)
 Q %
"RTN","ZISHGUX",191,0)
 ;
"RTN","ZISHGUX",192,0)
SIZE(DIR,FILE) ; ef,SR. *10002* Get Size of a File
"RTN","ZISHGUX",193,0)
 I $ZV["Darwin" Q $$RETURN^%ZOSV("stat -f%z "_$$DEFDIR(DIR)_FILE)
"RTN","ZISHGUX",194,0)
 Q $$RETURN^%ZOSV("stat -c%s "_$$DEFDIR(DIR)_FILE)
"RTN","ZISHGUX",195,0)
 ;
"RTN","ZISHGUX",196,0)
WGETSYNC(server,remoteDir,localDir,filePatt,port,isTLS) ; ef,SR. *10002* Sync remote directory
"RTN","ZISHGUX",197,0)
 s port=$g(port,443)
"RTN","ZISHGUX",198,0)
 s isTLS=$g(isTLS,1)
"RTN","ZISHGUX",199,0)
 ;
"RTN","ZISHGUX",200,0)
 i $e(remoteDir)'="/" s remoteDir="/"_remoteDir
"RTN","ZISHGUX",201,0)
 ;
"RTN","ZISHGUX",202,0)
 n url s url="http"
"RTN","ZISHGUX",203,0)
 i isTLS s url=url_"s"
"RTN","ZISHGUX",204,0)
 s url=url_"://"_server_":"_port_remoteDir
"RTN","ZISHGUX",205,0)
 ;
"RTN","ZISHGUX",206,0)
 ; -r recursive
"RTN","ZISHGUX",207,0)
 ; -N Turn on time-stamping
"RTN","ZISHGUX",208,0)
 ; -nd Do not create directories
"RTN","ZISHGUX",209,0)
 ; -np Do not follow follow
"RTN","ZISHGUX",210,0)
 ; -A What to accept (file pattern)
"RTN","ZISHGUX",211,0)
 ; -P where to save
"RTN","ZISHGUX",212,0)
 ;
"RTN","ZISHGUX",213,0)
 ; Get compressed file from remote source
"RTN","ZISHGUX",214,0)
 n %cmd s %cmd="wget --header='Accept-Encoding: gzip' -rNndp -A '"_filePatt_"' '"_url_"' -P "_localDir
"RTN","ZISHGUX",215,0)
 n % s %=$$RETURN^%ZOSV(%cmd,1)
"RTN","ZISHGUX",216,0)
 i % quit %
"RTN","ZISHGUX",217,0)
 ;
"RTN","ZISHGUX",218,0)
 ; Rename them to .gz if they are really compressed
"RTN","ZISHGUX",219,0)
 n %cmd s %cmd="for f in `file "_localDir_"/* | grep gzip | cut -d':' -f1`; do mv $f $f.gz; done"
"RTN","ZISHGUX",220,0)
 n % s %=$$RETURN^%ZOSV(%cmd,1)
"RTN","ZISHGUX",221,0)
 i % quit %
"RTN","ZISHGUX",222,0)
 ;
"RTN","ZISHGUX",223,0)
 ; gunzip (but don't warn if there is nothing to do: -q)
"RTN","ZISHGUX",224,0)
 n %cmd s %cmd="gzip -dq "_localDir_"/*"
"RTN","ZISHGUX",225,0)
 n % s %=$$RETURN^%ZOSV(%cmd,1)
"RTN","ZISHGUX",226,0)
 i %=1 s %=0 ; BSD gzip (in OS X) will return 1 if there are no files to operate on. Error safe to ignore.
"RTN","ZISHGUX",227,0)
 i % quit %
"RTN","ZISHGUX",228,0)
 ;
"RTN","ZISHGUX",229,0)
 ; dos2unix
"RTN","ZISHGUX",230,0)
 n %cmd s %cmd="dos2unix "_localDir_"/"_filePatt
"RTN","ZISHGUX",231,0)
 n % s %=$$RETURN^%ZOSV(%cmd,1)
"RTN","ZISHGUX",232,0)
 i % quit %
"RTN","ZISHGUX",233,0)
 ;
"RTN","ZISHGUX",234,0)
 quit %
"RTN","ZISHGUX",235,0)
 ;
"RTN","ZISHGUX",236,0)
STATUS() ;ef,SR. Return EOF status
"RTN","ZISHGUX",237,0)
 U $I
"RTN","ZISHGUX",238,0)
 Q $ZEOF
"RTN","ZISHGUX",239,0)
 ;
"RTN","ZISHGUX",240,0)
EOF(X) ;Eof flag, Pass in $ZA
"RTN","ZISHGUX",241,0)
 Q X
"RTN","ZISHGUX",242,0)
 ;
"RTN","ZISHGUX",243,0)
MAKEREF(HF,IX,OVF) ;Internal call to rebuild global ref.
"RTN","ZISHGUX",244,0)
 ;Return %ZISHF,%ZISHO,%ZISHI,%ZISUB
"RTN","ZISHGUX",245,0)
 ; ZEXCEPT: %ZISHF,%ZISHO,%ZISHI,%ZISUB
"RTN","ZISHGUX",246,0)
 N I,F,MX
"RTN","ZISHGUX",247,0)
 S OVF=$G(OVF,"%ZISHOF")
"RTN","ZISHGUX",248,0)
 S %ZISHI=$QS(HF,IX),MX=$QL(HF) ;
"RTN","ZISHGUX",249,0)
 S F=$NA(@HF,IX-1) ;Get first part
"RTN","ZISHGUX",250,0)
 I IX=1 S %ZISHF=F_"(%ZISHI" ;Build root, IX=1
"RTN","ZISHGUX",251,0)
 I IX>1 S %ZISHF=$E(F,1,$L(F)-1)_",%ZISHI" ;Build root
"RTN","ZISHGUX",252,0)
 S %ZISHO=%ZISHF_","_OVF_",%OVFCNT)" ;Make overflow
"RTN","ZISHGUX",253,0)
 F I=IX+1:1:MX S %ZISHF=%ZISHF_",%ZISUB("_I_")",%ZISUB(I)=$QS(HF,I)
"RTN","ZISHGUX",254,0)
 S %ZISHF=%ZISHF_")"
"RTN","ZISHGUX",255,0)
 Q
"RTN","ZISHGUX",256,0)
FTG(%ZX1,%ZX2,%ZX3,%ZX4,%ZX5) ;ef,SR. Unload contents of host file into global
"RTN","ZISHGUX",257,0)
 ;p1=host file directory
"RTN","ZISHGUX",258,0)
 ;p2=host file name
"RTN","ZISHGUX",259,0)
 ;p3= $NAME REFERENCE INCLUDING STARTING SUBSCRIPT
"RTN","ZISHGUX",260,0)
 ;p4=INCREMENT SUBSCRIPT
"RTN","ZISHGUX",261,0)
 ;p5=Overflow subscript, defaults to "OVF"
"RTN","ZISHGUX",262,0)
 ; 
"RTN","ZISHGUX",263,0)
 N %ZA,%ZB,%ZC,%ZL,X,%OVFCNT,%CONT,%EXIT,%XX
"RTN","ZISHGUX",264,0)
 N I,%ZISH,%ZISH1,%ZISHI,%ZISHL,%ZISHLGR,%ZISHOF,%ZISHOX,%ZISHS,%ZX,%ZISHY,POP,%ZISUB,%ZISHF,%ZISHO
"RTN","ZISHGUX",265,0)
 S %ZX1=$$DEFDIR($G(%ZX1)),%ZISHOF=$G(%ZX5,"OVF")
"RTN","ZISHGUX",266,0)
 D MAKEREF(%ZX3,%ZX4,"%ZISHOF")
"RTN","ZISHGUX",267,0)
 D OPEN^%ZISH(,%ZX1,%ZX2,"R")
"RTN","ZISHGUX",268,0)
 I POP Q 0
"RTN","ZISHGUX",269,0)
 N $ETRAP S %EXIT=0,$ETRAP="S %ZA=1,%EXIT=1,$ECODE="""" Q"
"RTN","ZISHGUX",270,0)
 N MAX S MAX=$$MAXREC(%ZISHF)
"RTN","ZISHGUX",271,0)
 U IO F  K %XX D READNXT(.%XX,MAX) Q:$$EOF(%ZA)  D
"RTN","ZISHGUX",272,0)
 . S @%ZISHF=%XX
"RTN","ZISHGUX",273,0)
 . I $D(%XX)>2 F %OVFCNT=1:1 Q:'$D(%XX(%OVFCNT))  S @%ZISHO=%XX(%OVFCNT)
"RTN","ZISHGUX",274,0)
 . S %ZISHI=%ZISHI+1
"RTN","ZISHGUX",275,0)
 . Q
"RTN","ZISHGUX",276,0)
 D CLOSE() ;Normal exit
"RTN","ZISHGUX",277,0)
 Q '%EXIT
"RTN","ZISHGUX",278,0)
 ;
"RTN","ZISHGUX",279,0)
READNXT(REC,MAX) ;
"RTN","ZISHGUX",280,0)
 ; ZEXCEPT: %ZA
"RTN","ZISHGUX",281,0)
 N T,I,X,%
"RTN","ZISHGUX",282,0)
 U IO R X:0 S %ZA=$ZEOF,REC=$E(X,1,MAX-1)
"RTN","ZISHGUX",283,0)
 Q:$L(X)<MAX
"RTN","ZISHGUX",284,0)
 S %=MAX
"RTN","ZISHGUX",285,0)
 F I=1:1 Q:$L(X)<%  S REC(I)=$E(X,%,%+(MAX-2)),%=%+(MAX-1)
"RTN","ZISHGUX",286,0)
 Q
"RTN","ZISHGUX",287,0)
 ;
"RTN","ZISHGUX",288,0)
GTF(%ZX1,%ZX2,%ZX3,%ZX4) ;ef,SR. Load contents of global to host file.
"RTN","ZISHGUX",289,0)
 ;Previously name LOAD
"RTN","ZISHGUX",290,0)
 ;p1=$NAME of global reference
"RTN","ZISHGUX",291,0)
 ;p2=incrementing subscript
"RTN","ZISHGUX",292,0)
 ;p3=host file directory
"RTN","ZISHGUX",293,0)
 ;p4=host file name
"RTN","ZISHGUX",294,0)
 N %ZISHY,%ZISHLGR,%ZISHOX
"RTN","ZISHGUX",295,0)
 S %ZISHY=$$MGTF(%ZX1,%ZX2,$G(%ZX3),%ZX4,"W")
"RTN","ZISHGUX",296,0)
 Q %ZISHY
"RTN","ZISHGUX",297,0)
 ;
"RTN","ZISHGUX",298,0)
GATF(%ZX1,%ZX2,%ZX3,%ZX4) ;ef,SR. Append to host file.
"RTN","ZISHGUX",299,0)
 ;
"RTN","ZISHGUX",300,0)
 ;p1=$NAME of global reference
"RTN","ZISHGUX",301,0)
 ;p2=incrementing subscript
"RTN","ZISHGUX",302,0)
 ;p3=host file directory
"RTN","ZISHGUX",303,0)
 ;p4=host file name
"RTN","ZISHGUX",304,0)
 N %ZISHY
"RTN","ZISHGUX",305,0)
 S %ZISHY=$$MGTF(%ZX1,%ZX2,$G(%ZX3),%ZX4,"A")
"RTN","ZISHGUX",306,0)
 Q %ZISHY
"RTN","ZISHGUX",307,0)
 ;
"RTN","ZISHGUX",308,0)
MGTF(%ZX1,%ZX2,%ZX3,%ZX4,%ZX5) ;
"RTN","ZISHGUX",309,0)
 ;p1=$NAME of global reference
"RTN","ZISHGUX",310,0)
 ;p2=incrementing subscript
"RTN","ZISHGUX",311,0)
 ;p3=host file directory
"RTN","ZISHGUX",312,0)
 ;p4=host file name
"RTN","ZISHGUX",313,0)
 ; ZEXCEPT: POP
"RTN","ZISHGUX",314,0)
 N %ZISH,%ZISH1,%ZISHI,%ZISHL,%ZISHLGR,%ZISHS,%ZISHOX,IO,%ZX,Y,%ZISHF
"RTN","ZISHGUX",315,0)
 D MAKEREF(%ZX1,%ZX2)
"RTN","ZISHGUX",316,0)
 D OPEN^%ZISH(,%ZX3,%ZX4,%ZX5) ;Default dir set in open
"RTN","ZISHGUX",317,0)
 I POP Q 0
"RTN","ZISHGUX",318,0)
 U IO
"RTN","ZISHGUX",319,0)
 N $ETRAP S $ETRAP="S $EC="""" D CLOSE^%ZISH() Q 0"
"RTN","ZISHGUX",320,0)
 ;
"RTN","ZISHGUX",321,0)
 ; This algorithm takes 20ms for 200,4,5; 
"RTN","ZISHGUX",322,0)
 ; Prev algo was faster I think, but had a bug where it would stop early if we skipped a sub
"RTN","ZISHGUX",323,0)
 D  F  S %ZISHI=$O(@$NA(@%ZX1,%ZX2-1)@(%ZISHI)) Q:'%ZISHI  D
"RTN","ZISHGUX",324,0)
 . Q:'($D(@%ZISHF)#2)
"RTN","ZISHGUX",325,0)
 . W @%ZISHF,!
"RTN","ZISHGUX",326,0)
 D CLOSE() ;Normal Exit
"RTN","ZISHGUX",327,0)
 Q 1
"RTN","ZISHGUX",328,0)
 ;
"RTN","ZISHGUX",329,0)
MAXREC(GLO) ; [Public] Maximum Record Size for a Global
"RTN","ZISHGUX",330,0)
 ; Global passed by name
"RTN","ZISHGUX",331,0)
 N REGION S REGION=$VIEW("REGION",$NA(@GLO))
"RTN","ZISHGUX",332,0)
 I REGION="" S $EC=",U-ERROR,"
"RTN","ZISHGUX",333,0)
 I $T(^%PEEKBYNAME)]"" Q $$^%PEEKBYNAME("gd_region.max_rec_size",REGION)
"RTN","ZISHGUX",334,0)
 I $T(^%DSEWRAP)]"" N FDUMP D  Q FDUMP(REGION,"Maximum record size")
"RTN","ZISHGUX",335,0)
 . D DUMP^%DSEWRAP(REGION,.FDUMP,"fileheader","all")
"RTN","ZISHGUX",336,0)
 ;
"RTN","ZISHGUX",337,0)
 ; -- RPMS ENTRY POINTS! --
"RTN","ZISHGUX",338,0)
 ;
"RTN","ZISHGUX",339,0)
DF(X) ;Directory format
"RTN","ZISHGUX",340,0)
 ; Pass X by ref - both input and output
"RTN","ZISHGUX",341,0)
 Q:X=""
"RTN","ZISHGUX",342,0)
 S X=$TR(X,"\","/")
"RTN","ZISHGUX",343,0)
 S:$E(X,$L(X))'="/" X=X_"/"
"RTN","ZISHGUX",344,0)
 Q
"RTN","ZISHGUX",345,0)
 ;
"RTN","ZISHGUX",346,0)
SEND(ZISH1,ZISH2,ZISH3,ZISHPARM) ;Send UNIX or Windows fl
"RTN","ZISHGUX",347,0)
 Q ""
"RTN","ZISHGUX",348,0)
 ;
"RTN","ZISHGUX",349,0)
SENDTO1(ZISH1,ZISH2)         ;use sendto1 script
"RTN","ZISHGUX",350,0)
 Q ""
"RTN","ZISTCPS")
0^8^B17029601
"RTN","ZISTCPS",1,0)
%ZISTCPS ;ISF/RWF - DEVICE HANDLER TCP/IP SERVER CALLS ;2017-01-09  3:19 PM
"RTN","ZISTCPS",2,0)
 ;;8.0;KERNEL;**78,118,127,225,275,388,10001**;Jul 10, 1995;Build 21
"RTN","ZISTCPS",3,0)
 ; Submitted to OSEHRA in 2017 by Sam Habiel for OSEHRA
"RTN","ZISTCPS",4,0)
 ; Original Routine authored by Department of Veterans Affairs
"RTN","ZISTCPS",5,0)
 ; EPs LGTM and GTMLNCH authored by Sam Habiel 2016.
"RTN","ZISTCPS",6,0)
 Q
"RTN","ZISTCPS",7,0)
 ;
"RTN","ZISTCPS",8,0)
CLOSE ;Close and reset
"RTN","ZISTCPS",9,0)
 G CLOSE^%ZISTCP
"RTN","ZISTCPS",10,0)
 Q
"RTN","ZISTCPS",11,0)
 ;
"RTN","ZISTCPS",12,0)
 ;In ZRULE, set ZISQUIT=1 to quit
"RTN","ZISTCPS",13,0)
LISTEN(SOCK,RTN,ZRULE) ;Listen on socket, start routine
"RTN","ZISTCPS",14,0)
 N %A,ZISOS,X,NIO,EXIT
"RTN","ZISTCPS",15,0)
 N $ES,$ET S $ETRAP="D OPNERR^%ZISTCPS"
"RTN","ZISTCPS",16,0)
 S ZISOS=^%ZOSF("OS"),ZRULE=$G(ZRULE)
"RTN","ZISTCPS",17,0)
 S POP=1
"RTN","ZISTCPS",18,0)
 D GETENV^%ZOSV S U="^",XUENV=Y,XQVOL=$P(Y,U,2)
"RTN","ZISTCPS",19,0)
 S POP=1 D LONT:ZISOS["OpenM",LGTM:ZISOS["GT.M"
"RTN","ZISTCPS",20,0)
 I 'POP C NIO ;Close port
"RTN","ZISTCPS",21,0)
 Q
"RTN","ZISTCPS",22,0)
 ;
"RTN","ZISTCPS",23,0)
 ;
"RTN","ZISTCPS",24,0)
LONT ;Open port in Accept mode with standard terminators.
"RTN","ZISTCPS",25,0)
 N %ZA,NEWCHAR
"RTN","ZISTCPS",26,0)
 S NIO="|TCP|"_SOCK,EXIT=0
"RTN","ZISTCPS",27,0)
 ;(adr:sock:term:ibuf:obuf:queue)
"RTN","ZISTCPS",28,0)
 O NIO:(:SOCK:"AT"::512:512:10):30 Q:'$T  S POP=0 U NIO
"RTN","ZISTCPS",29,0)
 ;Wait on read for a connect
"RTN","ZISTCPS",30,0)
LONT2 F  U NIO R *NEWCHAR:30 S EXIT=$$EXIT Q:$T!EXIT
"RTN","ZISTCPS",31,0)
 I EXIT C NIO Q
"RTN","ZISTCPS",32,0)
 ;JOB params (:Concurrent Server bit:principal input:principal output)
"RTN","ZISTCPS",33,0)
 J CHILDONT^%ZISTCPS(NIO,RTN):(:16::):10 S %ZA=$ZA
"RTN","ZISTCPS",34,0)
 I %ZA\8196#2=1 W *-2 ;Job failed to clear bit
"RTN","ZISTCPS",35,0)
 G LONT2
"RTN","ZISTCPS",36,0)
 ;
"RTN","ZISTCPS",37,0)
CHILDONT(IO,RTN) ;Child process for OpenM
"RTN","ZISTCPS",38,0)
 S $ETRAP="D ^%ZTER L  HALT",IO=$ZU(53)
"RTN","ZISTCPS",39,0)
 U IO:(::"-M") ;Work like DSM
"RTN","ZISTCPS",40,0)
 S NEWJOB=$$NEWOK
"RTN","ZISTCPS",41,0)
 I 'NEWJOB W "421 Service temporarily down.",$C(13,10),!
"RTN","ZISTCPS",42,0)
 I NEWJOB K NEWJOB D VAR,@RTN
"RTN","ZISTCPS",43,0)
 HALT
"RTN","ZISTCPS",44,0)
 ;
"RTN","ZISTCPS",45,0)
VAR ;Setup IO variables
"RTN","ZISTCPS",46,0)
 S IO(0)=IO,IO(1,IO)="",POP=0
"RTN","ZISTCPS",47,0)
 S IOT="TCP",IOST="P-TCP",IOST(0)=0
"RTN","ZISTCPS",48,0)
 S IOF=$$FLUSHCHR^%ZISTCP
"RTN","ZISTCPS",49,0)
 S ^XUTL("XQ",$J,0)=$$DT^XLFDT
"RTN","ZISTCPS",50,0)
 Q
"RTN","ZISTCPS",51,0)
NEWOK() ;Is it OK to start a new process
"RTN","ZISTCPS",52,0)
 I $G(^%ZIS(14.5,"LOGON",^%ZOSF("VOL"))) Q 0
"RTN","ZISTCPS",53,0)
 I $$AVJ^%ZOSV()<3 Q 0
"RTN","ZISTCPS",54,0)
 Q 1
"RTN","ZISTCPS",55,0)
OPNERR ;
"RTN","ZISTCPS",56,0)
 S POP=1,EXIT=1,IO("ERROR")=$ECODE,$ECODE=""
"RTN","ZISTCPS",57,0)
 Q
"RTN","ZISTCPS",58,0)
EXIT() ;See if time to exit
"RTN","ZISTCPS",59,0)
 I $$S^%ZTLOAD Q 1
"RTN","ZISTCPS",60,0)
 N ZISQUIT S ZISQUIT=0
"RTN","ZISTCPS",61,0)
 I $L(ZRULE) X ZRULE I $G(ZISQUIT) Q 1
"RTN","ZISTCPS",62,0)
 Q 0
"RTN","ZISTCPS",63,0)
 ;
"RTN","ZISTCPS",64,0)
LGTM ;GT.M multi-threaded server
"RTN","ZISTCPS",65,0)
 S $ZINT="I $$JOBEXAM^ZU($ZPOSITION)"
"RTN","ZISTCPS",66,0)
 K ^TMP("ZISTCP",$J)
"RTN","ZISTCPS",67,0)
 ;
"RTN","ZISTCPS",68,0)
 I +$P($ZV,"V",2)<6.1 D  QUIT  ; Not supported under 6.1 of GT.M
"RTN","ZISTCPS",69,0)
 . D LOG("Multi-threaded listener doesn't work in GT.M < 6.1")
"RTN","ZISTCPS",70,0)
 ;
"RTN","ZISTCPS",71,0)
 S NIO="SCK$"_SOCK
"RTN","ZISTCPS",72,0)
 D LOG("Open for Listen "_NIO)
"RTN","ZISTCPS",73,0)
 ;
"RTN","ZISTCPS",74,0)
 ; Open the device
"RTN","ZISTCPS",75,0)
 O NIO:(LISTEN=SOCK_":TCP":ATTACH="server"):2:"SOCKET"
"RTN","ZISTCPS",76,0)
 I '$T D LOG("Can't Open Socket: "_SOCK) QUIT
"RTN","ZISTCPS",77,0)
 ;
"RTN","ZISTCPS",78,0)
 ; Use Device
"RTN","ZISTCPS",79,0)
 U NIO S NIO("ZISTCP",0)=$KEY D LOG("Have port.")
"RTN","ZISTCPS",80,0)
 ;
"RTN","ZISTCPS",81,0)
 ;Start Listening
"RTN","ZISTCPS",82,0)
 W /LISTEN(5) S NIO("ZISTCP",1)=$KEY D LOG("Start Listening. "_NIO("ZISTCP",1))
"RTN","ZISTCPS",83,0)
 ;
"RTN","ZISTCPS",84,0)
 ;Wait for connection
"RTN","ZISTCPS",85,0)
 S POP=0
"RTN","ZISTCPS",86,0)
 F  D  Q:POP
"RTN","ZISTCPS",87,0)
 . S POP=$$EXIT ; Exit?
"RTN","ZISTCPS",88,0)
 . Q:POP        ; oh okay, exit.
"RTN","ZISTCPS",89,0)
 . W /WAIT(5)   ; Wait for connect
"RTN","ZISTCPS",90,0)
 . Q:$KEY=""    ; no connection; loop around, and check if we need to shut down.
"RTN","ZISTCPS",91,0)
 . N CHILDSOCK S CHILDSOCK=$P($KEY,"|",2) ; child socket from server.
"RTN","ZISTCPS",92,0)
 . U NIO:(detach=CHILDSOCK) ; detach it so that we can job it off.
"RTN","ZISTCPS",93,0)
 . S NIO("ZISTCP",2)=$KEY
"RTN","ZISTCPS",94,0)
 . S NIO("SOCK")=$P($G(NIO("ZISTCP",2)),"|",2)
"RTN","ZISTCPS",95,0)
 . D LOG("Got connection on "_NIO("SOCK"))
"RTN","ZISTCPS",96,0)
 . I '$$NEWOK D  QUIT
"RTN","ZISTCPS",97,0)
 . . U NIO:(SOCKET=NIO("SOCK")) W "421 Service temporarily down.",$C(13,10),#
"RTN","ZISTCPS",98,0)
 . . C NIO:(SOCKET=NIO("SOCK")) K NIO("ZISTCP",2)
"RTN","ZISTCPS",99,0)
 . N Q S Q="""" ; next three lines build job command's argument.
"RTN","ZISTCPS",100,0)
 . N ARG S ARG=Q_"SOCKET:"_CHILDSOCK_Q ; ditto
"RTN","ZISTCPS",101,0)
 . N J S J="GTMLNCH("_Q_RTN_Q_"):(input="_ARG_":output="_ARG_":error="_Q_"/dev/null"_Q_")" ; ditto 
"RTN","ZISTCPS",102,0)
 . J @J
"RTN","ZISTCPS",103,0)
 I POP C NIO Q
"RTN","ZISTCPS",104,0)
 Q
"RTN","ZISTCPS",105,0)
 ;
"RTN","ZISTCPS",106,0)
GTMLNCH(RTN) ;Run gt.m job for this conncetion.
"RTN","ZISTCPS",107,0)
 N NIO,SOCK,ZISOS,EXIT,XQVOL,$ETRAP
"RTN","ZISTCPS",108,0)
 S U="^",$ETRAP="D ^%ZTER L  HALT"
"RTN","ZISTCPS",109,0)
 S IO=$P
"RTN","ZISTCPS",110,0)
 X "U IO:(nowrap:nodelimiter:IOERROR=""TRAP"")"
"RTN","ZISTCPS",111,0)
 S IO(0)=IO,IO(1,IO)=""
"RTN","ZISTCPS",112,0)
 D VAR,@RTN
"RTN","ZISTCPS",113,0)
 Q $D(IO("C")) ;Use IO("C") to quit server
"RTN","ZISTCPS",114,0)
 ;
"RTN","ZISTCPS",115,0)
LOG(MSG) ;LOG STATUS
"RTN","ZISTCPS",116,0)
 N CNT
"RTN","ZISTCPS",117,0)
 S CNT=$G(^TMP("ZISTCP",$J))+1,^TMP("ZISTCP",$J)=CNT,^($J,CNT)=MSG
"RTN","ZISTCPS",118,0)
 Q
"RTN","ZISTCPS",119,0)
 ;
"RTN","ZOSV2GTM")
0^2^B12432300
"RTN","ZOSV2GTM",1,0)
%ZOSV2 ;ISF/RWF,FIS/KSB,VEN/SMH - More GT.M support routines ;2017-01-09  3:32 PM
"RTN","ZOSV2GTM",2,0)
 ;;8.0;KERNEL;**275,425,10001**;Jul 10, 1995;Build 21
"RTN","ZOSV2GTM",3,0)
 ; Submitted to OSEHRA in 2017 by Sam Habiel for OSEHRA
"RTN","ZOSV2GTM",4,0)
 ; Original Routine authored by Department of Veterans Affairs
"RTN","ZOSV2GTM",5,0)
 ; All EPs authored by Sam Habiel 2016 except RSUM and RSUM2
"RTN","ZOSV2GTM",6,0)
 ; except: TEST is authored by KS Bhaskar
"RTN","ZOSV2GTM",7,0)
 Q
"RTN","ZOSV2GTM",8,0)
 ;SAVE: DIE open array reference.
"RTN","ZOSV2GTM",9,0)
 ;      XCN is the starting value to $O from.
"RTN","ZOSV2GTM",10,0)
SAVE(RN) ;Save a routine
"RTN","ZOSV2GTM",11,0)
 N %,%F,%I,%N,SP,$ETRAP
"RTN","ZOSV2GTM",12,0)
 S $ETRAP="S $ECODE="""" Q"
"RTN","ZOSV2GTM",13,0)
 S %I=$I,SP=" ",%F=$$RTNDIR^%ZOSV()_$TR(RN,"%","_")_".m"
"RTN","ZOSV2GTM",14,0)
 O %F:(NEWVERSION:NOWRAP:STREAM) U %F
"RTN","ZOSV2GTM",15,0)
 F  S XCN=$O(@(DIE_XCN_")")) Q:XCN'>0  S %=@(DIE_XCN_",0)") Q:$E(%,1)="$"  I $E(%)'=";" W %,!
"RTN","ZOSV2GTM",16,0)
 C %F
"RTN","ZOSV2GTM",17,0)
 I $G(^%ZOSF("COMPILEWARNING")) ZLINK RN
"RTN","ZOSV2GTM",18,0)
 E  ZLINK RN:"-nowarning"
"RTN","ZOSV2GTM",19,0)
 U %I
"RTN","ZOSV2GTM",20,0)
 Q
"RTN","ZOSV2GTM",21,0)
DEL(RN) ; Delete Routine, VEN/SMH
"RTN","ZOSV2GTM",22,0)
 ; Input: Routine Name by Value
"RTN","ZOSV2GTM",23,0)
 ; Output: None
"RTN","ZOSV2GTM",24,0)
 N CNT S CNT=0
"RTN","ZOSV2GTM",25,0)
DELLOOP ; Loop entry point
"RTN","ZOSV2GTM",26,0)
 I CNT>5 S $EC=",U-DELETION-FAILED,"
"RTN","ZOSV2GTM",27,0)
 N %ZR ; Output from GT.M %RSEL
"RTN","ZOSV2GTM",28,0)
 N %S,%O ; Source directory, object directory 
"RTN","ZOSV2GTM",29,0)
 ; 
"RTN","ZOSV2GTM",30,0)
 ; NB: For future works, %RSEL support * syntax to get a bunch of routines
"RTN","ZOSV2GTM",31,0)
 D SILENT^%RSEL(RN,"SRC") S %S=$G(%ZR(RN)) ; Source Directory
"RTN","ZOSV2GTM",32,0)
 D SILENT^%RSEL(RN,"OBJ") S %O=$G(%ZR(RN)) ; Object Directory
"RTN","ZOSV2GTM",33,0)
 ;
"RTN","ZOSV2GTM",34,0)
 I '$L(%S)&('$L(%O)) QUIT
"RTN","ZOSV2GTM",35,0)
 ;
"RTN","ZOSV2GTM",36,0)
 S RN=$TR(RN,"%","_") ; change % to _ in routine name
"RTN","ZOSV2GTM",37,0)
 ;
"RTN","ZOSV2GTM",38,0)
 N $ET,$ES S $ET="Q:$ES  S $EC="""" Q" ; In case somebody else deletes this; we don't crash
"RTN","ZOSV2GTM",39,0)
 ;
"RTN","ZOSV2GTM",40,0)
 I $L(%S) D  ; If source routine present?
"RTN","ZOSV2GTM",41,0)
 . O %S_RN_".m":(newversion):0  ; Write out a new routine that's completely empty.
"RTN","ZOSV2GTM",42,0)
 . E  Q
"RTN","ZOSV2GTM",43,0)
 . ZLINK RN  ; Tell this process that that's the new routine. Other proceses that have the object linked be notified using the RELINK_CTL file.
"RTN","ZOSV2GTM",44,0)
 . C %S_RN_".m":(delete)  ; now delete
"RTN","ZOSV2GTM",45,0)
 . I CNT>3 N % S %=$$RETURN^%ZOSV("rm -r "_%S_RN_".m")
"RTN","ZOSV2GTM",46,0)
 ;
"RTN","ZOSV2GTM",47,0)
 I $L(%O) D  ; If object code present?
"RTN","ZOSV2GTM",48,0)
 . O %O_RN_".o":(readonly):0
"RTN","ZOSV2GTM",49,0)
 . E  Q
"RTN","ZOSV2GTM",50,0)
 . C %O_RN_".o":(delete)
"RTN","ZOSV2GTM",51,0)
 . I CNT>3 N % S %=$$RETURN^%ZOSV("rm -r "_%O_RN_".o")
"RTN","ZOSV2GTM",52,0)
 S CNT=CNT+1
"RTN","ZOSV2GTM",53,0)
 ;
"RTN","ZOSV2GTM",54,0)
 G DELLOOP
"RTN","ZOSV2GTM",55,0)
 ;
"RTN","ZOSV2GTM",56,0)
 ;
"RTN","ZOSV2GTM",57,0)
 ;LOAD: DIF open array to receive the routine lines.
"RTN","ZOSV2GTM",58,0)
LOAD(RN) ;Load a routine using $TEXT
"RTN","ZOSV2GTM",59,0)
 N %
"RTN","ZOSV2GTM",60,0)
 S XCNP=0 F  S %=$T(+$I(XCNP)^@RN) Q:$L(%)=0  S @(DIF_XCNP_",0)")=%
"RTN","ZOSV2GTM",61,0)
 Q
"RTN","ZOSV2GTM",62,0)
 ;
"RTN","ZOSV2GTM",63,0)
LOAD2(RN) ;Load a routine from the Filesystem
"RTN","ZOSV2GTM",64,0)
 N %,%1,%F,%N,$ETRAP
"RTN","ZOSV2GTM",65,0)
 S %I=$I,%F=$$RTNDIR^%ZOSV()_$TR(RN,"%","_")_".m"
"RTN","ZOSV2GTM",66,0)
 O %F:(READONLY):1 Q:'$T  U %F
"RTN","ZOSV2GTM",67,0)
 N CNT S CNT=0
"RTN","ZOSV2GTM",68,0)
 F  R %1 Q:$ZEOF  S CNT=$I(CNT),@(DIF_CNT_",0)")=%1
"RTN","ZOSV2GTM",69,0)
 U:$L(%I) %I C %F
"RTN","ZOSV2GTM",70,0)
 Q
"RTN","ZOSV2GTM",71,0)
 ;
"RTN","ZOSV2GTM",72,0)
RSUM(RN) ;Calculate a RSUM value
"RTN","ZOSV2GTM",73,0)
 N %,DIF,XCNP,%N,Y,$ETRAP K ^TMP("RSUM",$J)
"RTN","ZOSV2GTM",74,0)
 S $ETRAP="S $ECODE="""" Q"
"RTN","ZOSV2GTM",75,0)
 S Y=0,DIF="^TMP(""RSUM"",$J,",XCNP=0 D LOAD2(RN)
"RTN","ZOSV2GTM",76,0)
 F %=1,3:1 S %1=$G(^TMP("RSUM",$J,%,0)),%3=$F(%1," ") Q:'%3  S %3=$S($E(%1,%3)'=";":$L(%1),$E(%1,%3+1)=";":$L(%1),1:%3-2) F %2=1:1:%3 S Y=$A(%1,%2)*%2+Y
"RTN","ZOSV2GTM",77,0)
 K ^TMP("RSUM",$J)
"RTN","ZOSV2GTM",78,0)
 Q Y
"RTN","ZOSV2GTM",79,0)
 ;
"RTN","ZOSV2GTM",80,0)
RSUM2(RN) ;Calculate a RSUM2 value
"RTN","ZOSV2GTM",81,0)
 N %,DIF,XCNP,%N,Y,$ETRAP K ^TMP("RSUM",$J)
"RTN","ZOSV2GTM",82,0)
 S $ETRAP="S $ECODE="""" Q"
"RTN","ZOSV2GTM",83,0)
 S Y=0,DIF="^TMP(""RSUM"",$J,",XCNP=0 D LOAD2(RN)
"RTN","ZOSV2GTM",84,0)
 F %=1,3:1 S %1=$G(^TMP("RSUM",$J,%,0)),%3=$F(%1," ") Q:'%3  S %3=$S($E(%1,%3)'=";":$L(%1),$E(%1,%3+1)=";":$L(%1),1:%3-2) F %2=1:1:%3 S Y=$A(%1,%2)*(%2+%)+Y
"RTN","ZOSV2GTM",85,0)
 K ^TMP("RSUM",$J)
"RTN","ZOSV2GTM",86,0)
 Q Y
"RTN","ZOSV2GTM",87,0)
 ;
"RTN","ZOSV2GTM",88,0)
TEST(RN) ;Special GT.M Test to see if routine is here.
"RTN","ZOSV2GTM",89,0)
 N %ZR
"RTN","ZOSV2GTM",90,0)
 D SILENT^%RSEL(RN) Q $S(%ZR:%ZR(RN)_$TR($E(RN,1),"%","_")_$E(RN,2,$L(RN))_".m",1:"")
"RTN","ZOSVGUT1")
0^14^B130237275
"RTN","ZOSVGUT1",1,0)
ZOSVGUT1 ;KRM/CJE,VEN/SMH - GT.M Kernel unit tests ;2018-06-06  1:29 PM
"RTN","ZOSVGUT1",2,0)
 ;;8.0;KERNEL;**10001,10002**;Aug 28, 2013;Build 21
"RTN","ZOSVGUT1",3,0)
 ; Submitted to OSEHRA in 2017 by Sam Habiel for OSEHRA
"RTN","ZOSVGUT1",4,0)
 ; Authored by Sam Habiel & Christopher Edwards 2014-2016.
"RTN","ZOSVGUT1",5,0)
 ;
"RTN","ZOSVGUT1",6,0)
 ; makes it easy to run tests simply by running this routine and
"RTN","ZOSVGUT1",7,0)
 ; insures that %ut will be run only where it is present
"RTN","ZOSVGUT1",8,0)
 ;
"RTN","ZOSVGUT1",9,0)
 I $T(EN^%ut)'="" D EN^%ut($T(+0),3,1)
"RTN","ZOSVGUT1",10,0)
 Q
"RTN","ZOSVGUT1",11,0)
 ;
"RTN","ZOSVGUT1",12,0)
STARTUP ;
"RTN","ZOSVGUT1",13,0)
 D DUZ^XUP(.5)
"RTN","ZOSVGUT1",14,0)
 QUIT
"RTN","ZOSVGUT1",15,0)
 ;
"RTN","ZOSVGUT1",16,0)
COV ; [Coverage of Unit Tests] Must use M-Unit 1.5 for this!
"RTN","ZOSVGUT1",17,0)
 N NMSPS
"RTN","ZOSVGUT1",18,0)
 S (NMSPS("%ZOSV*"),NMSPS("%ZISH"),NMSPS("ZTMGRSET"))=""
"RTN","ZOSVGUT1",19,0)
 S (NMSPS("XLFNSLK"),NMSPS("XLFIPV"),NMSPS("XUSHSH"),NMSPS("XQ82"))=""
"RTN","ZOSVGUT1",20,0)
 S (NMSPS("ZSY"))=""
"RTN","ZOSVGUT1",21,0)
 D COV^%ut(.NMSPS,"D ^"_$T(+0),1)
"RTN","ZOSVGUT1",22,0)
 QUIT
"RTN","ZOSVGUT1",23,0)
 ;
"RTN","ZOSVGUT1",24,0)
 ;
"RTN","ZOSVGUT1",25,0)
SETNM ; @TEST Set Environment Name
"RTN","ZOSVGUT1",26,0)
 D SETNM^%ZOSV("ZOSV UT for GT.M")
"RTN","ZOSVGUT1",27,0)
 QUIT
"RTN","ZOSVGUT1",28,0)
 ;
"RTN","ZOSVGUT1",29,0)
ZRO1 ; @TEST $ZROUTINES Parsing Single Object Multiple dirs
"RTN","ZOSVGUT1",30,0)
 N ZR S ZR="o(p r) /var/abc(/var/abc/r/) /abc/def $gtm_dist/libgtmutl.so vista.so"
"RTN","ZOSVGUT1",31,0)
 N DIRS D PARSEZRO^%ZOSV(.DIRS,ZR)
"RTN","ZOSVGUT1",32,0)
 N FIRSTDIR S FIRSTDIR=$$ZRO1ST^%ZOSV(.DIRS)
"RTN","ZOSVGUT1",33,0)
 D CHKEQ^%ut(FIRSTDIR,"p/")
"RTN","ZOSVGUT1",34,0)
 QUIT
"RTN","ZOSVGUT1",35,0)
 ;
"RTN","ZOSVGUT1",36,0)
ZRO2 ; @TEST $ZROUTINES Parsing 2 Single Object Single dir
"RTN","ZOSVGUT1",37,0)
 N ZR S ZR="/var/abc(/var/abc/r/) o(p r) /abc/def $gtm_dist/libgtmutl.so vista.so"
"RTN","ZOSVGUT1",38,0)
 N DIRS D PARSEZRO^%ZOSV(.DIRS,ZR)
"RTN","ZOSVGUT1",39,0)
 N FIRSTDIR S FIRSTDIR=$$ZRO1ST^%ZOSV(.DIRS)
"RTN","ZOSVGUT1",40,0)
 D CHKEQ^%ut(FIRSTDIR,"/var/abc/r/")
"RTN","ZOSVGUT1",41,0)
 QUIT
"RTN","ZOSVGUT1",42,0)
 ;
"RTN","ZOSVGUT1",43,0)
ZRO3 ; @TEST $ZROUTINES Parsing Shared Object/Code dir
"RTN","ZOSVGUT1",44,0)
 N ZR S ZR="/abc/def /var/abc(/var/abc/r/) o(p r) $gtm_dist/libgtmutl.so vista.so"
"RTN","ZOSVGUT1",45,0)
 N DIRS D PARSEZRO^%ZOSV(.DIRS,ZR)
"RTN","ZOSVGUT1",46,0)
 N FIRSTDIR S FIRSTDIR=$$ZRO1ST^%ZOSV(.DIRS)
"RTN","ZOSVGUT1",47,0)
 D CHKEQ^%ut(FIRSTDIR,"/abc/def/")
"RTN","ZOSVGUT1",48,0)
 QUIT
"RTN","ZOSVGUT1",49,0)
 ;
"RTN","ZOSVGUT1",50,0)
ZRO4 ; @TEST $ZROUTINES Parsing Single Directory by itself
"RTN","ZOSVGUT1",51,0)
 N ZR S ZR="/home/osehra/r"
"RTN","ZOSVGUT1",52,0)
 N DIRS D PARSEZRO^%ZOSV(.DIRS,ZR)
"RTN","ZOSVGUT1",53,0)
 N FIRSTDIR S FIRSTDIR=$$ZRO1ST^%ZOSV(.DIRS)
"RTN","ZOSVGUT1",54,0)
 D CHKEQ^%ut(FIRSTDIR,"/home/osehra/r/")
"RTN","ZOSVGUT1",55,0)
 QUIT
"RTN","ZOSVGUT1",56,0)
 ;
"RTN","ZOSVGUT1",57,0)
ZRO5 ; @TEST $ZROUTINES Parsing Leading Space
"RTN","ZOSVGUT1",58,0)
 N ZR S ZR=" o(p r) /var/abc(/var/abc/r/) /abc/def $gtm_dist/libgtmutl.so vista.so"
"RTN","ZOSVGUT1",59,0)
 N DIRS D PARSEZRO^%ZOSV(.DIRS,ZR)
"RTN","ZOSVGUT1",60,0)
 N FIRSTDIR S FIRSTDIR=$$ZRO1ST^%ZOSV(.DIRS)
"RTN","ZOSVGUT1",61,0)
 D CHKEQ^%ut(FIRSTDIR,"p/")
"RTN","ZOSVGUT1",62,0)
 QUIT
"RTN","ZOSVGUT1",63,0)
 ;
"RTN","ZOSVGUT1",64,0)
 ;
"RTN","ZOSVGUT1",65,0)
ZRO7 ; @TEST $ZROUTINES Shared Object Only
"RTN","ZOSVGUT1",66,0)
 N ZR S ZR="/home/osehra/lib/gtm/libgtmutil.so"
"RTN","ZOSVGUT1",67,0)
 N DIRS D PARSEZRO^%ZOSV(.DIRS,ZR)
"RTN","ZOSVGUT1",68,0)
 N FIRSTDIR S FIRSTDIR=$$ZRO1ST^%ZOSV(.DIRS)
"RTN","ZOSVGUT1",69,0)
 D CHKEQ^%ut(FIRSTDIR,"")
"RTN","ZOSVGUT1",70,0)
 Q
"RTN","ZOSVGUT1",71,0)
 ;
"RTN","ZOSVGUT1",72,0)
ZRO8 ; @TEST $ZROUTINES No shared object
"RTN","ZOSVGUT1",73,0)
 N ZR S ZR="/home/osehra/r/V6.0-002_x86_64(/home/osehra/r) /home/osehra/lib/gtm"
"RTN","ZOSVGUT1",74,0)
 N DIRS D PARSEZRO^%ZOSV(.DIRS,ZR)
"RTN","ZOSVGUT1",75,0)
 N FIRSTDIR S FIRSTDIR=$$ZRO1ST^%ZOSV(.DIRS)
"RTN","ZOSVGUT1",76,0)
 D CHKEQ^%ut(FIRSTDIR,"/home/osehra/r/")
"RTN","ZOSVGUT1",77,0)
 Q
"RTN","ZOSVGUT1",78,0)
 ;
"RTN","ZOSVGUT1",79,0)
ZRO9 ; @TEST $ZROUTINES Shared Object First
"RTN","ZOSVGUT1",80,0)
 N ZR S ZR="/home/osehra/lib/gtm/libgtmutil.so /home/osehra/r/V6.0-002_x86_64(/home/osehra/r)"
"RTN","ZOSVGUT1",81,0)
 N DIRS D PARSEZRO^%ZOSV(.DIRS,ZR)
"RTN","ZOSVGUT1",82,0)
 N FIRSTDIR S FIRSTDIR=$$ZRO1ST^%ZOSV(.DIRS)
"RTN","ZOSVGUT1",83,0)
 D CHKEQ^%ut(FIRSTDIR,"/home/osehra/r/")
"RTN","ZOSVGUT1",84,0)
 Q
"RTN","ZOSVGUT1",85,0)
 ;
"RTN","ZOSVGUT1",86,0)
ZRO10 ; @TEST $ZROUTINES Shared Object First but multiple rtn dirs
"RTN","ZOSVGUT1",87,0)
 N ZR S ZR="/home/osehra/lib/gtm/libgtmutil.so /home/osehra/p/V6.0-002_x86_64(/home/osehra/p) /home/osehra/s/V6.0-002_x86_64(/home/osehra/s) /home/osehra/r/V6.0-002_x86_64(/home/osehra/r)"
"RTN","ZOSVGUT1",88,0)
 N DIRS D PARSEZRO^%ZOSV(.DIRS,ZR)
"RTN","ZOSVGUT1",89,0)
 N FIRSTDIR S FIRSTDIR=$$ZRO1ST^%ZOSV(.DIRS)
"RTN","ZOSVGUT1",90,0)
 D CHKEQ^%ut(FIRSTDIR,"/home/osehra/p/")
"RTN","ZOSVGUT1",91,0)
 Q
"RTN","ZOSVGUT1",92,0)
 ;
"RTN","ZOSVGUT1",93,0)
ZRO99 ; @TEST $$RTNDIR^%ZOSV Shouldn't be Empty
"RTN","ZOSVGUT1",94,0)
 N RTNDIR S RTNDIR=$$RTNDIR^%ZOSV
"RTN","ZOSVGUT1",95,0)
 D CHKTF^%ut(RTNDIR]"")
"RTN","ZOSVGUT1",96,0)
 QUIT
"RTN","ZOSVGUT1",97,0)
 ;
"RTN","ZOSVGUT1",98,0)
ACTJ ; @TEST Default path through ACTJ^ZOSV
"RTN","ZOSVGUT1",99,0)
 N ACTJ
"RTN","ZOSVGUT1",100,0)
 ; Run the algorithm
"RTN","ZOSVGUT1",101,0)
 S ACTJ=$$ACTJ^%ZOSV
"RTN","ZOSVGUT1",102,0)
 D CHKTF^%ut(ACTJ>0,"$$ACTJ^%ZOSV didn't return the correct value")
"RTN","ZOSVGUT1",103,0)
 Q
"RTN","ZOSVGUT1",104,0)
 ;
"RTN","ZOSVGUT1",105,0)
ACTJ0 ; @TEST Force ^XUTL("XUSYS","CNT") to 0 to force algorithm to run
"RTN","ZOSVGUT1",106,0)
 ; Force algorithm to run
"RTN","ZOSVGUT1",107,0)
 S ^XUTL("XUSYS","CNT")=0
"RTN","ZOSVGUT1",108,0)
 ; Run the algorithm
"RTN","ZOSVGUT1",109,0)
 N ACTJ S ACTJ=$$ACTJ^%ZOSV
"RTN","ZOSVGUT1",110,0)
 D CHKTF^%ut(ACTJ,"Active Jobs must not be zero")
"RTN","ZOSVGUT1",111,0)
 ;
"RTN","ZOSVGUT1",112,0)
 ; Run again, but this time we get the cached result
"RTN","ZOSVGUT1",113,0)
 N ACTJ2 S ACTJ2=$$ACTJ^%ZOSV
"RTN","ZOSVGUT1",114,0)
 D CHKEQ^%ut(ACTJ2,ACTJ,"$$ACTJ^%ZOSV is out of sync with jobs on file")
"RTN","ZOSVGUT1",115,0)
 ;
"RTN","ZOSVGUT1",116,0)
 ; Force algorithm to run
"RTN","ZOSVGUT1",117,0)
 S ^XUTL("XUSYS","CNT")=0
"RTN","ZOSVGUT1",118,0)
 ; Run the algorithm
"RTN","ZOSVGUT1",119,0)
 N ACTJ3 S ACTJ3=$$ACTJ^%ZOSV
"RTN","ZOSVGUT1",120,0)
 D CHKEQ^%ut(ACTJ2,ACTJ3,"$$ACTJ^%ZOSV is out of sync with jobs on file")
"RTN","ZOSVGUT1",121,0)
 ; 
"RTN","ZOSVGUT1",122,0)
 Q
"RTN","ZOSVGUT1",123,0)
 ;
"RTN","ZOSVGUT1",124,0)
AVJ ; @TEST Available Jobs
"RTN","ZOSVGUT1",125,0)
 D CHKTF^%ut($$AVJ^%ZOSV>0)
"RTN","ZOSVGUT1",126,0)
 QUIT
"RTN","ZOSVGUT1",127,0)
 ;
"RTN","ZOSVGUT1",128,0)
DEVOK ; @TEST Dev Okay
"RTN","ZOSVGUT1",129,0)
 N X,X1,Y
"RTN","ZOSVGUT1",130,0)
 S X="ORB NOTIFICATION RESOURCE",X1="RES" D DEVOK^%ZOSV
"RTN","ZOSVGUT1",131,0)
 D CHKTF^%ut(Y=0)
"RTN","ZOSVGUT1",132,0)
 S X="NULL" D DEVOK^%ZOSV
"RTN","ZOSVGUT1",133,0)
 D CHKTF^%ut(Y=0)
"RTN","ZOSVGUT1",134,0)
 QUIT
"RTN","ZOSVGUT1",135,0)
 ;
"RTN","ZOSVGUT1",136,0)
DEVOPN ; @TEST Show open devices
"RTN","ZOSVGUT1",137,0)
 N Y D DEVOPN^%ZOSV
"RTN","ZOSVGUT1",138,0)
 D CHKTF^%ut(Y'="")
"RTN","ZOSVGUT1",139,0)
 QUIT
"RTN","ZOSVGUT1",140,0)
 ;
"RTN","ZOSVGUT1",141,0)
GETPEER ; @TEST Get Peer
"RTN","ZOSVGUT1",142,0)
 N PEER S PEER=$$GETPEER^%ZOSV
"RTN","ZOSVGUT1",143,0)
 D SUCCEED^%ut
"RTN","ZOSVGUT1",144,0)
 QUIT
"RTN","ZOSVGUT1",145,0)
 ;
"RTN","ZOSVGUT1",146,0)
PRGMODE ; @TEST Prog Mode
"RTN","ZOSVGUT1",147,0)
 N % S %=$$PROGMODE^%ZOSV()
"RTN","ZOSVGUT1",148,0)
 D PRGMODE^%ZOSV
"RTN","ZOSVGUT1",149,0)
 D SUCCEED^%ut
"RTN","ZOSVGUT1",150,0)
 QUIT
"RTN","ZOSVGUT1",151,0)
 ;
"RTN","ZOSVGUT1",152,0)
JOBPAR ; @TEST Job Parameter -- Dummy; doesn't do anything useful.
"RTN","ZOSVGUT1",153,0)
 N X,Y S X=$J D JOBPAR^%ZOSV
"RTN","ZOSVGUT1",154,0)
 D SUCCEED^%ut
"RTN","ZOSVGUT1",155,0)
 QUIT
"RTN","ZOSVGUT1",156,0)
 ;
"RTN","ZOSVGUT1",157,0)
LOGRSRC ; @TEST Turn on Resource Logging
"RTN","ZOSVGUT1",158,0)
 ; KMPR package not ported to GT.M. Noop.
"RTN","ZOSVGUT1",159,0)
 D LOGRSRC^%ZOSV("TEST",1,"OPEN")
"RTN","ZOSVGUT1",160,0)
 QUIT
"RTN","ZOSVGUT1",161,0)
 ;
"RTN","ZOSVGUT1",162,0)
ORDER ; @TEST Order
"RTN","ZOSVGUT1",163,0)
 N X,Y
"RTN","ZOSVGUT1",164,0)
 S X="^TMP($J,"
"RTN","ZOSVGUT1",165,0)
 K ^TMP($J)
"RTN","ZOSVGUT1",166,0)
 S Y="%ut*"
"RTN","ZOSVGUT1",167,0)
 D ORDER^%ZOSV
"RTN","ZOSVGUT1",168,0)
 D CHKTF^%ut(^TMP($J,"%ut","CHK")) ; Must be a number
"RTN","ZOSVGUT1",169,0)
 QUIT
"RTN","ZOSVGUT1",170,0)
 ;
"RTN","ZOSVGUT1",171,0)
DOLRO ; @TEST Ensure symbol table is saved correctly
"RTN","ZOSVGUT1",172,0)
 N TEST,X
"RTN","ZOSVGUT1",173,0)
 ; Will check for this variable and value in the open root
"RTN","ZOSVGUT1",174,0)
 S TEST="TEST1"
"RTN","ZOSVGUT1",175,0)
 ; DOLRO reads the variable X to figure put where to save the symbol table to
"RTN","ZOSVGUT1",176,0)
 S X="^TMP(""ZZUTZOSV"","
"RTN","ZOSVGUT1",177,0)
 ; Save the symbol table
"RTN","ZOSVGUT1",178,0)
 D DOLRO^%ZOSV
"RTN","ZOSVGUT1",179,0)
 D CHKEQ^%ut(^TMP("ZZUTZOSV","TEST"),"TEST1","DOLRO^%ZSOV Didn't save the correct variable value")
"RTN","ZOSVGUT1",180,0)
 ; Debug
"RTN","ZOSVGUT1",181,0)
 ; ZWR ^TMP("ZZUTZOSV",*)
"RTN","ZOSVGUT1",182,0)
 ; Kill test variable
"RTN","ZOSVGUT1",183,0)
 K ^TMP("ZZUTZOSV")
"RTN","ZOSVGUT1",184,0)
 Q
"RTN","ZOSVGUT1",185,0)
 ;
"RTN","ZOSVGUT1",186,0)
TMTRAN ; @TEST Make sure that Taskman is running
"RTN","ZOSVGUT1",187,0)
 I '$$TM^%ZTLOAD() D FAIL^%ut("Can't run this test. Taskman isn't running.") QUIT
"RTN","ZOSVGUT1",188,0)
 ;
"RTN","ZOSVGUT1",189,0)
 N ZTSK D Q^XUTMTZ
"RTN","ZOSVGUT1",190,0)
 D CHKTF^%ut(ZTSK)
"RTN","ZOSVGUT1",191,0)
 N TOTALWAIT S TOTALWAIT=0
"RTN","ZOSVGUT1",192,0)
 F  Q:'$D(^%ZTSK(ZTSK))  H .05 S TOTALWAIT=TOTALWAIT+.05 Q:TOTALWAIT>3
"RTN","ZOSVGUT1",193,0)
 D CHKTF^%ut(TOTALWAIT<2,"Taskman didn't process task")
"RTN","ZOSVGUT1",194,0)
 QUIT
"RTN","ZOSVGUT1",195,0)
 ;
"RTN","ZOSVGUT1",196,0)
GETENV ; @TEST Test GETENV
"RTN","ZOSVGUT1",197,0)
 N Y D GETENV^%ZOSV
"RTN","ZOSVGUT1",198,0)
 D CHKEQ^%ut($L(Y,"^"),4)
"RTN","ZOSVGUT1",199,0)
 QUIT
"RTN","ZOSVGUT1",200,0)
 ;
"RTN","ZOSVGUT1",201,0)
OS ; @TEST OS
"RTN","ZOSVGUT1",202,0)
 D CHKEQ^%ut($$OS^%ZOSV(),"UNIX")
"RTN","ZOSVGUT1",203,0)
 QUIT
"RTN","ZOSVGUT1",204,0)
 ;
"RTN","ZOSVGUT1",205,0)
VERSION ; @TEST VERSION
"RTN","ZOSVGUT1",206,0)
 N V0 S V0=$$VERSION^%ZOSV(0)
"RTN","ZOSVGUT1",207,0)
 N OS S OS=$$VERSION^%ZOSV(1)
"RTN","ZOSVGUT1",208,0)
 D CHKTF^%ut(V0,"Must be positive")
"RTN","ZOSVGUT1",209,0)
 D CHKTF^%ut($L(V0,"-")=2,"Must be in xx.xxxx")
"RTN","ZOSVGUT1",210,0)
 D CHKTF^%ut(OS["nux"!(OS["nix")!(OS["BSD")!(OS["Darwin")!(OS["CYGWIN"))
"RTN","ZOSVGUT1",211,0)
 QUIT
"RTN","ZOSVGUT1",212,0)
 ;
"RTN","ZOSVGUT1",213,0)
SID ; @TEST System ID
"RTN","ZOSVGUT1",214,0)
 N SID S SID=$$SID^%ZOSV
"RTN","ZOSVGUT1",215,0)
 D CHKTF^%ut(SID[$ZGBLDIR)
"RTN","ZOSVGUT1",216,0)
 QUIT
"RTN","ZOSVGUT1",217,0)
 ;
"RTN","ZOSVGUT1",218,0)
UCI ; @TEST Get UCI/Vol
"RTN","ZOSVGUT1",219,0)
 N Y D UCI^%ZOSV
"RTN","ZOSVGUT1",220,0)
 D CHKTF^%ut(Y=^%ZOSF("PROD"))
"RTN","ZOSVGUT1",221,0)
 QUIT
"RTN","ZOSVGUT1",222,0)
UCICHECK ; @TEST Noop
"RTN","ZOSVGUT1",223,0)
 N % S %=$$UCICHECK^%ZOSV(88)
"RTN","ZOSVGUT1",224,0)
 D CHKEQ^%ut(88,%)
"RTN","ZOSVGUT1",225,0)
 QUIT
"RTN","ZOSVGUT1",226,0)
PARSIZ ; @TEST PARSIZE NOOP
"RTN","ZOSVGUT1",227,0)
 N X
"RTN","ZOSVGUT1",228,0)
 D PARSIZ^%ZOSV
"RTN","ZOSVGUT1",229,0)
 D SUCCEED^%ut
"RTN","ZOSVGUT1",230,0)
 QUIT
"RTN","ZOSVGUT1",231,0)
NOLOG ; @TEST NOLOG NOOP
"RTN","ZOSVGUT1",232,0)
 N Y
"RTN","ZOSVGUT1",233,0)
 D NOLOG^%ZOSV
"RTN","ZOSVGUT1",234,0)
 D SUCCEED^%ut
"RTN","ZOSVGUT1",235,0)
 QUIT
"RTN","ZOSVGUT1",236,0)
 ;
"RTN","ZOSVGUT1",237,0)
SHARELIC ; @TEST SHARELIC NOOP
"RTN","ZOSVGUT1",238,0)
 D SHARELIC^%ZOSV()
"RTN","ZOSVGUT1",239,0)
 D SUCCEED^%ut
"RTN","ZOSVGUT1",240,0)
 QUIT
"RTN","ZOSVGUT1",241,0)
 ;
"RTN","ZOSVGUT1",242,0)
PRIORITY ; @TEST PRIORITY NOOP
"RTN","ZOSVGUT1",243,0)
 D PRIORITY^%ZOSV
"RTN","ZOSVGUT1",244,0)
 D SUCCEED^%ut
"RTN","ZOSVGUT1",245,0)
 QUIT
"RTN","ZOSVGUT1",246,0)
 ;
"RTN","ZOSVGUT1",247,0)
PRIINQ ; @TEST PRIINQ() NOOP
"RTN","ZOSVGUT1",248,0)
 N % S %=$$PRIINQ^%ZOSV()
"RTN","ZOSVGUT1",249,0)
 D SUCCEED^%ut
"RTN","ZOSVGUT1",250,0)
 QUIT
"RTN","ZOSVGUT1",251,0)
 ;
"RTN","ZOSVGUT1",252,0)
BAUD ; @TEST BAUD NOOP
"RTN","ZOSVGUT1",253,0)
 N X D BAUD^%ZOSV
"RTN","ZOSVGUT1",254,0)
 D SUCCEED^%ut
"RTN","ZOSVGUT1",255,0)
 S X="UNKNOWN"
"RTN","ZOSVGUT1",256,0)
 QUIT
"RTN","ZOSVGUT1",257,0)
 ;
"RTN","ZOSVGUT1",258,0)
SETTRM ; @TEST Set Terminators
"RTN","ZOSVGUT1",259,0)
 N % S %=$$SETTRM^%ZOSV($C(10,13))
"RTN","ZOSVGUT1",260,0)
 D CHKEQ^%ut(%,1)
"RTN","ZOSVGUT1",261,0)
 X ^%ZOSF("TRMON") ; Reset terminators
"RTN","ZOSVGUT1",262,0)
 QUIT
"RTN","ZOSVGUT1",263,0)
 ;
"RTN","ZOSVGUT1",264,0)
LGR ; @TEST Last Global Reference
"RTN","ZOSVGUT1",265,0)
 S ^TMP($J)=""
"RTN","ZOSVGUT1",266,0)
 I ^TMP($J)
"RTN","ZOSVGUT1",267,0)
 N R S R=$$LGR^%ZOSV()
"RTN","ZOSVGUT1",268,0)
 D CHKEQ^%ut(R,$NA(^TMP($J)))
"RTN","ZOSVGUT1",269,0)
 K ^TMP($J)
"RTN","ZOSVGUT1",270,0)
 QUIT
"RTN","ZOSVGUT1",271,0)
 ;
"RTN","ZOSVGUT1",272,0)
EC ; @TEST $$EC
"RTN","ZOSVGUT1",273,0)
 N A,%
"RTN","ZOSVGUT1",274,0)
 N $ET S $ET="S A=$$EC^%ZOSV,$EC="""" G EC1"
"RTN","ZOSVGUT1",275,0)
 S %=1/0
"RTN","ZOSVGUT1",276,0)
EC1 ;
"RTN","ZOSVGUT1",277,0)
 D CHKTF^%ut(A["divide")
"RTN","ZOSVGUT1",278,0)
 QUIT
"RTN","ZOSVGUT1",279,0)
 ;
"RTN","ZOSVGUT1",280,0)
ZTMGRSET ; @TEST ZTMGRSET Renames Routines on GT.M
"RTN","ZOSVGUT1",281,0)
 ;ZEXCEPT: shell
"RTN","ZOSVGUT1",282,0)
 N %ZR,%Y,%YY
"RTN","ZOSVGUT1",283,0)
 N RTNFS S RTNFS="_ZTLOAD1.o"
"RTN","ZOSVGUT1",284,0)
 D SILENT^%RSEL("%ZTLOAD1","OBJ")
"RTN","ZOSVGUT1",285,0)
 N FILE S FILE=%ZR("%ZTLOAD1")_RTNFS
"RTN","ZOSVGUT1",286,0)
 S %Y=$$RETURN^%ZOSV("stat -c %X "_FILE)
"RTN","ZOSVGUT1",287,0)
 N ZTOS S ZTOS=$$OSNUM^ZTMGRSET()
"RTN","ZOSVGUT1",288,0)
 N SCR S SCR="I 0"
"RTN","ZOSVGUT1",289,0)
 N ZTMODE S ZTMODE=2
"RTN","ZOSVGUT1",290,0)
 N IOP S IOP="NULL" D ^%ZIS U IO
"RTN","ZOSVGUT1",291,0)
 D DOIT^ZTMGRSET
"RTN","ZOSVGUT1",292,0)
 D ^%ZISC
"RTN","ZOSVGUT1",293,0)
 D SILENT^%RSEL("%ZTLOAD1","OBJ")
"RTN","ZOSVGUT1",294,0)
 N FILE S FILE=%ZR("%ZTLOAD1")_RTNFS
"RTN","ZOSVGUT1",295,0)
 S %YY=$$RETURN^%ZOSV("stat -c %X "_FILE)
"RTN","ZOSVGUT1",296,0)
 D CHKTF^%ut(%YY'<%Y)
"RTN","ZOSVGUT1",297,0)
 ;
"RTN","ZOSVGUT1",298,0)
 ; Now that we know that it works, just run some of the other EPs to inc coverage
"RTN","ZOSVGUT1",299,0)
 N IOP S IOP="NULL" D ^%ZIS U IO
"RTN","ZOSVGUT1",300,0)
 D PATCH^ZTMGRSET(599) ; %ZIS
"RTN","ZOSVGUT1",301,0)
 ;
"RTN","ZOSVGUT1",302,0)
 N DTIME S DTIME=.001
"RTN","ZOSVGUT1",303,0)
 D NAME^ZTMGRSET
"RTN","ZOSVGUT1",304,0)
 D GLOBALS^ZTMGRSET
"RTN","ZOSVGUT1",305,0)
 D RUM^ZTMGRSET
"RTN","ZOSVGUT1",306,0)
 D ^%ZISC
"RTN","ZOSVGUT1",307,0)
 QUIT
"RTN","ZOSVGUT1",308,0)
 ;
"RTN","ZOSVGUT1",309,0)
ZHOROLOG ; @TEST $ZHOROLOG Functions
"RTN","ZOSVGUT1",310,0)
 Q:$$VERSION^%ZOSV<6.3
"RTN","ZOSVGUT1",311,0)
 N %ZH0,%ZH1,%ZH2
"RTN","ZOSVGUT1",312,0)
 D T0^%ZOSV
"RTN","ZOSVGUT1",313,0)
 D CHKTF^%ut(%ZH0)
"RTN","ZOSVGUT1",314,0)
 D CHKTF^%ut($L(%ZH0,",")=4)
"RTN","ZOSVGUT1",315,0)
 D T1^%ZOSV
"RTN","ZOSVGUT1",316,0)
 D CHKTF^%ut(%ZH1)
"RTN","ZOSVGUT1",317,0)
 D CHKTF^%ut($L(%ZH1,",")=4)
"RTN","ZOSVGUT1",318,0)
 D ZHDIF^%ZOSV
"RTN","ZOSVGUT1",319,0)
 D CHKTF^%ut(%ZH2<.001,"%ZH2 is "_%ZH2)
"RTN","ZOSVGUT1",320,0)
 QUIT
"RTN","ZOSVGUT1",321,0)
 ;
"RTN","ZOSVGUT1",322,0)
TEMP ; @TEST getting temp directory
"RTN","ZOSVGUT1",323,0)
 N TMP S TMP=$$TEMP^%ZOSV()
"RTN","ZOSVGUT1",324,0)
 N FN S FN=TMP_"/test.txt"
"RTN","ZOSVGUT1",325,0)
 O FN:newvesrion
"RTN","ZOSVGUT1",326,0)
 U FN
"RTN","ZOSVGUT1",327,0)
 W "TEST",!
"RTN","ZOSVGUT1",328,0)
 C FN:delete
"RTN","ZOSVGUT1",329,0)
 D SUCCEED^%ut
"RTN","ZOSVGUT1",330,0)
 QUIT
"RTN","ZOSVGUT1",331,0)
 ;
"RTN","ZOSVGUT1",332,0)
PASS ; @TEST PASTHRU and NOPASS
"RTN","ZOSVGUT1",333,0)
 D PASSALL^%ZOSV
"RTN","ZOSVGUT1",334,0)
 D NOPASS^%ZOSV
"RTN","ZOSVGUT1",335,0)
 D SUCCEED^%ut
"RTN","ZOSVGUT1",336,0)
 QUIT
"RTN","ZOSVGUT1",337,0)
 ;
"RTN","ZOSVGUT1",338,0)
NSLOOKUP ; @TEST Test DNS Utilities
"RTN","ZOSVGUT1",339,0)
 ; REVERSE DNS
"RTN","ZOSVGUT1",340,0)
 N % S %=$$HOST^XLFNSLK("208.67.220.220")
"RTN","ZOSVGUT1",341,0)
 D CHKTF^%ut(%["opendns")
"RTN","ZOSVGUT1",342,0)
 N % S %=$$HOST^XLFNSLK("2607:F8B0:400D:0C01:0000:0000:0000:0066")
"RTN","ZOSVGUT1",343,0)
 D CHKTF^%ut(%["1e100")
"RTN","ZOSVGUT1",344,0)
 N % S %=$$HOST^XLFNSLK("")
"RTN","ZOSVGUT1",345,0)
 D SUCCEED^%ut
"RTN","ZOSVGUT1",346,0)
 N % S %=$$HOST^XLFNSLK("93.184.216.34") ; example.com doesn't have reverse dns
"RTN","ZOSVGUT1",347,0)
 D CHKTF^%ut(%="")
"RTN","ZOSVGUT1",348,0)
 ;
"RTN","ZOSVGUT1",349,0)
 ; FORWARD DNS
"RTN","ZOSVGUT1",350,0)
 ; dig may fail with localhost lookup
"RTN","ZOSVGUT1",351,0)
 N IPV6 S IPV6=$$VERSION^XLFIPV
"RTN","ZOSVGUT1",352,0)
 I IPV6 D CHKTF^%ut($$ADDRESS^XLFNSLK("localhost")["0000:0000:0000:0000:0000:0000:0000:000") I 1
"RTN","ZOSVGUT1",353,0)
 E  D CHKTF^%ut(($$ADDRESS^XLFNSLK("localhost")["127.0.0.1")!($$ADDRESS^XLFNSLK("localhost")["0.0.0.0"))
"RTN","ZOSVGUT1",354,0)
 D CHKTF^%ut(($$ADDRESS^XLFNSLK("localhost","A")["127.0.0.1")!($$ADDRESS^XLFNSLK("localhost","A")["0.0.0.0"))
"RTN","ZOSVGUT1",355,0)
 D CHKTF^%ut($$ADDRESS^XLFNSLK("localhost","AAAA")["0000:0000:0000:0000:0000:0000:0000:000")
"RTN","ZOSVGUT1",356,0)
 QUIT
"RTN","ZOSVGUT1",357,0)
 ;
"RTN","ZOSVGUT1",358,0)
IPV6 ; @TEST Test GT.M support for IPV6
"RTN","ZOSVGUT1",359,0)
 I $ZV["CYGWIN" QUIT  ; We run Cygwin on IPv4 only as Cygwin doesn't support between the two as well as Linux
"RTN","ZOSVGUT1",360,0)
 D CHKEQ^%ut($$VERSION^XLFIPV(),1)
"RTN","ZOSVGUT1",361,0)
 QUIT
"RTN","ZOSVGUT1",362,0)
 ;
"RTN","ZOSVGUT1",363,0)
SSVNJOB ; @TEST Replacement for ^$JOB in XQ82
"RTN","ZOSVGUT1",364,0)
 ; ZEXCEPT: SSVNJOB,SSVNJOB1,ERR,IN
"RTN","ZOSVGUT1",365,0)
 L +SSVNJOB
"RTN","ZOSVGUT1",366,0)
 J SSVNJOB1:(IN="/dev/null":OUT="/dev/null":ERR="/dev/null")
"RTN","ZOSVGUT1",367,0)
 N CHILDPID S CHILDPID=$ZJOB
"RTN","ZOSVGUT1",368,0)
 L -SSVNJOB
"RTN","ZOSVGUT1",369,0)
 H .01 ; This must be big enough to let your computer start the job
"RTN","ZOSVGUT1",370,0)
 I $ZV["CYGWIN" H 1 ; Wish I knew why...
"RTN","ZOSVGUT1",371,0)
 I $ZV["arm" H 1 ; Arm chips too slow...
"RTN","ZOSVGUT1",372,0)
 L +SSVNJOB
"RTN","ZOSVGUT1",373,0)
 L
"RTN","ZOSVGUT1",374,0)
 D CHKTF^%ut($D(^TMP(CHILDPID)))
"RTN","ZOSVGUT1",375,0)
 S ^XUTL("XQ",$J)="" ; So that ^XQ82 won't kill our temp globals 
"RTN","ZOSVGUT1",376,0)
 D ^XQ82
"RTN","ZOSVGUT1",377,0)
 D CHKTF^%ut('$D(^TMP(CHILDPID)))
"RTN","ZOSVGUT1",378,0)
 QUIT
"RTN","ZOSVGUT1",379,0)
 ;
"RTN","ZOSVGUT1",380,0)
SSVNJOB1 ; [Private] Helper for SSVNJOB
"RTN","ZOSVGUT1",381,0)
 ; ZEXCEPT: SSVNJOB
"RTN","ZOSVGUT1",382,0)
 L +SSVNJOB
"RTN","ZOSVGUT1",383,0)
 K ^TMP($J)
"RTN","ZOSVGUT1",384,0)
 S ^TMP($J,"SAM")=1
"RTN","ZOSVGUT1",385,0)
 S ^TMP($J,"CHRISTOPHER")=2
"RTN","ZOSVGUT1",386,0)
 L -SSVNJOB
"RTN","ZOSVGUT1",387,0)
 QUIT
"RTN","ZOSVGUT1",388,0)
 ;
"RTN","ZOSVGUT1",389,0)
ZSY ; @TEST Run System Status
"RTN","ZOSVGUT1",390,0)
 ; ZEXCEPT: in,out,err
"RTN","ZOSVGUT1",391,0)
 N IOP S IOP="NULL" D ^%ZIS U IO
"RTN","ZOSVGUT1",392,0)
 D ^ZSY
"RTN","ZOSVGUT1",393,0)
 N %utAnswer s %utAnswer=2
"RTN","ZOSVGUT1",394,0)
 D QUERY^ZSY
"RTN","ZOSVGUT1",395,0)
 N nProcs s nProcs=$$UNIXLSOF^ZSY()
"RTN","ZOSVGUT1",396,0)
 D HALTALL^ZSY ; Kill all other processes
"RTN","ZOSVGUT1",397,0)
 i $zv["arm" h 5 ; Needed for Arm chips... not fast enough in the kill
"RTN","ZOSVGUT1",398,0)
 N nProcsAfter S nProcsAfter=$$UNIXLSOF^ZSY()
"RTN","ZOSVGUT1",399,0)
 D CHKTF^%ut(nProcs>nProcsAfter)
"RTN","ZOSVGUT1",400,0)
 D CHKTF^%ut(nProcsAfter=1)
"RTN","ZOSVGUT1",401,0)
 D ^ZTMB ; bring it back up.
"RTN","ZOSVGUT1",402,0)
 D LW^ZSY
"RTN","ZOSVGUT1",403,0)
 D ERR^ZSY
"RTN","ZOSVGUT1",404,0)
 D UERR^ZSY
"RTN","ZOSVGUT1",405,0)
 D SUCCEED^%ut
"RTN","ZOSVGUT1",406,0)
 D ^%ZISC
"RTN","ZOSVGUT1",407,0)
 QUIT
"RTN","ZOSVGUT1",408,0)
 ;
"RTN","ZOSVGUT1",409,0)
HALTONE ; @TEST Test HALTONE^ZSY entry point
"RTN","ZOSVGUT1",410,0)
 ; ZEXCEPT: TESTJOB,input,output,error
"RTN","ZOSVGUT1",411,0)
 J TESTJOB:(input="/dev/null":output="/dev/null":error="/dev/null")
"RTN","ZOSVGUT1",412,0)
 N %J S %J=$ZJOB
"RTN","ZOSVGUT1",413,0)
 D CHKTF^%ut($zgetjpi(%J,"isprocalive"))
"RTN","ZOSVGUT1",414,0)
 D HALTONE^ZSY(%J)
"RTN","ZOSVGUT1",415,0)
 H .01
"RTN","ZOSVGUT1",416,0)
 D CHKTF^%ut('$zgetjpi(%J,"isprocalive"))
"RTN","ZOSVGUT1",417,0)
 QUIT
"RTN","ZOSVGUT1",418,0)
 ;
"RTN","ZOSVGUT1",419,0)
TESTJOB ; [Private] Entry point for a test job to kill
"RTN","ZOSVGUT1",420,0)
 HANG 100
"RTN","ZOSVGUT1",421,0)
 QUIT
"RTN","ZOSVGUT1",422,0)
 ;
"RTN","ZOSVGUT1",423,0)
XTROU ;;
"RTN","ZOSVGUT1",424,0)
 ;;ZOSVGUT2
"RTN","ZOSVGUT2")
0^15^B42570307
"RTN","ZOSVGUT2",1,0)
ZOSVGUT2 ; VEN/SMH - Unit Tests for GT.M VistA Port;2018-06-06  1:11 PM
"RTN","ZOSVGUT2",2,0)
 ;;8.0;KERNEL;**10001,10002**;;Build 21
"RTN","ZOSVGUT2",3,0)
 ; Submitted to OSEHRA in 2017 by Sam Habiel for OSEHRA
"RTN","ZOSVGUT2",4,0)
 ; Authored by Sam Habiel 2016.
"RTN","ZOSVGUT2",5,0)
 ;
"RTN","ZOSVGUT2",6,0)
STARTUP QUIT
"RTN","ZOSVGUT2",7,0)
 ;
"RTN","ZOSVGUT2",8,0)
SHUTDOWN ; 
"RTN","ZOSVGUT2",9,0)
 S $ZSOURCE="ZOSVGUT2"
"RTN","ZOSVGUT2",10,0)
 QUIT
"RTN","ZOSVGUT2",11,0)
 ;
"RTN","ZOSVGUT2",12,0)
NOOP ; @TEST Top doesn't do anything.
"RTN","ZOSVGUT2",13,0)
 D ^%ZOSV2
"RTN","ZOSVGUT2",14,0)
 D SUCCEED^%ut
"RTN","ZOSVGUT2",15,0)
 QUIT
"RTN","ZOSVGUT2",16,0)
 ;
"RTN","ZOSVGUT2",17,0)
SAVE1 ; @TEST Save a Routine normal
"RTN","ZOSVGUT2",18,0)
 N XCN,DIE
"RTN","ZOSVGUT2",19,0)
 S XCN=0,DIE=$$OREF^DILF($NA(^TMP($J)))
"RTN","ZOSVGUT2",20,0)
 K ^TMP($J)
"RTN","ZOSVGUT2",21,0)
 S ^TMP($J,$I(XCN),0)="KBANHELLO ; VEN/SMH - Sample Testing Routine"
"RTN","ZOSVGUT2",22,0)
 S ^TMP($J,$I(XCN),0)=" ;;"
"RTN","ZOSVGUT2",23,0)
 S ^TMP($J,$I(XCN),0)=";this is not supposed to be saved"
"RTN","ZOSVGUT2",24,0)
 S ^TMP($J,$I(XCN),0)=" WRITE ""HELLO WORLD"""
"RTN","ZOSVGUT2",25,0)
 S ^TMP($J,$I(XCN),0)=" QUIT"
"RTN","ZOSVGUT2",26,0)
 S XCN=0
"RTN","ZOSVGUT2",27,0)
 D SAVE^%ZOSV2("KBANHELLO")
"RTN","ZOSVGUT2",28,0)
 D CHKTF^%ut($T(+1^KBANHELLO)["VEN/SMH")
"RTN","ZOSVGUT2",29,0)
 D CHKTF^%ut($T(+2^KBANHELLO)[";;")
"RTN","ZOSVGUT2",30,0)
 D CHKTF^%ut($T(+3^KBANHELLO)["HELLO WORLD")
"RTN","ZOSVGUT2",31,0)
 D CHKTF^%ut($T(+4^KBANHELLO)["QUIT")
"RTN","ZOSVGUT2",32,0)
 D CHKTF^%ut($T(+3^KBANHELLO)'[$C(9)) ; no tabs
"RTN","ZOSVGUT2",33,0)
 D CHKTF^%ut($T(+4^KBANHELLO)'[$C(9)) ; no tabs
"RTN","ZOSVGUT2",34,0)
 QUIT
"RTN","ZOSVGUT2",35,0)
 ;
"RTN","ZOSVGUT2",36,0)
SAVE2 ; @TEST Save a Routine with syntax errors -- should not show.
"RTN","ZOSVGUT2",37,0)
 N XCN,DIE
"RTN","ZOSVGUT2",38,0)
 S XCN=0,DIE=$$OREF^DILF($NA(^TMP($J)))
"RTN","ZOSVGUT2",39,0)
 K ^TMP($J)
"RTN","ZOSVGUT2",40,0)
 S ^TMP($J,$I(XCN),0)="KBANHELLO ; VEN/SMH - Sample Testing Routine"
"RTN","ZOSVGUT2",41,0)
 S ^TMP($J,$I(XCN),0)=" ;;"
"RTN","ZOSVGUT2",42,0)
 S ^TMP($J,$I(XCN),0)=" WROTE ""HELLO WORLD"""
"RTN","ZOSVGUT2",43,0)
 S ^TMP($J,$I(XCN),0)=" W $P(""TEST"")"
"RTN","ZOSVGUT2",44,0)
 S ^TMP($J,$I(XCN),0)=" QUIT"
"RTN","ZOSVGUT2",45,0)
 S XCN=0
"RTN","ZOSVGUT2",46,0)
 N % S %=$$RETURN^%ZOSV("rm -f /tmp/kbanhello.mje",1)
"RTN","ZOSVGUT2",47,0)
 ; ZEXCEPT: SAVE,error,%ZOSV2,in,out,PASS
"RTN","ZOSVGUT2",48,0)
 J SAVE^%ZOSV2("KBANHELLO"):(error="/tmp/kbanhello.mje":in="/dev/null":out="/dev/null":PASS)
"RTN","ZOSVGUT2",49,0)
 F  H .001  Q:($$RETURN^%ZOSV("stat /tmp/kbanhello.mje",1)=0)
"RTN","ZOSVGUT2",50,0)
 D CHKTF^%ut(+$$RETURN^%ZOSV("wc -l /tmp/kbanhello.mje")=0)
"RTN","ZOSVGUT2",51,0)
 QUIT
"RTN","ZOSVGUT2",52,0)
 ;
"RTN","ZOSVGUT2",53,0)
LOAD ; @TEST Load Routine
"RTN","ZOSVGUT2",54,0)
 N XCN,DIE
"RTN","ZOSVGUT2",55,0)
 S XCN=0,DIE=$$OREF^DILF($NA(^TMP($J)))
"RTN","ZOSVGUT2",56,0)
 K ^TMP($J)
"RTN","ZOSVGUT2",57,0)
 S ^TMP($J,$I(XCN),0)="KBANHELLO ; VEN/SMH - Sample Testing Routine"
"RTN","ZOSVGUT2",58,0)
 S ^TMP($J,$I(XCN),0)=" ;;"
"RTN","ZOSVGUT2",59,0)
 S ^TMP($J,$I(XCN),0)=";this is not supposed to be saved"
"RTN","ZOSVGUT2",60,0)
 S ^TMP($J,$I(XCN),0)=" WRITE ""HELLO WORLD"""
"RTN","ZOSVGUT2",61,0)
 S ^TMP($J,$I(XCN),0)=" QUIT"
"RTN","ZOSVGUT2",62,0)
 S XCN=0
"RTN","ZOSVGUT2",63,0)
 D SAVE^%ZOSV2("KBANHELLO")
"RTN","ZOSVGUT2",64,0)
 N DIF
"RTN","ZOSVGUT2",65,0)
 K ^TMP($J)
"RTN","ZOSVGUT2",66,0)
 S DIF=$$OREF^DILF($NA(^TMP($J,"ROU")))
"RTN","ZOSVGUT2",67,0)
 D LOAD^%ZOSV2("KBANHELLO")
"RTN","ZOSVGUT2",68,0)
 D CHKTF^%ut(^TMP($J,"ROU",1,0)["KBANHELLO")
"RTN","ZOSVGUT2",69,0)
 D CHKTF^%ut(^TMP($J,"ROU",4,0)["QUIT")
"RTN","ZOSVGUT2",70,0)
 QUIT
"RTN","ZOSVGUT2",71,0)
 ;
"RTN","ZOSVGUT2",72,0)
RSUM ; @TEST Checksums
"RTN","ZOSVGUT2",73,0)
 D CHKTF^%ut($$RSUM^%ZOSV2("KBANHELLO"))
"RTN","ZOSVGUT2",74,0)
 D CHKTF^%ut($$RSUM2^%ZOSV2("KBANHELLO"))
"RTN","ZOSVGUT2",75,0)
 QUIT
"RTN","ZOSVGUT2",76,0)
 ;
"RTN","ZOSVGUT2",77,0)
TESTR ; @TEST Test existence of routine
"RTN","ZOSVGUT2",78,0)
 D CHKTF^%ut($$TEST^%ZOSV2("KBANHELLO")]"")
"RTN","ZOSVGUT2",79,0)
 QUIT
"RTN","ZOSVGUT2",80,0)
 ;
"RTN","ZOSVGUT2",81,0)
DELSUPER ; @TEST Test Super Duper Deleter
"RTN","ZOSVGUT2",82,0)
 H .01 ; Necessary so that object deletion would work
"RTN","ZOSVGUT2",83,0)
 D DEL^%ZOSV2("KBANHELLO")
"RTN","ZOSVGUT2",84,0)
 D CHKTF^%ut($T(+1^KBANHELLO)="")
"RTN","ZOSVGUT2",85,0)
 D CHKTF^%ut($$TEST^%ZOSV2("KBANHELLO")="")
"RTN","ZOSVGUT2",86,0)
 QUIT
"RTN","ZOSVGUT2",87,0)
 ;
"RTN","ZOSVGUT2",88,0)
XUSHSH ; @TEST Top of XUSHSH
"RTN","ZOSVGUT2",89,0)
 N X S X="TEST"
"RTN","ZOSVGUT2",90,0)
 D ^XUSHSH
"RTN","ZOSVGUT2",91,0)
 D CHKTF^%ut(X="TEST")
"RTN","ZOSVGUT2",92,0)
 QUIT
"RTN","ZOSVGUT2",93,0)
 ;
"RTN","ZOSVGUT2",94,0)
SHA ; @TEST SHA-1 and SHA-256 in Hex and Base64
"RTN","ZOSVGUT2",95,0)
 D CHKEQ^%ut($$SHAHASH^XUSHSH(160,"test"),"A94A8FE5CCB19BA61C4C0873D391E987982FBBD3")
"RTN","ZOSVGUT2",96,0)
 D CHKEQ^%ut($$SHAHASH^XUSHSH(160,"test","H"),"A94A8FE5CCB19BA61C4C0873D391E987982FBBD3")
"RTN","ZOSVGUT2",97,0)
 D CHKEQ^%ut($$SHAHASH^XUSHSH(160,"test","B"),"qUqP5cyxm6YcTAhz05Hph5gvu9M=")
"RTN","ZOSVGUT2",98,0)
 D CHKEQ^%ut($$SHAHASH^XUSHSH(256,"test"),"9F86D081884C7D659A2FEAA0C55AD015A3BF4F1B2B0B822CD15D6C15B0F00A08")
"RTN","ZOSVGUT2",99,0)
 QUIT
"RTN","ZOSVGUT2",100,0)
 ;
"RTN","ZOSVGUT2",101,0)
BASE64 ; @TEST Base 64 Encode and Decode
"RTN","ZOSVGUT2",102,0)
 D CHKEQ^%ut($$B64ENCD^XUSHSH("test"),"dGVzdA==")
"RTN","ZOSVGUT2",103,0)
 D CHKEQ^%ut($$B64DECD^XUSHSH("dGVzdA=="),"test")
"RTN","ZOSVGUT2",104,0)
 QUIT
"RTN","ZOSVGUT2",105,0)
 ;
"RTN","ZOSVGUT2",106,0)
RSAENC ; @TEST Test RSA Encryption
"RTN","ZOSVGUT2",107,0)
 N SECRET S SECRET="Alice and Bob had Sex!"
"RTN","ZOSVGUT2",108,0)
 ;
"RTN","ZOSVGUT2",109,0)
 ; Create RSA certificate and private key w/ no password
"RTN","ZOSVGUT2",110,0)
 N %CMD
"RTN","ZOSVGUT2",111,0)
 S %CMD="openssl req -x509 -nodes -days 365 -sha256 -subj '/C=US/ST=Washington/L=Seattle/CN=www.smh101.com' -newkey rsa:2048 -keyout /tmp/mycert.key -out /tmp/mycert.pem"
"RTN","ZOSVGUT2",112,0)
 N % S %=$$RETURN^%ZOSV(%CMD,1)
"RTN","ZOSVGUT2",113,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVGUT2",114,0)
 N CIPHERTEXT S CIPHERTEXT=$$RSAENCR^XUSHSH(SECRET,"/tmp/mycert.pem")
"RTN","ZOSVGUT2",115,0)
 D CHKTF^%ut($ZL(CIPHERTEXT)>$ZL(SECRET))
"RTN","ZOSVGUT2",116,0)
 N DECRYPTION S DECRYPTION=$$RSADECR^XUSHSH(CIPHERTEXT,"/tmp/mycert.key")
"RTN","ZOSVGUT2",117,0)
 D CHKEQ^%ut(SECRET,DECRYPTION)
"RTN","ZOSVGUT2",118,0)
 ;
"RTN","ZOSVGUT2",119,0)
 ; Create RSA certificate and private key with a password
"RTN","ZOSVGUT2",120,0)
 ; Apparently, no way to do all of this in a single line in openssl; have to do
"RTN","ZOSVGUT2",121,0)
 ; it the traditional way: key, CSR, Cert.
"RTN","ZOSVGUT2",122,0)
 ; VEN/SMH - For some reason, the darwin command doesn't create the
"RTN","ZOSVGUT2",123,0)
 ; certificate when running from inside GT.M; it does okay in Bash.
"RTN","ZOSVGUT2",124,0)
 ; So, for now, let's just disable this check on Darwin; I don't have time
"RTN","ZOSVGUT2",125,0)
 ; for this shit.
"RTN","ZOSVGUT2",126,0)
 I $$VERSION^%ZOSV(1)["Darwin" QUIT
"RTN","ZOSVGUT2",127,0)
 I $$VERSION^%ZOSV(1)["CYGWIN" QUIT
"RTN","ZOSVGUT2",128,0)
 ;
"RTN","ZOSVGUT2",129,0)
 N %CMD
"RTN","ZOSVGUT2",130,0)
 S %CMD="openssl genrsa -aes128 -passout pass:monkey1234 -out /tmp/mycert.key 2048"
"RTN","ZOSVGUT2",131,0)
 N % S %=$$RETURN^%ZOSV(%CMD,1)
"RTN","ZOSVGUT2",132,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVGUT2",133,0)
 S %CMD="openssl req -new -key /tmp/mycert.key -passin pass:monkey1234 -subj '/C=US/ST=Washington/L=Seattle/CN=www.smh101.com' -out /tmp/mycert.csr"
"RTN","ZOSVGUT2",134,0)
 N % S %=$$RETURN^%ZOSV(%CMD,1)
"RTN","ZOSVGUT2",135,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVGUT2",136,0)
 S %CMD="openssl req -x509 -days 365 -sha256 -in /tmp/mycert.csr -key /tmp/mycert.key -passin pass:monkey1234 -out /tmp/mycert.pem"
"RTN","ZOSVGUT2",137,0)
 ;I $$VERSION^%ZOSV["arwin" S %CMD="openssl req -x509 -days 365 -sha256 -in /tmp/mycert.csr -subj '/C=US/ST=Washington/L=Seattle/CN=www.smh101.com' -key /tmp/mycert.key -passin pass:monkey1234 -out /tmp/mycert.pem"
"RTN","ZOSVGUT2",138,0)
 N % S %=$$RETURN^%ZOSV(%CMD,1)
"RTN","ZOSVGUT2",139,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVGUT2",140,0)
 N CIPHERTEXT S CIPHERTEXT=$$RSAENCR^XUSHSH(SECRET,"/tmp/mycert.pem")
"RTN","ZOSVGUT2",141,0)
 D CHKTF^%ut($ZL(CIPHERTEXT)>$ZL(SECRET))
"RTN","ZOSVGUT2",142,0)
 N DECRYPTION S DECRYPTION=$$RSADECR^XUSHSH(CIPHERTEXT,"/tmp/mycert.key","monkey1234")
"RTN","ZOSVGUT2",143,0)
 D CHKEQ^%ut(SECRET,DECRYPTION)
"RTN","ZOSVGUT2",144,0)
 QUIT
"RTN","ZOSVGUT2",145,0)
 ;
"RTN","ZOSVGUT2",146,0)
AESENC ; @TEST Test AES Encryption
"RTN","ZOSVGUT2",147,0)
 N SECRET S SECRET="Alice and Bob had Sex!"
"RTN","ZOSVGUT2",148,0)
 N X S X=$$AESENCR^XUSHSH(SECRET,"ABCDABCDABCDABCD","DCBADCBADCBADCBA")
"RTN","ZOSVGUT2",149,0)
 N Y S Y=$$AESDECR^XUSHSH(X,"ABCDABCDABCDABCD","DCBADCBADCBADCBA")
"RTN","ZOSVGUT2",150,0)
 D CHKEQ^%ut(SECRET,Y)
"RTN","ZOSVGUT2",151,0)
 QUIT
"RTN","ZOSVGUT2",152,0)
 ;
"RTN","ZOSVGUT2",153,0)
BROKER ; @TEST Test the new GT.M MTL Broker
"RTN","ZOSVGUT2",154,0)
 ; Old version died after first connection.
"RTN","ZOSVGUT2",155,0)
 ; NB: It DOES NOT WANT anything that's not IPv4.
"RTN","ZOSVGUT2",156,0)
 ; Hard to do on any modern computer that is hardwired to give you IPv6
"RTN","ZOSVGUT2",157,0)
 ; addressed for localhost.
"RTN","ZOSVGUT2",158,0)
 N PORT S PORT=58738
"RTN","ZOSVGUT2",159,0)
 ; ZEXCEPT: ZISTCP,XWBTCPM1
"RTN","ZOSVGUT2",160,0)
 J ZISTCP^XWBTCPM1(58738)
"RTN","ZOSVGUT2",161,0)
 N BROKERJOB S BROKERJOB=$ZJOB
"RTN","ZOSVGUT2",162,0)
 N % S %=$$TEST^XWBTCPMT("127.0.0.1",PORT)
"RTN","ZOSVGUT2",163,0)
 D CHKEQ^%ut(+%,1)
"RTN","ZOSVGUT2",164,0)
 N % S %=$$TEST^XWBTCPMT("127.0.0.1",PORT)
"RTN","ZOSVGUT2",165,0)
 D CHKEQ^%ut(+%,1)
"RTN","ZOSVGUT2",166,0)
 N % S %=$$TEST^XWBTCPMT("127.0.0.1",PORT)
"RTN","ZOSVGUT2",167,0)
 D CHKEQ^%ut(+%,1)
"RTN","ZOSVGUT2",168,0)
 N % S %=$$TEST^XWBTCPMT("127.0.0.1",PORT)
"RTN","ZOSVGUT2",169,0)
 D CHKEQ^%ut(+%,1)
"RTN","ZOSVGUT2",170,0)
 N % S %=$$RETURN^%ZOSV("$gtm_dist/mupip stop "_BROKERJOB)
"RTN","ZOSVGUT2",171,0)
 H .05 ; It doesn't die right away...
"RTN","ZOSVGUT2",172,0)
 D CHKTF^%ut('$ZGETJPI(BROKERJOB,"ISPROCALIVE"))
"RTN","ZOSVGUT2",173,0)
 W ! ; reset $X
"RTN","ZOSVGUT2",174,0)
 QUIT
"RTN","ZOSVGUT2",175,0)
 ;
"RTN","ZOSVGUT2",176,0)
ACTJPEEK ; @TEST Active Jobs using $$^%PEEKBYNAME("node_local.ref_cnt",...)
"RTN","ZOSVGUT2",177,0)
 Q:$T(^%PEEKBYNAME)=""
"RTN","ZOSVGUT2",178,0)
 N % S %=$$^%PEEKBYNAME("node_local.ref_cnt","DEFAULT")
"RTN","ZOSVGUT2",179,0)
 D CHKTF^%ut(%>1)
"RTN","ZOSVGUT2",180,0)
 QUIT
"RTN","ZOSVGUT2",181,0)
ACTJREG ; @TEST Active Jobs using current API
"RTN","ZOSVGUT2",182,0)
 K ^XUTL("XUSYS","CNT")
"RTN","ZOSVGUT2",183,0)
 N % S %=$$ACTJ^%ZOSV
"RTN","ZOSVGUT2",184,0)
 D CHKTF^%ut(%>1)
"RTN","ZOSVGUT2",185,0)
 QUIT
"RTN","ZOSVGUT2",186,0)
XTROU ;;
"RTN","ZOSVGUT2",187,0)
 ;;ZOSVGUT3
"RTN","ZOSVGUX")
0^1^B45533042
"RTN","ZOSVGUX",1,0)
%ZOSV ;VEN/SMH,KRM/CJE,FIS/KSB - View commands & special functions. ;2018-02-26  1:05 PM
"RTN","ZOSVGUX",2,0)
 ;;8.0;KERNEL;**275,425,499,10001,10002**;Jul 10, 1995;Build 21
"RTN","ZOSVGUX",3,0)
 ; Submitted to OSEHRA in 2017 by Sam Habiel for OSEHRA
"RTN","ZOSVGUX",4,0)
 ; Original Routine authored by Department of Veterans Affairs
"RTN","ZOSVGUX",5,0)
 ; Almost the entire routine was rewritten by Sam Habiel, Christopher Edwards, KS Bhaskar
"RTN","ZOSVGUX",6,0)
 ;
"RTN","ZOSVGUX",7,0)
ACTJ() ; # active jobs
"RTN","ZOSVGUX",8,0)
 ; Next call active as of 6.3
"RTN","ZOSVGUX",9,0)
 I $T(^%PEEKBYNAME)]"" Q $$^%PEEKBYNAME("node_local.ref_cnt","DEFAULT")
"RTN","ZOSVGUX",10,0)
 I ($G(^XUTL("XUSYS","CNT"))<1)!($G(^XUTL("XUSYS","CNT","SEC"))>($$SEC^XLFDT($H)+3600)) D
"RTN","ZOSVGUX",11,0)
 . I $$UP^XLFSTR($ZV)["LINUX" D
"RTN","ZOSVGUX",12,0)
 .. N I,IO,LINE
"RTN","ZOSVGUX",13,0)
 .. S IO=$IO
"RTN","ZOSVGUX",14,0)
 .. O "FTOK":(SHELL="/bin/sh":COMMAND="$gtm_dist/mupip ftok "_$V("GVFILE","DEFAULT"):READONLY)::"PIPE" U "FTOK"
"RTN","ZOSVGUX",15,0)
 .. F I=1:1:3 R LINE
"RTN","ZOSVGUX",16,0)
 .. O "IPCS":(SHELL="/bin/sh":COMMAND="ipcs -mi "_$TR($P($P(LINE,"::",3),"[",1)," ",""):READONLY)::"PIPE" U "IPCS"
"RTN","ZOSVGUX",17,0)
 .. F I=1:1 R LINE Q:$ZEO  I 1<$L(LINE,"nattch=") S ^XUTL("XUSYS","CNT")=+$P(LINE,"nattch=",2) Q
"RTN","ZOSVGUX",18,0)
 .. U IO C "FTOK" C "IPCS"
"RTN","ZOSVGUX",19,0)
 . ;
"RTN","ZOSVGUX",20,0)
 . I $$UP^XLFSTR($ZV)["DARWIN" D  ; OSEHRA/SMH - Should work on Linux too!
"RTN","ZOSVGUX",21,0)
 .. N I,IO,LINE
"RTN","ZOSVGUX",22,0)
 .. S IO=$IO
"RTN","ZOSVGUX",23,0)
 .. ; Count number of processes returned by lsof accessing this database; and trim using xargs
"RTN","ZOSVGUX",24,0)
 .. O "LSOF":(SHELL="/bin/sh":COMMAND="lsof -t "_$V("GVFILE","DEFAULT")_" | wc -l | xargs":READONLY)::"PIPE" U "LSOF"
"RTN","ZOSVGUX",25,0)
 .. F  R LINE:1 Q:$ZEOF  Q:LINE
"RTN","ZOSVGUX",26,0)
 .. S ^XUTL("XUSYS","CNT")=LINE
"RTN","ZOSVGUX",27,0)
 .. U IO C "LSOF"
"RTN","ZOSVGUX",28,0)
 . ;
"RTN","ZOSVGUX",29,0)
 . I $$UP^XLFSTR($ZV)["CYGWIN" D
"RTN","ZOSVGUX",30,0)
 .. S ^XUTL("XUSYS","CNT")=+$$RETURN^%ZOSV("ps -as | grep mumps | grep -v grep | wc -l")
"RTN","ZOSVGUX",31,0)
 . ;
"RTN","ZOSVGUX",32,0)
 . S ^XUTL("XUSYS","CNT","SEC")=$$SEC^XLFDT($H)
"RTN","ZOSVGUX",33,0)
 Q ^XUTL("XUSYS","CNT")
"RTN","ZOSVGUX",34,0)
 ;
"RTN","ZOSVGUX",35,0)
AVJ() ; # available jobs, Limit is in the OS.
"RTN","ZOSVGUX",36,0)
 N V,J
"RTN","ZOSVGUX",37,0)
 S V=^%ZOSF("VOL"),J=$O(^XTV(8989.3,1,4,"B",V,0)),J=$P($G(^XTV(8989.3,1,4,J,0),"^^1000"),"^",3)
"RTN","ZOSVGUX",38,0)
 Q J-$$ACTJ ;Use signon Max
"RTN","ZOSVGUX",39,0)
 ;
"RTN","ZOSVGUX",40,0)
RTNDIR() ; primary routine source directory
"RTN","ZOSVGUX",41,0)
 N DIRS
"RTN","ZOSVGUX",42,0)
 D PARSEZRO(.DIRS,$ZRO)
"RTN","ZOSVGUX",43,0)
 N I F I=1:1 Q:'$D(DIRS(I))  I DIRS(I)[".so" K DIRS(I)
"RTN","ZOSVGUX",44,0)
 I '$D(DIRS) S $EC=",U255,"
"RTN","ZOSVGUX",45,0)
 QUIT $$ZRO1ST(.DIRS)
"RTN","ZOSVGUX",46,0)
 ;
"RTN","ZOSVGUX",47,0)
PARSEZRO(DIRS,ZRO) ; Parse $zroutines properly into an array
"RTN","ZOSVGUX",48,0)
 ; Eat spaces
"RTN","ZOSVGUX",49,0)
 F  Q:($E(ZRO)'=" ")  S ZRO=$E(ZRO,2,1024) ; 1023 is the GT.M maximum
"RTN","ZOSVGUX",50,0)
 ;
"RTN","ZOSVGUX",51,0)
 N PIECE
"RTN","ZOSVGUX",52,0)
 N I
"RTN","ZOSVGUX",53,0)
 F I=1:1:$L(ZRO," ") S PIECE(I)=$P(ZRO," ",I)
"RTN","ZOSVGUX",54,0)
 N CNT S CNT=1
"RTN","ZOSVGUX",55,0)
 F I=0:0 S I=$O(PIECE(I)) Q:'I  D
"RTN","ZOSVGUX",56,0)
 . S DIRS(CNT)=$G(DIRS(CNT))_PIECE(I)
"RTN","ZOSVGUX",57,0)
 . I DIRS(CNT)["("&(DIRS(CNT)[")") S CNT=CNT+1 QUIT
"RTN","ZOSVGUX",58,0)
 . I DIRS(CNT)'["("&(DIRS(CNT)'[")") S CNT=CNT+1 QUIT
"RTN","ZOSVGUX",59,0)
 . S DIRS(CNT)=DIRS(CNT)_" " ; prep for next piece
"RTN","ZOSVGUX",60,0)
 QUIT
"RTN","ZOSVGUX",61,0)
 ;
"RTN","ZOSVGUX",62,0)
ZRO1ST(DIRS) ; $$ Get first usable routine directory
"RTN","ZOSVGUX",63,0)
 N OUT S OUT="" ; $$ Return; default empty
"RTN","ZOSVGUX",64,0)
 N I F I=0:0 S I=$O(DIRS(I)) Q:'I  D  Q:OUT]""  ; 1st directory
"RTN","ZOSVGUX",65,0)
 . N %1 S %1=DIRS(I)
"RTN","ZOSVGUX",66,0)
 . N SO S SO=$E(%1,$L(%1)-2,$L(%1))
"RTN","ZOSVGUX",67,0)
 . S SO=$$UP^XLFSTR(SO)
"RTN","ZOSVGUX",68,0)
 . I SO=".SO" QUIT
"RTN","ZOSVGUX",69,0)
 . ;
"RTN","ZOSVGUX",70,0)
 . ; Parse with (...)
"RTN","ZOSVGUX",71,0)
 . I %1["(" DO
"RTN","ZOSVGUX",72,0)
 . . S OUT=$P(%1,"(",2)
"RTN","ZOSVGUX",73,0)
 . . I OUT[" " S OUT=$P(OUT," ")
"RTN","ZOSVGUX",74,0)
 . . E  S OUT=$P(OUT,")")
"RTN","ZOSVGUX",75,0)
 . ; no parens
"RTN","ZOSVGUX",76,0)
 . E  S OUT=%1
"RTN","ZOSVGUX",77,0)
 ;
"RTN","ZOSVGUX",78,0)
 ; Add trailing slash
"RTN","ZOSVGUX",79,0)
 I OUT]"",$E(OUT,$L(OUT))'="/" S OUT=OUT_"/"
"RTN","ZOSVGUX",80,0)
 QUIT OUT
"RTN","ZOSVGUX",81,0)
 ;
"RTN","ZOSVGUX",82,0)
TEMP() ; Return path to temp directory
"RTN","ZOSVGUX",83,0)
 ;N %TEMP S %TEMP=$P($$RTNDIR," "),%TEMP=$P(%TEMP,"/",1,$L(%TEMP,"/")-2)_"/t/"
"RTN","ZOSVGUX",84,0)
 Q $G(^%ZOSF("TMP"),$P($G(^XTV(8989.3,1,"DEV"),"/tmp/"),U))
"RTN","ZOSVGUX",85,0)
 ;
"RTN","ZOSVGUX",86,0)
PASSALL ;
"RTN","ZOSVGUX",87,0)
 U $I:(NOESCAPE:NOTERMINATOR:PASTHRU) Q
"RTN","ZOSVGUX",88,0)
NOPASS ;
"RTN","ZOSVGUX",89,0)
 U $I:(ESCAPE:TERMINATOR="":NOPASTHRU) Q
"RTN","ZOSVGUX",90,0)
 ;
"RTN","ZOSVGUX",91,0)
GETPEER() ;Get the IP address of a connection peer
"RTN","ZOSVGUX",92,0)
 N PEER
"RTN","ZOSVGUX",93,0)
 S PEER=$P($ZTRNLNM("SSH_CLIENT")," ") S:PEER="" PEER=$ZTRNLNM("REMOTEHOST")
"RTN","ZOSVGUX",94,0)
 S PEER=$S($L(PEER):PEER,$L($G(IO("IP"))):IO("IP"),$L($G(IO("GTM-IP"))):IO("GTM-IP"),1:"")
"RTN","ZOSVGUX",95,0)
 I $G(^XTV(8989.3,1,"PEER"))[PEER S PEER="" ;p499
"RTN","ZOSVGUX",96,0)
 Q PEER
"RTN","ZOSVGUX",97,0)
 ;
"RTN","ZOSVGUX",98,0)
PRGMODE ;Drop into direct mode
"RTN","ZOSVGUX",99,0)
 N X,XUCI,XUSLNT
"RTN","ZOSVGUX",100,0)
 W ! S ZTPAC=$P($G(^VA(200,+DUZ,.1)),"^",5),XUVOL=^%ZOSF("VOL")
"RTN","ZOSVGUX",101,0)
 S X="" X ^%ZOSF("EOFF") R:ZTPAC]"" !,"PAC: ",X:60 D LC^XUS X ^%ZOSF("EON") I X'=ZTPAC W "??",$C(7) Q
"RTN","ZOSVGUX",102,0)
 N XMB,XMTEXT,XMY S XMB="XUPROGMODE",XMB(1)=DUZ,XMB(2)=$I D ^XMB:$L($T(^XMB)) D BYE^XUSCLEAN K ZTPAC,X,XMB
"RTN","ZOSVGUX",103,0)
 D UCI S XUCI=Y D PRGM^ZUA
"RTN","ZOSVGUX",104,0)
 I $D(%ut) QUIT
"RTN","ZOSVGUX",105,0)
 F  BREAK
"RTN","ZOSVGUX",106,0)
 HALT
"RTN","ZOSVGUX",107,0)
 ;
"RTN","ZOSVGUX",108,0)
PROGMODE() ; In Application mode
"RTN","ZOSVGUX",109,0)
 Q 1 ; This was used to control UCI switching, has no meaning in GT.M
"RTN","ZOSVGUX",110,0)
 ;
"RTN","ZOSVGUX",111,0)
UCI ;
"RTN","ZOSVGUX",112,0)
 S Y=^%ZOSF("PROD") Q
"RTN","ZOSVGUX",113,0)
 ;
"RTN","ZOSVGUX",114,0)
UCICHECK(X) ;
"RTN","ZOSVGUX",115,0)
 Q X
"RTN","ZOSVGUX",116,0)
 ;
"RTN","ZOSVGUX",117,0)
JOBPAR ; <=====
"RTN","ZOSVGUX",118,0)
 N CMD,COMM,IO
"RTN","ZOSVGUX",119,0)
 S IO=$IO,COMM="/proc/"_X_"/comm"
"RTN","ZOSVGUX",120,0)
 O COMM:(READONLY:EXCEPTION="S Y="""" Q") U COMM R CMD U IO C COMM
"RTN","ZOSVGUX",121,0)
 S Y=$S("mumps"=$G(CMD):^%ZOSF("PROD"),1:"")
"RTN","ZOSVGUX",122,0)
 Q
"RTN","ZOSVGUX",123,0)
 ;
"RTN","ZOSVGUX",124,0)
SHARELIC(TYPE) ;Used by Cache implementations
"RTN","ZOSVGUX",125,0)
 Q
"RTN","ZOSVGUX",126,0)
 ;
"RTN","ZOSVGUX",127,0)
PRIORITY ;
"RTN","ZOSVGUX",128,0)
 K Y ; VA has this disabled in general.
"RTN","ZOSVGUX",129,0)
 Q
"RTN","ZOSVGUX",130,0)
 ;
"RTN","ZOSVGUX",131,0)
PRIINQ() ;
"RTN","ZOSVGUX",132,0)
 Q 5 ; for now, we're always middle of the road
"RTN","ZOSVGUX",133,0)
 ;
"RTN","ZOSVGUX",134,0)
BAUD S X="UNKNOWN"
"RTN","ZOSVGUX",135,0)
 Q
"RTN","ZOSVGUX",136,0)
 ;
"RTN","ZOSVGUX",137,0)
LGR() ; Last global reference ($REFERENCE)
"RTN","ZOSVGUX",138,0)
 Q $R
"RTN","ZOSVGUX",139,0)
 ;
"RTN","ZOSVGUX",140,0)
EC() ; Error Code: returning $ZS in format more like $ZE from DSM
"RTN","ZOSVGUX",141,0)
 N %ZE
"RTN","ZOSVGUX",142,0)
 I $ZS="" S %ZE=""
"RTN","ZOSVGUX",143,0)
 S %ZE=$P($ZS,",",2)_","_$P($ZS,",",4)_","_$P($ZS,",")_",-"_$P($ZS,",",3)
"RTN","ZOSVGUX",144,0)
 Q %ZE
"RTN","ZOSVGUX",145,0)
 ;
"RTN","ZOSVGUX",146,0)
DOLRO ;SAVE ENTIRE SYMBOL TABLE IN LOCATION SPECIFIED BY X
"RTN","ZOSVGUX",147,0)
 ; Old Algorithm
"RTN","ZOSVGUX",148,0)
 S Y="%" F  M @(X_"Y)="_Y) S Y=$O(@Y) Q:Y=""
"RTN","ZOSVGUX",149,0)
 QUIT
"RTN","ZOSVGUX",150,0)
 ;
"RTN","ZOSVGUX",151,0)
 ; New Algorithm; faster by 2-6ms
"RTN","ZOSVGUX",152,0)
 ;N %11111,Y
"RTN","ZOSVGUX",153,0)
 ;ZSHOW "V":%11111
"RTN","ZOSVGUX",154,0)
 ;N %00000 F %00000=0:0 S %00000=$O(%11111("V",%00000)) Q:'%00000  S Y=$P(%11111("V",%00000),"=") I Y'["(" M @(X_"Y)="_Y)
"RTN","ZOSVGUX",155,0)
 ;QUIT
"RTN","ZOSVGUX",156,0)
 ;
"RTN","ZOSVGUX",157,0)
ORDER ;SAVE PART OF SYMBOL TABLE IN LOCATION SPECIFIED BY X
"RTN","ZOSVGUX",158,0)
 N %
"RTN","ZOSVGUX",159,0)
 S (Y,%)=$P(Y,"*",1) ;I $D(@Y)=0 F  S Y=$O(@Y) Q:Y=""!(Y[Y1)
"RTN","ZOSVGUX",160,0)
 Q:Y=""
"RTN","ZOSVGUX",161,0)
 ;S %=$D(@Y) S:%#2 @(X_"Y)="_Y) I %>9 S %X=Y_"(",%Y=X_"Y," D %XY^%RCR
"RTN","ZOSVGUX",162,0)
 ;F  S Y=$O(@Y) Q:Y=""!(Y'[Y1)  S %=$D(@Y) S:%#2 @(X_"Y)="_Y) I %>9 S %X=Y_"(",%Y=X_"Y," D %XY^%RCR
"RTN","ZOSVGUX",163,0)
 F  M:$D(@Y) @(X_"Y)="_Y) S Y=$O(@Y) Q:Y=""!(Y'[%)
"RTN","ZOSVGUX",164,0)
 Q
"RTN","ZOSVGUX",165,0)
 ;
"RTN","ZOSVGUX",166,0)
PARSIZ ;
"RTN","ZOSVGUX",167,0)
 S X=3 Q
"RTN","ZOSVGUX",168,0)
 ;
"RTN","ZOSVGUX",169,0)
NOLOG ;
"RTN","ZOSVGUX",170,0)
 S Y=0 Q
"RTN","ZOSVGUX",171,0)
 ;
"RTN","ZOSVGUX",172,0)
GETENV ;Get environment Return Y='UCI^VOL^NODE^BOX LOOKUP'
"RTN","ZOSVGUX",173,0)
 N %HOST,%V S %V=^%ZOSF("PROD"),%HOST=$P($SYSTEM,",",2) ; Uses env variable gtm_sysid
"RTN","ZOSVGUX",174,0)
 S Y=$TR(%V,",","^")_"^"_%HOST_"^"_$P(%V,",",2)_":"_%HOST
"RTN","ZOSVGUX",175,0)
 Q
"RTN","ZOSVGUX",176,0)
 ;
"RTN","ZOSVGUX",177,0)
VERSION(X) ;return OS version, X=1 - return OS
"RTN","ZOSVGUX",178,0)
 Q $S($G(X):$P($ZV," ",3,99),1:$P($P($ZV," V",2)," "))
"RTN","ZOSVGUX",179,0)
 ;
"RTN","ZOSVGUX",180,0)
OS() ;
"RTN","ZOSVGUX",181,0)
 Q "UNIX"
"RTN","ZOSVGUX",182,0)
 ;
"RTN","ZOSVGUX",183,0)
SETNM(X) ;Set name, Trap dup's, Fall into SETENV
"RTN","ZOSVGUX",184,0)
 N $ETRAP S $ETRAP="S $ECODE="""" Q"
"RTN","ZOSVGUX",185,0)
SETENV ;Set environment X='PROCESS NAME^ '
"RTN","ZOSVGUX",186,0)
 S ^XUTL("XUSYS",$J,0)=$H,^("NM")=X ; workaround
"RTN","ZOSVGUX",187,0)
 Q
"RTN","ZOSVGUX",188,0)
 ;
"RTN","ZOSVGUX",189,0)
SID() ;System ID
"RTN","ZOSVGUX",190,0)
 N J1,T S T="~"
"RTN","ZOSVGUX",191,0)
 S J1(1)=$ZROUTINES,J1(1)=$P(J1(1)," ")
"RTN","ZOSVGUX",192,0)
 S J1(2)=$ZGBLDIR
"RTN","ZOSVGUX",193,0)
 Q "1~"_J1(1)_T_J1(2)
"RTN","ZOSVGUX",194,0)
 ;
"RTN","ZOSVGUX",195,0)
PRI() ;Check if a mixed OS enviroment.
"RTN","ZOSVGUX",196,0)
 ;Default return 1 unless we are on the secondary OS.
"RTN","ZOSVGUX",197,0)
 ;Only Cache on a VMS/Linux mix is supported now.
"RTN","ZOSVGUX",198,0)
 Q 1
"RTN","ZOSVGUX",199,0)
 ;
"RTN","ZOSVGUX",200,0)
T0 ; start RT clock
"RTN","ZOSVGUX",201,0)
 N V S V=$$VERSION(0)
"RTN","ZOSVGUX",202,0)
 I +V'<6.2 S %ZH0=$ZH QUIT
"RTN","ZOSVGUX",203,0)
 S %ZH0=$S(""'=$T(ZHOROLOG^%POSIX):$$ZHOROLOG^%POSIX,1:$H)
"RTN","ZOSVGUX",204,0)
 Q
"RTN","ZOSVGUX",205,0)
 ;
"RTN","ZOSVGUX",206,0)
T1 ; store RT datum w/ZHDIF
"RTN","ZOSVGUX",207,0)
 N V S V=$$VERSION(0)
"RTN","ZOSVGUX",208,0)
 I +V'<6.2 S %ZH1=$ZH QUIT
"RTN","ZOSVGUX",209,0)
 S %ZH1=$S(""'=$T(ZHOROLOG^%POSIX):$$ZHOROLOG^%POSIX,1:$H)
"RTN","ZOSVGUX",210,0)
 Q
"RTN","ZOSVGUX",211,0)
 ;
"RTN","ZOSVGUX",212,0)
ZHDIF ;Display dif of two $ZH's
"RTN","ZOSVGUX",213,0)
 N SC0 S SC0=$P(%ZH0,",",2)
"RTN","ZOSVGUX",214,0)
 N SC1 S SC1=$P(%ZH1,",",2)
"RTN","ZOSVGUX",215,0)
 N DC0 S DC0=$P(%ZH0,",")*86400
"RTN","ZOSVGUX",216,0)
 N DC1 S DC1=$P(%ZH1,",")*86400
"RTN","ZOSVGUX",217,0)
 N MCS0 S MCS0=$P(%ZH0,",",3)/1000000
"RTN","ZOSVGUX",218,0)
 N MCS1 S MCS1=$P(%ZH1,",",3)/1000000
"RTN","ZOSVGUX",219,0)
 ;
"RTN","ZOSVGUX",220,0)
 N T0 S T0=SC0+DC0+MCS0
"RTN","ZOSVGUX",221,0)
 N T1 S T1=SC1+DC1+MCS1
"RTN","ZOSVGUX",222,0)
 ;
"RTN","ZOSVGUX",223,0)
 S %ZH2=T1-T0
"RTN","ZOSVGUX",224,0)
 QUIT
"RTN","ZOSVGUX",225,0)
 ;
"RTN","ZOSVGUX",226,0)
 ;Code moved to %ZOSVKR, Comment out if needed.
"RTN","ZOSVGUX",227,0)
LOGRSRC(OPT,TYPE,STATUS) ;record resource usage in ^XTMP("KMPR"
"RTN","ZOSVGUX",228,0)
 Q:'$G(^%ZTSCH("LOGRSRC"))  ; quit if RUM not turned on.
"RTN","ZOSVGUX",229,0)
 ; call to RUM routine.
"RTN","ZOSVGUX",230,0)
 D RU^%ZOSVKR($G(OPT),$G(TYPE),$G(STATUS))
"RTN","ZOSVGUX",231,0)
 Q
"RTN","ZOSVGUX",232,0)
 ;
"RTN","ZOSVGUX",233,0)
SETTRM(X) ;Turn on specified terminators.
"RTN","ZOSVGUX",234,0)
 U $I:(TERMINATOR=X)
"RTN","ZOSVGUX",235,0)
 Q 1
"RTN","ZOSVGUX",236,0)
 ;
"RTN","ZOSVGUX",237,0)
DEVOK ;
"RTN","ZOSVGUX",238,0)
 ;use lsof (list open files)
"RTN","ZOSVGUX",239,0)
 ; given a device name in X
"RTN","ZOSVGUX",240,0)
 ;INPUT:  X=Device $I, X1=IOT -- X1 needed for resources
"RTN","ZOSVGUX",241,0)
 ;OUTPUT: Y=0 if available, Y=job # if owned
"RTN","ZOSVGUX",242,0)
 ; Y=-1 if device does not exists.
"RTN","ZOSVGUX",243,0)
 ; return Y=0 if not owned, Y=$J of owning job, Y=999 if dev cycling
"RTN","ZOSVGUX",244,0)
 ;
"RTN","ZOSVGUX",245,0)
 I $G(X1)="RES" G RESOK^%ZIS6
"RTN","ZOSVGUX",246,0)
 S Y=0
"RTN","ZOSVGUX",247,0)
 Q  ;Let ZIS deal with it.
"RTN","ZOSVGUX",248,0)
 ;
"RTN","ZOSVGUX",249,0)
DEVOPN ;List of Devices opened.  Linux only
"RTN","ZOSVGUX",250,0)
 ;Returns variable Y. Y=Devices owned separated by a comma
"RTN","ZOSVGUX",251,0)
 N %I,%X,%Y
"RTN","ZOSVGUX",252,0)
 ZSHOW "D":%Y
"RTN","ZOSVGUX",253,0)
 S %I=0,Y="",%X=""
"RTN","ZOSVGUX",254,0)
 F  S %I=$O(%Y("D",%I)) Q:'%I  I %Y("D",%I)'["CLOSED" S Y=Y_%X_$P(%Y("D",%I)," "),%X=","
"RTN","ZOSVGUX",255,0)
 Q
"RTN","ZOSVGUX",256,0)
 ;
"RTN","ZOSVGUX",257,0)
RETURN(%COMMAND,JUSTSTATUS) ; [Public] execute a shell command 
"RTN","ZOSVGUX",258,0)
 ; - return the last line; or just the status of the command.
"RTN","ZOSVGUX",259,0)
 ; %COMMAND is the string value of the Linux command
"RTN","ZOSVGUX",260,0)
 N IO,LINE,TMP
"RTN","ZOSVGUX",261,0)
 S IO=$IO
"RTN","ZOSVGUX",262,0)
 O "COMMAND":(SHELL="/bin/sh":COMMAND=%COMMAND:READONLY)::"PIPE" U "COMMAND"
"RTN","ZOSVGUX",263,0)
 F  R TMP:1 Q:$ZEO  S LINE=TMP
"RTN","ZOSVGUX",264,0)
 U IO C "COMMAND"
"RTN","ZOSVGUX",265,0)
 I $G(JUSTSTATUS) Q $ZCLOSE
"RTN","ZOSVGUX",266,0)
 Q $G(LINE)
"RTN","ZOSVONUT")
0^16^B31454787
"RTN","ZOSVONUT",1,0)
ZOSVONUT ; VEN/SMH - Unit Tests for Cache Encryption Functions XUSHSH;2017-10-30  5:32 pm ; 6/6/18 6:46am
"RTN","ZOSVONUT",2,0)
 ;;8.0;KERNEL;**10001,10002**;;Build 21
"RTN","ZOSVONUT",3,0)
 ; Submitted to OSEHRA in 2017 by Sam Habiel for OSEHRA
"RTN","ZOSVONUT",4,0)
 ; Authored by Sam Habiel 2017
"RTN","ZOSVONUT",5,0)
 ; This is a copy of ZOSVGUT2 modified to work on Cache
"RTN","ZOSVONUT",6,0)
 ;
"RTN","ZOSVONUT",7,0)
 ; Windows Users:
"RTN","ZOSVONUT",8,0)
 ; Openssl for Windows: https://slproweb.com/products/Win32OpenSSL.html - Restart Cache after install
"RTN","ZOSVONUT",9,0)
 ; Wget for Windows: https://eternallybored.org/misc/wget/
"RTN","ZOSVONUT",10,0)
 ;
"RTN","ZOSVONUT",11,0)
 D EN^%ut($t(+0),3)
"RTN","ZOSVONUT",12,0)
 quit
"RTN","ZOSVONUT",13,0)
 ;
"RTN","ZOSVONUT",14,0)
XUSHSH ; @TEST Top of XUSHSH
"RTN","ZOSVONUT",15,0)
 N X S X="TEST"
"RTN","ZOSVONUT",16,0)
 D ^XUSHSH
"RTN","ZOSVONUT",17,0)
 D CHKTF^%ut(X="TEST")
"RTN","ZOSVONUT",18,0)
 QUIT
"RTN","ZOSVONUT",19,0)
 ;
"RTN","ZOSVONUT",20,0)
SHA ; @TEST SHA-1 and SHA-256 in Hex and Base64
"RTN","ZOSVONUT",21,0)
 D CHKEQ^%ut($$SHAHASH^XUSHSH(160,"test"),"A94A8FE5CCB19BA61C4C0873D391E987982FBBD3")
"RTN","ZOSVONUT",22,0)
 D CHKEQ^%ut($$SHAHASH^XUSHSH(160,"test","H"),"A94A8FE5CCB19BA61C4C0873D391E987982FBBD3")
"RTN","ZOSVONUT",23,0)
 D CHKEQ^%ut($$SHAHASH^XUSHSH(160,"test","B"),"qUqP5cyxm6YcTAhz05Hph5gvu9M=")
"RTN","ZOSVONUT",24,0)
 D CHKEQ^%ut($$SHAHASH^XUSHSH(256,"test"),"9F86D081884C7D659A2FEAA0C55AD015A3BF4F1B2B0B822CD15D6C15B0F00A08")
"RTN","ZOSVONUT",25,0)
 QUIT
"RTN","ZOSVONUT",26,0)
 ;
"RTN","ZOSVONUT",27,0)
BASE64 ; @TEST Base 64 Encode and Decode
"RTN","ZOSVONUT",28,0)
 D CHKEQ^%ut($$B64ENCD^XUSHSH("test"),"dGVzdA==")
"RTN","ZOSVONUT",29,0)
 D CHKEQ^%ut($$B64DECD^XUSHSH("dGVzdA=="),"test")
"RTN","ZOSVONUT",30,0)
 QUIT
"RTN","ZOSVONUT",31,0)
 ;
"RTN","ZOSVONUT",32,0)
RSAENC ; @TEST Test RSA Encryption
"RTN","ZOSVONUT",33,0)
 N SECRET S SECRET="Alice and Bob had Sex!"
"RTN","ZOSVONUT",34,0)
 ;
"RTN","ZOSVONUT",35,0)
 N TD S TD=$$DEFDIR^%ZISH()
"RTN","ZOSVONUT",36,0)
 ;
"RTN","ZOSVONUT",37,0)
 ; Create RSA certificate and private key w/ no password
"RTN","ZOSVONUT",38,0)
 N %CMD
"RTN","ZOSVONUT",39,0)
 S %CMD="openssl req -x509 -nodes -days 365 -sha256 -subj ""/C=US/ST=Washington/L=Seattle/CN=www.smh101.com"" -newkey rsa:2048 -keyout "_TD_"mycert.key -out "_TD_"mycert.pem"
"RTN","ZOSVONUT",40,0)
 N % S %=$ZF(-1,%CMD)
"RTN","ZOSVONUT",41,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVONUT",42,0)
 N CIPHERTEXT S CIPHERTEXT=$$RSAENCR^XUSHSH(SECRET,TD_"mycert.pem")
"RTN","ZOSVONUT",43,0)
 D CHKTF^%ut($L(CIPHERTEXT)>$L(SECRET))
"RTN","ZOSVONUT",44,0)
 N DECRYPTION S DECRYPTION=$$RSADECR^XUSHSH(CIPHERTEXT,TD_"mycert.key")
"RTN","ZOSVONUT",45,0)
 D CHKEQ^%ut(SECRET,DECRYPTION)
"RTN","ZOSVONUT",46,0)
 ;
"RTN","ZOSVONUT",47,0)
 ; Create RSA certificate and private key with a password
"RTN","ZOSVONUT",48,0)
 ; Apparently, no way to do all of this in a single line in openssl; have to do
"RTN","ZOSVONUT",49,0)
 ; it the traditional way: key, CSR, Cert.
"RTN","ZOSVONUT",50,0)
 ; VEN/SMH - For some reason, the darwin command doesn't create the
"RTN","ZOSVONUT",51,0)
 ; certificate when running from inside GT.M; it does okay in Bash.
"RTN","ZOSVONUT",52,0)
 ; So, for now, let's just disable this check on Darwin; I don't have time
"RTN","ZOSVONUT",53,0)
 ; for this shit.
"RTN","ZOSVONUT",54,0)
 I $$VERSION^%ZOSV(1)["Darwin" QUIT
"RTN","ZOSVONUT",55,0)
 I $$VERSION^%ZOSV(1)["CYGWIN" QUIT
"RTN","ZOSVONUT",56,0)
 ;
"RTN","ZOSVONUT",57,0)
 N %CMD
"RTN","ZOSVONUT",58,0)
 S %CMD="openssl genrsa -aes128 -passout pass:monkey1234 -out "_TD_"mycert.key 2048"
"RTN","ZOSVONUT",59,0)
 N % S %=$ZF(-1,%CMD)
"RTN","ZOSVONUT",60,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVONUT",61,0)
 S %CMD="openssl req -new -key "_TD_"mycert.key -passin pass:monkey1234 -subj ""/C=US/ST=Washington/L=Seattle/CN=www.smh101.com"" -out "_TD_"mycert.csr"
"RTN","ZOSVONUT",62,0)
 N % S %=$ZF(-1,%CMD)
"RTN","ZOSVONUT",63,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVONUT",64,0)
 S %CMD="openssl req -x509 -days 365 -sha256 -in "_TD_"mycert.csr -key "_TD_"mycert.key -passin pass:monkey1234 -out "_TD_"mycert.pem"
"RTN","ZOSVONUT",65,0)
 ;I $$VERSION^%ZOSV["arwin" S %CMD="openssl req -x509 -days 365 -sha256 -in /tmp/mycert.csr -subj '/C=US/ST=Washington/L=Seattle/CN=www.smh101.com' -key /tmp/mycert.key -passin pass:monkey1234 -out /tmp/mycert.pem"
"RTN","ZOSVONUT",66,0)
 N % S %=$ZF(-1,%CMD)
"RTN","ZOSVONUT",67,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVONUT",68,0)
 N CIPHERTEXT S CIPHERTEXT=$$RSAENCR^XUSHSH(SECRET,TD_"mycert.pem")
"RTN","ZOSVONUT",69,0)
 D CHKTF^%ut($L(CIPHERTEXT)>$L(SECRET))
"RTN","ZOSVONUT",70,0)
 N DECRYPTION S DECRYPTION=$$RSADECR^XUSHSH(CIPHERTEXT,TD_"mycert.key","monkey1234")
"RTN","ZOSVONUT",71,0)
 D CHKEQ^%ut(SECRET,DECRYPTION)
"RTN","ZOSVONUT",72,0)
 QUIT
"RTN","ZOSVONUT",73,0)
 ;
"RTN","ZOSVONUT",74,0)
AESENC ; @TEST Test AES Encryption
"RTN","ZOSVONUT",75,0)
 N SECRET S SECRET="Alice and Bob had Sex!"
"RTN","ZOSVONUT",76,0)
 N X S X=$$AESENCR^XUSHSH(SECRET,"ABCDABCDABCDABCD","DCBADCBADCBADCBA")
"RTN","ZOSVONUT",77,0)
 N Y S Y=$$AESDECR^XUSHSH(X,"ABCDABCDABCDABCD","DCBADCBADCBADCBA")
"RTN","ZOSVONUT",78,0)
 D CHKEQ^%ut(SECRET,Y)
"RTN","ZOSVONUT",79,0)
 QUIT
"RTN","ZOSVONUT",80,0)
 ;
"RTN","ZOSVONUT",81,0)
SIZE ; @TEST $$SIZE^%ZISH
"RTN","ZOSVONUT",82,0)
 N OS S OS=$$OS^%ZOSV
"RTN","ZOSVONUT",83,0)
 N %
"RTN","ZOSVONUT",84,0)
 I OS="UNIX" S %=$$SIZE^%ZISH("/usr/include/","stdio.h")
"RTN","ZOSVONUT",85,0)
 I OS="NT"   S %=$$SIZE^%ZISH("c:\windows\system32\","cmd.exe")
"RTN","ZOSVONUT",86,0)
 D CHKTF^%ut(%>1000)
"RTN","ZOSVONUT",87,0)
 QUIT
"RTN","ZOSVONUT",88,0)
 ;
"RTN","ZOSVONUT",89,0)
MKDIR ; @TEST $$MKDIR^%ZISH for Unix
"RTN","ZOSVONUT",90,0)
 N OS S OS=$$OS^%ZOSV
"RTN","ZOSVONUT",91,0)
 I OS'="UNIX" QUIT
"RTN","ZOSVONUT",92,0)
 N % S %=$$RETURN^%ZOSV("rm -r /tmp/foo/boo",1)
"RTN","ZOSVONUT",93,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVONUT",94,0)
 N % S %=$$MKDIR^%ZISH("/tmp/foo/boo")
"RTN","ZOSVONUT",95,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVONUT",96,0)
 N % S %=$$RETURN^%ZOSV("stat /tmp/foo/boo",1)
"RTN","ZOSVONUT",97,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVONUT",98,0)
 QUIT
"RTN","ZOSVONUT",99,0)
 ;
"RTN","ZOSVONUT",100,0)
MDWIN ; @TEST $$MKDIR^%ZISH for Windows
"RTN","ZOSVONUT",101,0)
 N OS S OS=$$OS^%ZOSV
"RTN","ZOSVONUT",102,0)
 I OS'="NT" QUIT
"RTN","ZOSVONUT",103,0)
 N % S %=$$RETURN^%ZOSV("rmdir /s /q %temp%\foo",1)
"RTN","ZOSVONUT",104,0)
 N % S %=$$MKDIR^%ZISH("%temp%\foo\boo")
"RTN","ZOSVONUT",105,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVONUT",106,0)
 N % S %=$$RETURN^%ZOSV("dir %temp%\foo\boo",1)
"RTN","ZOSVONUT",107,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVONUT",108,0)
 QUIT
"RTN","ZOSVONUT",109,0)
 ;
"RTN","ZOSVONUT",110,0)
WGETSYNC ; @TEST $$WGETSYNC^%ZISH on NDF DAT files for Unix and Windows
"RTN","ZOSVONUT",111,0)
 N OS S OS=$$OS^%ZOSV
"RTN","ZOSVONUT",112,0)
 N FOLDER
"RTN","ZOSVONUT",113,0)
 I OS="UNIX" S FOLDER="/tmp/foo/boo"
"RTN","ZOSVONUT",114,0)
 n temp s temp=$System.Util.GetEnviron("TEMP")
"RTN","ZOSVONUT",115,0)
 I OS="NT" S FOLDER=temp_"\foo\boo"
"RTN","ZOSVONUT",116,0)
 N SEC1 S SEC1=$P($H,",",2)
"RTN","ZOSVONUT",117,0)
 N % S %=$$WGETSYNC^%ZISH("foia-vista.osehra.org","Patches_By_Application/PSN-NATIONAL DRUG FILE (NDF)/PPS_DATS/",FOLDER,"*.DAT*")
"RTN","ZOSVONUT",118,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVONUT",119,0)
 N A,CURR S A("*")=""
"RTN","ZOSVONUT",120,0)
 N % S %=$$LIST^%ZISH(FOLDER,"A","CURR")
"RTN","ZOSVONUT",121,0)
 D CHKTF^%ut($D(CURR("PPS_0PRV_1NEW.DAT")))
"RTN","ZOSVONUT",122,0)
 ;
"RTN","ZOSVONUT",123,0)
 ; Do it again. Should be faster.
"RTN","ZOSVONUT",124,0)
 N SEC2 S SEC2=$P($H,",",2)
"RTN","ZOSVONUT",125,0)
 N % S %=$$WGETSYNC^%ZISH("foia-vista.osehra.org","Patches_By_Application/PSN-NATIONAL DRUG FILE (NDF)/PPS_DATS/",FOLDER,"*.DAT*")
"RTN","ZOSVONUT",126,0)
 N A,CURR S A("*")=""
"RTN","ZOSVONUT",127,0)
 N % S %=$$LIST^%ZISH(FOLDER,"A","CURR")
"RTN","ZOSVONUT",128,0)
 D CHKTF^%ut($D(CURR("PPS_0PRV_1NEW.DAT")))
"RTN","ZOSVONUT",129,0)
 ;
"RTN","ZOSVONUT",130,0)
 ; Remove a file and download again
"RTN","ZOSVONUT",131,0)
 N SEC3 S SEC3=$P($H,",",2)
"RTN","ZOSVONUT",132,0)
 I OS="UNIX" N % S %=$$RETURN^%ZOSV("rm /tmp/foo/boo/PPS_2PRV_3NEW.DAT",1)
"RTN","ZOSVONUT",133,0)
 I OS="NT"   N % S %=$$RETURN^%ZOSV("del /q /f %temp%\foo\boo\PPS_2PRV_3NEW.DAT",1)
"RTN","ZOSVONUT",134,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVONUT",135,0)
 N % S %=$$WGETSYNC^%ZISH("foia-vista.osehra.org","Patches_By_Application/PSN-NATIONAL DRUG FILE (NDF)/PPS_DATS/",FOLDER,"*.DAT*")
"RTN","ZOSVONUT",136,0)
 N A,CURR S A("*")=""
"RTN","ZOSVONUT",137,0)
 N % S %=$$LIST^%ZISH(FOLDER,"A","CURR")
"RTN","ZOSVONUT",138,0)
 D CHKTF^%ut($D(CURR("PPS_2PRV_3NEW.DAT")))
"RTN","ZOSVONUT",139,0)
 ;
"RTN","ZOSVONUT",140,0)
 D CHKTF^%ut((SEC3-SEC2)'>(SEC2-SEC1))
"RTN","ZOSVONUT",141,0)
 QUIT
"RTN","ZSY")
0^11^B420055711
"RTN","ZSY",1,0)
ZSY ;ISF/RWF,VEN/SMH - GT.M/VA system status display ;2018-06-06  1:27 PM
"RTN","ZSY",2,0)
 ;;8.0;KERNEL;**349,10001,10002**;Jul 10, 1995;Build 21
"RTN","ZSY",3,0)
 ; Submitted to OSEHRA in 2017 by Sam Habiel for OSEHRA
"RTN","ZSY",4,0)
 ; Original Routine of unknown provenance -- was in unreleased VA patch XU*8.0*349 and thus perhaps in the public domain.
"RTN","ZSY",5,0)
 ; Rewritten by KS Bhaskar and Sam Habiel 2005-2015
"RTN","ZSY",6,0)
 ; Sam: JOBEXAM, WORK, USHOW, UNIX, UNIXLSOF, INTRPT, INTRPTALL, HALTALL, ZJOBff
"RTN","ZSY",7,0)
 ; Bhaskar provided pipe implementations of various commands.
"RTN","ZSY",8,0)
 ;GT.M/VA %SY utility - status display
"RTN","ZSY",9,0)
 ;
"RTN","ZSY",10,0)
EN ; [Public] Main Entry Point
"RTN","ZSY",11,0)
 ;From the top just show by PID
"RTN","ZSY",12,0)
 N MODE
"RTN","ZSY",13,0)
 L +^XUTL("XUSYS","COMMAND"):1 I '$T G LW
"RTN","ZSY",14,0)
 S MODE=0 D WORK(MODE)
"RTN","ZSY",15,0)
 Q
"RTN","ZSY",16,0)
 ;
"RTN","ZSY",17,0)
QUERY ; [Public] Alternate Entry Point
"RTN","ZSY",18,0)
 N MODE,X
"RTN","ZSY",19,0)
 L +^XUTL("XUSYS","COMMAND"):1 I '$T G LW
"RTN","ZSY",20,0)
 S X=$$ASK W ! I X=-1 L -^XUTL("XUSYS","COMMAND") Q
"RTN","ZSY",21,0)
 S MODE=+X D WORK(MODE)
"RTN","ZSY",22,0)
 Q
"RTN","ZSY",23,0)
 ;
"RTN","ZSY",24,0)
TMMGR ; [Public] Show only taskman manager tasks
"RTN","ZSY",25,0)
 N MODE
"RTN","ZSY",26,0)
 L +^XUTL("XUSYS","COMMAND"):1 I '$T G LW
"RTN","ZSY",27,0)
 N FILTER S FILTER("%ZTM")="",FILTER("%ZTM0")=""
"RTN","ZSY",28,0)
 S MODE=0 D WORK(MODE,.FILTER)
"RTN","ZSY",29,0)
 QUIT
"RTN","ZSY",30,0)
 ;
"RTN","ZSY",31,0)
TMSUB ; [Public] Show only taskman submanager tasks
"RTN","ZSY",32,0)
 N MODE
"RTN","ZSY",33,0)
 L +^XUTL("XUSYS","COMMAND"):1 I '$T G LW
"RTN","ZSY",34,0)
 N FILTER S FILTER("%ZTMS1")=""
"RTN","ZSY",35,0)
 S MODE=0 D WORK(MODE,.FILTER)
"RTN","ZSY",36,0)
 QUIT
"RTN","ZSY",37,0)
 ;
"RTN","ZSY",38,0)
ASK() ;Ask sort item
"RTN","ZSY",39,0)
 ; ZEXCEPT: %utAnswer
"RTN","ZSY",40,0)
 I $D(%utAnswer) Q %utAnswer
"RTN","ZSY",41,0)
 N RES,X,GROUP
"RTN","ZSY",42,0)
 S RES=0,GROUP=2
"RTN","ZSY",43,0)
 W !,"1 pid",!,"2 cpu time"
"RTN","ZSY",44,0)
 F  R !,"1// ",X:600 S:X="" X=1 Q:X["^"  Q:(X>0)&(X<3)  W " not valid"
"RTN","ZSY",45,0)
 Q:X["^" -1
"RTN","ZSY",46,0)
 S X=X-1,RES=(X#GROUP)_"~"_(X\GROUP)
"RTN","ZSY",47,0)
 Q RES
"RTN","ZSY",48,0)
 ;
"RTN","ZSY",49,0)
 ;
"RTN","ZSY",50,0)
JOBEXAM(%ZPOS) ; [Public; Called by ^ZU]
"RTN","ZSY",51,0)
 ; Preserve old state for process
"RTN","ZSY",52,0)
 N OLDIO S OLDIO=$IO
"RTN","ZSY",53,0)
 N %reference S %reference=$REFERENCE
"RTN","ZSY",54,0)
 K ^XUTL("XUSYS",$J,"JE")
"RTN","ZSY",55,0)
 ;
"RTN","ZSY",56,0)
 ; Halt the Job if requested - no need to do other work
"RTN","ZSY",57,0)
 I $G(^XUTL("XUSYS",$J,"CMD"))="HALT" D H2^XUSCLEAN G HALT^ZU
"RTN","ZSY",58,0)
 ;
"RTN","ZSY",59,0)
 ;
"RTN","ZSY",60,0)
 ; Save these
"RTN","ZSY",61,0)
 S ^XUTL("XUSYS",$J,0)=$H
"RTN","ZSY",62,0)
 S ^XUTL("XUSYS",$J,"JE","INTERRUPT")=$G(%ZPOS)
"RTN","ZSY",63,0)
 S ^XUTL("XUSYS",$J,"JE","ZMODE")=$ZMODE ; SMH - INTERACTIVE or OTHER
"RTN","ZSY",64,0)
 I %ZPOS'["GTM$DMOD" S ^XUTL("XUSYS",$J,"JE","codeline")=$T(@%ZPOS)
"RTN","ZSY",65,0)
 I $G(DUZ) S ^XUTL("XUSYS",$J,"JE","UNAME")=$P($G(^VA(200,DUZ,0)),"^")
"RTN","ZSY",66,0)
 E           S ^XUTL("XUSYS",$J,"JE","UNAME")=$G(^XUTL("XUSYS",$J,"NM"))
"RTN","ZSY",67,0)
 ;
"RTN","ZSY",68,0)
 ;
"RTN","ZSY",69,0)
 ; Default System Status.
"RTN","ZSY",70,0)
 ; S -> Stack
"RTN","ZSY",71,0)
 ; D -> Devices
"RTN","ZSY",72,0)
 ; G -> Global Stats
"RTN","ZSY",73,0)
 ; L -> Locks
"RTN","ZSY",74,0)
 I '$D(^XUTL("XUSYS",$J,"CMD")) ZSHOW "SGDL":^XUTL("XUSYS",$J,"JE") ; Default case -- most of the time this is what happens.
"RTN","ZSY",75,0)
 ;
"RTN","ZSY",76,0)
 ; Examine the Job
"RTN","ZSY",77,0)
 ; ZSHOW "*" is "BDGILRV"
"RTN","ZSY",78,0)
 ; B is break points
"RTN","ZSY",79,0)
 ; D is Devices
"RTN","ZSY",80,0)
 ; G are global stats
"RTN","ZSY",81,0)
 ; I is ISVs
"RTN","ZSY",82,0)
 ; L is Locks
"RTN","ZSY",83,0)
 ; R is Routines with Hash (similar to S)
"RTN","ZSY",84,0)
 ; V is Variables
"RTN","ZSY",85,0)
 ; ZSHOW "*" does not include:
"RTN","ZSY",86,0)
 ; A -> Autorelink information
"RTN","ZSY",87,0)
 ; C -> External programs that are loaded (presumable with D &)
"RTN","ZSY",88,0)
 ; S -> Stack (use R instead)
"RTN","ZSY",89,0)
 I $G(^XUTL("XUSYS",$J,"CMD"))="EXAM"!($P($G(^("CMD")),U)="DEBUG") ZSHOW "*":^XUTL("XUSYS",$J,"JE")
"RTN","ZSY",90,0)
 ;
"RTN","ZSY",91,0)
 ; ^XUTL("XUSYS",8563,"JE","G",0)="GLD:*,REG:*,SET:25610,KIL:593,GET:12284,...
"RTN","ZSY",92,0)
 ; Just grab the default region only. Decreases the stats as a side effect from this utility
"RTN","ZSY",93,0)
 N GLOSTAT
"RTN","ZSY",94,0)
 N I F I=0:0 S I=$O(^XUTL("XUSYS",$J,"JE","G",I)) Q:'I  I ^(I)[$ZGLD,^(I)["DEFAULT" S GLOSTAT=^(I)
"RTN","ZSY",95,0)
 I GLOSTAT]"" N I F I=1:1:$L(GLOSTAT,",") D
"RTN","ZSY",96,0)
 . N EACHSTAT S EACHSTAT=$P(GLOSTAT,",",I)
"RTN","ZSY",97,0)
 . N SUB,OBJ S SUB=$P(EACHSTAT,":"),OBJ=$P(EACHSTAT,":",2)
"RTN","ZSY",98,0)
 . S ^XUTL("XUSYS",$J,"JE","GSTAT",SUB)=OBJ
"RTN","ZSY",99,0)
 ;
"RTN","ZSY",100,0)
 ; Capture IO statistics for this process
"RTN","ZSY",101,0)
 ; ZEXCEPT: READONLY,REWIND
"RTN","ZSY",102,0)
 I $ZV["Linux" D
"RTN","ZSY",103,0)
 . N F S F="/proc/"_$J_"/io"
"RTN","ZSY",104,0)
 . O F:(READONLY:REWIND):0 E  Q
"RTN","ZSY",105,0)
 . U F
"RTN","ZSY",106,0)
 . N DONE S DONE=0 ; $ZEOF doesn't seem to work (https://github.com/YottaDB/YottaDB/issues/120)
"RTN","ZSY",107,0)
 . N X F  R X:0 U F D  Q:DONE
"RTN","ZSY",108,0)
 .. I X["read_bytes"  S ^XUTL("XUSYS",$J,"JE","RBYTE")=$P(X,": ",2)
"RTN","ZSY",109,0)
 .. I X["write_bytes" S ^XUTL("XUSYS",$J,"JE","WBYTE")=$P(X,": ",2) S DONE=1
"RTN","ZSY",110,0)
 . U OLDIO C F
"RTN","ZSY",111,0)
 ;
"RTN","ZSY",112,0)
 ; Capture String Pool Stats: Full size - Freed Data
"RTN","ZSY",113,0)
 ; spstat 2nd piece is the actual size--but that fluctuates wildly
"RTN","ZSY",114,0)
 ; I use the full size allocated (defaults at 0.10 MB) - the size freed.
"RTN","ZSY",115,0)
 n spstat s spstat=$view("spsize")
"RTN","ZSY",116,0)
 ;
"RTN","ZSY",117,0)
 S ^XUTL("XUSYS",$J,"JE","SPOOL")=spstat
"RTN","ZSY",118,0)
 S ^XUTL("XUSYS",$J,"JE","HEAP_MEM")=$p(spstat,",",1)-$p(spstat,",",3)
"RTN","ZSY",119,0)
 ;
"RTN","ZSY",120,0)
 ; Done. We can tell others we are ready
"RTN","ZSY",121,0)
 SET ^XUTL("XUSYS",$J,"JE","COMPLETE")=1
"RTN","ZSY",122,0)
 ;
"RTN","ZSY",123,0)
 ; TODO: IMPLEMENT DEBUG
"RTN","ZSY",124,0)
 I $P($G(^XUTL("XUSYS",$J,"CMD")),U)="DEBUG" QUIT  ; **NOT IMPLEMENTED**
"RTN","ZSY",125,0)
 ;
"RTN","ZSY",126,0)
 ; Restore old IO and $R
"RTN","ZSY",127,0)
 U OLDIO
"RTN","ZSY",128,0)
 I %reference
"RTN","ZSY",129,0)
 Q 1
"RTN","ZSY",130,0)
 ;
"RTN","ZSY",131,0)
WORK(MODE,FILTER) ; [Private] Main driver, Will release lock
"RTN","ZSY",132,0)
 ; int MODE
"RTN","ZSY",133,0)
 ; FILTER ref
"RTN","ZSY",134,0)
 N USERS,GROUP,PROCID
"RTN","ZSY",135,0)
 N TNAME,I,SORT,TAB
"RTN","ZSY",136,0)
 N $ES,$ET
"RTN","ZSY",137,0)
 n %PS,RTN,%OS,DONE
"RTN","ZSY",138,0)
 ;
"RTN","ZSY",139,0)
 ;Save $ZINTERRUPT, set new one
"RTN","ZSY",140,0)
 N OLDINT
"RTN","ZSY",141,0)
 S OLDINT=$ZINTERRUPT,$ZINTERRUPT="I $$JOBEXAM^ZU($ZPOSITION) S DONE=1"
"RTN","ZSY",142,0)
 ;
"RTN","ZSY",143,0)
 ;Clear old data
"RTN","ZSY",144,0)
 S ^XUTL("XUSYS","COMMAND")="Status"
"RTN","ZSY",145,0)
 ;
"RTN","ZSY",146,0)
 S I=0 F  S I=$O(^XUTL("XUSYS",I)) Q:'I  K ^XUTL("XUSYS",I,"CMD"),^("JE")
"RTN","ZSY",147,0)
 ;
"RTN","ZSY",148,0)
 ; Counts; Turn on Ctrl-C.
"RTN","ZSY",149,0)
 ; ZEXCEPT: CTRAP,NOESCAPE,NOFILTER
"RTN","ZSY",150,0)
 N USERS S USERS=0
"RTN","ZSY",151,0)
 U $P:(CTRAP=$C(3):NOESCAPE:NOFILTER)
"RTN","ZSY",152,0)
 ;
"RTN","ZSY",153,0)
 ;Go get the data
"RTN","ZSY",154,0)
 D UNIX(MODE,.USERS,.SORT)
"RTN","ZSY",155,0)
 ;
"RTN","ZSY",156,0)
 ;Now show the results
"RTN","ZSY",157,0)
 I USERS D
"RTN","ZSY",158,0)
 . D HEADER(.TAB),USHOW(.TAB,.SORT,.FILTER)
"RTN","ZSY",159,0)
 . W !!,"Total ",USERS," user",$S(USERS>1:"s.",1:"."),!
"RTN","ZSY",160,0)
 . Q
"RTN","ZSY",161,0)
 E  W !,"No current GT.M users.",!
"RTN","ZSY",162,0)
 ;
"RTN","ZSY",163,0)
 ;
"RTN","ZSY",164,0)
EXIT ;
"RTN","ZSY",165,0)
 L -^XUTL("XUSYS","COMMAND") ;Release lock and let others in
"RTN","ZSY",166,0)
 I $L($G(OLDINT)) S $ZINTERRUPT=OLDINT
"RTN","ZSY",167,0)
 U $P:CTRAP=""
"RTN","ZSY",168,0)
 Q
"RTN","ZSY",169,0)
 ;
"RTN","ZSY",170,0)
ERR ;
"RTN","ZSY",171,0)
 U $P W !,$P($ZS,",",2,99),!
"RTN","ZSY",172,0)
 D EXIT
"RTN","ZSY",173,0)
 Q
"RTN","ZSY",174,0)
 ;
"RTN","ZSY",175,0)
LW ;Lock wait
"RTN","ZSY",176,0)
 W !,"Someone else is running the System status now."
"RTN","ZSY",177,0)
 Q
"RTN","ZSY",178,0)
 ;
"RTN","ZSY",179,0)
HEADER(TAB) ;Display Header
"RTN","ZSY",180,0)
 ; ZEXCEPT: AB
"RTN","ZSY",181,0)
 W #
"RTN","ZSY",182,0)
 S IOM=+$$AUTOMARG
"RTN","ZSY",183,0)
 W !,"GT.M System Status users on ",$$DATETIME($H)
"RTN","ZSY",184,0)
 W:IOM>80 " - (stats reflect accessing DEFAULT region ONLY except *)"
"RTN","ZSY",185,0)
 S TAB(0)=0,TAB(1)=6,TAB(2)=14,TAB(3)=18,TAB(4)=27,TAB(5)=46,TAB(6)=66
"RTN","ZSY",186,0)
 S TAB(7)=75,TAB(8)=85,TAB(9)=100,TAB(10)=110,TAB(11)=115,TAB(12)=123
"RTN","ZSY",187,0)
 S TAB(13)=130,TAB(14)=141,TAB(15)=150
"RTN","ZSY",188,0)
 U 0:FILTER="ESCAPE"
"RTN","ZSY",189,0)
 W !
"RTN","ZSY",190,0)
 D EACHHEADER("PID",TAB(0))
"RTN","ZSY",191,0)
 D EACHHEADER("PName",TAB(1))
"RTN","ZSY",192,0)
 D EACHHEADER("Device",TAB(2))
"RTN","ZSY",193,0)
 D EACHHEADER("Routine",TAB(4))
"RTN","ZSY",194,0)
 D EACHHEADER("Name",TAB(5))
"RTN","ZSY",195,0)
 D EACHHEADER("CPU Time",TAB(6))
"RTN","ZSY",196,0)
 I IOM>80 D
"RTN","ZSY",197,0)
 . D EACHHEADER("OP/READ",TAB(7))
"RTN","ZSY",198,0)
 . D EACHHEADER("NTR/NTW",TAB(8))
"RTN","ZSY",199,0)
 . D EACHHEADER("NR0123",TAB(9))
"RTN","ZSY",200,0)
 . D EACHHEADER("#L",TAB(10))
"RTN","ZSY",201,0)
 . D EACHHEADER("%LSUCC",TAB(11))
"RTN","ZSY",202,0)
 . D EACHHEADER("%CFAIL",TAB(12))
"RTN","ZSY",203,0)
 I IOM>130 D
"RTN","ZSY",204,0)
 . D EACHHEADER("R MB*",TAB(13))
"RTN","ZSY",205,0)
 . D EACHHEADER("W MB*",TAB(14))
"RTN","ZSY",206,0)
 . D EACHHEADER("SP MB*",TAB(15))
"RTN","ZSY",207,0)
 Q
"RTN","ZSY",208,0)
EACHHEADER(H,TAB) ; [Internal]
"RTN","ZSY",209,0)
 ; ZEXCEPT: AB
"RTN","ZSY",210,0)
 N BOLD S BOLD=$C(27,91,49,109)
"RTN","ZSY",211,0)
 N RESET S RESET=$C(27,91,109)
"RTN","ZSY",212,0)
 W ?TAB,BOLD,H,RESET
"RTN","ZSY",213,0)
 QUIT
"RTN","ZSY",214,0)
USHOW(TAB,SORT,FILTER) ;Display job info, sorted by pid
"RTN","ZSY",215,0)
 ; ZEXCEPT: AB
"RTN","ZSY",216,0)
 N SI,I
"RTN","ZSY",217,0)
 S SI=""
"RTN","ZSY",218,0)
 F  S SI=$ORDER(SORT(SI)) Q:SI=""  F I=1:1:SORT(SI) D
"RTN","ZSY",219,0)
 . N X,TNAME,PROCID,PROCNAME,CTIME,PS,PID,PLACE
"RTN","ZSY",220,0)
 . S X=SORT(SI,I)
"RTN","ZSY",221,0)
 . S PID=$P(X,"~",8)
"RTN","ZSY",222,0)
 . S PLACE=$G(^XUTL("XUSYS",PID,"JE","INTERRUPT"))
"RTN","ZSY",223,0)
 . ; Debug
"RTN","ZSY",224,0)
 . ; I $D(^XUTL("XUSYS",PID)) ZWRITE ^(PID,*)
"RTN","ZSY",225,0)
 . ; debug
"RTN","ZSY",226,0)
 . N RTNNAME S RTNNAME=$P(PLACE,"^",2)
"RTN","ZSY",227,0)
 . I $D(FILTER)=10 Q:$$FILTROUT(.FILTER,RTNNAME,PID)
"RTN","ZSY",228,0)
 . N DEV D DEV(.DEV,PID)
"RTN","ZSY",229,0)
 . S TNAME=$$DEVSEL(.DEV),PROCID=$P(X,"~",1) ; TNAME is Terminal Name, i.e. the device.
"RTN","ZSY",230,0)
 . S PROCNAME=$P(X,"~",5),CTIME=$P(X,"~",6)
"RTN","ZSY",231,0)
 . I $G(^XUTL("XUSYS",PID,"JE","ZMODE"))="OTHER" S TNAME="BG-"_TNAME
"RTN","ZSY",232,0)
 . N UNAME S UNAME=$G(^XUTL("XUSYS",PID,"JE","UNAME"))
"RTN","ZSY",233,0)
 . W !,PROCID,?TAB(1),PROCNAME,?TAB(2),TNAME,?TAB(4),PLACE,?TAB(5),UNAME,?TAB(6),$J(CTIME,6)
"RTN","ZSY",234,0)
 . I IOM>80 D
"RTN","ZSY",235,0)
 .. I '$D(^XUTL("XUSYS",PID,"JE","GSTAT","DRD")) W ?TAB(7),"PROCESS NOT RESPONDING" QUIT
"RTN","ZSY",236,0)
 .. N DRD,DTA,GET,ORD,ZPR,QRY
"RTN","ZSY",237,0)
 .. S DRD=^XUTL("XUSYS",PID,"JE","GSTAT","DRD"),DTA=^("DTA"),GET=^("GET"),ORD=^("ORD"),ZPR=^("ZPR"),QRY=^("QRY")
"RTN","ZSY",238,0)
 .. N opPerRead
"RTN","ZSY",239,0)
 .. i DRD=0 s opPerRead=0
"RTN","ZSY",240,0)
 .. e  S opPerRead=(DTA+GET+ORD+ZPR+QRY)/DRD
"RTN","ZSY",241,0)
 .. W ?TAB(7),$J(opPerRead,"",2)
"RTN","ZSY",242,0)
 .. N NTR,NTW S NTR=^XUTL("XUSYS",PID,"JE","GSTAT","NTR"),NTW=^("NTW") ; **NAKED**
"RTN","ZSY",243,0)
 .. I NTR>9999 S NTR=$J(NTR/1024,"",0)_"k",NTW=$J(NTW/1024,"",0)_"k"
"RTN","ZSY",244,0)
 .. W ?TAB(8),NTR,"/",NTW
"RTN","ZSY",245,0)
 .. W ?TAB(9),^XUTL("XUSYS",PID,"JE","GSTAT","NR0"),"/",^("NR1"),"/",^("NR2"),"/",^("NR3")
"RTN","ZSY",246,0)
 .. ; ^XUTL("XUSYS",14295,"JE","L",1)="LOCK ^XUTL(""XUSYS"",""COMMAND"") LEVEL=2"
"RTN","ZSY",247,0)
 .. N numLocks s numLocks=0
"RTN","ZSY",248,0)
 .. N I F I=0:0 S I=$O(^XUTL("XUSYS",PID,"JE","L",I)) Q:'I  N S S S=^(I) D  ; **NAKED**
"RTN","ZSY",249,0)
 ... N levelLocation S levelLocation=$find(S,"LEVEL=")
"RTN","ZSY",250,0)
 ... n level s level=+$E(S,levelLocation,999)
"RTN","ZSY",251,0)
 ... s numLocks=numLocks+level
"RTN","ZSY",252,0)
 .. W ?TAB(10),numLocks
"RTN","ZSY",253,0)
 .. N LKS,LKF S LKS=^XUTL("XUSYS",PID,"JE","GSTAT","LKS"),LKF=^("LKF")
"RTN","ZSY",254,0)
 .. N lockSuccess
"RTN","ZSY",255,0)
 .. I LKS+LKF'=0 S lockSuccess=LKS/(LKS+LKF)
"RTN","ZSY",256,0)
 .. e  s lockSuccess=0
"RTN","ZSY",257,0)
 .. W ?TAB(11)
"RTN","ZSY",258,0)
 .. i (LKS+LKF)<100 W LKS,"/",LKS+LKF
"RTN","ZSY",259,0)
 .. e  w $J(lockSuccess*100,"",2)_"%"
"RTN","ZSY",260,0)
 .. N CFT,CAT S CFT=$g(^XUTL("XUSYS",PID,"JE","GSTAT","CFT")),CAT=$g(^("CAT"))
"RTN","ZSY",261,0)
 .. N critAcqFailure
"RTN","ZSY",262,0)
 .. I CFT+CAT'=0 S critAcqFailure=CFT/(CFT+CAT)
"RTN","ZSY",263,0)
 .. e  s critAcqFailure=0
"RTN","ZSY",264,0)
 .. W ?TAB(12)
"RTN","ZSY",265,0)
 .. i (CFT+CAT)<100 W CFT,"/",CFT+CAT
"RTN","ZSY",266,0)
 .. e  w $J(critAcqFailure*100,"",2)_"%"
"RTN","ZSY",267,0)
 . I IOM>130 D
"RTN","ZSY",268,0)
 .. W ?TAB(13),$J($G(^XUTL("XUSYS",PID,"JE","RBYTE"))/(1024*1024),"",2)
"RTN","ZSY",269,0)
 .. W ?TAB(14),$J($G(^XUTL("XUSYS",PID,"JE","WBYTE"))/(1024*1024),"",2)
"RTN","ZSY",270,0)
 .. W ?TAB(15),$J($G(^XUTL("XUSYS",PID,"JE","HEAP_MEM"))/(1024*1024),"",2)
"RTN","ZSY",271,0)
 . ;
"RTN","ZSY",272,0)
 . ; Device print - Extract Info
"RTN","ZSY",273,0)
 . ; F DI=0:0 S DI=$O(DEV(DI)) Q:'DI  D
"RTN","ZSY",274,0)
 . ; W DEV(DI)
"RTN","ZSY",275,0)
 . ;I $O(DEV("")) D
"RTN","ZSY",276,0)
 .;. W !
"RTN","ZSY",277,0)
 .;. I IOM>130 W " " F DI=0:0 S DI=$O(DEV(DI)) Q:'DI
"RTN","ZSY",278,0)
 .;. E  W DEV(DI)  
"RTN","ZSY",279,0)
 .;.. W:$E(DEV(DI))=" " !
"RTN","ZSY",280,0)
 .;.. W ?TAB(1),DEV(DI)
"RTN","ZSY",281,0)
 Q
"RTN","ZSY",282,0)
 ;
"RTN","ZSY",283,0)
FILTROUT(FILTER,RTNNAME,PID) ; [Private] Should this item be filtered out?
"RTN","ZSY",284,0)
 I RTNNAME="" QUIT 1  ; yes, filter out processes that didn't respond
"RTN","ZSY",285,0)
 ; ^XUTL("XUSYS",24754,"JE","S",1)="JOBEXAM+22^ZSY"
"RTN","ZSY",286,0)
 ; ^XUTL("XUSYS",24754,"JE","S",2)="JOBEXAM+2^ZU"
"RTN","ZSY",287,0)
 ; ^XUTL("XUSYS",24754,"JE","S",3)="GETTASK+3^%ZTMS1    ($ZINTERRUPT) "
"RTN","ZSY",288,0)
 ; ^XUTL("XUSYS",24754,"JE","S",4)="SUBMGR+1^%ZTMS1"
"RTN","ZSY",289,0)
 n found s found=0
"RTN","ZSY",290,0)
 N I F I=1:1 Q:'$D(^XUTL("XUSYS",PID,"JE","S",I))  do  q:found
"RTN","ZSY",291,0)
 . i ^XUTL("XUSYS",PID,"JE","S",I)["Call-In" quit
"RTN","ZSY",292,0)
 . i ^XUTL("XUSYS",PID,"JE","S",I)["GTM$DMOD" quit
"RTN","ZSY",293,0)
 . n rtnName s rtnName=$p(^XUTL("XUSYS",PID,"JE","S",I),"^",2)
"RTN","ZSY",294,0)
 . i rtnName[" " s rtnName=$p(rtnName," ")
"RTN","ZSY",295,0)
 . n each s each=""
"RTN","ZSY",296,0)
 . f  s each=$o(FILTER(each)) q:each=""  do  q:found
"RTN","ZSY",297,0)
 .. i $d(FILTER(rtnName)) s found=1
"RTN","ZSY",298,0)
 ;
"RTN","ZSY",299,0)
 ; If we find it, we don't want to filter it out.
"RTN","ZSY",300,0)
 QUIT 'found
"RTN","ZSY",301,0)
 ;
"RTN","ZSY",302,0)
DEV(DEV,PID) ; [Private] Device Processing
"RTN","ZSY",303,0)
 ; Input: Global ^XUTL("XUSYS",PID,"JE","D"), PID
"RTN","ZSY",304,0)
 ; Output: .DEV
"RTN","ZSY",305,0)
 ; Device processing
"RTN","ZSY",306,0)
 ; First pass, normalize output into single lines
"RTN","ZSY",307,0)
 N DEVCNT,X
"RTN","ZSY",308,0)
 S DEVCNT=0
"RTN","ZSY",309,0)
 N DI F DI=1:1 Q:'$D(^XUTL("XUSYS",PID,"JE","D",DI))  S X=^(DI) D
"RTN","ZSY",310,0)
 . I X["CLOSED" QUIT  ; Don't print closed devices
"RTN","ZSY",311,0)
 . I PID=$J,$E(X,1,2)="ps" QUIT  ; Don't print our ps device
"RTN","ZSY",312,0)
 . I $E(X)'=" " S DEVCNT=DEVCNT+1,DEV(DEVCNT)=X
"RTN","ZSY",313,0)
 . E  S DEV(DEVCNT)=DEV(DEVCNT)_" "_$$TRIM(X)
"RTN","ZSY",314,0)
 ;
"RTN","ZSY",315,0)
 ; Second Pass, identify Devices
"RTN","ZSY",316,0)
 S DEVCNT="" F  S DEVCNT=$O(DEV(DEVCNT)) Q:DEVCNT=""  D
"RTN","ZSY",317,0)
 . S X=DEV(DEVCNT)
"RTN","ZSY",318,0)
 . N UPX S UPX=$ZCO(X,"U")
"RTN","ZSY",319,0)
 . I $E(X)=0 S DEV("4JOB")="0"
"RTN","ZSY",320,0)
 . I $P(X," ")["/dev/" S DEV("3TERM")=$P(X," ")
"RTN","ZSY",321,0)
 . I $P(X," ")["/",$P(X," ")'["/dev/" S DEV("1FILE")=$P(X," ")
"RTN","ZSY",322,0)
 . I UPX["SOCKET",UPX["SERVER" S DEV("2SOCK")=+$P(UPX,"PORT=",2)
"RTN","ZSY",323,0)
 QUIT
"RTN","ZSY",324,0)
 ;
"RTN","ZSY",325,0)
DEVSEL(DEV) ; [Private] Select Device to Print
"RTN","ZSY",326,0)
 N DEVTYP S DEVTYP=$O(DEV(" "))
"RTN","ZSY",327,0)
 Q:DEVTYP="" ""
"RTN","ZSY",328,0)
 I DEVTYP="4JOB" Q "0"
"RTN","ZSY",329,0)
 I DEVTYP="2SOCK" Q "S"_DEV(DEVTYP)
"RTN","ZSY",330,0)
 I DEVTYP="3TERM" Q DEV(DEVTYP)
"RTN","ZSY",331,0)
 I DEVTYP="1FILE" Q DEV(DEVTYP)
"RTN","ZSY",332,0)
 Q "ERROR"
"RTN","ZSY",333,0)
 ;
"RTN","ZSY",334,0)
TRIM(STR) ; [Private] Trim spaces
"RTN","ZSY",335,0)
 Q $$FUNC^%TRIM(STR)
"RTN","ZSY",336,0)
 ;
"RTN","ZSY",337,0)
DATETIME(HOROLOG) ;
"RTN","ZSY",338,0)
 Q $ZDATE(HOROLOG,"DD-MON-YY 24:60:SS")
"RTN","ZSY",339,0)
 ;
"RTN","ZSY",340,0)
UNIX(MODE,USERS,SORT) ;PUG/TOAD,FIS/KSB,VEN/SMH - Kernel System Status Report for GT.M
"RTN","ZSY",341,0)
 N %I,U,$ET,$ES
"RTN","ZSY",342,0)
 S $ET="D UERR^ZSY"
"RTN","ZSY",343,0)
 S %I=$I,U="^"
"RTN","ZSY",344,0)
 n procs
"RTN","ZSY",345,0)
 D INTRPTALL(.procs)
"RTN","ZSY",346,0)
 H .205 ; 200ms for TCP Read processes; 5ms b/c I am nice.
"RTN","ZSY",347,0)
 n procgrps
"RTN","ZSY",348,0)
 n done s done=0
"RTN","ZSY",349,0)
 n j s j=1
"RTN","ZSY",350,0)
 n i s i=0 f  s i=$o(procs(i)) q:'i  d
"RTN","ZSY",351,0)
 . s procgrps(j)=$g(procgrps(j))_procs(i)_" "
"RTN","ZSY",352,0)
 . i $l(procgrps(j))>220 s j=j+1 ; Max GT.M pipe len is 255
"RTN","ZSY",353,0)
 f j=1:1 q:'$d(procgrps(j))  d
"RTN","ZSY",354,0)
 . N %LINE,%TEXT,CMD
"RTN","ZSY",355,0)
 . I $ZV["Linux" S CMD="ps o pid,tty,stat,time,cmd -p"_procgrps(j)
"RTN","ZSY",356,0)
 . I $ZV["Darwin" S CMD="ps o pid,tty,stat,time,args -p"_procgrps(j)
"RTN","ZSY",357,0)
 . I $ZV["CYGWIN" S CMD="for p in "_procgrps(j)_"; do ps -p $p; done | awk '{print $1"" ""$5"" n/a ""$7"" ""$8"" n/a ""}'"
"RTN","ZSY",358,0)
 . ; ZEXCEPT: COMMAND,READONLY,SHELL
"RTN","ZSY",359,0)
 . O "ps":(SHELL="/bin/sh":COMMAND=CMD:READONLY)::"PIPE" U "ps"
"RTN","ZSY",360,0)
 . F  R %TEXT Q:$ZEO  D
"RTN","ZSY",361,0)
 .. S %LINE=$$VPE(%TEXT," ",U) ; parse each line of the ps output
"RTN","ZSY",362,0)
 .. Q:$P(%LINE,U)="PID"  ; header line
"RTN","ZSY",363,0)
 .. D JOBSET(%LINE,MODE,.USERS,.SORT)
"RTN","ZSY",364,0)
 . U %I C "ps"
"RTN","ZSY",365,0)
 Q
"RTN","ZSY",366,0)
 ;
"RTN","ZSY",367,0)
UERR ;Linux Error
"RTN","ZSY",368,0)
 N ZE S ZE=$ZS,$EC="" U $P
"RTN","ZSY",369,0)
 ZSHOW "*"
"RTN","ZSY",370,0)
 Q  ;halt
"RTN","ZSY",371,0)
 ;
"RTN","ZSY",372,0)
JOBSET(%LINE,MODE,USERS,SORT) ;Get data from a Linux job
"RTN","ZSY",373,0)
 N %J
"RTN","ZSY",374,0)
 N UNAME,PS,TNAME,CTIME
"RTN","ZSY",375,0)
 S (UNAME,PS,TNAME,CTIME)=""
"RTN","ZSY",376,0)
 N %J,PID,PROCID S (%J,PID,PROCID)=$P(%LINE,U)
"RTN","ZSY",377,0)
 S TNAME=$P(%LINE,U,2) S:TNAME="?" TNAME="" ; TTY, ? if none
"RTN","ZSY",378,0)
 S PS=$P(%LINE,U,3) ; process STATE
"RTN","ZSY",379,0)
 S CTIME=$P(%LINE,U,4) ;cpu time
"RTN","ZSY",380,0)
 N PROCNAME S PROCNAME=$P(%LINE,U,5) ; process name
"RTN","ZSY",381,0)
 I PROCNAME["/" S PROCNAME=$P(PROCNAME,"/",$L(PROCNAME,"/")) ; get actual image name if path
"RTN","ZSY",382,0)
 I $D(^XUTL("XUSYS",%J)) S UNAME=$G(^XUTL("XUSYS",%J,"NM"))
"RTN","ZSY",383,0)
 E  S UNAME="unknown"
"RTN","ZSY",384,0)
 N SI S SI=$S(MODE=0:PID,MODE=1:CTIME,1:PID)
"RTN","ZSY",385,0)
 N I S I=$GET(SORT(SI))+1
"RTN","ZSY",386,0)
 S SORT(SI)=I
"RTN","ZSY",387,0)
 S SORT(SI,I)=PROCID_"~"_UNAME_"~"_PS_"~"_TNAME_"~"_PROCNAME_"~"_CTIME_"~"_""_"~"_PID
"RTN","ZSY",388,0)
 S USERS=USERS+1
"RTN","ZSY",389,0)
 Q
"RTN","ZSY",390,0)
 ;
"RTN","ZSY",391,0)
VPE(%OLDSTR,%OLDDEL,%NEWDEL) ; $PIECE extract based on variable length delimiter
"RTN","ZSY",392,0)
 N %LEN,%PIECE,%NEWSTR
"RTN","ZSY",393,0)
 S %OLDDEL=$G(%OLDDEL) I %OLDDEL="" S %OLDDEL=" "
"RTN","ZSY",394,0)
 S %LEN=$L(%OLDDEL)
"RTN","ZSY",395,0)
 ; each %OLDDEL-sized chunk of %OLDSTR that might be delimiter
"RTN","ZSY",396,0)
 S %NEWDEL=$G(%NEWDEL) I %NEWDEL="" S %NEWDEL="^"
"RTN","ZSY",397,0)
 ; each piece of the old string
"RTN","ZSY",398,0)
 S %NEWSTR="" ; new reformatted string to retun
"RTN","ZSY",399,0)
 F  Q:%OLDSTR=""  D
"RTN","ZSY",400,0)
 . S %PIECE=$P(%OLDSTR,%OLDDEL)
"RTN","ZSY",401,0)
 . S $P(%OLDSTR,%OLDDEL)=""
"RTN","ZSY",402,0)
 . S %NEWSTR=%NEWSTR_$S(%NEWSTR="":"",1:%NEWDEL)_%PIECE
"RTN","ZSY",403,0)
 . F  Q:%OLDDEL'=$E(%OLDSTR,1,%LEN)  S $E(%OLDSTR,1,%LEN)=""
"RTN","ZSY",404,0)
 Q %NEWSTR
"RTN","ZSY",405,0)
 ;
"RTN","ZSY",406,0)
 ; Sam's entry points
"RTN","ZSY",407,0)
UNIXLSOF(procs) ; [Public] - Get all processes accessing THIS database (only!)
"RTN","ZSY",408,0)
 ; (return) .procs(n)=unix process number
"RTN","ZSY",409,0)
 ; ZEXCEPT: shell,parse
"RTN","ZSY",410,0)
 n %cmd s %cmd="lsof -t "_$view("gvfile","DEFAULT")
"RTN","ZSY",411,0)
 i $ZV["CYGWIN" s %cmd="ps -a | grep mumps | grep -v grep | awk '{print $1}'"
"RTN","ZSY",412,0)
 n oldio s oldio=$IO
"RTN","ZSY",413,0)
 o "lsof":(shell="/bin/bash":command=%cmd:parse)::"pipe"
"RTN","ZSY",414,0)
 u "lsof"
"RTN","ZSY",415,0)
 n i f i=1:1 q:$ZEOF  r procs(i):1  i procs(i)="" k procs(i)
"RTN","ZSY",416,0)
 u oldio c "lsof"
"RTN","ZSY",417,0)
 n cnt s cnt=0
"RTN","ZSY",418,0)
 n i f i=0:0 s i=$o(procs(i)) q:'i  i $i(cnt)
"RTN","ZSY",419,0)
 quit:$Q cnt quit
"RTN","ZSY",420,0)
 ;
"RTN","ZSY",421,0)
INTRPT(%J) ; [Public] Send mupip interrupt (currently SIGUSR1)
"RTN","ZSY",422,0)
 N SIGUSR1
"RTN","ZSY",423,0)
 I $ZV["Linux" S SIGUSR1=10
"RTN","ZSY",424,0)
 I $ZV["Darwin" S SIGUSR1=30
"RTN","ZSY",425,0)
 I $ZV["CYGWIN" S SIGUSR1=30
"RTN","ZSY",426,0)
 N % S %=$ZSIGPROC(%J,SIGUSR1)
"RTN","ZSY",427,0)
 QUIT
"RTN","ZSY",428,0)
 ;
"RTN","ZSY",429,0)
INTRPTALL(procs) ; [Public] Send mupip interrupt to every single database process
"RTN","ZSY",430,0)
 N SIGUSR1
"RTN","ZSY",431,0)
 I $ZV["Linux" S SIGUSR1=10
"RTN","ZSY",432,0)
 I $ZV["Darwin" S SIGUSR1=30
"RTN","ZSY",433,0)
 I $ZV["CYGWIN" S SIGUSR1=30
"RTN","ZSY",434,0)
 ; Collect processes
"RTN","ZSY",435,0)
 D UNIXLSOF(.procs)
"RTN","ZSY",436,0)
 ; Signal all processes
"RTN","ZSY",437,0)
 N i,% s i=0 f  s i=$o(procs(i)) q:'i  S %=$ZSIGPROC(procs(i),SIGUSR1)
"RTN","ZSY",438,0)
 QUIT
"RTN","ZSY",439,0)
 ;
"RTN","ZSY",440,0)
HALTALL ; [Public] Gracefully halt all jobs accessing current database
"RTN","ZSY",441,0)
 ; Calls ^XUSCLEAN then HALT^ZU
"RTN","ZSY",442,0)
 ;Clear old data
"RTN","ZSY",443,0)
 S ^XUTL("XUSYS","COMMAND")="Status"
"RTN","ZSY",444,0)
 N I F I=0:0 S I=$O(^XUTL("XUSYS",I)) Q:'I  K ^XUTL("XUSYS",I,"JE"),^("INTERUPT")
"RTN","ZSY",445,0)
 ;
"RTN","ZSY",446,0)
 ; Get jobs accessing this database
"RTN","ZSY",447,0)
 n procs d UNIXLSOF(.procs)
"RTN","ZSY",448,0)
 ;
"RTN","ZSY",449,0)
 ; Tell them to stop
"RTN","ZSY",450,0)
 n i f i=1:1 q:'$d(procs(i))  s ^XUTL("XUSYS",procs(i),"CMD")="HALT"
"RTN","ZSY",451,0)
 K ^XUTL("XUSYS",$J,"CMD")  ; but not us
"RTN","ZSY",452,0)
 ;
"RTN","ZSY",453,0)
 ; Sayonara
"RTN","ZSY",454,0)
 N J F J=0:0 S J=$O(^XUTL("XUSYS",J)) Q:'J  D INTRPT(J)
"RTN","ZSY",455,0)
 ;
"RTN","ZSY",456,0)
 ; Wait; Long hang for TCP jobs that can't receive interrupts for .2 seconds
"RTN","ZSY",457,0)
 H .25
"RTN","ZSY",458,0)
 ;
"RTN","ZSY",459,0)
 ; Check that they are all dead. If not, kill it "softly".
"RTN","ZSY",460,0)
 ; Need to do this for node and java processes that won't respond normally.
"RTN","ZSY",461,0)
 N J F J=0:0 S J=$O(^XUTL("XUSYS",J)) Q:'J  I $zgetjpi(J,"isprocalive"),J'=$J D KILL(J)
"RTN","ZSY",462,0)
 ;
"RTN","ZSY",463,0)
 quit
"RTN","ZSY",464,0)
 ;
"RTN","ZSY",465,0)
HALTONE(%J) ; [Public] Halt a single process
"RTN","ZSY",466,0)
 S ^XUTL("XUSYS",%J,"CMD")="HALT"
"RTN","ZSY",467,0)
 D INTRPT(%J)
"RTN","ZSY",468,0)
 H .25 ; Long hang for TCP jobs that can't receive interrupts
"RTN","ZSY",469,0)
 I $zgetjpi(%J,"isprocalive") D KILL(%J)
"RTN","ZSY",470,0)
 QUIT
"RTN","ZSY",471,0)
 ;
"RTN","ZSY",472,0)
KILL(%J) ; [Private] Kill %J
"RTN","ZSY",473,0)
 ; ZEXCEPT: shell
"RTN","ZSY",474,0)
 n %cmd s %cmd="kill "_%J
"RTN","ZSY",475,0)
 o "kill":(shell="/bin/sh":command=%cmd)::"pipe" u "kill" c "kill"
"RTN","ZSY",476,0)
 quit
"RTN","ZSY",477,0)
 ;
"RTN","ZSY",478,0)
ZJOB(PID) G JOBVIEWZ ; [Public, Interactive] Examine a specific job -- written by OSEHRA/SMH
"RTN","ZSY",479,0)
EXAMJOB(PID) G JOBVIEWZ ;
"RTN","ZSY",480,0)
VIEWJOB(PID) G JOBVIEWZ ;
"RTN","ZSY",481,0)
JOBVIEW(PID) G JOBVIEWZ ;
"RTN","ZSY",482,0)
JOBVIEWZ ;
"RTN","ZSY",483,0)
 ; ZEXCEPT: CTRAP,NOESCAPE,NOFILTER,PID
"RTN","ZSY",484,0)
 U $P:(CTRAP=$C(3):NOESCAPE:NOFILTER)
"RTN","ZSY",485,0)
 I $G(PID) D JOBVIEWZ2(PID) QUIT
"RTN","ZSY",486,0)
 D ^ZSY
"RTN","ZSY",487,0)
 N X,DONE
"RTN","ZSY",488,0)
 S DONE=0
"RTN","ZSY",489,0)
 ; Nasty read loop. I hate read loops
"RTN","ZSY",490,0)
 F  D  Q:DONE
"RTN","ZSY",491,0)
 . R !,"Enter a job number to examine (^ to quit): ",X:$G(DTIME,300)
"RTN","ZSY",492,0)
 . E  S DONE=1 QUIT
"RTN","ZSY",493,0)
 . I X="^" S DONE=1 QUIT
"RTN","ZSY",494,0)
 . I X="" D ^ZSY QUIT
"RTN","ZSY",495,0)
 . I X["?" D ^ZSY QUIT
"RTN","ZSY",496,0)
 . ;
"RTN","ZSY",497,0)
 . D JOBVIEWZ2(X)
"RTN","ZSY",498,0)
 . D ^ZSY
"RTN","ZSY",499,0)
 QUIT
"RTN","ZSY",500,0)
 ;
"RTN","ZSY",501,0)
JOBVIEWZ2(X) ; [Private] View Job Information
"RTN","ZSY",502,0)
 I X'?1.N W !,"Not a valid job number." Q
"RTN","ZSY",503,0)
 I '$zgetjpi(X,"isprocalive") W !,"This process does not exist" Q
"RTN","ZSY",504,0)
 ;
"RTN","ZSY",505,0)
 N EXAMREAD
"RTN","ZSY",506,0)
 N DONEONE S DONEONE=0
"RTN","ZSY",507,0)
 F  D  Q:DONEONE  ; This is an inner read loop to refresh a process.
"RTN","ZSY",508,0)
 . N % S %=$$EXAMINEJOBBYPID(X)
"RTN","ZSY",509,0)
 . I %'=0 W !,"The job didn't respond to examination for 305 ms. You may try again." S DONEONE=1 QUIT
"RTN","ZSY",510,0)
 . D PRINTEXAMDATA(X,$G(EXAMREAD))
"RTN","ZSY",511,0)
 . W "Enter to Refersh, V for variables, I for ISVs, K to kill",!
"RTN","ZSY",512,0)
 . W "L to load variables into your ST and quit, ^ to go back: ",!
"RTN","ZSY",513,0)
 . W "D to debug (broken), Z to zshow all data for debugging."
"RTN","ZSY",514,0)
 . R EXAMREAD:$G(DTIME,300)
"RTN","ZSY",515,0)
 . E  S DONEONE=1
"RTN","ZSY",516,0)
 . I EXAMREAD="^" S DONEONE=1
"RTN","ZSY",517,0)
 . I $TR(EXAMREAD,"k","K")="K" D HALTONE(X) S DONEONE=1
"RTN","ZSY",518,0)
 QUIT
"RTN","ZSY",519,0)
 ;
"RTN","ZSY",520,0)
EXAMINEJOBBYPID(%J) ; [$$, Public, Silent] Examine Job by PID; Non-zero output failure
"RTN","ZSY",521,0)
 Q:'$ZGETJPI(%J,"isprocalive") -1
"RTN","ZSY",522,0)
 K ^XUTL("XUSYS",%J,"CMD"),^("JE")
"RTN","ZSY",523,0)
 S ^XUTL("XUSYS",%J,"CMD")="EXAM"
"RTN","ZSY",524,0)
 D INTRPT(%J)
"RTN","ZSY",525,0)
 N I F I=1:1:5 H .001 Q:$G(^XUTL("XUSYS",%J,"JE","COMPLETE"))
"RTN","ZSY",526,0)
 I '$G(^XUTL("XUSYS",%J,"JE","COMPLETE")) H .2
"RTN","ZSY",527,0)
 I '$G(^XUTL("XUSYS",%J,"JE","COMPLETE")) H .2
"RTN","ZSY",528,0)
 I '$G(^XUTL("XUSYS",%J,"JE","COMPLETE")) Q -1
"RTN","ZSY",529,0)
 QUIT 0
"RTN","ZSY",530,0)
 ;
"RTN","ZSY",531,0)
PRINTEXAMDATA(%J,FLAG) ; [Private] Print the exam data
"RTN","ZSY",532,0)
 ; ^XUTL("XUSYS",8563,"JE","INTERRUPT")="GETTASK+3^%ZTMS1"
"RTN","ZSY",533,0)
 ; ^XUTL("XUSYS",8563,"JE","G",0)="GLD:*,REG:*,SET:25610,KIL:593,GET:12284,...
"RTN","ZSY",534,0)
 ; ^XUTL("XUSYS",8563,"JE","ZMODE")="OTHER"
"RTN","ZSY",535,0)
 N ZSY M ZSY=^XUTL("XUSYS",%J)
"RTN","ZSY",536,0)
 ;
"RTN","ZSY",537,0)
 N BOLD S BOLD=$C(27,91,49,109)
"RTN","ZSY",538,0)
 N RESET S RESET=$C(27,91,109)
"RTN","ZSY",539,0)
 N UNDER S UNDER=$C(27,91,52,109)
"RTN","ZSY",540,0)
 N DIM S DIM=$$AUTOMARG()
"RTN","ZSY",541,0)
 ;
"RTN","ZSY",542,0)
 ; Debug
"RTN","ZSY",543,0)
 I $TR(FLAG,"d","D")="D" D DEBUG(%J)
"RTN","ZSY",544,0)
 ;
"RTN","ZSY",545,0)
 ; Show all data
"RTN","ZSY",546,0)
 I $TR(FLAG,"z","Z")="Z" ZWRITE ZSY QUIT
"RTN","ZSY",547,0)
 ;
"RTN","ZSY",548,0)
 ; List Variables?
"RTN","ZSY",549,0)
 I $TR(FLAG,"v","V")="V" D  QUIT
"RTN","ZSY",550,0)
 . W !!,BOLD,"Variables: ",RESET,!
"RTN","ZSY",551,0)
 . N V F V=0:0 S V=$O(ZSY("JE","V",V)) Q:'V  W ZSY("JE","V",V),!
"RTN","ZSY",552,0)
 ;
"RTN","ZSY",553,0)
 ; Load Variables into my Symbol Table?
"RTN","ZSY",554,0)
 ; ZGOTO pops the stack and drops you to direct mode ($ZLEVEL is 2 to exit one above direct mode)
"RTN","ZSY",555,0)
 I $TR(FLAG,"l","L")="L" D  ZGOTO 2:LOADST
"RTN","ZSY",556,0)
 . K ^TMP("ZSY",$J)
"RTN","ZSY",557,0)
 . M ^TMP("ZSY",$J)=ZSY("JE","V")
"RTN","ZSY",558,0)
 ;
"RTN","ZSY",559,0)
 ; List ISVs?
"RTN","ZSY",560,0)
 I $TR(FLAG,"i","I")="I" D  QUIT
"RTN","ZSY",561,0)
 . W !!,BOLD,"ISVs: ",RESET,!
"RTN","ZSY",562,0)
 . N I F I=0:0 S I=$O(ZSY("JE","I",I)) Q:'I  W ZSY("JE","I",I),!
"RTN","ZSY",563,0)
 ;
"RTN","ZSY",564,0)
 ; Normal Display: Job Info, Stack, Locks, Devices
"RTN","ZSY",565,0)
 W #
"RTN","ZSY",566,0)
 W UNDER,"JOB INFORMATION FOR "_%J," (",$ZDATE(ZSY(0),"YYYY-MON-DD 24:60:SS"),")",RESET,!
"RTN","ZSY",567,0)
 W BOLD,"AT: ",RESET,ZSY("JE","INTERRUPT"),": ",$G(ZSY("JE","codeline")),!!
"RTN","ZSY",568,0)
 ;
"RTN","ZSY",569,0)
 N CNT S CNT=1
"RTN","ZSY",570,0)
 W BOLD,"Stack: ",RESET,!
"RTN","ZSY",571,0)
 ; Stack is funny -- print just to $ZINTERRUPT
"RTN","ZSY",572,0)
 N S F S=$O(ZSY("JE","R"," "),-1):-1:1 Q:ZSY("JE","R",S)["$ZINTERRUPT"  D
"RTN","ZSY",573,0)
 . N PLACE S PLACE=$P(ZSY("JE","R",S),":")
"RTN","ZSY",574,0)
 . I $E(PLACE)=" " QUIT  ; GTM adds an extra level sometimes for display -- messes me up
"RTN","ZSY",575,0)
 . W CNT,". "
"RTN","ZSY",576,0)
 . I PLACE'["GTM$DMOD" W PLACE,?40,$T(@PLACE)
"RTN","ZSY",577,0)
 . W !
"RTN","ZSY",578,0)
 . S CNT=CNT+1
"RTN","ZSY",579,0)
 W CNT,". ",ZSY("JE","INTERRUPT"),":",?40,$G(ZSY("JE","codeline")),!
"RTN","ZSY",580,0)
 ;
"RTN","ZSY",581,0)
 W !
"RTN","ZSY",582,0)
 W BOLD,"Locks: ",RESET,!
"RTN","ZSY",583,0)
 N L F L=0:0 S L=$O(ZSY("JE","L",L)) Q:'L  W ZSY("JE","L",L),!
"RTN","ZSY",584,0)
 ;
"RTN","ZSY",585,0)
 W !
"RTN","ZSY",586,0)
 W BOLD,"Devices: ",RESET,!
"RTN","ZSY",587,0)
 N D F D=0:0 S D=$O(ZSY("JE","D",D)) Q:'D  W ZSY("JE","D",D),!
"RTN","ZSY",588,0)
 ;
"RTN","ZSY",589,0)
 W !
"RTN","ZSY",590,0)
 W BOLD,"Breakpoints: ",RESET,!
"RTN","ZSY",591,0)
 N B F B=0:0 S B=$O(ZSY("JE","B",B)) Q:'B  W ZSY("JE","B",B),!
"RTN","ZSY",592,0)
 ;
"RTN","ZSY",593,0)
 W !
"RTN","ZSY",594,0)
 W BOLD,"Global Stats for default region: ",RESET,!
"RTN","ZSY",595,0)
 N G S G=""
"RTN","ZSY",596,0)
 N SLOTS S SLOTS=+DIM\15
"RTN","ZSY",597,0)
 N SLOT S SLOT=0
"RTN","ZSY",598,0)
 F  S G=$O(ZSY("JE","GSTAT",G)) Q:G=""  D
"RTN","ZSY",599,0)
 . I G="GLD" QUIT
"RTN","ZSY",600,0)
 . N V S V=ZSY("JE","GSTAT",G)
"RTN","ZSY",601,0)
 . I V>9999 S V=$J(V/1024,"",0)_"k"
"RTN","ZSY",602,0)
 . I V>9999,V["k" S V=$J(V/1024,"",0)_"m"
"RTN","ZSY",603,0)
 . W ?(SLOT*15),G,": ",V," "
"RTN","ZSY",604,0)
 . S SLOT=SLOT+1
"RTN","ZSY",605,0)
 . I SLOT+1>SLOTS S SLOT=0 W !
"RTN","ZSY",606,0)
 W !!
"RTN","ZSY",607,0)
 ;
"RTN","ZSY",608,0)
 W BOLD,"String Pool (size,currently used,freed): ",RESET,ZSY("JE","SPOOL"),!!
"RTN","ZSY",609,0)
 QUIT
"RTN","ZSY",610,0)
 ;
"RTN","ZSY",611,0)
LOADST ; [Private] Load the symbol table into the current process
"RTN","ZSY",612,0)
 KILL
"RTN","ZSY",613,0)
 N V F V=0:0 S V=$O(^TMP("ZSY",$J,V)) Q:'V  S @^(V)
"RTN","ZSY",614,0)
 K ^TMP("ZSY",$J)
"RTN","ZSY",615,0)
 QUIT
"RTN","ZSY",616,0)
 ;
"RTN","ZSY",617,0)
DEBUG(%J) ; [Private] Debugging logic
"RTN","ZSY",618,0)
 Q:'$ZGETJPI(%J,"isprocalive") -1
"RTN","ZSY",619,0)
 K ^XUTL("XUSYS",%J,"CMD"),^("JE")
"RTN","ZSY",620,0)
 S ^XUTL("XUSYS",%J,"CMD")="DEBUG"
"RTN","ZSY",621,0)
 D INTRPT(%J)
"RTN","ZSY",622,0)
 N I F I=1:1:5 H .001 Q:$G(^XUTL("XUSYS",%J,"JE","COMPLETE"))
"RTN","ZSY",623,0)
 I '$G(^XUTL("XUSYS",%J,"JE","COMPLETE")) H .2
"RTN","ZSY",624,0)
 I '$G(^XUTL("XUSYS",%J,"JE","COMPLETE")) H .1
"RTN","ZSY",625,0)
 I '$G(^XUTL("XUSYS",%J,"JE","COMPLETE")) Q -1
"RTN","ZSY",626,0)
 N ZSY M ZSY=^XUTL("XUSYS",%J)
"RTN","ZSY",627,0)
 ;
"RTN","ZSY",628,0)
 N BOLD S BOLD=$C(27,91,49,109)
"RTN","ZSY",629,0)
 N RESET S RESET=$C(27,91,109)
"RTN","ZSY",630,0)
 N UNDER S UNDER=$C(27,91,52,109)
"RTN","ZSY",631,0)
 N DIM S DIM=$$AUTOMARG()
"RTN","ZSY",632,0)
 ;
"RTN","ZSY",633,0)
 ; Normal Display: Job Info, Stack, Locks, Devices
"RTN","ZSY",634,0)
 W #
"RTN","ZSY",635,0)
 W UNDER,"JOB INFORMATION FOR "_%J," (",$ZDATE(ZSY(0),"YYYY-MON-DD 24:60:SS"),")",RESET,!
"RTN","ZSY",636,0)
 W BOLD,"AT: ",RESET,ZSY("JE","INTERRUPT"),": ",ZSY("JE","codeline"),!!
"RTN","ZSY",637,0)
 ;
"RTN","ZSY",638,0)
 N CNT S CNT=1
"RTN","ZSY",639,0)
 W BOLD,"Stack: ",RESET,!
"RTN","ZSY",640,0)
 ; Stack is funny -- print just to $ZINTERRUPT
"RTN","ZSY",641,0)
 N S F S=$O(ZSY("JE","R"," "),-1):-1:1 Q:ZSY("JE","R",S)["$ZINTERRUPT"  D
"RTN","ZSY",642,0)
 . N PLACE S PLACE=$P(ZSY("JE","R",S),":")
"RTN","ZSY",643,0)
 . I $E(PLACE)=" " QUIT  ; GTM adds an extra level sometimes for display -- messes me up
"RTN","ZSY",644,0)
 . W CNT,". "
"RTN","ZSY",645,0)
 . I PLACE'["GTM$DMOD" W PLACE,?40,$T(@PLACE)
"RTN","ZSY",646,0)
 . W !
"RTN","ZSY",647,0)
 . S CNT=CNT+1
"RTN","ZSY",648,0)
 W CNT,". ",ZSY("JE","INTERRUPT"),":",?40,ZSY("JE","codeline"),!
"RTN","ZSY",649,0)
 ;
"RTN","ZSY",650,0)
 W !
"RTN","ZSY",651,0)
 W BOLD,"Locks: ",RESET,!
"RTN","ZSY",652,0)
 N L F L=0:0 S L=$O(ZSY("JE","L",L)) Q:'L  W ZSY("JE","L",L),!
"RTN","ZSY",653,0)
 ;
"RTN","ZSY",654,0)
 W !
"RTN","ZSY",655,0)
 W BOLD,"Devices: ",RESET,!
"RTN","ZSY",656,0)
 N D F D=0:0 S D=$O(ZSY("JE","D",D)) Q:'D  W ZSY("JE","D",D),!
"RTN","ZSY",657,0)
 W !
"RTN","ZSY",658,0)
 W BOLD,"Breakpoints: ",RESET,!
"RTN","ZSY",659,0)
 N B F B=0:0 S B=$O(ZSY("JE","B",B)) Q:'B  W ZSY("JE","B",B),!
"RTN","ZSY",660,0)
 ;
"RTN","ZSY",661,0)
 n x r "press key to continue",x
"RTN","ZSY",662,0)
 QUIT
"RTN","ZSY",663,0)
 ;
"RTN","ZSY",664,0)
AUTOMARG() ;RETURNS IOM^IOSL IF IT CAN and resets terminal to those dimensions; GT.M
"RTN","ZSY",665,0)
 ; ZEXCEPT: APC,TERM,NOECHO,WIDTH
"RTN","ZSY",666,0)
 I $PRINCIPAL'["/dev/" quit:$Q "" quit
"RTN","ZSY",667,0)
 U $PRINCIPAL:(WIDTH=0)
"RTN","ZSY",668,0)
 N %I,%T,ESC,DIM S %I=$I,%T=$T D
"RTN","ZSY",669,0)
 . ; resize terminal to match actual dimensions
"RTN","ZSY",670,0)
 . S ESC=$C(27)
"RTN","ZSY",671,0)
 . U $P:(TERM="R":NOECHO)
"RTN","ZSY",672,0)
 . W ESC,"7",ESC,"[r",ESC,"[999;999H",ESC,"[6n"
"RTN","ZSY",673,0)
 . R DIM:1 E  Q
"RTN","ZSY",674,0)
 . W ESC,"8"
"RTN","ZSY",675,0)
 . I DIM?.APC U $P:(TERM="":ECHO) Q
"RTN","ZSY",676,0)
 . I $L($G(DIM)) S DIM=+$P(DIM,";",2)_"^"_+$P(DIM,"[",2)
"RTN","ZSY",677,0)
 . U $P:(TERM="":ECHO:WIDTH=+$P(DIM,";",2):LENGTH=+$P(DIM,"[",2))
"RTN","ZSY",678,0)
 ; restore state
"RTN","ZSY",679,0)
 U %I I %T
"RTN","ZSY",680,0)
 ; Extra just for ^ZJOB - don't wrap
"RTN","ZSY",681,0)
 U $PRINCIPAL:(WIDTH=0)
"RTN","ZSY",682,0)
 Q:$Q $S($G(DIM):DIM,1:"") Q
"RTN","ZTLOAD1")
0^12^B24616598
"RTN","ZTLOAD1",1,0)
%ZTLOAD1 ;SEA/RDS-TaskMan: P I: Queue ;2017-01-09  3:45 PM
"RTN","ZTLOAD1",2,0)
 ;;8.0;KERNEL;**112,118,127,162,275,363,409,415,425,446,10001**;Jul 10, 1995;Build 21
"RTN","ZTLOAD1",3,0)
 ; Submitted to OSEHRA in 2017 by Sam Habiel for OSEHRA
"RTN","ZTLOAD1",4,0)
 ; Original Routine authored by Department of Veterans Affairs
"RTN","ZTLOAD1",5,0)
 ; Transactions removed by Christopher Edwards 2014.
"RTN","ZTLOAD1",6,0)
 ;
"RTN","ZTLOAD1",7,0)
GET ;get task data
"RTN","ZTLOAD1",8,0)
 N %X,%Y,X,Y,X1,ZT,ZTC1,ZTC2,ZTA1,ZTA4,ZTA5,ZTINC,ZTGOT,ZTC34P
"RTN","ZTLOAD1",9,0)
 K %ZTLOAD
"RTN","ZTLOAD1",10,0)
 I ("^"[$G(ZTRTN))!($L($G(ZTRTN),"^")>2) D REJECT^%ZTLOAD2("Bad Routine") G EXIT
"RTN","ZTLOAD1",11,0)
 S U="^" I ZTRTN'[U S ZTRTN=U_ZTRTN
"RTN","ZTLOAD1",12,0)
 S ZTC1=+$G(DUZ),ZTC2=""
"RTN","ZTLOAD1",13,0)
 I ZTC1>0 S ZTC2=$P($G(^VA(200,ZTC1,0)),U)
"RTN","ZTLOAD1",14,0)
 ;Check Date/Time
"RTN","ZTLOAD1",15,0)
1 I $D(ZTDTH)[0 S ZTDTH=""
"RTN","ZTLOAD1",16,0)
 I ZTDTH?7N.".".N S ZTDTH=$$FMTH^%ZTLOAD7(ZTDTH)
"RTN","ZTLOAD1",17,0)
 I $P($G(XQY0),U,18) D RESTRCT^%ZTLOAD2
"RTN","ZTLOAD1",18,0)
 I ZTDTH'="@",ZTDTH'?1.5N1","1.5N D ASK^%ZTLOAD2 I ZTDTH'>0 D REJECT^%ZTLOAD2("Bad Date/Time") G EXIT
"RTN","ZTLOAD1",19,0)
 ;
"RTN","ZTLOAD1",20,0)
 S ZTA1="R",ZTA4="",ZTA5=""
"RTN","ZTLOAD1",21,0)
 I ZTRTN="ZTSK^XQ1" D OPTION^%ZTLOAD2 I ZTA1="" D REJECT^%ZTLOAD2("Bad Option") G EXIT
"RTN","ZTLOAD1",22,0)
 I ZTA1="R" D
"RTN","ZTLOAD1",23,0)
 . S ZTSAVE("XQY")="",ZTSAVE("XQY0")="",ZTA4=$G(XQY),ZTA5=$P($G(XQY0),U)
"RTN","ZTLOAD1",24,0)
 ;
"RTN","ZTLOAD1",25,0)
 D GETENV^%ZOSV S ZTC34P=Y
"RTN","ZTLOAD1",26,0)
 ;Description
"RTN","ZTLOAD1",27,0)
2 I $D(ZTDESC)[0 S ZTDESC="No Description (%ZTLOAD)"
"RTN","ZTLOAD1",28,0)
 ;
"RTN","ZTLOAD1",29,0)
 I $G(ZTKIL)]"" D ZTKIL^%ZTLOAD2
"RTN","ZTLOAD1",30,0)
 S:$G(ZTUCI)["," ZTUCI=$P(ZTUCI,",") S:$G(ZTCPU)["," ZTCPU=$P(ZTCPU,",",2)
"RTN","ZTLOAD1",31,0)
DEVICE ;get device data
"RTN","ZTLOAD1",32,0)
 I $D(ZTIO)#2,$G(ION)=$P(ZTIO,";"),$G(IOT)="SPL" D SPOOL^%ZTLOAD2
"RTN","ZTLOAD1",33,0)
 ;If no ZTIO, build from symbol table
"RTN","ZTLOAD1",34,0)
 I $D(ZTIO)[0 S ZTIO=$G(ION) I $L(ZTIO) D
"RTN","ZTLOAD1",35,0)
 . S:$G(IOST)]"" $P(ZTIO,";",2)=IOST
"RTN","ZTLOAD1",36,0)
 . I $G(IO("DOC"))]"" S ZTIO=ZTIO_";"_IO("DOC")
"RTN","ZTLOAD1",37,0)
 . E  I $G(IOM)]"" S ZTIO=ZTIO_";"_IOM I $G(IOSL)]"" S ZTIO=ZTIO_";"_IOSL
"RTN","ZTLOAD1",38,0)
 . Q
"RTN","ZTLOAD1",39,0)
 ;
"RTN","ZTLOAD1",40,0)
 I $E(ZTIO,1)="`" S $P(ZTIO,";")=$P(^%ZIS(1,+$E(ZTIO,2,99),0),"^") ;Convert `IEN format
"RTN","ZTLOAD1",41,0)
 S ZTIO(1)=$S($G(ZTIO(1))'="D":"Q",1:"DIRECT")
"RTN","ZTLOAD1",42,0)
 I $L(ZTIO) D  ;Skip if no device
"RTN","ZTLOAD1",43,0)
 . ;IO("HFSIO") and IOPAR are how %ZIS reports the user selected file name and parameters
"RTN","ZTLOAD1",44,0)
 . S:'$D(ZTIO("H")) ZTIO("H")=$G(IO("HFSIO"))
"RTN","ZTLOAD1",45,0)
 . S:'$D(ZTIO("P")) ZTIO("P")=$G(IOPAR)
"RTN","ZTLOAD1",46,0)
 . I $G(IO("P"))]"",ZTIO'[";/" S ZTIO=ZTIO_";/"_IO("P")
"RTN","ZTLOAD1",47,0)
 . I $$NOQ^%ZISUTL($P(ZTIO,";")) D BADDEV^%ZTLOAD2("Restricted Device")
"RTN","ZTLOAD1",48,0)
 . I $E(ZTIO,1,9)="P-MESSAGE" S ZTSAVE("^TMP(""XM-MESS"",$J,")=""
"RTN","ZTLOAD1",49,0)
 . Q
"RTN","ZTLOAD1",50,0)
 ;
"RTN","ZTLOAD1",51,0)
 I $D(%ZTLOAD("ERROR")) G EXIT
"RTN","ZTLOAD1",52,0)
 ;
"RTN","ZTLOAD1",53,0)
 ;See that ^%ZTSK(-1) is set
"RTN","ZTLOAD1",54,0)
 I $D(^%ZTSK(-1))[0 S ^%ZTSK(-1)=$S($P($G(^%ZTSK(0)),U,3):$P(^(0),U,3),1:1000)
"RTN","ZTLOAD1",55,0)
RECORD ;build record
"RTN","ZTLOAD1",56,0)
 S ZTINC=$G(^%ZOSF("$INC"),1) ;Set to 1 if this system has $INCREMENT, otherwise 0.
"RTN","ZTLOAD1",57,0)
 S ZTGOT=0
"RTN","ZTLOAD1",58,0)
 I 'ZTINC D  ;For System that don't have $INC (GT.M, DTM, MSM)
"RTN","ZTLOAD1",59,0)
 . ;Find a free entry, Claim it and Lock it.
"RTN","ZTLOAD1",60,0)
 . L +^%ZTSK(-1):0 S ZTSK=^%ZTSK(-1) ;This is just a starting point
"RTN","ZTLOAD1",61,0)
 . F  S ZTSK=ZTSK+1 I '$D(^%ZTSK(ZTSK)) D  Q:ZTGOT
"RTN","ZTLOAD1",62,0)
 . . L +^%ZTSK(ZTSK):$G(DILOCKTM,3) Q:'$T  ;Can we lock it
"RTN","ZTLOAD1",63,0)
 . . I $D(^%ZTSK(ZTSK)) L -^%ZTSK(ZTSK) ;Already claimed
"RTN","ZTLOAD1",64,0)
 . . S ^%ZTSK(ZTSK,.1)=0,^%ZTSK(-1)=ZTSK,ZTGOT=1 ;Claim it
"RTN","ZTLOAD1",65,0)
 . . Q
"RTN","ZTLOAD1",66,0)
 . L -^%ZTSK(-1) ;
"RTN","ZTLOAD1",67,0)
 . Q
"RTN","ZTLOAD1",68,0)
 I ZTINC D  ;For DSM and OpenM. Faster over network(DDP)
"RTN","ZTLOAD1",69,0)
 . S ZTSK=$INCREMENT(^%ZTSK(-1))
"RTN","ZTLOAD1",70,0)
 . L +^%ZTSK(ZTSK):$G(DILOCKTM,3) S ZTGOT=$T ;p446
"RTN","ZTLOAD1",71,0)
 I 'ZTGOT!($D(^%ZTSK(ZTSK,0))) L -^%ZTSK(ZTSK) G RECORD
"RTN","ZTLOAD1",72,0)
 S ^%ZTSK(ZTSK,0)=ZTRTN_U_ZTC1_U_$G(ZTUCI)_U_$H_U_ZTDTH_U_ZTA1_U_ZTA4_U_ZTA5_U_ZTC2_U_$P(ZTC34P,U,1,2)_U_"ZTDESC"_U_$G(ZTCPU)_U_$G(ZTPRI)
"RTN","ZTLOAD1",73,0)
 S ^%ZTSK(ZTSK,.1)=0,^%ZTSK(ZTSK,.03)=ZTDESC
"RTN","ZTLOAD1",74,0)
 S ^%ZTSK(ZTSK,.2)=ZTIO_"^^^^"_ZTIO(1)_U_$G(ZTIO("H")) S:$D(ZTSYNC) $P(^%ZTSK(ZTSK,.2),U,7)=ZTSYNC
"RTN","ZTLOAD1",75,0)
 I $G(ZTIO("P"))]"" S ^%ZTSK(ZTSK,.25)=ZTIO("P")
"RTN","ZTLOAD1",76,0)
 ;
"RTN","ZTLOAD1",77,0)
 D ZTSAVE
"RTN","ZTLOAD1",78,0)
 ;
"RTN","ZTLOAD1",79,0)
SCHED ;schedule task and quit
"RTN","ZTLOAD1",80,0)
 S ZTSTAT=$S(ZTDTH'="@":1,1:"K")_"^"_$H,$P(ZTSTAT,U,8)=$G(ZTKIL)
"RTN","ZTLOAD1",81,0)
 S ^%ZTSK(ZTSK,.1)=ZTSTAT
"RTN","ZTLOAD1",82,0)
 I ZTDTH'="@" L +^%ZTSCH("SCHQ"):$G(DILOCKTM,3) S ZT=$$H3(ZTDTH),^%ZTSK(ZTSK,.04)=ZT,^%ZTSCH(ZT,ZTSK)="" L -^%ZTSCH("SCHQ")
"RTN","ZTLOAD1",83,0)
 L -^%ZTSK(ZTSK) S ZTSK("D")=ZTDTH
"RTN","ZTLOAD1",84,0)
EXIT ;Clean up
"RTN","ZTLOAD1",85,0)
 I $E($G(ZTIO),1,9)="P-MESSAGE" K ^TMP("XM-MESS",$J) ;Clean up the Global
"RTN","ZTLOAD1",86,0)
 K X1,ZT,ZT1,ZTDTH,ZTKIL,ZTSAVE,ZTSTAT,ZTIO
"RTN","ZTLOAD1",87,0)
 Q
"RTN","ZTLOAD1",88,0)
 ;
"RTN","ZTLOAD1",89,0)
ZTSAVE ;save variables
"RTN","ZTLOAD1",90,0)
 N ZTIO
"RTN","ZTLOAD1",91,0)
 K %H,%T,ZTA1,ZTA4,ZTA5,ZTC1,ZTC2,ZTC34P,ZTCPU,ZTDESC,ZTIO,ZTNOGO,ZTPRI,ZTRTN,ZTUCI,ZTSYNC
"RTN","ZTLOAD1",92,0)
 S ZTSAVE("DUZ(")=""
"RTN","ZTLOAD1",93,0)
 S ZT1="" F  S ZT1=$O(ZTSAVE(ZT1)) Q:ZT1=""  D EVAL
"RTN","ZTLOAD1",94,0)
 K ^%ZTSK(ZTSK,.3,"DUZ(","NEWCODE")
"RTN","ZTLOAD1",95,0)
 K ^%ZTSK(ZTSK,.3,"ZTSK"),^("ZTSAVE"),^("ZTDTH")
"RTN","ZTLOAD1",96,0)
 K ^%ZTSK(ZTSK,.3,"XQNOGO")
"RTN","ZTLOAD1",97,0)
 Q
"RTN","ZTLOAD1",98,0)
 ;
"RTN","ZTLOAD1",99,0)
EVAL ;ZTSAVE--evaluate expression
"RTN","ZTLOAD1",100,0)
 I ZT1="*" S X="^%ZTSK(ZTSK,.3," D DOLRO^%ZOSV Q
"RTN","ZTLOAD1",101,0)
 I ZT1["*",$P(ZT1,"*")'["(" S X="^%ZTSK(ZTSK,.3,",Y=ZT1 D ORDER^%ZOSV Q
"RTN","ZTLOAD1",102,0)
 I $S($E(ZT1)="""":1,+ZT1'=ZT1:0,1:ZT1]0),$D(ZTSAVE(ZT1))#2 S @("^%ZTSK(ZTSK,"_ZT1_")=ZTSAVE(ZT1)") Q
"RTN","ZTLOAD1",103,0)
 I $S(ZT1'["(":1,1:$E(ZT1,$L(ZT1))=")"),$S($D(@ZT1)#2:1,1:ZTSAVE(ZT1)]"") S ^%ZTSK(ZTSK,.3,ZT1)=$S(ZTSAVE(ZT1)]"":ZTSAVE(ZT1),1:@ZT1) Q
"RTN","ZTLOAD1",104,0)
 I $E(ZT1)="^",ZT1["(" S %X=ZT1,%Y="^%ZTSK(ZTSK,.3,ZT1," D %XY^%RCR Q
"RTN","ZTLOAD1",105,0)
 I ZT1["(" S %X=ZT1,%Y="^%ZTSK(ZTSK,.3,ZT1," D %XY^%RCR
"RTN","ZTLOAD1",106,0)
 ;I ZT1["(" M ^%ZTSK(ZTSK,.3,ZT1)=@$P(ZT1,"(")
"RTN","ZTLOAD1",107,0)
 Q
"RTN","ZTLOAD1",108,0)
 ;
"RTN","ZTLOAD1",109,0)
H3(%) ;Convert $H to seconds.
"RTN","ZTLOAD1",110,0)
 Q 86400*%+$P(%,",",2)
"RTN","ZTLOAD1",111,0)
H0(%) ;Covert from seconds to $H
"RTN","ZTLOAD1",112,0)
 Q (%\86400)_","_(%#86400)
"RTN","ZTM6")
0^13^B9150597
"RTN","ZTM6",1,0)
%ZTM6 ;SEA/RDS-TaskMan: Manager, Part 8 (Load Balancing) ;2017-01-09  3:46 PM
"RTN","ZTM6",2,0)
 ;;8.0;KERNEL;**23,118,127,136,355,446,10001**;JUL 10, 1995;Build 21
"RTN","ZTM6",3,0)
 ; Submitted to OSEHRA in 2017 by Sam Habiel for OSEHRA
"RTN","ZTM6",4,0)
 ; Original Routine authored by Department of Veterans Affairs
"RTN","ZTM6",5,0)
 ; Transactions removed by Christopher Edwards 2014.
"RTN","ZTM6",6,0)
 ;
"RTN","ZTM6",7,0)
BALANCE ;CHECK^%ZTM--determine whether cpu should wait for balance
"RTN","ZTM6",8,0)
 ;Return ZTOVERLD =1 if need to wait, 0 to run
"RTN","ZTM6",9,0)
 ;The TM with the largest value sets ^%ZTSCH("LOAD")=who^value^when p446
"RTN","ZTM6",10,0)
 ;If your value is greater or equal then you run.
"RTN","ZTM6",11,0)
 ;If your value is less you wait unless you set LOAD then you run.
"RTN","ZTM6",12,0)
 ;Tell sub-managers by setting ^%ZTSCH("LOADA",%ZTPAIR)=run^value^time^$J
"RTN","ZTM6",13,0)
 ;Use %ZTLKTM for lock timeout
"RTN","ZTM6",14,0)
 S ZTOVERLD=0 ;p446 Default
"RTN","ZTM6",15,0)
 L +^%ZTSCH("LOAD"):(%ZTLKTM+1) E  Q  ;p446 Keep working if can't get lock
"RTN","ZTM6",16,0)
 N X,ZTIME,ZTLEFT,ZTPREV
"RTN","ZTM6",17,0)
 N $ES,$ET S $ET="Q:$ES>0  D ERR^%ZTM6"
"RTN","ZTM6",18,0)
 S ZTOVERLD=0,ZTPREV=+$P($G(^%ZTSCH("LOAD")),"^",2),ZTIME=$$H3($H)
"RTN","ZTM6",19,0)
 S @("ZTLEFT="_%ZTPFLG("BAL"))
"RTN","ZTM6",20,0)
 S ZTIME=$$H3($H),ZTOVERLD=$$COMPARE(%ZTPAIR,ZTLEFT,ZTPREV)
"RTN","ZTM6",21,0)
 ;If we are RUNNING have other submanagers wait
"RTN","ZTM6",22,0)
 I 'ZTOVERLD D
"RTN","ZTM6",23,0)
 . S X="" F  S X=$O(^%ZTSCH("LOADA",X)) Q:X=""  S $P(^(X),"^")=1 ;Have others wait
"RTN","ZTM6",24,0)
 . S ^%ZTSCH("LOAD")=%ZTPAIR_"^"_ZTLEFT_"^"_ZTIME
"RTN","ZTM6",25,0)
 ;Now set a value that is used by our %ZTMS to run/wait also
"RTN","ZTM6",26,0)
 S ^%ZTSCH("LOADA",%ZTPAIR)=ZTOVERLD_"^"_ZTLEFT_"^"_ZTIME_"^"_$J
"RTN","ZTM6",27,0)
 L -^%ZTSCH("LOAD")
"RTN","ZTM6",28,0)
 Q
"RTN","ZTM6",29,0)
 ;
"RTN","ZTM6",30,0)
STOPWT() ;See if we should stop Balance wait, Called from %ZTM.
"RTN","ZTM6",31,0)
 L +^%ZTSCH("LOAD"):%ZTLKTM Q:'$T 1 ;Run if can't get lock
"RTN","ZTM6",32,0)
 N I,J S I="",J=1
"RTN","ZTM6",33,0)
 F  S I=$O(^%ZTSCH("LOADA",I)) Q:I=""  I '^(I) S J=0
"RTN","ZTM6",34,0)
 L -^%ZTSCH("LOAD")
"RTN","ZTM6",35,0)
 Q J ;Return: 1 stop waiting, 0 keep waiting. (Someone is in run state)
"RTN","ZTM6",36,0)
 ;
"RTN","ZTM6",37,0)
CHECK ;Called when job limit reached.
"RTN","ZTM6",38,0)
 ;If not doing balancing, remove node and quit
"RTN","ZTM6",39,0)
 N I,J,K
"RTN","ZTM6",40,0)
 I %ZTPFLG("BAL")="" K ^%ZTSCH("LOADA",%ZTPAIR) Q
"RTN","ZTM6",41,0)
 L +^%ZTSCH("LOAD"):%ZTLKTM Q:'$T  ;Get it next time
"RTN","ZTM6",42,0)
 ;If at job limit see if sub-managers should run
"RTN","ZTM6",43,0)
 S I=$P($G(^%ZTSCH("LOAD")),"^",2),J=$P($G(^%ZTSCH("LOADA",%ZTPAIR)),"^",2)
"RTN","ZTM6",44,0)
 S K=(J<I),$P(^%ZTSCH("LOADA",%ZTPAIR),"^",1)=K
"RTN","ZTM6",45,0)
 L -^%ZTSCH("LOAD")
"RTN","ZTM6",46,0)
 Q
"RTN","ZTM6",47,0)
 ;
"RTN","ZTM6",48,0)
COMPARE(ID,ZTLEFT,ZTPREV) ;
"RTN","ZTM6",49,0)
 ;BALANCE--compare our cpu capacity left to that of previous checker
"RTN","ZTM6",50,0)
 ;input:  cpu name, cpu capacity left, cpu capacity of previous checker
"RTN","ZTM6",51,0)
 ;output: whether current cpu should wait, 0=run, 1=wait
"RTN","ZTM6",52,0)
 N X
"RTN","ZTM6",53,0)
 I ZTLEFT'<ZTPREV Q 0
"RTN","ZTM6",54,0)
 S X=^%ZTSCH("LOAD")
"RTN","ZTM6",55,0)
 I $P(X,"^",3)+(%ZTPFLG("BI")+5)<ZTIME Q 0
"RTN","ZTM6",56,0)
 Q $P(X,"^")'[ID
"RTN","ZTM6",57,0)
 ;
"RTN","ZTM6",58,0)
ERR ;Clean up if error
"RTN","ZTM6",59,0)
 S %ZTPFLG("EBAL")=1+$G(%ZTPFLG("EBAL")),ZTOVERLD=0
"RTN","ZTM6",60,0)
 I $G(%ZTPFLG("EBAL"))>10 D ^%ZTER S %ZTPFLG("BAL")="" ;Only stop after 10 errors ;p446
"RTN","ZTM6",61,0)
 S $EC=""
"RTN","ZTM6",62,0)
 ;TROLLBACK
"RTN","ZTM6",63,0)
 L -^%ZTSCH("LOAD")
"RTN","ZTM6",64,0)
 Q
"RTN","ZTM6",65,0)
 ;
"RTN","ZTM6",66,0)
H3(%) ;Convert $H to seconds
"RTN","ZTM6",67,0)
 Q 86400*%+$P(%,",",2)
"RTN","ZTM6",68,0)
 ;
"RTN","ZTM6",69,0)
VXD(BIAS) ;--algorithm for VAX DSM
"RTN","ZTM6",70,0)
 ;Capacity Left=Available Jobs + BIAS
"RTN","ZTM6",71,0)
 Q $$AVJ^%ZOSV()+$G(BIAS)
"RTN","ZTM6",72,0)
 ;
"RTN","ZTM6",73,0)
MSM4() ;Use MSMv4 LAT calcuation
"RTN","ZTM6",74,0)
 N MAXJOB,CURJOB
"RTN","ZTM6",75,0)
 X "S MAXJOB=$V($V(3,-5),-3,0),CURJOB=$V(168,-4,2)"
"RTN","ZTM6",76,0)
 Q MAXJOB-CURJOB*255\MAXJOB
"RTN","ZTM6",77,0)
 ;
"RTN","ZTM6",78,0)
CACHE1(BIAS) ;Use available jobs
"RTN","ZTM6",79,0)
 N CUR,MAX
"RTN","ZTM6",80,0)
 Q $$AVJ^%ZOSV()+$G(BIAS)
"RTN","ZTM6",81,0)
 ;
"RTN","ZTM6",82,0)
CACHE2(%COM,%LOG) ;Cache, Pull metric data
"RTN","ZTM6",83,0)
 N TMP,$ET
"RTN","ZTM6",84,0)
 S $ETRAP="S $ECODE="""" Q ZTPREV"
"RTN","ZTM6",85,0)
 S %LOG=$G(%LOG,"VISTA$METRIC")
"RTN","ZTM6",86,0)
 I $L($G(%COM)) S TMP=$ZF(-1,%COM)
"RTN","ZTM6",87,0)
 Q $ZF("TRNLNM",%LOG)
"RTN","ZTM6",88,0)
 ;
"RTN","ZTM6",89,0)
RNDRBN() ;Round Robin
"RTN","ZTM6",90,0)
 ;value^node^time
"RTN","ZTM6",91,0)
 N R,R2
"RTN","ZTM6",92,0)
 L +^%ZTSCH("RNDRBN"):$G(%ZTLKTM,1)
"RTN","ZTM6",93,0)
 S R=$G(^%ZTSCH("RNDRBN"))
"RTN","ZTM6",94,0)
 I $P(R,U,2)=%ZTPAIR S R2=+R G RX
"RTN","ZTM6",95,0)
 I ZTIME<$P(R,U,3) S R2=R-1 G RX
"RTN","ZTM6",96,0)
 S R2=R+2#512,^%ZTSCH("RNDRBN")=R2_U_%ZTPAIR_U_(ZTIME+%ZTPFLG("BI"))
"RTN","ZTM6",97,0)
RX L -^%ZTSCH("RNDRBN")
"RTN","ZTM6",98,0)
 Q R2
"RTN","ZTMGRSET")
0^10^B56546290
"RTN","ZTMGRSET",1,0)
ZTMGRSET ;SF/RWF,PUG/TOAD - SET UP THE MGR ACCOUNT FOR THE SYSTEM ;2017-01-09  3:49 PM
"RTN","ZTMGRSET",2,0)
 ;;8.0;KERNEL;**34,36,69,94,121,127,136,191,275,355,446,584,10001**;JUL 10, 1995;Build 21
"RTN","ZTMGRSET",3,0)
 ; Submitted to OSEHRA in 2017 by Sam Habiel for OSEHRA
"RTN","ZTMGRSET",4,0)
 ; Original Routine authored by Department of Veterans Affairs
"RTN","ZTMGRSET",5,0)
 ; Sam Habiel made tiny changes throughout routine (Max Patch > 999 now, ZISHGUX
"RTN","ZTMGRSET",6,0)
 ; instead of ZISHGTM for GT.M on Unix) 2016.
"RTN","ZTMGRSET",7,0)
 ; KS Bhaksar rewrote COPY and R 2014. Sam contributed bug fixes to these.
"RTN","ZTMGRSET",8,0)
 ;
"RTN","ZTMGRSET",9,0)
 N %D,%S,I,OSMAX,U,X,X1,X2,Y,Z1,Z2,ZTOS,ZTMODE,SCR
"RTN","ZTMGRSET",10,0)
 S ZTMODE=0
"RTN","ZTMGRSET",11,0)
A W !!,"ZTMGRSET Version ",$P($T(+2),";",3)," Patch level ",$P($T(+2),";",5)
"RTN","ZTMGRSET",12,0)
 W !,"HELLO! I exist to assist you in correctly initializing the current account."
"RTN","ZTMGRSET",13,0)
 I $D(^%ZOSF("UCI")) X ^%ZOSF("UCI") D  G A:"YNyn"'[$E(X) Q:"Nn"[$E(X)
"RTN","ZTMGRSET",14,0)
 . I ZTMODE=2 S X="Y" Q
"RTN","ZTMGRSET",15,0)
 . W $C(7),!!,"This is namespace or uci ",Y,".",!
"RTN","ZTMGRSET",16,0)
 . R "Should I continue? N//",X:120
"RTN","ZTMGRSET",17,0)
 . Q
"RTN","ZTMGRSET",18,0)
 S ZTOS=$$OS() I ZTOS'>0 W !,"OS type not selected. Exiting ZTMGRSET." Q
"RTN","ZTMGRSET",19,0)
 I ZTMODE D  I (PCNM<1)!(PCNM>9999999) W !,"Need a Patch number to load." Q
"RTN","ZTMGRSET",20,0)
 . I ZTMODE<2 R !!,"Patch number to load: ",PCNM:120 Q:(PCNM<1)!(PCNM>9999999)
"RTN","ZTMGRSET",21,0)
 . S SCR="I $P($T(+2^@X),"";"",5)?.E1P1"_$C(34)_PCNM_$C(34)_"1P.E"
"RTN","ZTMGRSET",22,0)
 ;
"RTN","ZTMGRSET",23,0)
 K ^%ZOSF("MASTER"),^("SIGNOFF") ;Remove old nodes.
"RTN","ZTMGRSET",24,0)
 ;
"RTN","ZTMGRSET",25,0)
DOIT D MES("I will now rename a group of routines specific to your operating system.",1)
"RTN","ZTMGRSET",26,0)
 D @ZTOS,ALL,GLOBALS:'ZTMODE D MES("ALL DONE",1)
"RTN","ZTMGRSET",27,0)
 Q
"RTN","ZTMGRSET",28,0)
 ;========================================
"RTN","ZTMGRSET",29,0)
RELOAD ;Reload any patched routines
"RTN","ZTMGRSET",30,0)
 N %D,%S,I,OSMAX,U,X,X1,X2,Y,Z1,Z2,ZTOS,ZTMODE,SCR
"RTN","ZTMGRSET",31,0)
 S ZTMODE=1 G A
"RTN","ZTMGRSET",32,0)
 Q
"RTN","ZTMGRSET",33,0)
 ;
"RTN","ZTMGRSET",34,0)
PATCH(PCNM) ;Post install Reload any patched routines
"RTN","ZTMGRSET",35,0)
 N %D,%S,I,OSMAX,U,X,X1,X2,Y,Z1,Z2,ZTOS,ZTMODE,SCR
"RTN","ZTMGRSET",36,0)
 I (1>PCNM)!(PCNM>9999999) D MES("PATCH NUMBER OUT OF RANGE",1) Q
"RTN","ZTMGRSET",37,0)
 D MES("Rename the routines in Patch "_PCNM,1)
"RTN","ZTMGRSET",38,0)
 S ZTMODE=2 G A
"RTN","ZTMGRSET",39,0)
 Q
"RTN","ZTMGRSET",40,0)
 ;
"RTN","ZTMGRSET",41,0)
MES(T,B) ;Write message.
"RTN","ZTMGRSET",42,0)
 S B=$G(B)
"RTN","ZTMGRSET",43,0)
 I $L($T(BMES^XPDUTL)) D BMES^XPDUTL(T):B,MES^XPDUTL(T):'B Q
"RTN","ZTMGRSET",44,0)
 W:B ! W !,T
"RTN","ZTMGRSET",45,0)
 Q
"RTN","ZTMGRSET",46,0)
 ;
"RTN","ZTMGRSET",47,0)
OS() ;Select the OS
"RTN","ZTMGRSET",48,0)
 N Y,X1,X,OSMAX
"RTN","ZTMGRSET",49,0)
 S U="^",SCR="I 1" F I=1:1:20 S X=$T(@I) Q:X=""  S OSMAX=I
"RTN","ZTMGRSET",50,0)
B S Y=0,ZTOS=0 I $D(^%ZOSF("OS")) D
"RTN","ZTMGRSET",51,0)
 . S X1=$P(^%ZOSF("OS"),U),ZTOS=$$OSNUM W !,"I think you are using ",X1
"RTN","ZTMGRSET",52,0)
 I ZTMODE=2,ZTOS>0 Q ZTOS
"RTN","ZTMGRSET",53,0)
 W !,"Which MUMPS system should I install?",!
"RTN","ZTMGRSET",54,0)
 F I=1:1:OSMAX W !,I," = ",$P($T(@I),";",3)
"RTN","ZTMGRSET",55,0)
 W !,"System: " W:ZTOS ZTOS,"//"
"RTN","ZTMGRSET",56,0)
 R X:300 S:X="" X=ZTOS
"RTN","ZTMGRSET",57,0)
 I $S(X<1!(X>OSMAX):1,1:$P($T(@X),";",3)="") W !,"NOT A VALID CHOICE" Q:X[U 0 G B
"RTN","ZTMGRSET",58,0)
 Q X
"RTN","ZTMGRSET",59,0)
 ;
"RTN","ZTMGRSET",60,0)
OSNUM() ;Return the OS number
"RTN","ZTMGRSET",61,0)
 N I,X1,X2,Y S Y=0,X1=$P($G(^%ZOSF("OS")),"^")
"RTN","ZTMGRSET",62,0)
 F I=1:1 S X2=$T(@I) Q:X2=""  I X2[X1 S Y=I Q
"RTN","ZTMGRSET",63,0)
 Q Y
"RTN","ZTMGRSET",64,0)
 ;
"RTN","ZTMGRSET",65,0)
ALL W !!,"Now to load routines common to all systems."
"RTN","ZTMGRSET",66,0)
 D TM,ETRAP,DEV,OTHER,FM
"RTN","ZTMGRSET",67,0)
 I ZTOS=7!(ZTOS=8) D
"RTN","ZTMGRSET",68,0)
 . S ^%ZE="D ^ZE"
"RTN","ZTMGRSET",69,0)
 E  D  ;With ZLoad, ZSave, ZInsert
"RTN","ZTMGRSET",70,0)
 . W !,"Installing ^%Z editor"
"RTN","ZTMGRSET",71,0)
 . D ^ZTEDIT
"RTN","ZTMGRSET",72,0)
 I 'ZTMODE W !,"Setting ^%ZIS('C')" K ^%ZIS("C") S ^%ZIS("C")="G ^%ZISC"
"RTN","ZTMGRSET",73,0)
 Q
"RTN","ZTMGRSET",74,0)
 ;
"RTN","ZTMGRSET",75,0)
TM ;Taskman
"RTN","ZTMGRSET",76,0)
 S %S="ZTLOAD^ZTLOAD1^ZTLOAD2^ZTLOAD3^ZTLOAD4^ZTLOAD5^ZTLOAD6^ZTLOAD7"
"RTN","ZTMGRSET",77,0)
 S %D="%ZTLOAD^%ZTLOAD1^%ZTLOAD2^%ZTLOAD3^%ZTLOAD4^%ZTLOAD5^%ZTLOAD6^%ZTLOAD7"
"RTN","ZTMGRSET",78,0)
 D MOVE
"RTN","ZTMGRSET",79,0)
 S %S="ZTM^ZTM0^ZTM1^ZTM2^ZTM3^ZTM4^ZTM5^ZTM6"
"RTN","ZTMGRSET",80,0)
 S %D="%ZTM^%ZTM0^%ZTM1^%ZTM2^%ZTM3^%ZTM4^%ZTM5^%ZTM6"
"RTN","ZTMGRSET",81,0)
 D MOVE
"RTN","ZTMGRSET",82,0)
 S %S="ZTMS^ZTMS0^ZTMS1^ZTMS2^ZTMS3^ZTMS4^ZTMS5^ZTMS7^ZTMSH"
"RTN","ZTMGRSET",83,0)
 S %D="%ZTMS^%ZTMS0^%ZTMS1^%ZTMS2^%ZTMS3^%ZTMS4^%ZTMS5^%ZTMS7^%ZTMSH"
"RTN","ZTMGRSET",84,0)
 D MOVE
"RTN","ZTMGRSET",85,0)
 Q
"RTN","ZTMGRSET",86,0)
FM ;Rename the FileMan routines
"RTN","ZTMGRSET",87,0)
 I ZTMODE>0 Q  ;Only ask on full install
"RTN","ZTMGRSET",88,0)
 R !,"Want to rename the FileMan routines: No//",X:600 Q:"Yy"'[$E(X_"N")
"RTN","ZTMGRSET",89,0)
 S %S="DIDT^DIDTC^DIRCR",%D="%DT^%DTC^%RCR"
"RTN","ZTMGRSET",90,0)
 D MOVE
"RTN","ZTMGRSET",91,0)
 Q
"RTN","ZTMGRSET",92,0)
 ;
"RTN","ZTMGRSET",93,0)
ETRAP ;Error Trap
"RTN","ZTMGRSET",94,0)
 S %S="ZTER^ZTER1",%D="%ZTER^%ZTER1"
"RTN","ZTMGRSET",95,0)
 D MOVE
"RTN","ZTMGRSET",96,0)
 Q
"RTN","ZTMGRSET",97,0)
OTHER S %S="ZTPP^ZTP1^ZTPTCH^ZTRDEL^ZTMOVE^ZTBKC"
"RTN","ZTMGRSET",98,0)
 S %D="%ZTPP^%ZTP1^%ZTPTCH^%ZTRDEL^%ZTMOVE^%ZTBKC"
"RTN","ZTMGRSET",99,0)
 D MOVE
"RTN","ZTMGRSET",100,0)
 Q
"RTN","ZTMGRSET",101,0)
DEV S %S="ZIS^ZIS1^ZIS2^ZIS3^ZIS5^ZIS6^ZIS7^ZISC^ZISP^ZISS^ZISS1^ZISS2^ZISTCP^ZISUTL"
"RTN","ZTMGRSET",102,0)
 S %D="%ZIS^%ZIS1^%ZIS2^%ZIS3^%ZIS5^%ZIS6^%ZIS7^%ZISC^%ZISP^%ZISS^%ZISS1^%ZISS2^%ZISTCP^%ZISUTL"
"RTN","ZTMGRSET",103,0)
 D MOVE
"RTN","ZTMGRSET",104,0)
 Q
"RTN","ZTMGRSET",105,0)
RUM ;Build the routines for Capacity Management (CM)
"RTN","ZTMGRSET",106,0)
 S %S=""
"RTN","ZTMGRSET",107,0)
 I ZTOS=1 S %S="ZOSVKRV^ZOSVKSVE^ZOSVKSVS^ZOSVKSD" ;DSM
"RTN","ZTMGRSET",108,0)
 I ZTOS=2 S %S="ZOSVKRM^ZOSVKSME^ZOSVKSMS^ZOSVKSD" ;MSM
"RTN","ZTMGRSET",109,0)
 I ZTOS=3 S %S="ZOSVKRO^ZOSVKSOE^ZOSVKSOS^ZOSVKSD" ;OpenM
"RTN","ZTMGRSET",110,0)
 I ZTOS=7!(ZTOS=8) S %S="ZOSVKRG^ZOSVKSGE^ZOSVKSGS^ZOSVKSD" ;GT.M
"RTN","ZTMGRSET",111,0)
 S %D="%ZOSVKR^%ZOSVKSE^%ZOSVKSS^%ZOSVKSD"
"RTN","ZTMGRSET",112,0)
 D MOVE
"RTN","ZTMGRSET",113,0)
 Q
"RTN","ZTMGRSET",114,0)
ZOSF(X) ;
"RTN","ZTMGRSET",115,0)
 X SCR I $T W ! D @(U_X) W !
"RTN","ZTMGRSET",116,0)
 Q
"RTN","ZTMGRSET",117,0)
1 ;;VAX DSM(V6), VAX DSM(V7)
"RTN","ZTMGRSET",118,0)
 S %S="ZOSVVXD^ZTBKCVXD^ZIS4VXD^ZISFVXD^ZISHVXD^XUCIVXD"
"RTN","ZTMGRSET",119,0)
 D DES,MOVE
"RTN","ZTMGRSET",120,0)
 S %S="ZOSV2VXD^ZTMDCL",%D="%ZOSV2^%ZTMDCL"
"RTN","ZTMGRSET",121,0)
 D MOVE,RUM,ZOSF("ZOSFVXD")
"RTN","ZTMGRSET",122,0)
 Q
"RTN","ZTMGRSET",123,0)
2 ;;MSM-PC/PLUS, MSM for NT or UNIX
"RTN","ZTMGRSET",124,0)
 W !,"- Use autostart to do ZTMB don't resave as STUSER."
"RTN","ZTMGRSET",125,0)
 S %S="ZOSVMSM^ZTBKCMSM^ZIS4MSM^ZISFMSM^ZISHMSM^XUCIMSM"
"RTN","ZTMGRSET",126,0)
 D DES,MOVE
"RTN","ZTMGRSET",127,0)
 S %S="ZOSV2MSM",%D="%ZOSV2"
"RTN","ZTMGRSET",128,0)
 D MOVE,RUM,ZOSF("ZOSFMSM")
"RTN","ZTMGRSET",129,0)
 I $$VERSION^%ZOSV(1)["UNIX" S %S="ZISHMSU",%D="%ZISH" D MOVE
"RTN","ZTMGRSET",130,0)
 Q
"RTN","ZTMGRSET",131,0)
3 ;;Cache (VMS, NT, Linux), OpenM-NT
"RTN","ZTMGRSET",132,0)
 S %S="ZOSVONT^ZTBKCONT^ZIS4ONT^ZISFONT^ZISHONT^XUCIONT"
"RTN","ZTMGRSET",133,0)
 D DES,MOVE
"RTN","ZTMGRSET",134,0)
 S %S="ZISTCPS^ZTMDCL",%D="%ZISTCPS^%ZTMDCL"
"RTN","ZTMGRSET",135,0)
 D MOVE,RUM,ZOSF("ZOSFONT")
"RTN","ZTMGRSET",136,0)
 Q
"RTN","ZTMGRSET",137,0)
4 ;;
"RTN","ZTMGRSET",138,0)
5 ;;
"RTN","ZTMGRSET",139,0)
6 ;;
"RTN","ZTMGRSET",140,0)
7 ;;GT.M (VMS)
"RTN","ZTMGRSET",141,0)
 S %ZE=".M" D init^%RSEL
"RTN","ZTMGRSET",142,0)
 S %S="ZOSVGTM^^ZIS4GTM^ZISFGTM^ZISHGTM^XUCIGTM"
"RTN","ZTMGRSET",143,0)
 D DES,MOVE
"RTN","ZTMGRSET",144,0)
 S %S="ZOSV2GTM^ZISTCPS^ZTMDCL",%D="%ZOSV2^%ZISTCPS^ZTMDCL"
"RTN","ZTMGRSET",145,0)
 D MOVE,ZOSF("ZOSFGTM")
"RTN","ZTMGRSET",146,0)
 Q
"RTN","ZTMGRSET",147,0)
8 ;;GT.M (Unix)
"RTN","ZTMGRSET",148,0)
 S %ZE=".m" D init^%RSEL
"RTN","ZTMGRSET",149,0)
 S %S="ZOSVGUX^^ZIS4GTM^ZISFGTM^ZISHGUX^XUCIGTM"
"RTN","ZTMGRSET",150,0)
 D DES,MOVE
"RTN","ZTMGRSET",151,0)
 S %S="ZOSV2GTM^ZISTCPS",%D="%ZOSV2^%ZISTCPS"
"RTN","ZTMGRSET",152,0)
 D MOVE,ZOSF("ZOSFGUX")
"RTN","ZTMGRSET",153,0)
 Q
"RTN","ZTMGRSET",154,0)
10 ;;NOT SUPPORTED
"RTN","ZTMGRSET",155,0)
 Q
"RTN","ZTMGRSET",156,0)
MOVE ; rename % routines
"RTN","ZTMGRSET",157,0)
 N %,X,Y,M
"RTN","ZTMGRSET",158,0)
 F %=1:1:$L(%D,"^") D  D MES(M)
"RTN","ZTMGRSET",159,0)
 . S M="",X=$P(%S,U,%) ; from
"RTN","ZTMGRSET",160,0)
 . S Y=$P(%D,U,%) ; to
"RTN","ZTMGRSET",161,0)
 . Q:X=""
"RTN","ZTMGRSET",162,0)
 . S M="Routine: "_$J(X,8)
"RTN","ZTMGRSET",163,0)
 . Q:Y=""  I $T(^@X)=""  S M=M_"  Missing" Q
"RTN","ZTMGRSET",164,0)
 . X SCR Q:'$T
"RTN","ZTMGRSET",165,0)
 . S M=M_" Loaded, "
"RTN","ZTMGRSET",166,0)
 . D COPY(X,Y)
"RTN","ZTMGRSET",167,0)
 . S M=M_"Saved as "_$J(Y,8)
"RTN","ZTMGRSET",168,0)
 Q
"RTN","ZTMGRSET",169,0)
 ;
"RTN","ZTMGRSET",170,0)
COPY(FROM,TO) ;
"RTN","ZTMGRSET",171,0)
 I ZTOS'=7,ZTOS'=8 X "ZL @FROM ZS @TO" Q
"RTN","ZTMGRSET",172,0)
 ;For GT.M below
"RTN","ZTMGRSET",173,0)
 N IO,PATH,COPY,CMD S PATH=$$R,IO=$IO
"RTN","ZTMGRSET",174,0)
 S TO=$TR(TO,"%","_")
"RTN","ZTMGRSET",175,0)
 N FULLTO S FULLTO=PATH_TO_".m"
"RTN","ZTMGRSET",176,0)
 S FROM="^"_FROM
"RTN","ZTMGRSET",177,0)
 O FULLTO:NEWVERSION U FULLTO ZPRINT @FROM U IO C FULLTO
"RTN","ZTMGRSET",178,0)
 N OLDSOURCE S OLDSOURCE=$ZSOURCE ; Don't change my zlink history
"RTN","ZTMGRSET",179,0)
 ZLINK TO:"-nowarning" ; don't print out compile time errors
"RTN","ZTMGRSET",180,0)
 S $ZSOURCE=OLDSOURCE ; ditto-1
"RTN","ZTMGRSET",181,0)
 Q
"RTN","ZTMGRSET",182,0)
 ;
"RTN","ZTMGRSET",183,0)
R() ; routine directory for GT.M
"RTN","ZTMGRSET",184,0)
 ; If $ZRO is a single directory, e.g., xxx, returns that directory, e.g., xxx/
"RTN","ZTMGRSET",185,0)
 ; If $ZRO is of the form xxx yyy ... returns xxx/, unless xxx is a shared library, in which case it is discarded and the search continued.
"RTN","ZTMGRSET",186,0)
 ; If $ZRO is of the form www(xxx) ... or www(xxx yyy) ... returns xxx/
"RTN","ZTMGRSET",187,0)
 N %C,%D,%ZRO
"RTN","ZTMGRSET",188,0)
 S %ZRO=$ZRO
"RTN","ZTMGRSET",189,0)
 F %C=0:1 S %D=$P($S(($F(%ZRO_" "," ")>$F(%ZRO,"("))&$F(%ZRO,"("):$P($P(%ZRO,")"),"(",2),1:%ZRO)," ") Q:'(%D?.E1".so")  S %ZRO=$P(%ZRO,%D_" ",2) S:""=%ZRO $EC=",U255,"
"RTN","ZTMGRSET",190,0)
 Q %D_"/"
"RTN","ZTMGRSET",191,0)
 ;
"RTN","ZTMGRSET",192,0)
DES S %D="%ZOSV^%ZTBKC1^%ZIS4^%ZISF^%ZISH^%XUCI" Q
"RTN","ZTMGRSET",193,0)
 ;
"RTN","ZTMGRSET",194,0)
GLOBALS ;Set node zero of file #3.05 & #3.07
"RTN","ZTMGRSET",195,0)
 W !!,"Now, I will check your % globals."
"RTN","ZTMGRSET",196,0)
 W ".........."
"RTN","ZTMGRSET",197,0)
 F %="^%ZIS","^%ZISL","^%ZTER","^%ZUA" S:'$D(@%) @%=""
"RTN","ZTMGRSET",198,0)
 S:$D(^%ZTSK(0))[0 ^%ZTSK(-1)=100,^%ZTSCH=""
"RTN","ZTMGRSET",199,0)
 S Z1=$G(^%ZTSK(-1),-1),Z2=$G(^%ZTSK(0))
"RTN","ZTMGRSET",200,0)
 I Z1'=$P(Z2,"^",3) S:Z1'>0 ^%ZTSK(-1)=+Z2 S ^%ZTSK(0)="TASKS^14.4^"_^%ZTSK(-1)
"RTN","ZTMGRSET",201,0)
 S:$D(^%ZUA(3.05,0))[0 ^%ZUA(3.05,0)="FAILED ACCESS ATTEMPTS LOG^3.05^^"
"RTN","ZTMGRSET",202,0)
 S:$D(^%ZUA(3.07,0))[0 ^%ZUA(3.07,0)="PROGRAMMER MODE LOG^3.07^^"
"RTN","ZTMGRSET",203,0)
 Q
"RTN","ZTMGRSET",204,0)
NAME ;Setup the static names for this system
"RTN","ZTMGRSET",205,0)
MGR W !,"NAME OF MANAGER'S UCI,VOLUME SET: "_^%ZOSF("MGR")_"// " R X:$S($G(DTIME):DTIME,1:9999) I X]"" X ^("UCICHECK") G MGR:0[Y S ^%ZOSF("MGR")=X
"RTN","ZTMGRSET",206,0)
PROD W !,"PRODUCTION (SIGN-ON) UCI,VOLUME SET: "_^%ZOSF("PROD")_"// " R X:$S($G(DTIME):DTIME,1:9999) I X]"" X ^("UCICHECK") G PROD:0[Y S ^%ZOSF("PROD")=X
"RTN","ZTMGRSET",207,0)
VOL W !,"NAME OF VOLUME SET: "_^%ZOSF("VOL")_"//" R X:$S($G(DTIME):DTIME,1:9999) I X]"" S:X?3U ^%ZOSF("VOL")=X I X'?3U W "MUST BE 3 Upper case." G VOL
"RTN","ZTMGRSET",208,0)
 W ! Q
"RTN","ZUGTM")
0^3^B8549914
"RTN","ZUGTM",1,0)
ZU ;SF/JLI,RWF - For GT.M, TIE ALL TERMINALS TO THIS ROUTINE!! ;2017-01-09  3:51 PM
"RTN","ZUGTM",2,0)
 ;;8.0;KERNEL;**275,419,10001**;Jul 10, 1995;Build 21
"RTN","ZUGTM",3,0)
 ; Submitted to OSEHRA in 2017 by Sam Habiel for OSEHRA
"RTN","ZUGTM",4,0)
 ; Original Routine authored by Department of Veterans Affairs
"RTN","ZUGTM",5,0)
 ; EP JOBEXAM rewritten by Sam Habiel 2016.
"RTN","ZUGTM",6,0)
 ;
"RTN","ZUGTM",7,0)
 ;The env var ZINTRRUPT should be set to catch all interrupts.
"RTN","ZUGTM",8,0)
EN ;See that escape processing is off, Conflict with Screenman
"RTN","ZUGTM",9,0)
 U $P:(NOCENABLE:NOESCAPE)
"RTN","ZUGTM",10,0)
 N $ESTACK,$ETRAP S $ETRAP="D ERR^ZU Q:$QUIT -9 Q"
"RTN","ZUGTM",11,0)
 S $ZINTERRUPT="I $$JOBEXAM^ZU($ZPOSITION)"
"RTN","ZUGTM",12,0)
 D:+$G(^%ZTSCH("LOGRSRC")) LOGRSRC^%ZOSV("$LOGIN$")
"RTN","ZUGTM",13,0)
 D COUNT^XUSCNT(1)
"RTN","ZUGTM",14,0)
 G ^XUS
"RTN","ZUGTM",15,0)
 ;
"RTN","ZUGTM",16,0)
 ;
"RTN","ZUGTM",17,0)
ERR ;Come here on error
"RTN","ZUGTM",18,0)
 ; handle stack overflow errors specifically
"RTN","ZUGTM",19,0)
 I $P($ZS,",",3)["STACKCRIT"!("STACKOFLOW"[$P($ZS,",",3)) S $ET="Q:$ST>"_($ST-8)_"  G ERR2^ZU" Q
"RTN","ZUGTM",20,0)
 ;
"RTN","ZUGTM",21,0)
ERR2 ;
"RTN","ZUGTM",22,0)
 S $ETRAP="D UNWIND^ZU" L  ;Backup Trap
"RTN","ZUGTM",23,0)
 U $P:NOCENABLE
"RTN","ZUGTM",24,0)
 Q:$ECODE["<PROG>"
"RTN","ZUGTM",25,0)
 I $P($ZS,",",2,3)["^XUS1A:2, %GTM-E-IOWRITERR" G HALT
"RTN","ZUGTM",26,0)
 ;
"RTN","ZUGTM",27,0)
 D ^%ZTER K %ZT ; Capture symbol table first!
"RTN","ZUGTM",28,0)
 ;
"RTN","ZUGTM",29,0)
 I $G(IO)]"",$D(IO(1,IO)),$E($G(IOST))="P" D
"RTN","ZUGTM",30,0)
 . U IO
"RTN","ZUGTM",31,0)
 . W @$S($D(IOF):IOF,1:"#")
"RTN","ZUGTM",32,0)
 I $G(IO(0))]"" D
"RTN","ZUGTM",33,0)
 . U IO(0)
"RTN","ZUGTM",34,0)
 . W !!,"RECORDING THAT AN ERROR OCCURRED ---"
"RTN","ZUGTM",35,0)
 . W !!?15,"Sorry 'bout that"
"RTN","ZUGTM",36,0)
 . W !,*7
"RTN","ZUGTM",37,0)
 . W !?10,"$STACK=",$STACK,"  $ECODE=",$ECODE
"RTN","ZUGTM",38,0)
 . W !?10,"$ZSTATUS=",$ZSTATUS
"RTN","ZUGTM",39,0)
 ;
"RTN","ZUGTM",40,0)
 ;
"RTN","ZUGTM",41,0)
 I $G(DUZ)'>0 G HALT
"RTN","ZUGTM",42,0)
 S $ET="D HALT^ZU"
"RTN","ZUGTM",43,0)
 ;
"RTN","ZUGTM",44,0)
 I $P($ZS,",",3)'["-CTRLC" S XUERF="" G ^XUSCLEAN ;419
"RTN","ZUGTM",45,0)
CTRLC U $P
"RTN","ZUGTM",46,0)
 W !,"--Interrupt Acknowledged",!
"RTN","ZUGTM",47,0)
 D KILL1^XUSCLEAN ;Clean up symbol table
"RTN","ZUGTM",48,0)
 S $ECODE=",<<POP>>,"
"RTN","ZUGTM",49,0)
 Q
"RTN","ZUGTM",50,0)
 ;
"RTN","ZUGTM",51,0)
UNWIND ;Unwind the stack
"RTN","ZUGTM",52,0)
 Q:$ESTACK>1  G CTRLC2:$ECODE["<<POP>>"
"RTN","ZUGTM",53,0)
 S $ECODE=""
"RTN","ZUGTM",54,0)
 Q
"RTN","ZUGTM",55,0)
 ;
"RTN","ZUGTM",56,0)
CTRLC2 S $ECODE="" G:$G(^XUTL("XQ",$J,"T"))<2 ^XUSCLEAN
"RTN","ZUGTM",57,0)
 S ^XUTL("XQ",$J,"T")=1,XQY=$G(^(1)),XQY0=$P(XQY,"^",2,99)
"RTN","ZUGTM",58,0)
 G:$P(XQY0,"^",4)'="M" HALT
"RTN","ZUGTM",59,0)
 S XQPSM=$P(XQY,"^",1),XQY=+XQPSM,XQPSM=$P(XQPSM,XQY,2,3)
"RTN","ZUGTM",60,0)
 G:'XQY ^XUSCLEAN
"RTN","ZUGTM",61,0)
 S $ECODE="",$ETRAP="D ERR^ZU Q:$QUIT 0 Q"
"RTN","ZUGTM",62,0)
 U $P:NOESCAPE
"RTN","ZUGTM",63,0)
 G M1^XQ
"RTN","ZUGTM",64,0)
 ;
"RTN","ZUGTM",65,0)
HALT I $D(^XUTL("XQ",$J)) D:$G(DUZ)>0 BYE^XUSCLEAN
"RTN","ZUGTM",66,0)
 D COUNT^XUSCNT(-1)
"RTN","ZUGTM",67,0)
 D:+$G(^%ZTSCH("LOGRSRC")) LOGRSRC^%ZOSV("$LOGOUT$")
"RTN","ZUGTM",68,0)
 HALT
"RTN","ZUGTM",69,0)
 ;
"RTN","ZUGTM",70,0)
JOBEXAM(%ZPOS) ;
"RTN","ZUGTM",71,0)
 I $T(NTRUPT^ZSY)]"" D NTRUPT^ZSY Q 1  ; Lloyd's ZSY
"RTN","ZUGTM",72,0)
 I $T(JOBEXAM^ZSY)]"" Q $$JOBEXAM^ZSY(%ZPOS)  ; FOIA improved by Sam
"RTN","ZUGTM",73,0)
 ;
"RTN","ZUGTM",74,0)
 ; This is the default code in case no ZSY is installed.
"RTN","ZUGTM",75,0)
 S ^XUTL("XUSYS",$J,0)=$H,^XUTL("XUSYS",$J,"INTERRUPT")=$G(%ZPOS)
"RTN","ZUGTM",76,0)
 S ^XUTL("XUSYS",$J,"ZMODE")=$ZMODE ; SMH - INTERACTIVE or OTHER
"RTN","ZUGTM",77,0)
 I %ZPOS'["GTM$DMOD" S ^XUTL("XUSYS",$J,"codeline")=$T(@%ZPOS)
"RTN","ZUGTM",78,0)
 K ^XUTL("XUSYS",$J,"JE")
"RTN","ZUGTM",79,0)
 ZSHOW "*":^XUTL("XUSYS",$J,"JE")
"RTN","ZUGTM",80,0)
 I $G(^XUTL("XUSYS",$J,"CMD"))="HALT" D H2^XUSCLEAN G HALT^ZU
"RTN","ZUGTM",81,0)
 Q 1
"RTN","ZUGTM",82,0)
 ;
"VER")
8.0^22.2
**INSTALL NAME**
XU*8.0*10002
"BLD",10873,0)
XU*8.0*10002^KERNEL^0^3180606^y
"BLD",10873,1,0)
^^4^4^3171130^
"BLD",10873,1,1,0)
Kernel Enhancements for better GT.M support. See full release notes 
"BLD",10873,1,2,0)
accompanying this patch.
"BLD",10873,1,3,0)
 
"BLD",10873,1,4,0)
This is the second release.
"BLD",10873,4,0)
^9.64PA^^
"BLD",10873,6.3)
26
"BLD",10873,"INI")
PRE^XU810002
"BLD",10873,"INIT")
POST^XU810002
"BLD",10873,"KRN",0)
^9.67PA^9002226^21
"BLD",10873,"KRN",.4,0)
.4
"BLD",10873,"KRN",.4,"NM",0)
^9.68A^^
"BLD",10873,"KRN",.401,0)
.401
"BLD",10873,"KRN",.401,"NM",0)
^9.68A^^
"BLD",10873,"KRN",.402,0)
.402
"BLD",10873,"KRN",.403,0)
.403
"BLD",10873,"KRN",.5,0)
.5
"BLD",10873,"KRN",.84,0)
.84
"BLD",10873,"KRN",3.6,0)
3.6
"BLD",10873,"KRN",3.8,0)
3.8
"BLD",10873,"KRN",9.2,0)
9.2
"BLD",10873,"KRN",9.8,0)
9.8
"BLD",10873,"KRN",9.8,"NM",0)
^9.68A^22^10
"BLD",10873,"KRN",9.8,"NM",1,0)
ZOSVGUX^^0^B45533042
"BLD",10873,"KRN",9.8,"NM",7,0)
ZISHGUX^^0^B84538989
"BLD",10873,"KRN",9.8,"NM",14,0)
ZOSVGUT1^^0^B130237275
"BLD",10873,"KRN",9.8,"NM",15,0)
ZOSVGUT2^^0^B42570307
"BLD",10873,"KRN",9.8,"NM",17,0)
ZOSVGUT3^^0^B182146595
"BLD",10873,"KRN",9.8,"NM",18,0)
XUSCNT^^0^B10554110
"BLD",10873,"KRN",9.8,"NM",19,0)
ZSY^^0^B420055711
"BLD",10873,"KRN",9.8,"NM",20,0)
ZOSVONUT^^0^B31454787
"BLD",10873,"KRN",9.8,"NM",21,0)
ZISHONT^^0^B103215011
"BLD",10873,"KRN",9.8,"NM",22,0)
ZOSVONT^^0^B26568303
"BLD",10873,"KRN",9.8,"NM","B","XUSCNT",18)

"BLD",10873,"KRN",9.8,"NM","B","ZISHGUX",7)

"BLD",10873,"KRN",9.8,"NM","B","ZISHONT",21)

"BLD",10873,"KRN",9.8,"NM","B","ZOSVGUT1",14)

"BLD",10873,"KRN",9.8,"NM","B","ZOSVGUT2",15)

"BLD",10873,"KRN",9.8,"NM","B","ZOSVGUT3",17)

"BLD",10873,"KRN",9.8,"NM","B","ZOSVGUX",1)

"BLD",10873,"KRN",9.8,"NM","B","ZOSVONT",22)

"BLD",10873,"KRN",9.8,"NM","B","ZOSVONUT",20)

"BLD",10873,"KRN",9.8,"NM","B","ZSY",19)

"BLD",10873,"KRN",19,0)
19
"BLD",10873,"KRN",19.1,0)
19.1
"BLD",10873,"KRN",101,0)
101
"BLD",10873,"KRN",409.61,0)
409.61
"BLD",10873,"KRN",771,0)
771
"BLD",10873,"KRN",779.2,0)
779.2
"BLD",10873,"KRN",870,0)
870
"BLD",10873,"KRN",8989.51,0)
8989.51
"BLD",10873,"KRN",8989.52,0)
8989.52
"BLD",10873,"KRN",8994,0)
8994
"BLD",10873,"KRN",9002226,0)
9002226
"BLD",10873,"KRN","B",.4,.4)

"BLD",10873,"KRN","B",.401,.401)

"BLD",10873,"KRN","B",.402,.402)

"BLD",10873,"KRN","B",.403,.403)

"BLD",10873,"KRN","B",.5,.5)

"BLD",10873,"KRN","B",.84,.84)

"BLD",10873,"KRN","B",3.6,3.6)

"BLD",10873,"KRN","B",3.8,3.8)

"BLD",10873,"KRN","B",9.2,9.2)

"BLD",10873,"KRN","B",9.8,9.8)

"BLD",10873,"KRN","B",19,19)

"BLD",10873,"KRN","B",19.1,19.1)

"BLD",10873,"KRN","B",101,101)

"BLD",10873,"KRN","B",409.61,409.61)

"BLD",10873,"KRN","B",771,771)

"BLD",10873,"KRN","B",779.2,779.2)

"BLD",10873,"KRN","B",870,870)

"BLD",10873,"KRN","B",8989.51,8989.51)

"BLD",10873,"KRN","B",8989.52,8989.52)

"BLD",10873,"KRN","B",8994,8994)

"BLD",10873,"KRN","B",9002226,9002226)

"BLD",10873,"QUES",0)
^9.62^^
"INI")
PRE^XU810002
"INIT")
POST^XU810002
"MBREQ")
0
"PKG",3,-1)
1^1
"PKG",3,0)
KERNEL^XU^SIGN-ON, SECURITY, MENU DRIVER, DEVICES, TASKMAN^
"PKG",3,20,0)
^9.402P^2^2
"PKG",3,20,1,0)
200^^XDRM200N
"PKG",3,20,1,1)

"PKG",3,20,2,0)
2^^RGDRM03
"PKG",3,20,2,1)

"PKG",3,20,"B",2,2)

"PKG",3,20,"B",200,1)

"PKG",3,22,0)
^9.49I^1^1
"PKG",3,22,1,0)
8.0^3051119^2960606^1
"PKG",3,22,1,"PAH",1,0)
10002^3180606^0
"PKG",3,22,1,"PAH",1,1,0)
^^4^4^3180606
"PKG",3,22,1,"PAH",1,1,1,0)
Kernel Enhancements for better GT.M support. See full release notes 
"PKG",3,22,1,"PAH",1,1,2,0)
accompanying this patch.
"PKG",3,22,1,"PAH",1,1,3,0)
 
"PKG",3,22,1,"PAH",1,1,4,0)
This is the second release.
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
NO
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
NO
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
NO
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
11
"RTN","XU810002")
0^^B1994975
"RTN","XU810002",1,0)
XU810002 ; VEN/SMH - XU*8.0*10002 Pre/Post Install;2017-01-09  3:36 PM ; 6/5/18 3:27pm
"RTN","XU810002",2,0)
 ;;8.0;KERNEL;**10002**;;Build 26
"RTN","XU810002",3,0)
 ; Submitted to OSEHRA in 2017 by Sam Habiel for OSEHRA
"RTN","XU810002",4,0)
 ; Authored by Sam Habiel 2017.
"RTN","XU810002",5,0)
PRE ; [KIDS PEP]
"RTN","XU810002",6,0)
 D MES^XPDUTL("Stopping Taskman...")
"RTN","XU810002",7,0)
 D GROUP^ZTMKU("SSUB(NODE)")
"RTN","XU810002",8,0)
 D GROUP^ZTMKU("SMAN(NODE)")
"RTN","XU810002",9,0)
 D MES^XPDUTL("Waiting around until Taskman reports it's stopped")
"RTN","XU810002",10,0)
 F  W "." Q:($$TM^%ZTLOAD=0)  H 1
"RTN","XU810002",11,0)
 QUIT
"RTN","XU810002",12,0)
 ;
"RTN","XU810002",13,0)
POST ; [KIDS PEP]
"RTN","XU810002",14,0)
 D PATCH^ZTMGRSET(10002)
"RTN","XU810002",15,0)
 ;
"RTN","XU810002",16,0)
 I ^%ZOSF("OS")["OpenM" QUIT ; Rest is for GTM
"RTN","XU810002",17,0)
 ;
"RTN","XU810002",18,0)
 D MES^XPDUTL("Renaming ZUGTM...")
"RTN","XU810002",19,0)
 D DO^ZUSET("ZUGTM")
"RTN","XU810002",20,0)
 ;
"RTN","XU810002",21,0)
 N Y D GETENV^%ZOSV
"RTN","XU810002",22,0)
 N UCIBOX S UCIBOX=$P(Y,U,4)
"RTN","XU810002",23,0)
 N IEN14P7 S IEN14P7=$O(^%ZIS(14.7," "),-1)
"RTN","XU810002",24,0)
 N FDA S FDA(14.7,IEN14P7_",",.01)=UCIBOX
"RTN","XU810002",25,0)
 N DIERR
"RTN","XU810002",26,0)
 D FILE^DIE(,$NA(FDA))
"RTN","XU810002",27,0)
 I $D(DIERR) D MES^XPDUTL("Failed to updated Taskman Site Parameters. You need to update manually.")
"RTN","XU810002",28,0)
 D MES^XPDUTL("Starting Taskman...")
"RTN","XU810002",29,0)
 D ^ZTMB
"RTN","XU810002",30,0)
 QUIT
"RTN","XUSCNT")
0^18^B10554110
"RTN","XUSCNT",1,0)
XUSCNT ;ISF/RWF - Job counting for GTM ;2018-05-02  11:10 AM
"RTN","XUSCNT",2,0)
 ;;8.0;KERNEL;**275,10002**;July 10, 1995;Build 26
"RTN","XUSCNT",3,0)
 ;0 return CNT
"RTN","XUSCNT",4,0)
 ;1 inc CNT
"RTN","XUSCNT",5,0)
 ;-1 dec CNT
"RTN","XUSCNT",6,0)
COUNT(INC,JOB) ;Keep count of jobs
"RTN","XUSCNT",7,0)
 ; DECOMMISION *10002*
"RTN","XUSCNT",8,0)
 I $T(^%PEEKBYNAME)]"" QUIT
"RTN","XUSCNT",9,0)
 N XUCNT,X
"RTN","XUSCNT",10,0)
 S JOB=$G(JOB,$J)
"RTN","XUSCNT",11,0)
 ;Return Current Count
"RTN","XUSCNT",12,0)
 I INC=0 D TOUCH Q +$G(^XUTL("XUSYS","CNT"))
"RTN","XUSCNT",13,0)
 ;Increment Count
"RTN","XUSCNT",14,0)
 I INC>0 D  Q
"RTN","XUSCNT",15,0)
 . S X=$G(^XUTL("XUSYS",JOB,"NM")) K ^XUTL("XUSYS",JOB) S ^XUTL("XUSYS",JOB,"NM")=X
"RTN","XUSCNT",16,0)
 . D TOUCH
"RTN","XUSCNT",17,0)
 . L +^XUTL("XUSYS","CNT"):5
"RTN","XUSCNT",18,0)
 . S XUCNT=$G(^XUTL("XUSYS","CNT"))+1,^XUTL("XUSYS","CNT")=XUCNT
"RTN","XUSCNT",19,0)
 . L -^XUTL("XUSYS","CNT")
"RTN","XUSCNT",20,0)
 . Q
"RTN","XUSCNT",21,0)
 ;Decrement Count
"RTN","XUSCNT",22,0)
 I INC<0 D  Q
"RTN","XUSCNT",23,0)
 . L +^XUTL("XUSYS","CNT"):5
"RTN","XUSCNT",24,0)
 . S XUCNT=$G(^XUTL("XUSYS","CNT"))-1,^XUTL("XUSYS","CNT")=$S(XUCNT>0:XUCNT,1:0)
"RTN","XUSCNT",25,0)
 . L -^XUTL("XUSYS","CNT")
"RTN","XUSCNT",26,0)
 . K ^XUTL("XUSYS",JOB)
"RTN","XUSCNT",27,0)
 Q
"RTN","XUSCNT",28,0)
 ;
"RTN","XUSCNT",29,0)
CHECK(JOB) ;Check if job number active
"RTN","XUSCNT",30,0)
 ; 0 = Job doesn't seem to be running
"RTN","XUSCNT",31,0)
 ; 1 = Job maybe running
"RTN","XUSCNT",32,0)
 ; 2 = Job still has Lock out.
"RTN","XUSCNT",33,0)
 Q:$G(JOB)'>0 0
"RTN","XUSCNT",34,0)
 I '$D(^XUTL("XUSYS",JOB)) Q 0
"RTN","XUSCNT",35,0)
 N LK,%T
"RTN","XUSCNT",36,0)
 S %T=0,LK=$$GETLOCK()
"RTN","XUSCNT",37,0)
 I $L(LK) L +@LK:0 S %T=$T L:%T -@LK
"RTN","XUSCNT",38,0)
 Q $S(%T:2,1:1)
"RTN","XUSCNT",39,0)
 ;
"RTN","XUSCNT",40,0)
SETLOCK(NLK) ;Set the Lock we will keep
"RTN","XUSCNT",41,0)
 I $L($G(NLK)) S ^XUTL("XUSYS",$J,"LOCK")=NLK
"RTN","XUSCNT",42,0)
 E  K ^XUTL("XUSYS",$J,"LOCK")
"RTN","XUSCNT",43,0)
 D TOUCH ;Update the time
"RTN","XUSCNT",44,0)
 Q
"RTN","XUSCNT",45,0)
 ;
"RTN","XUSCNT",46,0)
TOUCH ;Update the time
"RTN","XUSCNT",47,0)
 S ^XUTL("XUSYS",$J,0)=$H
"RTN","XUSCNT",48,0)
 Q
"RTN","XUSCNT",49,0)
 ;
"RTN","XUSCNT",50,0)
GETLOCK() ;Get the node to Lock
"RTN","XUSCNT",51,0)
 Q $G(^XUTL("XUSYS",$J,"LOCK"))
"RTN","XUSCNT",52,0)
 ;
"RTN","XUSCNT",53,0)
CLEAR(DB) ;Check for locks and time clear old ones.
"RTN","XUSCNT",54,0)
 N %J,%T,CNT,CT,LK,IM,IMAGE,H K ^TMP($J)
"RTN","XUSCNT",55,0)
 D TOUCH ;See that we are current
"RTN","XUSCNT",56,0)
 ;S %J=0 F  S %J=$ZPID(%J) Q:%J'>0  S ^TMP($J,%J)="",^TMP($J,%J,1)=$ZGETJPI(%J,"IMAGNAME")
"RTN","XUSCNT",57,0)
 S DB=+$G(DB),IMAGE="mumps" ;$ZGETJPI($J,"IMAGNAME") ; ours
"RTN","XUSCNT",58,0)
 S %J=0,CNT=0,H=$H,CT=$$H3($H)
"RTN","XUSCNT",59,0)
 I DB W !,"Current Job Count: ",$$COUNT(0)
"RTN","XUSCNT",60,0)
 F  S %J=$O(^XUTL("XUSYS",%J)) Q:%J'>0  D
"RTN","XUSCNT",61,0)
 . S CNT=CNT+1
"RTN","XUSCNT",62,0)
 . I DB W !,CNT," Job: ",%J
"RTN","XUSCNT",63,0)
 . S LK=$G(^XUTL("XUSYS",%J,"LOCK")) ;Get lock name
"RTN","XUSCNT",64,0)
 . I '$L(LK) W:DB " No Lock node"
"RTN","XUSCNT",65,0)
 . I $L(LK) L +@LK:0 S %T=$T D  Q:'%T  L -@LK ;Quit if lock still held
"RTN","XUSCNT",66,0)
 . . I '%T,DB W " Lock Held"
"RTN","XUSCNT",67,0)
 . . I %T,DB W " Lock Fail"
"RTN","XUSCNT",68,0)
 . S IM=$G(^TMP($J,%J,1))
"RTN","XUSCNT",69,0)
 . I IM=IMAGE W:DB " Image Match: ",IM  Q
"RTN","XUSCNT",70,0)
 . I IM["ZFOO.EXE" W:DB " ZFOO Image" Q  ;Quit if in same image
"RTN","XUSCNT",71,0)
 . S H=$G(^XUTL("XUSYS",%J,0)) I H>0 S H=$$H3(H)
"RTN","XUSCNT",72,0)
 . I H+60>CT D  Q  ;Updated in last 30 seconds.
"RTN","XUSCNT",73,0)
 . .  I DB W " Current TimeStamp"
"RTN","XUSCNT",74,0)
 . S NM=$G(^XUTL("XUSYS",%J,"NM"))
"RTN","XUSCNT",75,0)
 . I NM["Task " S TM=+$P(NM,"Task ",2) I TM>0 D  Q:%
"RTN","XUSCNT",76,0)
 . . S TM(1)=$G(^%ZTSK(TM,.1)),%=(TM(1)=5)
"RTN","XUSCNT",77,0)
 . . I DB,% W " Running Task"
"RTN","XUSCNT",78,0)
 . . Q
"RTN","XUSCNT",79,0)
 . ;More checks
"RTN","XUSCNT",80,0)
 . D COUNT(-1,%J) I DB W " Not Active: Removed" ;Not Active
"RTN","XUSCNT",81,0)
 . Q
"RTN","XUSCNT",82,0)
 L +^XUTL("XUSYS","CNT"):3
"RTN","XUSCNT",83,0)
 S CNT=0,%J=0 F  S %J=$O(^XUTL("XUSYS",%J)) Q:%J'>0  S CNT=CNT+1
"RTN","XUSCNT",84,0)
 S ^XUTL("XUSYS","CNT")=CNT
"RTN","XUSCNT",85,0)
 L -^XUTL("XUSYS","CNT")
"RTN","XUSCNT",86,0)
 I DB W !,"New JOB count: ",CNT
"RTN","XUSCNT",87,0)
 Q
"RTN","XUSCNT",88,0)
 ;
"RTN","XUSCNT",89,0)
H3(%H) ;Just seconds
"RTN","XUSCNT",90,0)
 Q %H*86400+$P(%H,",",2)
"RTN","XUSCNT",91,0)
 ;
"RTN","XUSCNT",92,0)
 ;Called from the X-REF both the volume and Max signon from file 8989.3
"RTN","XUSCNT",93,0)
XREF(X1,V) ;V="S" or "K"
"RTN","XUSCNT",94,0)
 N %,N
"RTN","XUSCNT",95,0)
 S %=$G(^XTV(8989.3,1,4,X1,0)),N=$P(%,"^") Q:%=""
"RTN","XUSCNT",96,0)
 I V="K" K ^XTV(8989.3,"AMAX",N) Q
"RTN","XUSCNT",97,0)
 S ^XTV(8989.3,"AMAX",N)=$P(%,"^",3)
"RTN","XUSCNT",98,0)
 Q
"RTN","ZISHGUX")
0^7^B84538989
"RTN","ZISHGUX",1,0)
%ZISH ;ISF/AC,RWF,VEN/SMH - GT.M for Unix Host file Control ;2018-06-06  1:47 PM
"RTN","ZISHGUX",2,0)
 ;;8.0;KERNEL;**275,306,385,524,10001,10002**;Jul 10, 1995;Build 26
"RTN","ZISHGUX",3,0)
 ; Submitted to OSEHRA in 2017 by Sam Habiel for OSEHRA
"RTN","ZISHGUX",4,0)
 ; Original Routine authored by Department of Veterans Affairs
"RTN","ZISHGUX",5,0)
 ; EPs OPEN,DEL1,CD,PWD,MAXREC,MKDIR,SIZE,WGETSYNC,DF,SEND,SENDTO1 
"RTN","ZISHGUX",6,0)
 ; --> authored by Sam Habiel 2016-2018.
"RTN","ZISHGUX",7,0)
 ; EPs MV,DEFDIR,FTG,READNXT,MGTF have bugs fixed by Sam Habiel 2016.
"RTN","ZISHGUX",8,0)
 ; 
"RTN","ZISHGUX",9,0)
 ;
"RTN","ZISHGUX",10,0)
OPEN(X1,X2,X3,X4,X5,X6) ;SR. Open file
"RTN","ZISHGUX",11,0)
 ;D OPEN^%ZISH([handlename],[directory],filename,[accessmode],[recsize])
"RTN","ZISHGUX",12,0)
 ;X1=handle name
"RTN","ZISHGUX",13,0)
 ;X2=directory, X3=filename, X4=access mode
"RTN","ZISHGUX",14,0)
 ;X5=new file max record size, X6=Subtype
"RTN","ZISHGUX",15,0)
 ; ZEXCEPT: IOM,IOSL,IOT,POP
"RTN","ZISHGUX",16,0)
 ;
"RTN","ZISHGUX",17,0)
 ; RPMS has a 3 parameter version (directory, file, access mode)
"RTN","ZISHGUX",18,0)
 ; If we only have 3 parameters, move them over from X1,X2,X3 ->
"RTN","ZISHGUX",19,0)
 ; X2,X3,X4
"RTN","ZISHGUX",20,0)
 ; RPMS's OPENI also quits with a value, unlike the VistA call.
"RTN","ZISHGUX",21,0)
 ; So I added $Q to check for that.
"RTN","ZISHGUX",22,0)
 I '$D(X4) S X4=X3,X3=X2,X2=X1 K X1
"RTN","ZISHGUX",23,0)
 ;
"RTN","ZISHGUX",24,0)
 N %,%1,%2,%IO,%I2,%P,%T,X,Y,$ETRAP
"RTN","ZISHGUX",25,0)
 S $ETRAP="G OPNERR^%ZISH"
"RTN","ZISHGUX",26,0)
 ; If X2 isn't supplied, get default directory; or resolve it if supplied
"RTN","ZISHGUX",27,0)
 S U="^",X2=$$DEFDIR($G(X2)),X4=$$UP^XLFSTR(X4)
"RTN","ZISHGUX",28,0)
 ;
"RTN","ZISHGUX",29,0)
 ; These are common sense
"RTN","ZISHGUX",30,0)
 S Y=$S(X4["A":"append",X4["R":"readonly",X4["W":"newversion",1:"readonly")
"RTN","ZISHGUX",31,0)
 ;
"RTN","ZISHGUX",32,0)
 ; Binary mode. ! and # have no effect.
"RTN","ZISHGUX",33,0)
 ; NB: Reads are in record size; writes pad out to record size
"RTN","ZISHGUX",34,0)
 N RECSIZE S RECSIZE=$G(X5,"512")
"RTN","ZISHGUX",35,0)
 I X4["B" S Y=Y_":fixed:nowrap:recordsize="_RECSIZE ; Binary Mode
"RTN","ZISHGUX",36,0)
 ;
"RTN","ZISHGUX",37,0)
 ; Streaming Mode (almost everybody wants this all of the time)
"RTN","ZISHGUX",38,0)
 I X4'["B",'$G(X5) S Y=Y_":nowrap:stream" ; Streaming Mode (default)
"RTN","ZISHGUX",39,0)
 ;
"RTN","ZISHGUX",40,0)
 ; Variable records mode. Records are TRUNCATED at a specific width,
"RTN","ZISHGUX",41,0)
 ; but, unlike fixed records, you can end them early with a !.
"RTN","ZISHGUX",42,0)
 I X4'["B",$G(X5)  S Y=Y_":variable:nowrap:recordsize="_+X5
"RTN","ZISHGUX",43,0)
 ;
"RTN","ZISHGUX",44,0)
 S:$E(Y)=":" $E(Y)=""
"RTN","ZISHGUX",45,0)
 S %IO=X2_X3,%I2="%IO:"_$S($L(Y):"("_Y_")",1:"")_":0"
"RTN","ZISHGUX",46,0)
 O @%I2 E  S POP=1 Q:$Q 1 Q
"RTN","ZISHGUX",47,0)
 ;
"RTN","ZISHGUX",48,0)
 S IO=%IO,IO(1,IO)="",IOT="HFS",IOM=80,IOSL=60,POP=0 D SUBTYPE^%ZIS3($G(X6))
"RTN","ZISHGUX",49,0)
 I $G(X1)]"" D SAVDEV^%ZISUTL(X1)
"RTN","ZISHGUX",50,0)
 Q:$Q 0 Q
"RTN","ZISHGUX",51,0)
OPNERR ;error on open
"RTN","ZISHGUX",52,0)
 ; ZEXCEPT: POP
"RTN","ZISHGUX",53,0)
 S POP=1,$ECODE=""
"RTN","ZISHGUX",54,0)
 ;U:$G(%P)]"" %P
"RTN","ZISHGUX",55,0)
 Q:$Q 1 Q
"RTN","ZISHGUX",56,0)
 ;
"RTN","ZISHGUX",57,0)
CLOSE(X) ;SR. Close HFS device not opened by %ZIS.
"RTN","ZISHGUX",58,0)
 ;X1=Handle name, IO=device
"RTN","ZISHGUX",59,0)
 I IO]"" C IO K IO(1,IO)
"RTN","ZISHGUX",60,0)
 I $G(X)]"" D RMDEV^%ZISUTL(X)
"RTN","ZISHGUX",61,0)
 I $D(IO("HOME"))!$D(^XUTL("XQ",$J,"IOS")) D HOME^%ZIS
"RTN","ZISHGUX",62,0)
 Q
"RTN","ZISHGUX",63,0)
DEL(%ZX1,%ZX2) ;ef,SR. Del fl(s)
"RTN","ZISHGUX",64,0)
 ;S Y=$$DEL^%ZISH("dir path",$NA(array))
"RTN","ZISHGUX",65,0)
 N %ZISH,%ZISHLGR,%ZX,X,%ZXDEL
"RTN","ZISHGUX",66,0)
 S %ZX1=$$DEFDIR($G(%ZX1)),%ZXDEL=1,%ZISH=""
"RTN","ZISHGUX",67,0)
 ;
"RTN","ZISHGUX",68,0)
 ; Error trap is for $D(@%ZX2)
"RTN","ZISHGUX",69,0)
 N $ET S $ET="S $EC="""" G DELVAL^%ZISH"
"RTN","ZISHGUX",70,0)
 I $D(@%ZX2)<10 G DELVAL  ; RPMS format
"RTN","ZISHGUX",71,0)
 E  G DELNAME ; VISTA format
"RTN","ZISHGUX",72,0)
 ;
"RTN","ZISHGUX",73,0)
DELVAL ; [Internal] Delete by Val
"RTN","ZISHGUX",74,0)
 ; RPMS allows you to pass %ZX2 by value -- so handle that here
"RTN","ZISHGUX",75,0)
 ; Also, in the RPMS format, 0 = success and 1 = failure
"RTN","ZISHGUX",76,0)
 ; (b/c that's the return value of the unix rm command)
"RTN","ZISHGUX",77,0)
 ;
"RTN","ZISHGUX",78,0)
 S $ET="S $EC="""" Q 1"
"RTN","ZISHGUX",79,0)
 S %ZXDEL=0
"RTN","ZISHGUX",80,0)
 S %ZISH=%ZX2
"RTN","ZISHGUX",81,0)
 S %ZX=$S(%ZISH[%ZX1:%ZISH,1:%ZX1_%ZISH)
"RTN","ZISHGUX",82,0)
 O %ZX:READONLY:0
"RTN","ZISHGUX",83,0)
 E  S %ZXDEL=1 Q  ; Can't open it.
"RTN","ZISHGUX",84,0)
 C %ZX:DELETE
"RTN","ZISHGUX",85,0)
 I $ZSEARCH(%ZX)]"" S %ZXDEL=1 ; Delete was not successful.
"RTN","ZISHGUX",86,0)
 Q %ZXDEL
"RTN","ZISHGUX",87,0)
 ; /end RPMS implementation
"RTN","ZISHGUX",88,0)
 ;
"RTN","ZISHGUX",89,0)
DELNAME ; [Internal] Delete by Name
"RTN","ZISHGUX",90,0)
 ; ZEXCEPT: %ZISH,%ZISHLGR,%ZX,X,%ZXDEL,%ZX1,%ZX2
"RTN","ZISHGUX",91,0)
 ; %ZX2 is a named array (VistA format)
"RTN","ZISHGUX",92,0)
 F  S %ZISH=$O(@%ZX2@(%ZISH)) Q:%ZISH=""  D
"RTN","ZISHGUX",93,0)
 . N $ETRAP S $ETRAP="D DELERR^%ZISH"
"RTN","ZISHGUX",94,0)
 . I %ZISH["*" S %ZXDEL=0 Q  ; Wild card not allowed.
"RTN","ZISHGUX",95,0)
 . S %ZX=$ZSEARCH(%ZX1_%ZISH)
"RTN","ZISHGUX",96,0)
 . Q:%ZX=""           ; File doesn't exist - not an error, just quit.
"RTN","ZISHGUX",97,0)
 . O %ZX:READONLY:0
"RTN","ZISHGUX",98,0)
 . E  S %ZXDEL=0 Q  ; Can't open it.
"RTN","ZISHGUX",99,0)
 . C %ZX:DELETE
"RTN","ZISHGUX",100,0)
 . I $ZSEARCH(%ZX)]"" S %ZXDEL=0 ; Delete was not successful.
"RTN","ZISHGUX",101,0)
 Q %ZXDEL
"RTN","ZISHGUX",102,0)
 ;
"RTN","ZISHGUX",103,0)
DELERR ;Trap any $ETRAP error, unwind and return.
"RTN","ZISHGUX",104,0)
 ; ZEXCEPT: %ZXDEL
"RTN","ZISHGUX",105,0)
 S $ETRAP="D UNWIND^%ZTER"
"RTN","ZISHGUX",106,0)
 S %ZXDEL=0
"RTN","ZISHGUX",107,0)
 D UNWIND^%ZTER Q
"RTN","ZISHGUX",108,0)
 ;
"RTN","ZISHGUX",109,0)
DEL1(%ZX3) ;ef,SR. Delete one file
"RTN","ZISHGUX",110,0)
 N %ZI1,%ZI2
"RTN","ZISHGUX",111,0)
 D SPLIT(%ZX3,.%ZI1,.%ZI2) S %ZI2(%ZI2)=""
"RTN","ZISHGUX",112,0)
 Q $$DEL(%ZI1,$NA(%ZI2))
"RTN","ZISHGUX",113,0)
 ;
"RTN","ZISHGUX",114,0)
SPLIT(%I,%O1,%O2) ;[Public] Split to path,file
"RTN","ZISHGUX",115,0)
 N %D,D
"RTN","ZISHGUX",116,0)
 S %D="/",%O1="",%O2=""
"RTN","ZISHGUX",117,0)
 S D=$L(%I,%D),%O1=$P(%I,%D,1,D-1),%O2=$P(%I,%D,D)
"RTN","ZISHGUX",118,0)
 Q
"RTN","ZISHGUX",119,0)
LIST(%ZX1,%ZX2,%ZX3) ;ef,SR. Set local array holding fl names
"RTN","ZISHGUX",120,0)
 ;S Y=$$LIST^ZISH("/dir/","list_root","return_root")
"RTN","ZISHGUX",121,0)
 ;list_root can have XX("A*"), XX("test.com")...
"RTN","ZISHGUX",122,0)
 ;Both arrays passed as $NA values (closed roots).
"RTN","ZISHGUX",123,0)
 N %ZISH,%ZIX,%ZIY,POP,X
"RTN","ZISHGUX",124,0)
 N $ETRAP,$ESTACK
"RTN","ZISHGUX",125,0)
 S $ETRAP="G LSTX^%ZISH" ; for the next line
"RTN","ZISHGUX",126,0)
 S %ZX1=$$DEFDIR($G(%ZX1))
"RTN","ZISHGUX",127,0)
 ;
"RTN","ZISHGUX",128,0)
 ; RPMS allows %ZX2 to be passed by value and %ZX3 to be passed by reference
"RTN","ZISHGUX",129,0)
 ; Next line's error trap applies only to $D(@%ZX2)
"RTN","ZISHGUX",130,0)
 S $ETRAP="S $EC="""" Q $$LISTI()"
"RTN","ZISHGUX",131,0)
 I $D(@%ZX2)<10 Q $$LISTI()
"RTN","ZISHGUX",132,0)
 ;Get fls, Build listing in %ZISHDL1 with ls
"RTN","ZISHGUX",133,0)
 S $ETRAP="G LSTX^%ZISH"
"RTN","ZISHGUX",134,0)
 S %ZISH=""
"RTN","ZISHGUX",135,0)
 F  S %ZISH=$O(@%ZX2@(%ZISH)) Q:%ZISH=""  D
"RTN","ZISHGUX",136,0)
 . S %ZIX=$ZPARSE(%ZX1_%ZISH) Q:%ZIX=""
"RTN","ZISHGUX",137,0)
 . F  S %ZIY=$ZSEARCH(%ZIX) Q:%ZIY=""  S %ZIY=$ZPARSE(%ZIY,"NAME")_$ZPARSE(%ZIY,"TYPE"),@%ZX3@(%ZIY)=""
"RTN","ZISHGUX",138,0)
LSTX ;
"RTN","ZISHGUX",139,0)
 S $ECODE=""
"RTN","ZISHGUX",140,0)
 S $ETRAP="G LISTIX^%ZISH" ; This is in case $$DEFDIR fails but 2nd par is passed by reference (So @ on it will crash)
"RTN","ZISHGUX",141,0)
 Q ($Q(@%ZX3)]"")
"RTN","ZISHGUX",142,0)
 ;
"RTN","ZISHGUX",143,0)
LISTI() ; [Internal] RPMS implementation of directory lister
"RTN","ZISHGUX",144,0)
 ; %ZX1 by value; %ZX2 by value; %ZX3 by reference
"RTN","ZISHGUX",145,0)
 ; ZEXCEPT: %ZX1,%ZX2,%ZX3
"RTN","ZISHGUX",146,0)
 ; ZEXCEPT: %ZIX,%ZIY
"RTN","ZISHGUX",147,0)
 S $ETRAP="G LSTIX^%ZISH"
"RTN","ZISHGUX",148,0)
 I $G(%ZX1)']""!($G(%ZX2)']"") Q 0
"RTN","ZISHGUX",149,0)
 S %ZIX=$ZPARSE(%ZX1_%ZX2) Q:%ZIX="" 0
"RTN","ZISHGUX",150,0)
 N %ZISHN F %ZISHN=1:1 S %ZIY=$ZSEARCH(%ZIX) Q:%ZIY=""  D
"RTN","ZISHGUX",151,0)
 . S %ZIY=$ZPARSE(%ZIY,"NAME")_$ZPARSE(%ZIY,"TYPE")
"RTN","ZISHGUX",152,0)
 . S %ZX3(%ZISHN)=%ZIY
"RTN","ZISHGUX",153,0)
LISTIX ; [Internal] Error Trap target for LISTI; Fallthrough
"RTN","ZISHGUX",154,0)
 S $ECODE=""
"RTN","ZISHGUX",155,0)
 Q '$D(%ZX3)
"RTN","ZISHGUX",156,0)
 ;
"RTN","ZISHGUX",157,0)
MV(X1,X2,Y1,Y2) ;ef,SR. Rename a fl
"RTN","ZISHGUX",158,0)
 ;S Y=$$MV^ZISH("/dir/","fl","/dir/","fl")
"RTN","ZISHGUX",159,0)
 N %Z,%C
"RTN","ZISHGUX",160,0)
 S X1=$$DEFDIR($G(X1)),Y1=$$DEFDIR($G(Y1))
"RTN","ZISHGUX",161,0)
 S %C="mv "
"RTN","ZISHGUX",162,0)
 ;Pbv or qit
"RTN","ZISHGUX",163,0)
 I (X2="")!(Y2="") Q 0
"RTN","ZISHGUX",164,0)
 N % S %=$$RETURN^%ZOSV(%C_X1_X2_" "_Y1_Y2)
"RTN","ZISHGUX",165,0)
 S %Z=$ZSEARCH(Y1_Y2)
"RTN","ZISHGUX",166,0)
 Q $L(%Z)>0
"RTN","ZISHGUX",167,0)
 ;
"RTN","ZISHGUX",168,0)
CD(D) ; [Public] Change Directory
"RTN","ZISHGUX",169,0)
 S $ZD=D
"RTN","ZISHGUX",170,0)
 QUIT
"RTN","ZISHGUX",171,0)
 ;
"RTN","ZISHGUX",172,0)
PWD() ;ef,SR. Print working directory
"RTN","ZISHGUX",173,0)
 Q $ZDIRECTORY
"RTN","ZISHGUX",174,0)
 ;
"RTN","ZISHGUX",175,0)
DEFDIR(DF) ;ef. Default Dir and frmt
"RTN","ZISHGUX",176,0)
 S DF=$G(DF)
"RTN","ZISHGUX",177,0)
 S:DF="" DF=$P($G(^XTV(8989.3,1,"DEV")),"^",1)
"RTN","ZISHGUX",178,0)
 ;
"RTN","ZISHGUX",179,0)
 ; $ZPARSE is file specific; we need to tell it that we are looking for a DIRECTORY!
"RTN","ZISHGUX",180,0)
 ; Otherwise, we will get a false positive
"RTN","ZISHGUX",181,0)
 I $E(DF,$L(DF))'="/" S DF=DF_"/"
"RTN","ZISHGUX",182,0)
 ;
"RTN","ZISHGUX",183,0)
 S DF=$ZPARSE(DF)
"RTN","ZISHGUX",184,0)
 I DF="" S $EC=",U-INVALID-DIRECTORY,"
"RTN","ZISHGUX",185,0)
 ;
"RTN","ZISHGUX",186,0)
 Q DF
"RTN","ZISHGUX",187,0)
 ;
"RTN","ZISHGUX",188,0)
MKDIR(DIR) ; ef,SR. *10002* Make directory
"RTN","ZISHGUX",189,0)
 N % S %=$$RETURN^%ZOSV("mkdir -p "_DIR,1)
"RTN","ZISHGUX",190,0)
 Q %
"RTN","ZISHGUX",191,0)
 ;
"RTN","ZISHGUX",192,0)
SIZE(DIR,FILE) ; ef,SR. *10002* Get Size of a File
"RTN","ZISHGUX",193,0)
 I $ZV["Darwin" Q $$RETURN^%ZOSV("stat -f%z "_$$DEFDIR(DIR)_FILE)
"RTN","ZISHGUX",194,0)
 Q $$RETURN^%ZOSV("stat -c%s "_$$DEFDIR(DIR)_FILE)
"RTN","ZISHGUX",195,0)
 ;
"RTN","ZISHGUX",196,0)
WGETSYNC(server,remoteDir,localDir,filePatt,port,isTLS) ; ef,SR. *10002* Sync remote directory
"RTN","ZISHGUX",197,0)
 s port=$g(port,443)
"RTN","ZISHGUX",198,0)
 s isTLS=$g(isTLS,1)
"RTN","ZISHGUX",199,0)
 ;
"RTN","ZISHGUX",200,0)
 i $e(remoteDir)'="/" s remoteDir="/"_remoteDir
"RTN","ZISHGUX",201,0)
 ;
"RTN","ZISHGUX",202,0)
 n url s url="http"
"RTN","ZISHGUX",203,0)
 i isTLS s url=url_"s"
"RTN","ZISHGUX",204,0)
 s url=url_"://"_server_":"_port_remoteDir
"RTN","ZISHGUX",205,0)
 ;
"RTN","ZISHGUX",206,0)
 ; -r recursive
"RTN","ZISHGUX",207,0)
 ; -N Turn on time-stamping
"RTN","ZISHGUX",208,0)
 ; -nd Do not create directories
"RTN","ZISHGUX",209,0)
 ; -np Do not follow follow
"RTN","ZISHGUX",210,0)
 ; -A What to accept (file pattern)
"RTN","ZISHGUX",211,0)
 ; -P where to save
"RTN","ZISHGUX",212,0)
 ;
"RTN","ZISHGUX",213,0)
 ; Get compressed file from remote source
"RTN","ZISHGUX",214,0)
 n %cmd s %cmd="wget --header='Accept-Encoding: gzip' -rNndp -A '"_filePatt_"' '"_url_"' -P "_localDir
"RTN","ZISHGUX",215,0)
 n % s %=$$RETURN^%ZOSV(%cmd,1)
"RTN","ZISHGUX",216,0)
 i % quit %
"RTN","ZISHGUX",217,0)
 ;
"RTN","ZISHGUX",218,0)
 ; Rename them to .gz if they are really compressed
"RTN","ZISHGUX",219,0)
 n %cmd s %cmd="for f in `file "_localDir_"/* | grep gzip | cut -d':' -f1`; do mv $f $f.gz; done"
"RTN","ZISHGUX",220,0)
 n % s %=$$RETURN^%ZOSV(%cmd,1)
"RTN","ZISHGUX",221,0)
 i % quit %
"RTN","ZISHGUX",222,0)
 ;
"RTN","ZISHGUX",223,0)
 ; gunzip (but don't warn if there is nothing to do: -q)
"RTN","ZISHGUX",224,0)
 n %cmd s %cmd="gzip -dq "_localDir_"/*"
"RTN","ZISHGUX",225,0)
 n % s %=$$RETURN^%ZOSV(%cmd,1)
"RTN","ZISHGUX",226,0)
 i %=1 s %=0 ; BSD gzip (in OS X) will return 1 if there are no files to operate on. Error safe to ignore.
"RTN","ZISHGUX",227,0)
 i % quit %
"RTN","ZISHGUX",228,0)
 ;
"RTN","ZISHGUX",229,0)
 ; dos2unix
"RTN","ZISHGUX",230,0)
 n %cmd s %cmd="dos2unix "_localDir_"/"_filePatt
"RTN","ZISHGUX",231,0)
 n % s %=$$RETURN^%ZOSV(%cmd,1)
"RTN","ZISHGUX",232,0)
 i % quit %
"RTN","ZISHGUX",233,0)
 ;
"RTN","ZISHGUX",234,0)
 quit %
"RTN","ZISHGUX",235,0)
 ;
"RTN","ZISHGUX",236,0)
STATUS() ;ef,SR. Return EOF status
"RTN","ZISHGUX",237,0)
 U $I
"RTN","ZISHGUX",238,0)
 Q $ZEOF
"RTN","ZISHGUX",239,0)
 ;
"RTN","ZISHGUX",240,0)
EOF(X) ;Eof flag, Pass in $ZA
"RTN","ZISHGUX",241,0)
 Q X
"RTN","ZISHGUX",242,0)
 ;
"RTN","ZISHGUX",243,0)
MAKEREF(HF,IX,OVF) ;Internal call to rebuild global ref.
"RTN","ZISHGUX",244,0)
 ;Return %ZISHF,%ZISHO,%ZISHI,%ZISUB
"RTN","ZISHGUX",245,0)
 ; ZEXCEPT: %ZISHF,%ZISHO,%ZISHI,%ZISUB
"RTN","ZISHGUX",246,0)
 N I,F,MX
"RTN","ZISHGUX",247,0)
 S OVF=$G(OVF,"%ZISHOF")
"RTN","ZISHGUX",248,0)
 S %ZISHI=$QS(HF,IX),MX=$QL(HF) ;
"RTN","ZISHGUX",249,0)
 S F=$NA(@HF,IX-1) ;Get first part
"RTN","ZISHGUX",250,0)
 I IX=1 S %ZISHF=F_"(%ZISHI" ;Build root, IX=1
"RTN","ZISHGUX",251,0)
 I IX>1 S %ZISHF=$E(F,1,$L(F)-1)_",%ZISHI" ;Build root
"RTN","ZISHGUX",252,0)
 S %ZISHO=%ZISHF_","_OVF_",%OVFCNT)" ;Make overflow
"RTN","ZISHGUX",253,0)
 F I=IX+1:1:MX S %ZISHF=%ZISHF_",%ZISUB("_I_")",%ZISUB(I)=$QS(HF,I)
"RTN","ZISHGUX",254,0)
 S %ZISHF=%ZISHF_")"
"RTN","ZISHGUX",255,0)
 Q
"RTN","ZISHGUX",256,0)
FTG(%ZX1,%ZX2,%ZX3,%ZX4,%ZX5) ;ef,SR. Unload contents of host file into global
"RTN","ZISHGUX",257,0)
 ;p1=host file directory
"RTN","ZISHGUX",258,0)
 ;p2=host file name
"RTN","ZISHGUX",259,0)
 ;p3= $NAME REFERENCE INCLUDING STARTING SUBSCRIPT
"RTN","ZISHGUX",260,0)
 ;p4=INCREMENT SUBSCRIPT
"RTN","ZISHGUX",261,0)
 ;p5=Overflow subscript, defaults to "OVF"
"RTN","ZISHGUX",262,0)
 ; 
"RTN","ZISHGUX",263,0)
 N %ZA,%ZB,%ZC,%ZL,X,%OVFCNT,%CONT,%EXIT,%XX
"RTN","ZISHGUX",264,0)
 N I,%ZISH,%ZISH1,%ZISHI,%ZISHL,%ZISHLGR,%ZISHOF,%ZISHOX,%ZISHS,%ZX,%ZISHY,POP,%ZISUB,%ZISHF,%ZISHO
"RTN","ZISHGUX",265,0)
 S %ZX1=$$DEFDIR($G(%ZX1)),%ZISHOF=$G(%ZX5,"OVF")
"RTN","ZISHGUX",266,0)
 D MAKEREF(%ZX3,%ZX4,"%ZISHOF")
"RTN","ZISHGUX",267,0)
 D OPEN^%ZISH(,%ZX1,%ZX2,"R")
"RTN","ZISHGUX",268,0)
 I POP Q 0
"RTN","ZISHGUX",269,0)
 N $ETRAP S %EXIT=0,$ETRAP="S %ZA=1,%EXIT=1,$ECODE="""" Q"
"RTN","ZISHGUX",270,0)
 N MAX S MAX=$$MAXREC(%ZISHF)
"RTN","ZISHGUX",271,0)
 U IO F  K %XX D READNXT(.%XX,MAX) Q:$$EOF(%ZA)  D
"RTN","ZISHGUX",272,0)
 . S @%ZISHF=%XX
"RTN","ZISHGUX",273,0)
 . I $D(%XX)>2 F %OVFCNT=1:1 Q:'$D(%XX(%OVFCNT))  S @%ZISHO=%XX(%OVFCNT)
"RTN","ZISHGUX",274,0)
 . S %ZISHI=%ZISHI+1
"RTN","ZISHGUX",275,0)
 . Q
"RTN","ZISHGUX",276,0)
 D CLOSE() ;Normal exit
"RTN","ZISHGUX",277,0)
 Q '%EXIT
"RTN","ZISHGUX",278,0)
 ;
"RTN","ZISHGUX",279,0)
READNXT(REC,MAX) ;
"RTN","ZISHGUX",280,0)
 ; ZEXCEPT: %ZA
"RTN","ZISHGUX",281,0)
 N T,I,X,%
"RTN","ZISHGUX",282,0)
 U IO R X:0 S %ZA=$ZEOF,REC=$E(X,1,MAX-1)
"RTN","ZISHGUX",283,0)
 Q:$L(X)<MAX
"RTN","ZISHGUX",284,0)
 S %=MAX
"RTN","ZISHGUX",285,0)
 F I=1:1 Q:$L(X)<%  S REC(I)=$E(X,%,%+(MAX-2)),%=%+(MAX-1)
"RTN","ZISHGUX",286,0)
 Q
"RTN","ZISHGUX",287,0)
 ;
"RTN","ZISHGUX",288,0)
GTF(%ZX1,%ZX2,%ZX3,%ZX4) ;ef,SR. Load contents of global to host file.
"RTN","ZISHGUX",289,0)
 ;Previously name LOAD
"RTN","ZISHGUX",290,0)
 ;p1=$NAME of global reference
"RTN","ZISHGUX",291,0)
 ;p2=incrementing subscript
"RTN","ZISHGUX",292,0)
 ;p3=host file directory
"RTN","ZISHGUX",293,0)
 ;p4=host file name
"RTN","ZISHGUX",294,0)
 N %ZISHY,%ZISHLGR,%ZISHOX
"RTN","ZISHGUX",295,0)
 S %ZISHY=$$MGTF(%ZX1,%ZX2,$G(%ZX3),%ZX4,"W")
"RTN","ZISHGUX",296,0)
 Q %ZISHY
"RTN","ZISHGUX",297,0)
 ;
"RTN","ZISHGUX",298,0)
GATF(%ZX1,%ZX2,%ZX3,%ZX4) ;ef,SR. Append to host file.
"RTN","ZISHGUX",299,0)
 ;
"RTN","ZISHGUX",300,0)
 ;p1=$NAME of global reference
"RTN","ZISHGUX",301,0)
 ;p2=incrementing subscript
"RTN","ZISHGUX",302,0)
 ;p3=host file directory
"RTN","ZISHGUX",303,0)
 ;p4=host file name
"RTN","ZISHGUX",304,0)
 N %ZISHY
"RTN","ZISHGUX",305,0)
 S %ZISHY=$$MGTF(%ZX1,%ZX2,$G(%ZX3),%ZX4,"A")
"RTN","ZISHGUX",306,0)
 Q %ZISHY
"RTN","ZISHGUX",307,0)
 ;
"RTN","ZISHGUX",308,0)
MGTF(%ZX1,%ZX2,%ZX3,%ZX4,%ZX5) ;
"RTN","ZISHGUX",309,0)
 ;p1=$NAME of global reference
"RTN","ZISHGUX",310,0)
 ;p2=incrementing subscript
"RTN","ZISHGUX",311,0)
 ;p3=host file directory
"RTN","ZISHGUX",312,0)
 ;p4=host file name
"RTN","ZISHGUX",313,0)
 ; ZEXCEPT: POP
"RTN","ZISHGUX",314,0)
 N %ZISH,%ZISH1,%ZISHI,%ZISHL,%ZISHLGR,%ZISHS,%ZISHOX,IO,%ZX,Y,%ZISHF
"RTN","ZISHGUX",315,0)
 D MAKEREF(%ZX1,%ZX2)
"RTN","ZISHGUX",316,0)
 D OPEN^%ZISH(,%ZX3,%ZX4,%ZX5) ;Default dir set in open
"RTN","ZISHGUX",317,0)
 I POP Q 0
"RTN","ZISHGUX",318,0)
 U IO
"RTN","ZISHGUX",319,0)
 N $ETRAP S $ETRAP="S $EC="""" D CLOSE^%ZISH() Q 0"
"RTN","ZISHGUX",320,0)
 ;
"RTN","ZISHGUX",321,0)
 ; This algorithm takes 20ms for 200,4,5; 
"RTN","ZISHGUX",322,0)
 ; Prev algo was faster I think, but had a bug where it would stop early if we skipped a sub
"RTN","ZISHGUX",323,0)
 D  F  S %ZISHI=$O(@$NA(@%ZX1,%ZX2-1)@(%ZISHI)) Q:'%ZISHI  D
"RTN","ZISHGUX",324,0)
 . Q:'($D(@%ZISHF)#2)
"RTN","ZISHGUX",325,0)
 . W @%ZISHF,!
"RTN","ZISHGUX",326,0)
 D CLOSE() ;Normal Exit
"RTN","ZISHGUX",327,0)
 Q 1
"RTN","ZISHGUX",328,0)
 ;
"RTN","ZISHGUX",329,0)
MAXREC(GLO) ; [Public] Maximum Record Size for a Global
"RTN","ZISHGUX",330,0)
 ; Global passed by name
"RTN","ZISHGUX",331,0)
 N REGION S REGION=$VIEW("REGION",$NA(@GLO))
"RTN","ZISHGUX",332,0)
 I REGION="" S $EC=",U-ERROR,"
"RTN","ZISHGUX",333,0)
 I $T(^%PEEKBYNAME)]"" Q $$^%PEEKBYNAME("gd_region.max_rec_size",REGION)
"RTN","ZISHGUX",334,0)
 I $T(^%DSEWRAP)]"" N FDUMP D  Q FDUMP(REGION,"Maximum record size")
"RTN","ZISHGUX",335,0)
 . D DUMP^%DSEWRAP(REGION,.FDUMP,"fileheader","all")
"RTN","ZISHGUX",336,0)
 ;
"RTN","ZISHGUX",337,0)
 ; -- RPMS ENTRY POINTS! --
"RTN","ZISHGUX",338,0)
 ;
"RTN","ZISHGUX",339,0)
DF(X) ;Directory format
"RTN","ZISHGUX",340,0)
 ; Pass X by ref - both input and output
"RTN","ZISHGUX",341,0)
 Q:X=""
"RTN","ZISHGUX",342,0)
 S X=$TR(X,"\","/")
"RTN","ZISHGUX",343,0)
 S:$E(X,$L(X))'="/" X=X_"/"
"RTN","ZISHGUX",344,0)
 Q
"RTN","ZISHGUX",345,0)
 ;
"RTN","ZISHGUX",346,0)
SEND(ZISH1,ZISH2,ZISH3,ZISHPARM) ;Send UNIX or Windows fl
"RTN","ZISHGUX",347,0)
 Q ""
"RTN","ZISHGUX",348,0)
 ;
"RTN","ZISHGUX",349,0)
SENDTO1(ZISH1,ZISH2)         ;use sendto1 script
"RTN","ZISHGUX",350,0)
 Q ""
"RTN","ZISHONT")
0^21^B103215011
"RTN","ZISHONT",1,0)
%ZISH ;IHS/PR,SFISC/AC - Host File Control for Cache for VMS/NT/UNIX ; 6/6/18 7:39am
"RTN","ZISHONT",2,0)
 ;;8.0;KERNEL;**34,65,84,104,191,306,385,440,518,524,546,599,10002**;JUL 10, 1995;Build 26
"RTN","ZISHONT",3,0)
 ;
"RTN","ZISHONT",4,0)
 ; *10002* changes (c) Sam Habiel 2018
"RTN","ZISHONT",5,0)
 ; Licensed under Apache 2.0
"RTN","ZISHONT",6,0)
 ; Unit Tests can be found in routine ZOSVONUT.
"RTN","ZISHONT",7,0)
 ;
"RTN","ZISHONT",8,0)
 ; ZEXCEPT: IOM,IOSL,IOT,POP
"RTN","ZISHONT",9,0)
OPEN(X1,X2,X3,X4,X5,X6)    ;SR. Open Host File
"RTN","ZISHONT",10,0)
 ;X1=handle name
"RTN","ZISHONT",11,0)
 ;X2=directory name \dir\
"RTN","ZISHONT",12,0)
 ;X3=file name
"RTN","ZISHONT",13,0)
 ;X4=file access mode e.g.: W for write, R for read, A for append.
"RTN","ZISHONT",14,0)
 ;X5=Max record size for a new file, X6=Subtype
"RTN","ZISHONT",15,0)
 N %,%1,%2,%I,%ZOS,%T,%ZA,%ZISHIO,$ET
"RTN","ZISHONT",16,0)
 S $ET="D OPNERR^%ZISH"
"RTN","ZISHONT",17,0)
 S U="^",%I=$I,%T=0,POP=0,X2=$$DEFDIR($G(X2)),%ZOS=$$OS^%ZOSV M %ZISHIO=IO
"RTN","ZISHONT",18,0)
 I %ZOS'="VMS" S %1=$S(X4["A":"AW",X4["W":"WN",1:"R")_$S(X4["B":"U",1:"S") ;NT & Unix
"RTN","ZISHONT",19,0)
 I %ZOS="VMS" S %1=$S(X4["A":"AW",X4["W":"WN",1:"RH")_$S(X4["B":"U",1:"S")
"RTN","ZISHONT",20,0)
 ;The next line eliminates the <ENDOFFILE> error for sequential files for the current process.
"RTN","ZISHONT",21,0)
 S %ZA=$$ENDOFILE^%ZISUTL ;p599 Work like DSM
"RTN","ZISHONT",22,0)
 S %=X2_X3 O %:(%1):2 I '$T S POP=1 Q
"RTN","ZISHONT",23,0)
 S IO=%,IO(1,IO)="",IOT="HFS",IOM=80,IOSL=60,POP=0 D SUBTYPE^%ZIS3($G(X6,"P-OTHER"))
"RTN","ZISHONT",24,0)
 I $G(X1)]"" D SAVDEV^%ZISUTL(X1)
"RTN","ZISHONT",25,0)
 Q
"RTN","ZISHONT",26,0)
 ;
"RTN","ZISHONT",27,0)
OPNERR ;Handle open error
"RTN","ZISHONT",28,0)
 ; ZEXCEPT: POP
"RTN","ZISHONT",29,0)
 S POP=1,$ECODE=""
"RTN","ZISHONT",30,0)
 ;I $L($G(%I)) U %I
"RTN","ZISHONT",31,0)
 Q
"RTN","ZISHONT",32,0)
 ;
"RTN","ZISHONT",33,0)
CLOSE(X) ;SR. Close HFS device not opened by %ZIS.
"RTN","ZISHONT",34,0)
 ;X=HANDLE NAME
"RTN","ZISHONT",35,0)
 ;IO=Device
"RTN","ZISHONT",36,0)
 N %
"RTN","ZISHONT",37,0)
 I $L($G(IO)) C IO K IO(1,IO)
"RTN","ZISHONT",38,0)
 I $L($G(X)) D RMDEV^%ZISUTL(X)
"RTN","ZISHONT",39,0)
 ;Only reset home if one setup.
"RTN","ZISHONT",40,0)
 I $D(IO("HOME"))!$D(^XUTL("XQ",$J,"IOS")) D HOME^%ZIS
"RTN","ZISHONT",41,0)
 Q
"RTN","ZISHONT",42,0)
 ;
"RTN","ZISHONT",43,0)
OPENERR ;
"RTN","ZISHONT",44,0)
 Q 0
"RTN","ZISHONT",45,0)
 ;
"RTN","ZISHONT",46,0)
DEL(%ZX1,%ZX2) ;ef,SR. Del files, return 1 if deleted all requested.
"RTN","ZISHONT",47,0)
 ;S Y=$$DEL^%ZISH("dir path",$NA(array))
"RTN","ZISHONT",48,0)
 ; will invoke an OS command to delete file(s)
"RTN","ZISHONT",49,0)
 ; UNIX: rm -f filespec[ ...]
"RTN","ZISHONT",50,0)
 ; VMS: del filespec[,...]
"RTN","ZISHONT",51,0)
 N %ZARG,%ZXDEL,%ZOS,%ZDELIM,%ZCOMND,%ZLIST
"RTN","ZISHONT",52,0)
 S %ZARG="",%ZXDEL=1
"RTN","ZISHONT",53,0)
 S %ZX1=$$DEFDIR($G(%ZX1))
"RTN","ZISHONT",54,0)
 S %ZOS=$$OS^%ZOSV
"RTN","ZISHONT",55,0)
 S %ZDELIM=$S(%ZOS="UNIX":" ",1:",")
"RTN","ZISHONT",56,0)
 S %ZCOMND=$S(%ZOS="UNIX":"rm -f ",1:"del ")
"RTN","ZISHONT",57,0)
 D
"RTN","ZISHONT",58,0)
 . N $ETRAP,$ESTACK S $ETRAP="D DELERR^%ZISH"
"RTN","ZISHONT",59,0)
 . N %,%ZI,%ZISH,%ZX,%ZFOUND S %ZISH=""
"RTN","ZISHONT",60,0)
 . F %ZI=1:1 S %ZISH=$O(@%ZX2@(%ZISH)) Q:%ZISH=""  D
"RTN","ZISHONT",61,0)
 . . N $ETRAP,$ESTACK S $ETRAP="D DELERR^%ZISH"
"RTN","ZISHONT",62,0)
 . . I %ZISH["*" S %ZXDEL=0 Q  ; Wild card not allowed.
"RTN","ZISHONT",63,0)
 . . S %ZX=$S(%ZISH[%ZX1:%ZISH,1:%ZX1_%ZISH) ; prepend directory path
"RTN","ZISHONT",64,0)
 . . I %ZOS="VMS",%ZX'[";" S %ZX=%ZX_";*"
"RTN","ZISHONT",65,0)
 . . S %ZFOUND=$ZSEARCH(%ZX)]""  ; File exists
"RTN","ZISHONT",66,0)
 . . S:%ZFOUND %ZARG=$S(%ZARG="":%ZX,1:%ZARG_%ZDELIM_%ZX) ; join files
"RTN","ZISHONT",67,0)
 . . I $L(%ZARG)>2000 S %=$ZF(-1,%ZCOMND_%ZARG),%ZARG="" H 1 ; delete files at a time
"RTN","ZISHONT",68,0)
 . ;
"RTN","ZISHONT",69,0)
 . I $L(%ZARG) S %=$ZF(-1,%ZCOMND_%ZARG) ; delete remaining files
"RTN","ZISHONT",70,0)
 ;
"RTN","ZISHONT",71,0)
 I %ZXDEL S %ZXDEL='$$LIST(%ZX1,%ZX2,"%ZLIST")
"RTN","ZISHONT",72,0)
 Q %ZXDEL
"RTN","ZISHONT",73,0)
 ;
"RTN","ZISHONT",74,0)
DELERR ;Trap any $ETRAP error, unwind and return.
"RTN","ZISHONT",75,0)
 ; ZEXCEPT: %ZARG,%ZXDEL
"RTN","ZISHONT",76,0)
 S $ETRAP="D UNWIND^%ZTER"
"RTN","ZISHONT",77,0)
 S %ZXDEL=0,%ZARG=""
"RTN","ZISHONT",78,0)
 D UNWIND^%ZTER
"RTN","ZISHONT",79,0)
 Q
"RTN","ZISHONT",80,0)
 ;
"RTN","ZISHONT",81,0)
DEL1(%ZX3) ;ef,SR. Delete one file
"RTN","ZISHONT",82,0)
 N %ZI1,%ZI2
"RTN","ZISHONT",83,0)
 D SPLIT(%ZX3,.%ZI1,.%ZI2) S %ZI2(%ZI2)=""
"RTN","ZISHONT",84,0)
 Q $$DEL(%ZI1,$NA(%ZI2))
"RTN","ZISHONT",85,0)
 ;
"RTN","ZISHONT",86,0)
SPLIT(%I,%O1,%O2) ;Split to path,file
"RTN","ZISHONT",87,0)
 N %ZOS,%D,D S %ZOS=$$OS^%ZOSV
"RTN","ZISHONT",88,0)
 I %ZOS["VMS" D  Q
"RTN","ZISHONT",89,0)
 . S D=$S(%I["]":"]",1:":")
"RTN","ZISHONT",90,0)
 . S %O1=$P(%I,D,1)_D,%O2=$P(%I,D,2)
"RTN","ZISHONT",91,0)
 . Q
"RTN","ZISHONT",92,0)
 S %D=$S(%ZOS="UNIX":"/",%ZOS="NT":"\",1:""),%O1="",%O2="" Q:%D=""
"RTN","ZISHONT",93,0)
 S D=$L(%I,%D),%O1=$P(%I,%D,1,D-1),%O2=$P(%I,%D,D)
"RTN","ZISHONT",94,0)
 Q
"RTN","ZISHONT",95,0)
 ;
"RTN","ZISHONT",96,0)
FEXIST(%PATH,%FL) ;Check if files exsist.
"RTN","ZISHONT",97,0)
 ;S Y=$$DTEST("/usr/var",$NA(array))
"RTN","ZISHONT",98,0)
 N %ZISH,%ZISHY
"RTN","ZISHONT",99,0)
 S %ZISH=$$LIST(%PATH,%FL,"%ZISHY")
"RTN","ZISHONT",100,0)
 Q %ZISH
"RTN","ZISHONT",101,0)
 ;
"RTN","ZISHONT",102,0)
LIST(%ZX1,%ZX2,%ZX3) ;ef,SR. Create a local array holding file names
"RTN","ZISHONT",103,0)
 ;S Y=$$LIST^%ZISH("\dir\",$NA(array),$NA(return array)) Return 1 if found anything
"RTN","ZISHONT",104,0)
 ;
"RTN","ZISHONT",105,0)
 N %ZISH,%ZISHN,%ZX,%ZISHY,%ZY,%ZOS
"RTN","ZISHONT",106,0)
 S %ZX1=$$DEFDIR($G(%ZX1)),%ZOS=$$OS^%ZOSV
"RTN","ZISHONT",107,0)
 ;S %ZX1=$$TRNLNM(%ZX1)
"RTN","ZISHONT",108,0)
 ;Get fls to act on
"RTN","ZISHONT",109,0)
 S %ZISH="" F  S %ZISH=$O(@%ZX2@(%ZISH)) Q:%ZISH=""  D
"RTN","ZISHONT",110,0)
 . S %ZISHY=$P(%ZISH,"*")
"RTN","ZISHONT",111,0)
 . I %ZOS="VMS",%ZISH'["." S %ZISH=%ZISH_".*" ;Allways upper
"RTN","ZISHONT",112,0)
 . ;NT, display case, ignore for lookup
"RTN","ZISHONT",113,0)
 . S %ZX=%ZX1_%ZISH
"RTN","ZISHONT",114,0)
 . F %ZISHN=0:1 D  Q:(%ZX="")
"RTN","ZISHONT",115,0)
 . . S %ZX=$ZSEARCH($S(%ZISHN:"",1:%ZX))
"RTN","ZISHONT",116,0)
 . . ;Q:(%ZX="")!($$UP^XLFSTR(%ZX)'[%ZISHY)!(%ZX?.E1.2".")
"RTN","ZISHONT",117,0)
 . . Q:(%ZX="")!(%ZX?.E1.2".")
"RTN","ZISHONT",118,0)
 . . I %ZOS="VMS" S %ZX=$P(%ZX,"]",2),@%ZX3@(%ZX)=""
"RTN","ZISHONT",119,0)
 . . I %ZOS="NT" S %ZY=$P(%ZX,"\",$L(%ZX,"\")),@%ZX3@(%ZY)=""
"RTN","ZISHONT",120,0)
 . . I %ZOS="UNIX" S %ZY=$P(%ZX,"/",$L(%ZX,"/")) Q:%ZX'[%ZISHY  S @%ZX3@(%ZY)=""
"RTN","ZISHONT",121,0)
 . . Q
"RTN","ZISHONT",122,0)
 Q $O(@%ZX3@(""))]""
"RTN","ZISHONT",123,0)
 ;
"RTN","ZISHONT",124,0)
MV(X1,X2,Y1,Y2) ;ef,SR. Rename a fl
"RTN","ZISHONT",125,0)
 ;S Y=$$MV^ZOSHDOS("\dir\","fl","\dir\","fl")
"RTN","ZISHONT",126,0)
 ;Unix use mv, NT/VMS use COPY and DEL
"RTN","ZISHONT",127,0)
 N %,X,Y,%ZOS,%ZISHX S %ZOS=$$OS^%ZOSV
"RTN","ZISHONT",128,0)
 S X1=$$DEFDIR($G(X1)),Y1=$$DEFDIR($G(Y1))
"RTN","ZISHONT",129,0)
 S X=$ZSEARCH(X1_X2),Y=Y1_Y2 ;move X to Y
"RTN","ZISHONT",130,0)
 I X="" Q 0
"RTN","ZISHONT",131,0)
 ;Move to same place can delete file. Since at destination return 1
"RTN","ZISHONT",132,0)
 I $P(X,";")=Y Q 1
"RTN","ZISHONT",133,0)
 S %=$ZF(-1,$S(%ZOS="UNIX":"mv ",1:"copy ")_X_" "_Y) ;Use NT/VMS copy
"RTN","ZISHONT",134,0)
 I %ZOS'="UNIX" D
"RTN","ZISHONT",135,0)
 . S X2=$P(X,X1,2),%ZISHX(X2)=""
"RTN","ZISHONT",136,0)
 . S Y=$$DEL^%ZISH(X1,$NA(%ZISHX))
"RTN","ZISHONT",137,0)
 Q 1
"RTN","ZISHONT",138,0)
 ;
"RTN","ZISHONT",139,0)
PWD() ;ef,SR. Print working directory
"RTN","ZISHONT",140,0)
 N Y,%ZOS
"RTN","ZISHONT",141,0)
 S Y=$$DEFDIR(""),%ZOS=$$OS^%ZOSV
"RTN","ZISHONT",142,0)
 I Y="" S Y=$ZSEARCH("*")
"RTN","ZISHONT",143,0)
 Q $S(%ZOS["VMS":Y,1:$P(Y,".",1))
"RTN","ZISHONT",144,0)
 ;
"RTN","ZISHONT",145,0)
TRNLNM(PATH) ;ef. Expand logical path
"RTN","ZISHONT",146,0)
 N %ZOS,P1,P2
"RTN","ZISHONT",147,0)
 S %ZOS=$$OS^%ZOSV,PATH=$G(PATH)
"RTN","ZISHONT",148,0)
 I %ZOS="VMS" D  Q PATH
"RTN","ZISHONT",149,0)
 . S P1=PATH_$S(PATH[":":"*.*",1:":*.*")
"RTN","ZISHONT",150,0)
 . S P2=$ZSEARCH(P1)
"RTN","ZISHONT",151,0)
 . S:$L(P2) PATH=$S(P2["]":$P(P2,"]",1,$L(P2,"]")-1)_"]",1:$P(P2,":",1)_":")
"RTN","ZISHONT",152,0)
 . Q
"RTN","ZISHONT",153,0)
 I %ZOS="NT" D  Q PATH
"RTN","ZISHONT",154,0)
 . S P1=PATH_$S($E(PATH,$L(PATH))'="\":"\*",1:"*"),P2=$ZSEARCH(P1)
"RTN","ZISHONT",155,0)
 . S:$L(P2) PATH=$P(P2,"\",1,$L(P2,"\")-1)_"\"
"RTN","ZISHONT",156,0)
 . Q
"RTN","ZISHONT",157,0)
 ;Unix Cache $ZSEARCH uses % around an environment variable
"RTN","ZISHONT",158,0)
 I %ZOS="UNIX" D  Q PATH
"RTN","ZISHONT",159,0)
 . S P1=PATH_$S($E(PATH,$L(PATH))'="/":"/*",1:"*"),P2=$ZSEARCH(P1)
"RTN","ZISHONT",160,0)
 . S:$L(P2) PATH=$P(P2,"/",1,$L(P2,"/")-1)_"/"
"RTN","ZISHONT",161,0)
 . Q
"RTN","ZISHONT",162,0)
 Q PATH
"RTN","ZISHONT",163,0)
 ;
"RTN","ZISHONT",164,0)
DEFDIR(DF) ;ef. Default Dir and frmt
"RTN","ZISHONT",165,0)
 ;Need to handle NT, VMS and Linux
"RTN","ZISHONT",166,0)
 N %ZOS,P1,P2 S %ZOS=$$OS^%ZOSV,DF=$G(DF)
"RTN","ZISHONT",167,0)
 Q:DF="." "" ;Special way to get current dir.
"RTN","ZISHONT",168,0)
 S:DF="" DF=$G(^XTV(8989.3,1,"DEV")),DF=$P(DF,"^",$S($$PRI^%ZOSV<2:1,1:2))
"RTN","ZISHONT",169,0)
 Q:DF="" ""
"RTN","ZISHONT",170,0)
 ;Check syntax, VMS needs disk:[dir] or logical:
"RTN","ZISHONT",171,0)
 I %ZOS="VMS" D
"RTN","ZISHONT",172,0)
 . I DF[":" S P1=$P(DF,":")_":",P2=$P(DF,":",2)
"RTN","ZISHONT",173,0)
 . E  S P1="",P2=DF
"RTN","ZISHONT",174,0)
 . I P1="",P2["$" S P1=P2,P2=""  ;Could be a logical
"RTN","ZISHONT",175,0)
 . I $L(P2) S:P2'["[" P2="["_P2 S:P2'["]" P2=P2_"]"
"RTN","ZISHONT",176,0)
 . S DF=P1_P2 S:DF'[":" DF=DF_":"
"RTN","ZISHONT",177,0)
 . Q
"RTN","ZISHONT",178,0)
 ;Check syntax, Unix needs /mnt/fl, ./fl, ~/fl %HOME%/fl
"RTN","ZISHONT",179,0)
 I %ZOS="UNIX" D
"RTN","ZISHONT",180,0)
 . S DF=$TR(DF,"\","/")
"RTN","ZISHONT",181,0)
 . S:$E(DF,$L(DF))'="/" DF=DF_"/"
"RTN","ZISHONT",182,0)
 . Q
"RTN","ZISHONT",183,0)
 ;Check syntax, NT needs c:\dir\ or \\server\folder\
"RTN","ZISHONT",184,0)
 I %ZOS="NT" D
"RTN","ZISHONT",185,0)
 . N P1,P2
"RTN","ZISHONT",186,0)
 . I '(DF?1(1A1":\",1"\\").E) S DF=$$DEFDIR("")
"RTN","ZISHONT",187,0)
 . S P1="",P2=DF
"RTN","ZISHONT",188,0)
 . I DF[":" S P1=$P(DF,":")_":",P2=$P(DF,":",2)
"RTN","ZISHONT",189,0)
 . S P2=$TR(P2,"/","\")
"RTN","ZISHONT",190,0)
 . I $L(P2) S:".\"'[$E(P2,1) P2="\"_P2 S:$E(P2,$L(P2))'="\" P2=P2_"\"
"RTN","ZISHONT",191,0)
 . S DF=P1_P2
"RTN","ZISHONT",192,0)
 . Q
"RTN","ZISHONT",193,0)
 S DF=$$TRNLNM(DF) ;Resolve logicals
"RTN","ZISHONT",194,0)
 Q DF
"RTN","ZISHONT",195,0)
 ;
"RTN","ZISHONT",196,0)
FL(X) ;Fl len
"RTN","ZISHONT",197,0)
 N ZOSHP1,ZOSHP2
"RTN","ZISHONT",198,0)
 S ZOSHP1=$P(X,"."),ZOSHP2=$P(X,".",2)
"RTN","ZISHONT",199,0)
 I $L(ZOSHP1)>8 S X=4 Q
"RTN","ZISHONT",200,0)
 I $L(ZOSHP2)>3 S X=4 Q
"RTN","ZISHONT",201,0)
 Q
"RTN","ZISHONT",202,0)
 ;
"RTN","ZISHONT",203,0)
STATUS() ;ef,SR. Return EOF status
"RTN","ZISHONT",204,0)
 U $I
"RTN","ZISHONT",205,0)
 Q $$EOF($ZEOF)
"RTN","ZISHONT",206,0)
 ;
"RTN","ZISHONT",207,0)
EOF(X) ;Eof flag, pass in $ZEOF
"RTN","ZISHONT",208,0)
 Q (X=-1)
"RTN","ZISHONT",209,0)
 ;
"RTN","ZISHONT",210,0)
MKDIR(DIR) ; ef,SR. *10002* Make directory
"RTN","ZISHONT",211,0)
 N OS S OS=$$OS^%ZOSV()
"RTN","ZISHONT",212,0)
 I OS="UNIX" Q $$RETURN^%ZOSV("mkdir -p "_DIR,1)
"RTN","ZISHONT",213,0)
 I OS="NT" N % D  Q %
"RTN","ZISHONT",214,0)
 . S %=$$RETURN^%ZOSV("mkdir "_DIR,1) ; Windows does not need parents flag since Windows XP
"RTN","ZISHONT",215,0)
 . I %=1 S %=0 ; Directory already exists; no way to suppress this error.
"RTN","ZISHONT",216,0)
 ;
"RTN","ZISHONT",217,0)
 S $EC=",U-UNIMPLEMENTED," ; Don't support VMS.
"RTN","ZISHONT",218,0)
 ;
"RTN","ZISHONT",219,0)
SIZE(DIR,FILE) ; ef,SR. *10002* Get Size of a File
"RTN","ZISHONT",220,0)
 N OS S OS=$$OS^%ZOSV()
"RTN","ZISHONT",221,0)
 I OS="UNIX" Q $$RETURN^%ZOSV("stat -c%s "_$$DEFDIR(DIR)_FILE)
"RTN","ZISHONT",222,0)
 ;
"RTN","ZISHONT",223,0)
 ; WINDOWS IS NASTY!
"RTN","ZISHONT",224,0)
 ; https://stackoverflow.com/questions/483864/windows-command-for-file-size-only
"RTN","ZISHONT",225,0)
 I OS="NT" Q $$RETURN^%ZOSV("for %I in ("_$$DEFDIR(DIR)_FILE_") do @echo %~zI")
"RTN","ZISHONT",226,0)
 ;
"RTN","ZISHONT",227,0)
 S $EC=",U-UNIMPLEMENTED," ; Don't support VMS.
"RTN","ZISHONT",228,0)
 ;
"RTN","ZISHONT",229,0)
WGETSYNC(server,remoteDir,localDir,filePatt,port,isTLS) ; ef,SR. *10002* Sync remote directory
"RTN","ZISHONT",230,0)
 s port=$g(port,443)
"RTN","ZISHONT",231,0)
 s isTLS=$g(isTLS,1)
"RTN","ZISHONT",232,0)
 ;
"RTN","ZISHONT",233,0)
 i $e(remoteDir)'="/" s remoteDir="/"_remoteDir
"RTN","ZISHONT",234,0)
 ;
"RTN","ZISHONT",235,0)
 n url s url="http"
"RTN","ZISHONT",236,0)
 i isTLS s url=url_"s"
"RTN","ZISHONT",237,0)
 s url=url_"://"_server_":"_port_remoteDir
"RTN","ZISHONT",238,0)
 ;
"RTN","ZISHONT",239,0)
 ; -r recursive
"RTN","ZISHONT",240,0)
 ; -N Turn on time-stamping
"RTN","ZISHONT",241,0)
 ; -nd Do not create directories
"RTN","ZISHONT",242,0)
 ; -np Do not follow follow
"RTN","ZISHONT",243,0)
 ; -A What to accept (file pattern)
"RTN","ZISHONT",244,0)
 ; -P where to save
"RTN","ZISHONT",245,0)
 ;
"RTN","ZISHONT",246,0)
 N OS S OS=$$OS^%ZOSV()
"RTN","ZISHONT",247,0)
 I OS="NT" Q $$WGETWIN
"RTN","ZISHONT",248,0)
 I OS'="UNIX" S $EC=",U-UNIMPLMENTED,"
"RTN","ZISHONT",249,0)
 ;
"RTN","ZISHONT",250,0)
 ; Get compressed file from remote source
"RTN","ZISHONT",251,0)
 n %cmd s %cmd="wget --header='Accept-Encoding: gzip' -rNndp -A '"_filePatt_"' '"_url_"' -P "_localDir
"RTN","ZISHONT",252,0)
 n % s %=$$RETURN^%ZOSV(%cmd,1)
"RTN","ZISHONT",253,0)
 i % quit %
"RTN","ZISHONT",254,0)
 ;
"RTN","ZISHONT",255,0)
 ; Rename them to .gz if they are really compressed
"RTN","ZISHONT",256,0)
 n %cmd s %cmd="for f in `file "_localDir_"/* | grep gzip | cut -d':' -f1`; do mv $f $f.gz; done"
"RTN","ZISHONT",257,0)
 n % s %=$$RETURN^%ZOSV(%cmd,1)
"RTN","ZISHONT",258,0)
 i % quit %
"RTN","ZISHONT",259,0)
 ;
"RTN","ZISHONT",260,0)
 ; gunzip (but don't warn if there is nothing to do: -q)
"RTN","ZISHONT",261,0)
 n %cmd s %cmd="gzip -dq "_localDir_"/*"
"RTN","ZISHONT",262,0)
 n % s %=$$RETURN^%ZOSV(%cmd,1)
"RTN","ZISHONT",263,0)
 i % quit %
"RTN","ZISHONT",264,0)
 ;
"RTN","ZISHONT",265,0)
 ; dos2unix
"RTN","ZISHONT",266,0)
 n %cmd s %cmd="dos2unix "_localDir_"/"_filePatt
"RTN","ZISHONT",267,0)
 n % s %=$$RETURN^%ZOSV(%cmd,1)
"RTN","ZISHONT",268,0)
 i % quit %
"RTN","ZISHONT",269,0)
 ;
"RTN","ZISHONT",270,0)
 quit %
"RTN","ZISHONT",271,0)
 ;
"RTN","ZISHONT",272,0)
WGETWIN() ; [Private] Implementation of WGETSYNC for Cache on Windows
"RTN","ZISHONT",273,0)
 ; There is no file command on Windows; so can't identify gzip files
"RTN","ZISHONT",274,0)
 ; So, sad to say, but we will have to download the big fat unzipped files
"RTN","ZISHONT",275,0)
 ; Also, cmd can't use single quotes as delimters. So we have to use ""
"RTN","ZISHONT",276,0)
 ; No dos2unix is necessary since we are on DOS.
"RTN","ZISHONT",277,0)
 ; ZEXCEPT: server,remoteDir,localDir,filePatt,port,isTLS
"RTN","ZISHONT",278,0)
 ;
"RTN","ZISHONT",279,0)
 ; Wget has issues on Windows due to compilation with MinGW CRT.
"RTN","ZISHONT",280,0)
 ; See http://lists.gnu.org/archive/html/bug-wget/2018-06/msg00008.html
"RTN","ZISHONT",281,0)
 ;
"RTN","ZISHONT",282,0)
 ; Wget version I used:
"RTN","ZISHONT",283,0)
 ; https://eternallybored.org/misc/wget/, 64 bit binary
"RTN","ZISHONT",284,0)
 ;
"RTN","ZISHONT",285,0)
 n newFilePatt s newFilePatt=filePatt
"RTN","ZISHONT",286,0)
 i $e(filePatt)="*" s newFilePatt=$e(filePatt)_"["_$e(filePatt,2)_"]"_$e(filePatt,3,99)
"RTN","ZISHONT",287,0)
 n q s q=""""
"RTN","ZISHONT",288,0)
 n sp s sp=" "
"RTN","ZISHONT",289,0)
 s %cmd="wget -rNndp -A "_q_newFilePatt_q_sp_q_url_q_" -P "_localDir
"RTN","ZISHONT",290,0)
 s %=$$RETURN^%ZOSV(%cmd,1)
"RTN","ZISHONT",291,0)
 quit %
"RTN","ZISHONT",292,0)
 ;
"RTN","ZISHONT",293,0)
MAKEREF(HF,IX,OVF) ;Internal call to rebuild global ref.
"RTN","ZISHONT",294,0)
 ;Return %ZISHF,%ZISHO,%ZISHI,%ZISUB
"RTN","ZISHONT",295,0)
 ; ZEXCEPT: %ZISHF,%ZISHI,%ZISHO,%ZISUB
"RTN","ZISHONT",296,0)
 N I,F,MX
"RTN","ZISHONT",297,0)
 S OVF=$G(OVF,"%ZISHOF")
"RTN","ZISHONT",298,0)
 S %ZISHI=$QS(HF,IX),MX=$QL(HF) ;
"RTN","ZISHONT",299,0)
 S F=$NA(@HF,IX-1) ;Get first part
"RTN","ZISHONT",300,0)
 I IX=1 S %ZISHF=F_"(%ZISHI" ;Build root, IX=1
"RTN","ZISHONT",301,0)
 I IX>1 S %ZISHF=$E(F,1,$L(F)-1)_",%ZISHI" ;Build root
"RTN","ZISHONT",302,0)
 S %ZISHO=%ZISHF_","_OVF_",%OVFCNT)" ;Make overflow
"RTN","ZISHONT",303,0)
 F I=IX+1:1:MX S %ZISHF=%ZISHF_",%ZISUB("_I_")",%ZISUB(I)=$QS(HF,I)
"RTN","ZISHONT",304,0)
 S %ZISHF=%ZISHF_")"
"RTN","ZISHONT",305,0)
 Q
"RTN","ZISHONT",306,0)
 ;
"RTN","ZISHONT",307,0)
READNXT(REC) ;Read any sized record into array. %ZB has terminator
"RTN","ZISHONT",308,0)
 ; ZEXCEPT: %ZB
"RTN","ZISHONT",309,0)
 N %,I,X,$ES,$ET S REC="",$ET="D READNX^%ZISH Q"
"RTN","ZISHONT",310,0)
 U IO R X:5 S %ZB=$A($ZB),REC=$E(X,1,255)
"RTN","ZISHONT",311,0)
 Q:$L(X)<256
"RTN","ZISHONT",312,0)
 S %=256 F I=1:1 Q:$L(X)<%  S REC(I)=$E(X,%,%+254),%=%+255
"RTN","ZISHONT",313,0)
 Q
"RTN","ZISHONT",314,0)
READNX ;Check for EOF
"RTN","ZISHONT",315,0)
 ; ZEXCEPT: %ZA
"RTN","ZISHONT",316,0)
 I $ZE["ENDOFFILE" S %ZA=-1
"RTN","ZISHONT",317,0)
 S $EC=""
"RTN","ZISHONT",318,0)
 Q
"RTN","ZISHONT",319,0)
 ;
"RTN","ZISHONT",320,0)
FTG(%ZX1,%ZX2,%ZX3,%ZX4,%ZX5) ;ef,SR. Unload contents of host file into global
"RTN","ZISHONT",321,0)
 ;p1=hostf file directory
"RTN","ZISHONT",322,0)
 ;p2=host file name
"RTN","ZISHONT",323,0)
 ;p3= $NAME REFERENCE INCLUDING STARTING SUBSCRIPT
"RTN","ZISHONT",324,0)
 ;p4=INCREMENT SUBSCRIPT
"RTN","ZISHONT",325,0)
 ;p5=Overflow subscript, defaults to "OVF"
"RTN","ZISHONT",326,0)
 N %ZA,%ZB,%ZC,%XX,%OVFCNT,%ZISHF,%ZISHO,POP,%ZISUB,$ES,$ET
"RTN","ZISHONT",327,0)
 N I,%ZISH,%ZISH1,%ZISHI,%ZISHL,%ZISHOF,%ZISHOX,%ZISHS,%ZX,%ZISHY
"RTN","ZISHONT",328,0)
 S %ZX1=$$DEFDIR($G(%ZX1)),%ZISHOF=$G(%ZX5,"OVF")
"RTN","ZISHONT",329,0)
 D MAKEREF(%ZX3,%ZX4,"%ZISHOF")
"RTN","ZISHONT",330,0)
 D OPEN^%ZISH(,%ZX1,%ZX2,"R")
"RTN","ZISHONT",331,0)
 I POP Q 0
"RTN","ZISHONT",332,0)
 S %ZC=1,%ZA=0,$ET="S %ZC=0,%ZA=-1,$EC="""" Q"
"RTN","ZISHONT",333,0)
 U IO F  K %XX D READNXT(.%XX) Q:$$EOF($ZEOF)!%ZA  D
"RTN","ZISHONT",334,0)
 . S @%ZISHF=%XX
"RTN","ZISHONT",335,0)
 . I $D(%XX)>2 F %OVFCNT=1:1 Q:'$D(%XX(%OVFCNT))  S @%ZISHO=%XX(%OVFCNT)
"RTN","ZISHONT",336,0)
 . S %ZISHI=%ZISHI+1
"RTN","ZISHONT",337,0)
 . Q
"RTN","ZISHONT",338,0)
 D CLOSE() ;Normal exit
"RTN","ZISHONT",339,0)
 Q %ZC
"RTN","ZISHONT",340,0)
 ;
"RTN","ZISHONT",341,0)
GTF(%ZX1,%ZX2,%ZX3,%ZX4) ;ef,SR. Load contents of global to host file.
"RTN","ZISHONT",342,0)
 ;p1=$NAME of global reference
"RTN","ZISHONT",343,0)
 ;p2=incrementing subscript
"RTN","ZISHONT",344,0)
 ;p3=host file directory
"RTN","ZISHONT",345,0)
 ;p4=host file name
"RTN","ZISHONT",346,0)
 N %ZISHY,%ZISHOX
"RTN","ZISHONT",347,0)
 S %ZISHY=$$MGTF(%ZX1,%ZX2,%ZX3,%ZX4,"W")
"RTN","ZISHONT",348,0)
 Q %ZISHY
"RTN","ZISHONT",349,0)
 ;
"RTN","ZISHONT",350,0)
GATF(%ZX1,%ZX2,%ZX3,%ZX4) ;ef,SR. Append to host file.
"RTN","ZISHONT",351,0)
 ;
"RTN","ZISHONT",352,0)
 ;p1=$NAME of global reference
"RTN","ZISHONT",353,0)
 ;p2=incrementing subscript
"RTN","ZISHONT",354,0)
 ;p3=host file directory
"RTN","ZISHONT",355,0)
 ;p4=host file name
"RTN","ZISHONT",356,0)
 N %ZISHY
"RTN","ZISHONT",357,0)
 S %ZISHY=$$MGTF(%ZX1,%ZX2,%ZX3,%ZX4,"A")
"RTN","ZISHONT",358,0)
 Q %ZISHY
"RTN","ZISHONT",359,0)
 ;
"RTN","ZISHONT",360,0)
MGTF(%ZX1,%ZX2,%ZX3,%ZX4,%ZX5) ;
"RTN","ZISHONT",361,0)
 ;p1=$NAME of global reference
"RTN","ZISHONT",362,0)
 ;p2=incrementing subscript
"RTN","ZISHONT",363,0)
 ;p3=host file directory
"RTN","ZISHONT",364,0)
 ;p4=host file name
"RTN","ZISHONT",365,0)
 ; ZEXCEPT: %ZISHF,POP
"RTN","ZISHONT",366,0)
 N %ZISH,%ZISH1,%ZISHI,%ZISHL,%ZISHS,%ZISHOX,IO,%ZX,Y,%ZC
"RTN","ZISHONT",367,0)
 D MAKEREF(%ZX1,%ZX2)
"RTN","ZISHONT",368,0)
 D OPEN^%ZISH(,$G(%ZX3),%ZX4,%ZX5) ;Default dir set in open
"RTN","ZISHONT",369,0)
 I POP Q 0
"RTN","ZISHONT",370,0)
 N $ETRAP S $ETRAP="S $EC="""" D CLOSE^%ZISH() Q 0"
"RTN","ZISHONT",371,0)
 F  Q:'($D(@%ZISHF)#2)  S %ZX=@%ZISHF,%ZISHI=%ZISHI+1 U IO W %ZX,!
"RTN","ZISHONT",372,0)
 D CLOSE()
"RTN","ZISHONT",373,0)
 Q 1
"RTN","ZISHONT",374,0)
 ;
"RTN","ZOSVGUT1")
0^14^B130237275
"RTN","ZOSVGUT1",1,0)
ZOSVGUT1 ;KRM/CJE,VEN/SMH - GT.M Kernel unit tests ;2018-06-06  1:29 PM
"RTN","ZOSVGUT1",2,0)
 ;;8.0;KERNEL;**10001,10002**;Aug 28, 2013;Build 26
"RTN","ZOSVGUT1",3,0)
 ; Submitted to OSEHRA in 2017 by Sam Habiel for OSEHRA
"RTN","ZOSVGUT1",4,0)
 ; Authored by Sam Habiel & Christopher Edwards 2014-2016.
"RTN","ZOSVGUT1",5,0)
 ;
"RTN","ZOSVGUT1",6,0)
 ; makes it easy to run tests simply by running this routine and
"RTN","ZOSVGUT1",7,0)
 ; insures that %ut will be run only where it is present
"RTN","ZOSVGUT1",8,0)
 ;
"RTN","ZOSVGUT1",9,0)
 I $T(EN^%ut)'="" D EN^%ut($T(+0),3,1)
"RTN","ZOSVGUT1",10,0)
 Q
"RTN","ZOSVGUT1",11,0)
 ;
"RTN","ZOSVGUT1",12,0)
STARTUP ;
"RTN","ZOSVGUT1",13,0)
 D DUZ^XUP(.5)
"RTN","ZOSVGUT1",14,0)
 QUIT
"RTN","ZOSVGUT1",15,0)
 ;
"RTN","ZOSVGUT1",16,0)
COV ; [Coverage of Unit Tests] Must use M-Unit 1.5 for this!
"RTN","ZOSVGUT1",17,0)
 N NMSPS
"RTN","ZOSVGUT1",18,0)
 S (NMSPS("%ZOSV*"),NMSPS("%ZISH"),NMSPS("ZTMGRSET"))=""
"RTN","ZOSVGUT1",19,0)
 S (NMSPS("XLFNSLK"),NMSPS("XLFIPV"),NMSPS("XUSHSH"),NMSPS("XQ82"))=""
"RTN","ZOSVGUT1",20,0)
 S (NMSPS("ZSY"))=""
"RTN","ZOSVGUT1",21,0)
 D COV^%ut(.NMSPS,"D ^"_$T(+0),1)
"RTN","ZOSVGUT1",22,0)
 QUIT
"RTN","ZOSVGUT1",23,0)
 ;
"RTN","ZOSVGUT1",24,0)
 ;
"RTN","ZOSVGUT1",25,0)
SETNM ; @TEST Set Environment Name
"RTN","ZOSVGUT1",26,0)
 D SETNM^%ZOSV("ZOSV UT for GT.M")
"RTN","ZOSVGUT1",27,0)
 QUIT
"RTN","ZOSVGUT1",28,0)
 ;
"RTN","ZOSVGUT1",29,0)
ZRO1 ; @TEST $ZROUTINES Parsing Single Object Multiple dirs
"RTN","ZOSVGUT1",30,0)
 N ZR S ZR="o(p r) /var/abc(/var/abc/r/) /abc/def $gtm_dist/libgtmutl.so vista.so"
"RTN","ZOSVGUT1",31,0)
 N DIRS D PARSEZRO^%ZOSV(.DIRS,ZR)
"RTN","ZOSVGUT1",32,0)
 N FIRSTDIR S FIRSTDIR=$$ZRO1ST^%ZOSV(.DIRS)
"RTN","ZOSVGUT1",33,0)
 D CHKEQ^%ut(FIRSTDIR,"p/")
"RTN","ZOSVGUT1",34,0)
 QUIT
"RTN","ZOSVGUT1",35,0)
 ;
"RTN","ZOSVGUT1",36,0)
ZRO2 ; @TEST $ZROUTINES Parsing 2 Single Object Single dir
"RTN","ZOSVGUT1",37,0)
 N ZR S ZR="/var/abc(/var/abc/r/) o(p r) /abc/def $gtm_dist/libgtmutl.so vista.so"
"RTN","ZOSVGUT1",38,0)
 N DIRS D PARSEZRO^%ZOSV(.DIRS,ZR)
"RTN","ZOSVGUT1",39,0)
 N FIRSTDIR S FIRSTDIR=$$ZRO1ST^%ZOSV(.DIRS)
"RTN","ZOSVGUT1",40,0)
 D CHKEQ^%ut(FIRSTDIR,"/var/abc/r/")
"RTN","ZOSVGUT1",41,0)
 QUIT
"RTN","ZOSVGUT1",42,0)
 ;
"RTN","ZOSVGUT1",43,0)
ZRO3 ; @TEST $ZROUTINES Parsing Shared Object/Code dir
"RTN","ZOSVGUT1",44,0)
 N ZR S ZR="/abc/def /var/abc(/var/abc/r/) o(p r) $gtm_dist/libgtmutl.so vista.so"
"RTN","ZOSVGUT1",45,0)
 N DIRS D PARSEZRO^%ZOSV(.DIRS,ZR)
"RTN","ZOSVGUT1",46,0)
 N FIRSTDIR S FIRSTDIR=$$ZRO1ST^%ZOSV(.DIRS)
"RTN","ZOSVGUT1",47,0)
 D CHKEQ^%ut(FIRSTDIR,"/abc/def/")
"RTN","ZOSVGUT1",48,0)
 QUIT
"RTN","ZOSVGUT1",49,0)
 ;
"RTN","ZOSVGUT1",50,0)
ZRO4 ; @TEST $ZROUTINES Parsing Single Directory by itself
"RTN","ZOSVGUT1",51,0)
 N ZR S ZR="/home/osehra/r"
"RTN","ZOSVGUT1",52,0)
 N DIRS D PARSEZRO^%ZOSV(.DIRS,ZR)
"RTN","ZOSVGUT1",53,0)
 N FIRSTDIR S FIRSTDIR=$$ZRO1ST^%ZOSV(.DIRS)
"RTN","ZOSVGUT1",54,0)
 D CHKEQ^%ut(FIRSTDIR,"/home/osehra/r/")
"RTN","ZOSVGUT1",55,0)
 QUIT
"RTN","ZOSVGUT1",56,0)
 ;
"RTN","ZOSVGUT1",57,0)
ZRO5 ; @TEST $ZROUTINES Parsing Leading Space
"RTN","ZOSVGUT1",58,0)
 N ZR S ZR=" o(p r) /var/abc(/var/abc/r/) /abc/def $gtm_dist/libgtmutl.so vista.so"
"RTN","ZOSVGUT1",59,0)
 N DIRS D PARSEZRO^%ZOSV(.DIRS,ZR)
"RTN","ZOSVGUT1",60,0)
 N FIRSTDIR S FIRSTDIR=$$ZRO1ST^%ZOSV(.DIRS)
"RTN","ZOSVGUT1",61,0)
 D CHKEQ^%ut(FIRSTDIR,"p/")
"RTN","ZOSVGUT1",62,0)
 QUIT
"RTN","ZOSVGUT1",63,0)
 ;
"RTN","ZOSVGUT1",64,0)
 ;
"RTN","ZOSVGUT1",65,0)
ZRO7 ; @TEST $ZROUTINES Shared Object Only
"RTN","ZOSVGUT1",66,0)
 N ZR S ZR="/home/osehra/lib/gtm/libgtmutil.so"
"RTN","ZOSVGUT1",67,0)
 N DIRS D PARSEZRO^%ZOSV(.DIRS,ZR)
"RTN","ZOSVGUT1",68,0)
 N FIRSTDIR S FIRSTDIR=$$ZRO1ST^%ZOSV(.DIRS)
"RTN","ZOSVGUT1",69,0)
 D CHKEQ^%ut(FIRSTDIR,"")
"RTN","ZOSVGUT1",70,0)
 Q
"RTN","ZOSVGUT1",71,0)
 ;
"RTN","ZOSVGUT1",72,0)
ZRO8 ; @TEST $ZROUTINES No shared object
"RTN","ZOSVGUT1",73,0)
 N ZR S ZR="/home/osehra/r/V6.0-002_x86_64(/home/osehra/r) /home/osehra/lib/gtm"
"RTN","ZOSVGUT1",74,0)
 N DIRS D PARSEZRO^%ZOSV(.DIRS,ZR)
"RTN","ZOSVGUT1",75,0)
 N FIRSTDIR S FIRSTDIR=$$ZRO1ST^%ZOSV(.DIRS)
"RTN","ZOSVGUT1",76,0)
 D CHKEQ^%ut(FIRSTDIR,"/home/osehra/r/")
"RTN","ZOSVGUT1",77,0)
 Q
"RTN","ZOSVGUT1",78,0)
 ;
"RTN","ZOSVGUT1",79,0)
ZRO9 ; @TEST $ZROUTINES Shared Object First
"RTN","ZOSVGUT1",80,0)
 N ZR S ZR="/home/osehra/lib/gtm/libgtmutil.so /home/osehra/r/V6.0-002_x86_64(/home/osehra/r)"
"RTN","ZOSVGUT1",81,0)
 N DIRS D PARSEZRO^%ZOSV(.DIRS,ZR)
"RTN","ZOSVGUT1",82,0)
 N FIRSTDIR S FIRSTDIR=$$ZRO1ST^%ZOSV(.DIRS)
"RTN","ZOSVGUT1",83,0)
 D CHKEQ^%ut(FIRSTDIR,"/home/osehra/r/")
"RTN","ZOSVGUT1",84,0)
 Q
"RTN","ZOSVGUT1",85,0)
 ;
"RTN","ZOSVGUT1",86,0)
ZRO10 ; @TEST $ZROUTINES Shared Object First but multiple rtn dirs
"RTN","ZOSVGUT1",87,0)
 N ZR S ZR="/home/osehra/lib/gtm/libgtmutil.so /home/osehra/p/V6.0-002_x86_64(/home/osehra/p) /home/osehra/s/V6.0-002_x86_64(/home/osehra/s) /home/osehra/r/V6.0-002_x86_64(/home/osehra/r)"
"RTN","ZOSVGUT1",88,0)
 N DIRS D PARSEZRO^%ZOSV(.DIRS,ZR)
"RTN","ZOSVGUT1",89,0)
 N FIRSTDIR S FIRSTDIR=$$ZRO1ST^%ZOSV(.DIRS)
"RTN","ZOSVGUT1",90,0)
 D CHKEQ^%ut(FIRSTDIR,"/home/osehra/p/")
"RTN","ZOSVGUT1",91,0)
 Q
"RTN","ZOSVGUT1",92,0)
 ;
"RTN","ZOSVGUT1",93,0)
ZRO99 ; @TEST $$RTNDIR^%ZOSV Shouldn't be Empty
"RTN","ZOSVGUT1",94,0)
 N RTNDIR S RTNDIR=$$RTNDIR^%ZOSV
"RTN","ZOSVGUT1",95,0)
 D CHKTF^%ut(RTNDIR]"")
"RTN","ZOSVGUT1",96,0)
 QUIT
"RTN","ZOSVGUT1",97,0)
 ;
"RTN","ZOSVGUT1",98,0)
ACTJ ; @TEST Default path through ACTJ^ZOSV
"RTN","ZOSVGUT1",99,0)
 N ACTJ
"RTN","ZOSVGUT1",100,0)
 ; Run the algorithm
"RTN","ZOSVGUT1",101,0)
 S ACTJ=$$ACTJ^%ZOSV
"RTN","ZOSVGUT1",102,0)
 D CHKTF^%ut(ACTJ>0,"$$ACTJ^%ZOSV didn't return the correct value")
"RTN","ZOSVGUT1",103,0)
 Q
"RTN","ZOSVGUT1",104,0)
 ;
"RTN","ZOSVGUT1",105,0)
ACTJ0 ; @TEST Force ^XUTL("XUSYS","CNT") to 0 to force algorithm to run
"RTN","ZOSVGUT1",106,0)
 ; Force algorithm to run
"RTN","ZOSVGUT1",107,0)
 S ^XUTL("XUSYS","CNT")=0
"RTN","ZOSVGUT1",108,0)
 ; Run the algorithm
"RTN","ZOSVGUT1",109,0)
 N ACTJ S ACTJ=$$ACTJ^%ZOSV
"RTN","ZOSVGUT1",110,0)
 D CHKTF^%ut(ACTJ,"Active Jobs must not be zero")
"RTN","ZOSVGUT1",111,0)
 ;
"RTN","ZOSVGUT1",112,0)
 ; Run again, but this time we get the cached result
"RTN","ZOSVGUT1",113,0)
 N ACTJ2 S ACTJ2=$$ACTJ^%ZOSV
"RTN","ZOSVGUT1",114,0)
 D CHKEQ^%ut(ACTJ2,ACTJ,"$$ACTJ^%ZOSV is out of sync with jobs on file")
"RTN","ZOSVGUT1",115,0)
 ;
"RTN","ZOSVGUT1",116,0)
 ; Force algorithm to run
"RTN","ZOSVGUT1",117,0)
 S ^XUTL("XUSYS","CNT")=0
"RTN","ZOSVGUT1",118,0)
 ; Run the algorithm
"RTN","ZOSVGUT1",119,0)
 N ACTJ3 S ACTJ3=$$ACTJ^%ZOSV
"RTN","ZOSVGUT1",120,0)
 D CHKEQ^%ut(ACTJ2,ACTJ3,"$$ACTJ^%ZOSV is out of sync with jobs on file")
"RTN","ZOSVGUT1",121,0)
 ; 
"RTN","ZOSVGUT1",122,0)
 Q
"RTN","ZOSVGUT1",123,0)
 ;
"RTN","ZOSVGUT1",124,0)
AVJ ; @TEST Available Jobs
"RTN","ZOSVGUT1",125,0)
 D CHKTF^%ut($$AVJ^%ZOSV>0)
"RTN","ZOSVGUT1",126,0)
 QUIT
"RTN","ZOSVGUT1",127,0)
 ;
"RTN","ZOSVGUT1",128,0)
DEVOK ; @TEST Dev Okay
"RTN","ZOSVGUT1",129,0)
 N X,X1,Y
"RTN","ZOSVGUT1",130,0)
 S X="ORB NOTIFICATION RESOURCE",X1="RES" D DEVOK^%ZOSV
"RTN","ZOSVGUT1",131,0)
 D CHKTF^%ut(Y=0)
"RTN","ZOSVGUT1",132,0)
 S X="NULL" D DEVOK^%ZOSV
"RTN","ZOSVGUT1",133,0)
 D CHKTF^%ut(Y=0)
"RTN","ZOSVGUT1",134,0)
 QUIT
"RTN","ZOSVGUT1",135,0)
 ;
"RTN","ZOSVGUT1",136,0)
DEVOPN ; @TEST Show open devices
"RTN","ZOSVGUT1",137,0)
 N Y D DEVOPN^%ZOSV
"RTN","ZOSVGUT1",138,0)
 D CHKTF^%ut(Y'="")
"RTN","ZOSVGUT1",139,0)
 QUIT
"RTN","ZOSVGUT1",140,0)
 ;
"RTN","ZOSVGUT1",141,0)
GETPEER ; @TEST Get Peer
"RTN","ZOSVGUT1",142,0)
 N PEER S PEER=$$GETPEER^%ZOSV
"RTN","ZOSVGUT1",143,0)
 D SUCCEED^%ut
"RTN","ZOSVGUT1",144,0)
 QUIT
"RTN","ZOSVGUT1",145,0)
 ;
"RTN","ZOSVGUT1",146,0)
PRGMODE ; @TEST Prog Mode
"RTN","ZOSVGUT1",147,0)
 N % S %=$$PROGMODE^%ZOSV()
"RTN","ZOSVGUT1",148,0)
 D PRGMODE^%ZOSV
"RTN","ZOSVGUT1",149,0)
 D SUCCEED^%ut
"RTN","ZOSVGUT1",150,0)
 QUIT
"RTN","ZOSVGUT1",151,0)
 ;
"RTN","ZOSVGUT1",152,0)
JOBPAR ; @TEST Job Parameter -- Dummy; doesn't do anything useful.
"RTN","ZOSVGUT1",153,0)
 N X,Y S X=$J D JOBPAR^%ZOSV
"RTN","ZOSVGUT1",154,0)
 D SUCCEED^%ut
"RTN","ZOSVGUT1",155,0)
 QUIT
"RTN","ZOSVGUT1",156,0)
 ;
"RTN","ZOSVGUT1",157,0)
LOGRSRC ; @TEST Turn on Resource Logging
"RTN","ZOSVGUT1",158,0)
 ; KMPR package not ported to GT.M. Noop.
"RTN","ZOSVGUT1",159,0)
 D LOGRSRC^%ZOSV("TEST",1,"OPEN")
"RTN","ZOSVGUT1",160,0)
 QUIT
"RTN","ZOSVGUT1",161,0)
 ;
"RTN","ZOSVGUT1",162,0)
ORDER ; @TEST Order
"RTN","ZOSVGUT1",163,0)
 N X,Y
"RTN","ZOSVGUT1",164,0)
 S X="^TMP($J,"
"RTN","ZOSVGUT1",165,0)
 K ^TMP($J)
"RTN","ZOSVGUT1",166,0)
 S Y="%ut*"
"RTN","ZOSVGUT1",167,0)
 D ORDER^%ZOSV
"RTN","ZOSVGUT1",168,0)
 D CHKTF^%ut(^TMP($J,"%ut","CHK")) ; Must be a number
"RTN","ZOSVGUT1",169,0)
 QUIT
"RTN","ZOSVGUT1",170,0)
 ;
"RTN","ZOSVGUT1",171,0)
DOLRO ; @TEST Ensure symbol table is saved correctly
"RTN","ZOSVGUT1",172,0)
 N TEST,X
"RTN","ZOSVGUT1",173,0)
 ; Will check for this variable and value in the open root
"RTN","ZOSVGUT1",174,0)
 S TEST="TEST1"
"RTN","ZOSVGUT1",175,0)
 ; DOLRO reads the variable X to figure put where to save the symbol table to
"RTN","ZOSVGUT1",176,0)
 S X="^TMP(""ZZUTZOSV"","
"RTN","ZOSVGUT1",177,0)
 ; Save the symbol table
"RTN","ZOSVGUT1",178,0)
 D DOLRO^%ZOSV
"RTN","ZOSVGUT1",179,0)
 D CHKEQ^%ut(^TMP("ZZUTZOSV","TEST"),"TEST1","DOLRO^%ZSOV Didn't save the correct variable value")
"RTN","ZOSVGUT1",180,0)
 ; Debug
"RTN","ZOSVGUT1",181,0)
 ; ZWR ^TMP("ZZUTZOSV",*)
"RTN","ZOSVGUT1",182,0)
 ; Kill test variable
"RTN","ZOSVGUT1",183,0)
 K ^TMP("ZZUTZOSV")
"RTN","ZOSVGUT1",184,0)
 Q
"RTN","ZOSVGUT1",185,0)
 ;
"RTN","ZOSVGUT1",186,0)
TMTRAN ; @TEST Make sure that Taskman is running
"RTN","ZOSVGUT1",187,0)
 I '$$TM^%ZTLOAD() D FAIL^%ut("Can't run this test. Taskman isn't running.") QUIT
"RTN","ZOSVGUT1",188,0)
 ;
"RTN","ZOSVGUT1",189,0)
 N ZTSK D Q^XUTMTZ
"RTN","ZOSVGUT1",190,0)
 D CHKTF^%ut(ZTSK)
"RTN","ZOSVGUT1",191,0)
 N TOTALWAIT S TOTALWAIT=0
"RTN","ZOSVGUT1",192,0)
 F  Q:'$D(^%ZTSK(ZTSK))  H .05 S TOTALWAIT=TOTALWAIT+.05 Q:TOTALWAIT>3
"RTN","ZOSVGUT1",193,0)
 D CHKTF^%ut(TOTALWAIT<2,"Taskman didn't process task")
"RTN","ZOSVGUT1",194,0)
 QUIT
"RTN","ZOSVGUT1",195,0)
 ;
"RTN","ZOSVGUT1",196,0)
GETENV ; @TEST Test GETENV
"RTN","ZOSVGUT1",197,0)
 N Y D GETENV^%ZOSV
"RTN","ZOSVGUT1",198,0)
 D CHKEQ^%ut($L(Y,"^"),4)
"RTN","ZOSVGUT1",199,0)
 QUIT
"RTN","ZOSVGUT1",200,0)
 ;
"RTN","ZOSVGUT1",201,0)
OS ; @TEST OS
"RTN","ZOSVGUT1",202,0)
 D CHKEQ^%ut($$OS^%ZOSV(),"UNIX")
"RTN","ZOSVGUT1",203,0)
 QUIT
"RTN","ZOSVGUT1",204,0)
 ;
"RTN","ZOSVGUT1",205,0)
VERSION ; @TEST VERSION
"RTN","ZOSVGUT1",206,0)
 N V0 S V0=$$VERSION^%ZOSV(0)
"RTN","ZOSVGUT1",207,0)
 N OS S OS=$$VERSION^%ZOSV(1)
"RTN","ZOSVGUT1",208,0)
 D CHKTF^%ut(V0,"Must be positive")
"RTN","ZOSVGUT1",209,0)
 D CHKTF^%ut($L(V0,"-")=2,"Must be in xx.xxxx")
"RTN","ZOSVGUT1",210,0)
 D CHKTF^%ut(OS["nux"!(OS["nix")!(OS["BSD")!(OS["Darwin")!(OS["CYGWIN"))
"RTN","ZOSVGUT1",211,0)
 QUIT
"RTN","ZOSVGUT1",212,0)
 ;
"RTN","ZOSVGUT1",213,0)
SID ; @TEST System ID
"RTN","ZOSVGUT1",214,0)
 N SID S SID=$$SID^%ZOSV
"RTN","ZOSVGUT1",215,0)
 D CHKTF^%ut(SID[$ZGBLDIR)
"RTN","ZOSVGUT1",216,0)
 QUIT
"RTN","ZOSVGUT1",217,0)
 ;
"RTN","ZOSVGUT1",218,0)
UCI ; @TEST Get UCI/Vol
"RTN","ZOSVGUT1",219,0)
 N Y D UCI^%ZOSV
"RTN","ZOSVGUT1",220,0)
 D CHKTF^%ut(Y=^%ZOSF("PROD"))
"RTN","ZOSVGUT1",221,0)
 QUIT
"RTN","ZOSVGUT1",222,0)
UCICHECK ; @TEST Noop
"RTN","ZOSVGUT1",223,0)
 N % S %=$$UCICHECK^%ZOSV(88)
"RTN","ZOSVGUT1",224,0)
 D CHKEQ^%ut(88,%)
"RTN","ZOSVGUT1",225,0)
 QUIT
"RTN","ZOSVGUT1",226,0)
PARSIZ ; @TEST PARSIZE NOOP
"RTN","ZOSVGUT1",227,0)
 N X
"RTN","ZOSVGUT1",228,0)
 D PARSIZ^%ZOSV
"RTN","ZOSVGUT1",229,0)
 D SUCCEED^%ut
"RTN","ZOSVGUT1",230,0)
 QUIT
"RTN","ZOSVGUT1",231,0)
NOLOG ; @TEST NOLOG NOOP
"RTN","ZOSVGUT1",232,0)
 N Y
"RTN","ZOSVGUT1",233,0)
 D NOLOG^%ZOSV
"RTN","ZOSVGUT1",234,0)
 D SUCCEED^%ut
"RTN","ZOSVGUT1",235,0)
 QUIT
"RTN","ZOSVGUT1",236,0)
 ;
"RTN","ZOSVGUT1",237,0)
SHARELIC ; @TEST SHARELIC NOOP
"RTN","ZOSVGUT1",238,0)
 D SHARELIC^%ZOSV()
"RTN","ZOSVGUT1",239,0)
 D SUCCEED^%ut
"RTN","ZOSVGUT1",240,0)
 QUIT
"RTN","ZOSVGUT1",241,0)
 ;
"RTN","ZOSVGUT1",242,0)
PRIORITY ; @TEST PRIORITY NOOP
"RTN","ZOSVGUT1",243,0)
 D PRIORITY^%ZOSV
"RTN","ZOSVGUT1",244,0)
 D SUCCEED^%ut
"RTN","ZOSVGUT1",245,0)
 QUIT
"RTN","ZOSVGUT1",246,0)
 ;
"RTN","ZOSVGUT1",247,0)
PRIINQ ; @TEST PRIINQ() NOOP
"RTN","ZOSVGUT1",248,0)
 N % S %=$$PRIINQ^%ZOSV()
"RTN","ZOSVGUT1",249,0)
 D SUCCEED^%ut
"RTN","ZOSVGUT1",250,0)
 QUIT
"RTN","ZOSVGUT1",251,0)
 ;
"RTN","ZOSVGUT1",252,0)
BAUD ; @TEST BAUD NOOP
"RTN","ZOSVGUT1",253,0)
 N X D BAUD^%ZOSV
"RTN","ZOSVGUT1",254,0)
 D SUCCEED^%ut
"RTN","ZOSVGUT1",255,0)
 S X="UNKNOWN"
"RTN","ZOSVGUT1",256,0)
 QUIT
"RTN","ZOSVGUT1",257,0)
 ;
"RTN","ZOSVGUT1",258,0)
SETTRM ; @TEST Set Terminators
"RTN","ZOSVGUT1",259,0)
 N % S %=$$SETTRM^%ZOSV($C(10,13))
"RTN","ZOSVGUT1",260,0)
 D CHKEQ^%ut(%,1)
"RTN","ZOSVGUT1",261,0)
 X ^%ZOSF("TRMON") ; Reset terminators
"RTN","ZOSVGUT1",262,0)
 QUIT
"RTN","ZOSVGUT1",263,0)
 ;
"RTN","ZOSVGUT1",264,0)
LGR ; @TEST Last Global Reference
"RTN","ZOSVGUT1",265,0)
 S ^TMP($J)=""
"RTN","ZOSVGUT1",266,0)
 I ^TMP($J)
"RTN","ZOSVGUT1",267,0)
 N R S R=$$LGR^%ZOSV()
"RTN","ZOSVGUT1",268,0)
 D CHKEQ^%ut(R,$NA(^TMP($J)))
"RTN","ZOSVGUT1",269,0)
 K ^TMP($J)
"RTN","ZOSVGUT1",270,0)
 QUIT
"RTN","ZOSVGUT1",271,0)
 ;
"RTN","ZOSVGUT1",272,0)
EC ; @TEST $$EC
"RTN","ZOSVGUT1",273,0)
 N A,%
"RTN","ZOSVGUT1",274,0)
 N $ET S $ET="S A=$$EC^%ZOSV,$EC="""" G EC1"
"RTN","ZOSVGUT1",275,0)
 S %=1/0
"RTN","ZOSVGUT1",276,0)
EC1 ;
"RTN","ZOSVGUT1",277,0)
 D CHKTF^%ut(A["divide")
"RTN","ZOSVGUT1",278,0)
 QUIT
"RTN","ZOSVGUT1",279,0)
 ;
"RTN","ZOSVGUT1",280,0)
ZTMGRSET ; @TEST ZTMGRSET Renames Routines on GT.M
"RTN","ZOSVGUT1",281,0)
 ;ZEXCEPT: shell
"RTN","ZOSVGUT1",282,0)
 N %ZR,%Y,%YY
"RTN","ZOSVGUT1",283,0)
 N RTNFS S RTNFS="_ZTLOAD1.o"
"RTN","ZOSVGUT1",284,0)
 D SILENT^%RSEL("%ZTLOAD1","OBJ")
"RTN","ZOSVGUT1",285,0)
 N FILE S FILE=%ZR("%ZTLOAD1")_RTNFS
"RTN","ZOSVGUT1",286,0)
 S %Y=$$RETURN^%ZOSV("stat -c %X "_FILE)
"RTN","ZOSVGUT1",287,0)
 N ZTOS S ZTOS=$$OSNUM^ZTMGRSET()
"RTN","ZOSVGUT1",288,0)
 N SCR S SCR="I 0"
"RTN","ZOSVGUT1",289,0)
 N ZTMODE S ZTMODE=2
"RTN","ZOSVGUT1",290,0)
 N IOP S IOP="NULL" D ^%ZIS U IO
"RTN","ZOSVGUT1",291,0)
 D DOIT^ZTMGRSET
"RTN","ZOSVGUT1",292,0)
 D ^%ZISC
"RTN","ZOSVGUT1",293,0)
 D SILENT^%RSEL("%ZTLOAD1","OBJ")
"RTN","ZOSVGUT1",294,0)
 N FILE S FILE=%ZR("%ZTLOAD1")_RTNFS
"RTN","ZOSVGUT1",295,0)
 S %YY=$$RETURN^%ZOSV("stat -c %X "_FILE)
"RTN","ZOSVGUT1",296,0)
 D CHKTF^%ut(%YY'<%Y)
"RTN","ZOSVGUT1",297,0)
 ;
"RTN","ZOSVGUT1",298,0)
 ; Now that we know that it works, just run some of the other EPs to inc coverage
"RTN","ZOSVGUT1",299,0)
 N IOP S IOP="NULL" D ^%ZIS U IO
"RTN","ZOSVGUT1",300,0)
 D PATCH^ZTMGRSET(599) ; %ZIS
"RTN","ZOSVGUT1",301,0)
 ;
"RTN","ZOSVGUT1",302,0)
 N DTIME S DTIME=.001
"RTN","ZOSVGUT1",303,0)
 D NAME^ZTMGRSET
"RTN","ZOSVGUT1",304,0)
 D GLOBALS^ZTMGRSET
"RTN","ZOSVGUT1",305,0)
 D RUM^ZTMGRSET
"RTN","ZOSVGUT1",306,0)
 D ^%ZISC
"RTN","ZOSVGUT1",307,0)
 QUIT
"RTN","ZOSVGUT1",308,0)
 ;
"RTN","ZOSVGUT1",309,0)
ZHOROLOG ; @TEST $ZHOROLOG Functions
"RTN","ZOSVGUT1",310,0)
 Q:$$VERSION^%ZOSV<6.3
"RTN","ZOSVGUT1",311,0)
 N %ZH0,%ZH1,%ZH2
"RTN","ZOSVGUT1",312,0)
 D T0^%ZOSV
"RTN","ZOSVGUT1",313,0)
 D CHKTF^%ut(%ZH0)
"RTN","ZOSVGUT1",314,0)
 D CHKTF^%ut($L(%ZH0,",")=4)
"RTN","ZOSVGUT1",315,0)
 D T1^%ZOSV
"RTN","ZOSVGUT1",316,0)
 D CHKTF^%ut(%ZH1)
"RTN","ZOSVGUT1",317,0)
 D CHKTF^%ut($L(%ZH1,",")=4)
"RTN","ZOSVGUT1",318,0)
 D ZHDIF^%ZOSV
"RTN","ZOSVGUT1",319,0)
 D CHKTF^%ut(%ZH2<.001,"%ZH2 is "_%ZH2)
"RTN","ZOSVGUT1",320,0)
 QUIT
"RTN","ZOSVGUT1",321,0)
 ;
"RTN","ZOSVGUT1",322,0)
TEMP ; @TEST getting temp directory
"RTN","ZOSVGUT1",323,0)
 N TMP S TMP=$$TEMP^%ZOSV()
"RTN","ZOSVGUT1",324,0)
 N FN S FN=TMP_"/test.txt"
"RTN","ZOSVGUT1",325,0)
 O FN:newvesrion
"RTN","ZOSVGUT1",326,0)
 U FN
"RTN","ZOSVGUT1",327,0)
 W "TEST",!
"RTN","ZOSVGUT1",328,0)
 C FN:delete
"RTN","ZOSVGUT1",329,0)
 D SUCCEED^%ut
"RTN","ZOSVGUT1",330,0)
 QUIT
"RTN","ZOSVGUT1",331,0)
 ;
"RTN","ZOSVGUT1",332,0)
PASS ; @TEST PASTHRU and NOPASS
"RTN","ZOSVGUT1",333,0)
 D PASSALL^%ZOSV
"RTN","ZOSVGUT1",334,0)
 D NOPASS^%ZOSV
"RTN","ZOSVGUT1",335,0)
 D SUCCEED^%ut
"RTN","ZOSVGUT1",336,0)
 QUIT
"RTN","ZOSVGUT1",337,0)
 ;
"RTN","ZOSVGUT1",338,0)
NSLOOKUP ; @TEST Test DNS Utilities
"RTN","ZOSVGUT1",339,0)
 ; REVERSE DNS
"RTN","ZOSVGUT1",340,0)
 N % S %=$$HOST^XLFNSLK("208.67.220.220")
"RTN","ZOSVGUT1",341,0)
 D CHKTF^%ut(%["opendns")
"RTN","ZOSVGUT1",342,0)
 N % S %=$$HOST^XLFNSLK("2607:F8B0:400D:0C01:0000:0000:0000:0066")
"RTN","ZOSVGUT1",343,0)
 D CHKTF^%ut(%["1e100")
"RTN","ZOSVGUT1",344,0)
 N % S %=$$HOST^XLFNSLK("")
"RTN","ZOSVGUT1",345,0)
 D SUCCEED^%ut
"RTN","ZOSVGUT1",346,0)
 N % S %=$$HOST^XLFNSLK("93.184.216.34") ; example.com doesn't have reverse dns
"RTN","ZOSVGUT1",347,0)
 D CHKTF^%ut(%="")
"RTN","ZOSVGUT1",348,0)
 ;
"RTN","ZOSVGUT1",349,0)
 ; FORWARD DNS
"RTN","ZOSVGUT1",350,0)
 ; dig may fail with localhost lookup
"RTN","ZOSVGUT1",351,0)
 N IPV6 S IPV6=$$VERSION^XLFIPV
"RTN","ZOSVGUT1",352,0)
 I IPV6 D CHKTF^%ut($$ADDRESS^XLFNSLK("localhost")["0000:0000:0000:0000:0000:0000:0000:000") I 1
"RTN","ZOSVGUT1",353,0)
 E  D CHKTF^%ut(($$ADDRESS^XLFNSLK("localhost")["127.0.0.1")!($$ADDRESS^XLFNSLK("localhost")["0.0.0.0"))
"RTN","ZOSVGUT1",354,0)
 D CHKTF^%ut(($$ADDRESS^XLFNSLK("localhost","A")["127.0.0.1")!($$ADDRESS^XLFNSLK("localhost","A")["0.0.0.0"))
"RTN","ZOSVGUT1",355,0)
 D CHKTF^%ut($$ADDRESS^XLFNSLK("localhost","AAAA")["0000:0000:0000:0000:0000:0000:0000:000")
"RTN","ZOSVGUT1",356,0)
 QUIT
"RTN","ZOSVGUT1",357,0)
 ;
"RTN","ZOSVGUT1",358,0)
IPV6 ; @TEST Test GT.M support for IPV6
"RTN","ZOSVGUT1",359,0)
 I $ZV["CYGWIN" QUIT  ; We run Cygwin on IPv4 only as Cygwin doesn't support between the two as well as Linux
"RTN","ZOSVGUT1",360,0)
 D CHKEQ^%ut($$VERSION^XLFIPV(),1)
"RTN","ZOSVGUT1",361,0)
 QUIT
"RTN","ZOSVGUT1",362,0)
 ;
"RTN","ZOSVGUT1",363,0)
SSVNJOB ; @TEST Replacement for ^$JOB in XQ82
"RTN","ZOSVGUT1",364,0)
 ; ZEXCEPT: SSVNJOB,SSVNJOB1,ERR,IN
"RTN","ZOSVGUT1",365,0)
 L +SSVNJOB
"RTN","ZOSVGUT1",366,0)
 J SSVNJOB1:(IN="/dev/null":OUT="/dev/null":ERR="/dev/null")
"RTN","ZOSVGUT1",367,0)
 N CHILDPID S CHILDPID=$ZJOB
"RTN","ZOSVGUT1",368,0)
 L -SSVNJOB
"RTN","ZOSVGUT1",369,0)
 H .01 ; This must be big enough to let your computer start the job
"RTN","ZOSVGUT1",370,0)
 I $ZV["CYGWIN" H 1 ; Wish I knew why...
"RTN","ZOSVGUT1",371,0)
 I $ZV["arm" H 1 ; Arm chips too slow...
"RTN","ZOSVGUT1",372,0)
 L +SSVNJOB
"RTN","ZOSVGUT1",373,0)
 L
"RTN","ZOSVGUT1",374,0)
 D CHKTF^%ut($D(^TMP(CHILDPID)))
"RTN","ZOSVGUT1",375,0)
 S ^XUTL("XQ",$J)="" ; So that ^XQ82 won't kill our temp globals 
"RTN","ZOSVGUT1",376,0)
 D ^XQ82
"RTN","ZOSVGUT1",377,0)
 D CHKTF^%ut('$D(^TMP(CHILDPID)))
"RTN","ZOSVGUT1",378,0)
 QUIT
"RTN","ZOSVGUT1",379,0)
 ;
"RTN","ZOSVGUT1",380,0)
SSVNJOB1 ; [Private] Helper for SSVNJOB
"RTN","ZOSVGUT1",381,0)
 ; ZEXCEPT: SSVNJOB
"RTN","ZOSVGUT1",382,0)
 L +SSVNJOB
"RTN","ZOSVGUT1",383,0)
 K ^TMP($J)
"RTN","ZOSVGUT1",384,0)
 S ^TMP($J,"SAM")=1
"RTN","ZOSVGUT1",385,0)
 S ^TMP($J,"CHRISTOPHER")=2
"RTN","ZOSVGUT1",386,0)
 L -SSVNJOB
"RTN","ZOSVGUT1",387,0)
 QUIT
"RTN","ZOSVGUT1",388,0)
 ;
"RTN","ZOSVGUT1",389,0)
ZSY ; @TEST Run System Status
"RTN","ZOSVGUT1",390,0)
 ; ZEXCEPT: in,out,err
"RTN","ZOSVGUT1",391,0)
 N IOP S IOP="NULL" D ^%ZIS U IO
"RTN","ZOSVGUT1",392,0)
 D ^ZSY
"RTN","ZOSVGUT1",393,0)
 N %utAnswer s %utAnswer=2
"RTN","ZOSVGUT1",394,0)
 D QUERY^ZSY
"RTN","ZOSVGUT1",395,0)
 N nProcs s nProcs=$$UNIXLSOF^ZSY()
"RTN","ZOSVGUT1",396,0)
 D HALTALL^ZSY ; Kill all other processes
"RTN","ZOSVGUT1",397,0)
 i $zv["arm" h 5 ; Needed for Arm chips... not fast enough in the kill
"RTN","ZOSVGUT1",398,0)
 N nProcsAfter S nProcsAfter=$$UNIXLSOF^ZSY()
"RTN","ZOSVGUT1",399,0)
 D CHKTF^%ut(nProcs>nProcsAfter)
"RTN","ZOSVGUT1",400,0)
 D CHKTF^%ut(nProcsAfter=1)
"RTN","ZOSVGUT1",401,0)
 D ^ZTMB ; bring it back up.
"RTN","ZOSVGUT1",402,0)
 D LW^ZSY
"RTN","ZOSVGUT1",403,0)
 D ERR^ZSY
"RTN","ZOSVGUT1",404,0)
 D UERR^ZSY
"RTN","ZOSVGUT1",405,0)
 D SUCCEED^%ut
"RTN","ZOSVGUT1",406,0)
 D ^%ZISC
"RTN","ZOSVGUT1",407,0)
 QUIT
"RTN","ZOSVGUT1",408,0)
 ;
"RTN","ZOSVGUT1",409,0)
HALTONE ; @TEST Test HALTONE^ZSY entry point
"RTN","ZOSVGUT1",410,0)
 ; ZEXCEPT: TESTJOB,input,output,error
"RTN","ZOSVGUT1",411,0)
 J TESTJOB:(input="/dev/null":output="/dev/null":error="/dev/null")
"RTN","ZOSVGUT1",412,0)
 N %J S %J=$ZJOB
"RTN","ZOSVGUT1",413,0)
 D CHKTF^%ut($zgetjpi(%J,"isprocalive"))
"RTN","ZOSVGUT1",414,0)
 D HALTONE^ZSY(%J)
"RTN","ZOSVGUT1",415,0)
 H .01
"RTN","ZOSVGUT1",416,0)
 D CHKTF^%ut('$zgetjpi(%J,"isprocalive"))
"RTN","ZOSVGUT1",417,0)
 QUIT
"RTN","ZOSVGUT1",418,0)
 ;
"RTN","ZOSVGUT1",419,0)
TESTJOB ; [Private] Entry point for a test job to kill
"RTN","ZOSVGUT1",420,0)
 HANG 100
"RTN","ZOSVGUT1",421,0)
 QUIT
"RTN","ZOSVGUT1",422,0)
 ;
"RTN","ZOSVGUT1",423,0)
XTROU ;;
"RTN","ZOSVGUT1",424,0)
 ;;ZOSVGUT2
"RTN","ZOSVGUT2")
0^15^B42570307
"RTN","ZOSVGUT2",1,0)
ZOSVGUT2 ; VEN/SMH - Unit Tests for GT.M VistA Port;2018-06-06  1:11 PM
"RTN","ZOSVGUT2",2,0)
 ;;8.0;KERNEL;**10001,10002**;;Build 26
"RTN","ZOSVGUT2",3,0)
 ; Submitted to OSEHRA in 2017 by Sam Habiel for OSEHRA
"RTN","ZOSVGUT2",4,0)
 ; Authored by Sam Habiel 2016.
"RTN","ZOSVGUT2",5,0)
 ;
"RTN","ZOSVGUT2",6,0)
STARTUP QUIT
"RTN","ZOSVGUT2",7,0)
 ;
"RTN","ZOSVGUT2",8,0)
SHUTDOWN ; 
"RTN","ZOSVGUT2",9,0)
 S $ZSOURCE="ZOSVGUT2"
"RTN","ZOSVGUT2",10,0)
 QUIT
"RTN","ZOSVGUT2",11,0)
 ;
"RTN","ZOSVGUT2",12,0)
NOOP ; @TEST Top doesn't do anything.
"RTN","ZOSVGUT2",13,0)
 D ^%ZOSV2
"RTN","ZOSVGUT2",14,0)
 D SUCCEED^%ut
"RTN","ZOSVGUT2",15,0)
 QUIT
"RTN","ZOSVGUT2",16,0)
 ;
"RTN","ZOSVGUT2",17,0)
SAVE1 ; @TEST Save a Routine normal
"RTN","ZOSVGUT2",18,0)
 N XCN,DIE
"RTN","ZOSVGUT2",19,0)
 S XCN=0,DIE=$$OREF^DILF($NA(^TMP($J)))
"RTN","ZOSVGUT2",20,0)
 K ^TMP($J)
"RTN","ZOSVGUT2",21,0)
 S ^TMP($J,$I(XCN),0)="KBANHELLO ; VEN/SMH - Sample Testing Routine"
"RTN","ZOSVGUT2",22,0)
 S ^TMP($J,$I(XCN),0)=" ;;"
"RTN","ZOSVGUT2",23,0)
 S ^TMP($J,$I(XCN),0)=";this is not supposed to be saved"
"RTN","ZOSVGUT2",24,0)
 S ^TMP($J,$I(XCN),0)=" WRITE ""HELLO WORLD"""
"RTN","ZOSVGUT2",25,0)
 S ^TMP($J,$I(XCN),0)=" QUIT"
"RTN","ZOSVGUT2",26,0)
 S XCN=0
"RTN","ZOSVGUT2",27,0)
 D SAVE^%ZOSV2("KBANHELLO")
"RTN","ZOSVGUT2",28,0)
 D CHKTF^%ut($T(+1^KBANHELLO)["VEN/SMH")
"RTN","ZOSVGUT2",29,0)
 D CHKTF^%ut($T(+2^KBANHELLO)[";;")
"RTN","ZOSVGUT2",30,0)
 D CHKTF^%ut($T(+3^KBANHELLO)["HELLO WORLD")
"RTN","ZOSVGUT2",31,0)
 D CHKTF^%ut($T(+4^KBANHELLO)["QUIT")
"RTN","ZOSVGUT2",32,0)
 D CHKTF^%ut($T(+3^KBANHELLO)'[$C(9)) ; no tabs
"RTN","ZOSVGUT2",33,0)
 D CHKTF^%ut($T(+4^KBANHELLO)'[$C(9)) ; no tabs
"RTN","ZOSVGUT2",34,0)
 QUIT
"RTN","ZOSVGUT2",35,0)
 ;
"RTN","ZOSVGUT2",36,0)
SAVE2 ; @TEST Save a Routine with syntax errors -- should not show.
"RTN","ZOSVGUT2",37,0)
 N XCN,DIE
"RTN","ZOSVGUT2",38,0)
 S XCN=0,DIE=$$OREF^DILF($NA(^TMP($J)))
"RTN","ZOSVGUT2",39,0)
 K ^TMP($J)
"RTN","ZOSVGUT2",40,0)
 S ^TMP($J,$I(XCN),0)="KBANHELLO ; VEN/SMH - Sample Testing Routine"
"RTN","ZOSVGUT2",41,0)
 S ^TMP($J,$I(XCN),0)=" ;;"
"RTN","ZOSVGUT2",42,0)
 S ^TMP($J,$I(XCN),0)=" WROTE ""HELLO WORLD"""
"RTN","ZOSVGUT2",43,0)
 S ^TMP($J,$I(XCN),0)=" W $P(""TEST"")"
"RTN","ZOSVGUT2",44,0)
 S ^TMP($J,$I(XCN),0)=" QUIT"
"RTN","ZOSVGUT2",45,0)
 S XCN=0
"RTN","ZOSVGUT2",46,0)
 N % S %=$$RETURN^%ZOSV("rm -f /tmp/kbanhello.mje",1)
"RTN","ZOSVGUT2",47,0)
 ; ZEXCEPT: SAVE,error,%ZOSV2,in,out,PASS
"RTN","ZOSVGUT2",48,0)
 J SAVE^%ZOSV2("KBANHELLO"):(error="/tmp/kbanhello.mje":in="/dev/null":out="/dev/null":PASS)
"RTN","ZOSVGUT2",49,0)
 F  H .001  Q:($$RETURN^%ZOSV("stat /tmp/kbanhello.mje",1)=0)
"RTN","ZOSVGUT2",50,0)
 D CHKTF^%ut(+$$RETURN^%ZOSV("wc -l /tmp/kbanhello.mje")=0)
"RTN","ZOSVGUT2",51,0)
 QUIT
"RTN","ZOSVGUT2",52,0)
 ;
"RTN","ZOSVGUT2",53,0)
LOAD ; @TEST Load Routine
"RTN","ZOSVGUT2",54,0)
 N XCN,DIE
"RTN","ZOSVGUT2",55,0)
 S XCN=0,DIE=$$OREF^DILF($NA(^TMP($J)))
"RTN","ZOSVGUT2",56,0)
 K ^TMP($J)
"RTN","ZOSVGUT2",57,0)
 S ^TMP($J,$I(XCN),0)="KBANHELLO ; VEN/SMH - Sample Testing Routine"
"RTN","ZOSVGUT2",58,0)
 S ^TMP($J,$I(XCN),0)=" ;;"
"RTN","ZOSVGUT2",59,0)
 S ^TMP($J,$I(XCN),0)=";this is not supposed to be saved"
"RTN","ZOSVGUT2",60,0)
 S ^TMP($J,$I(XCN),0)=" WRITE ""HELLO WORLD"""
"RTN","ZOSVGUT2",61,0)
 S ^TMP($J,$I(XCN),0)=" QUIT"
"RTN","ZOSVGUT2",62,0)
 S XCN=0
"RTN","ZOSVGUT2",63,0)
 D SAVE^%ZOSV2("KBANHELLO")
"RTN","ZOSVGUT2",64,0)
 N DIF
"RTN","ZOSVGUT2",65,0)
 K ^TMP($J)
"RTN","ZOSVGUT2",66,0)
 S DIF=$$OREF^DILF($NA(^TMP($J,"ROU")))
"RTN","ZOSVGUT2",67,0)
 D LOAD^%ZOSV2("KBANHELLO")
"RTN","ZOSVGUT2",68,0)
 D CHKTF^%ut(^TMP($J,"ROU",1,0)["KBANHELLO")
"RTN","ZOSVGUT2",69,0)
 D CHKTF^%ut(^TMP($J,"ROU",4,0)["QUIT")
"RTN","ZOSVGUT2",70,0)
 QUIT
"RTN","ZOSVGUT2",71,0)
 ;
"RTN","ZOSVGUT2",72,0)
RSUM ; @TEST Checksums
"RTN","ZOSVGUT2",73,0)
 D CHKTF^%ut($$RSUM^%ZOSV2("KBANHELLO"))
"RTN","ZOSVGUT2",74,0)
 D CHKTF^%ut($$RSUM2^%ZOSV2("KBANHELLO"))
"RTN","ZOSVGUT2",75,0)
 QUIT
"RTN","ZOSVGUT2",76,0)
 ;
"RTN","ZOSVGUT2",77,0)
TESTR ; @TEST Test existence of routine
"RTN","ZOSVGUT2",78,0)
 D CHKTF^%ut($$TEST^%ZOSV2("KBANHELLO")]"")
"RTN","ZOSVGUT2",79,0)
 QUIT
"RTN","ZOSVGUT2",80,0)
 ;
"RTN","ZOSVGUT2",81,0)
DELSUPER ; @TEST Test Super Duper Deleter
"RTN","ZOSVGUT2",82,0)
 H .01 ; Necessary so that object deletion would work
"RTN","ZOSVGUT2",83,0)
 D DEL^%ZOSV2("KBANHELLO")
"RTN","ZOSVGUT2",84,0)
 D CHKTF^%ut($T(+1^KBANHELLO)="")
"RTN","ZOSVGUT2",85,0)
 D CHKTF^%ut($$TEST^%ZOSV2("KBANHELLO")="")
"RTN","ZOSVGUT2",86,0)
 QUIT
"RTN","ZOSVGUT2",87,0)
 ;
"RTN","ZOSVGUT2",88,0)
XUSHSH ; @TEST Top of XUSHSH
"RTN","ZOSVGUT2",89,0)
 N X S X="TEST"
"RTN","ZOSVGUT2",90,0)
 D ^XUSHSH
"RTN","ZOSVGUT2",91,0)
 D CHKTF^%ut(X="TEST")
"RTN","ZOSVGUT2",92,0)
 QUIT
"RTN","ZOSVGUT2",93,0)
 ;
"RTN","ZOSVGUT2",94,0)
SHA ; @TEST SHA-1 and SHA-256 in Hex and Base64
"RTN","ZOSVGUT2",95,0)
 D CHKEQ^%ut($$SHAHASH^XUSHSH(160,"test"),"A94A8FE5CCB19BA61C4C0873D391E987982FBBD3")
"RTN","ZOSVGUT2",96,0)
 D CHKEQ^%ut($$SHAHASH^XUSHSH(160,"test","H"),"A94A8FE5CCB19BA61C4C0873D391E987982FBBD3")
"RTN","ZOSVGUT2",97,0)
 D CHKEQ^%ut($$SHAHASH^XUSHSH(160,"test","B"),"qUqP5cyxm6YcTAhz05Hph5gvu9M=")
"RTN","ZOSVGUT2",98,0)
 D CHKEQ^%ut($$SHAHASH^XUSHSH(256,"test"),"9F86D081884C7D659A2FEAA0C55AD015A3BF4F1B2B0B822CD15D6C15B0F00A08")
"RTN","ZOSVGUT2",99,0)
 QUIT
"RTN","ZOSVGUT2",100,0)
 ;
"RTN","ZOSVGUT2",101,0)
BASE64 ; @TEST Base 64 Encode and Decode
"RTN","ZOSVGUT2",102,0)
 D CHKEQ^%ut($$B64ENCD^XUSHSH("test"),"dGVzdA==")
"RTN","ZOSVGUT2",103,0)
 D CHKEQ^%ut($$B64DECD^XUSHSH("dGVzdA=="),"test")
"RTN","ZOSVGUT2",104,0)
 QUIT
"RTN","ZOSVGUT2",105,0)
 ;
"RTN","ZOSVGUT2",106,0)
RSAENC ; @TEST Test RSA Encryption
"RTN","ZOSVGUT2",107,0)
 N SECRET S SECRET="Alice and Bob had Sex!"
"RTN","ZOSVGUT2",108,0)
 ;
"RTN","ZOSVGUT2",109,0)
 ; Create RSA certificate and private key w/ no password
"RTN","ZOSVGUT2",110,0)
 N %CMD
"RTN","ZOSVGUT2",111,0)
 S %CMD="openssl req -x509 -nodes -days 365 -sha256 -subj '/C=US/ST=Washington/L=Seattle/CN=www.smh101.com' -newkey rsa:2048 -keyout /tmp/mycert.key -out /tmp/mycert.pem"
"RTN","ZOSVGUT2",112,0)
 N % S %=$$RETURN^%ZOSV(%CMD,1)
"RTN","ZOSVGUT2",113,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVGUT2",114,0)
 N CIPHERTEXT S CIPHERTEXT=$$RSAENCR^XUSHSH(SECRET,"/tmp/mycert.pem")
"RTN","ZOSVGUT2",115,0)
 D CHKTF^%ut($ZL(CIPHERTEXT)>$ZL(SECRET))
"RTN","ZOSVGUT2",116,0)
 N DECRYPTION S DECRYPTION=$$RSADECR^XUSHSH(CIPHERTEXT,"/tmp/mycert.key")
"RTN","ZOSVGUT2",117,0)
 D CHKEQ^%ut(SECRET,DECRYPTION)
"RTN","ZOSVGUT2",118,0)
 ;
"RTN","ZOSVGUT2",119,0)
 ; Create RSA certificate and private key with a password
"RTN","ZOSVGUT2",120,0)
 ; Apparently, no way to do all of this in a single line in openssl; have to do
"RTN","ZOSVGUT2",121,0)
 ; it the traditional way: key, CSR, Cert.
"RTN","ZOSVGUT2",122,0)
 ; VEN/SMH - For some reason, the darwin command doesn't create the
"RTN","ZOSVGUT2",123,0)
 ; certificate when running from inside GT.M; it does okay in Bash.
"RTN","ZOSVGUT2",124,0)
 ; So, for now, let's just disable this check on Darwin; I don't have time
"RTN","ZOSVGUT2",125,0)
 ; for this shit.
"RTN","ZOSVGUT2",126,0)
 I $$VERSION^%ZOSV(1)["Darwin" QUIT
"RTN","ZOSVGUT2",127,0)
 I $$VERSION^%ZOSV(1)["CYGWIN" QUIT
"RTN","ZOSVGUT2",128,0)
 ;
"RTN","ZOSVGUT2",129,0)
 N %CMD
"RTN","ZOSVGUT2",130,0)
 S %CMD="openssl genrsa -aes128 -passout pass:monkey1234 -out /tmp/mycert.key 2048"
"RTN","ZOSVGUT2",131,0)
 N % S %=$$RETURN^%ZOSV(%CMD,1)
"RTN","ZOSVGUT2",132,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVGUT2",133,0)
 S %CMD="openssl req -new -key /tmp/mycert.key -passin pass:monkey1234 -subj '/C=US/ST=Washington/L=Seattle/CN=www.smh101.com' -out /tmp/mycert.csr"
"RTN","ZOSVGUT2",134,0)
 N % S %=$$RETURN^%ZOSV(%CMD,1)
"RTN","ZOSVGUT2",135,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVGUT2",136,0)
 S %CMD="openssl req -x509 -days 365 -sha256 -in /tmp/mycert.csr -key /tmp/mycert.key -passin pass:monkey1234 -out /tmp/mycert.pem"
"RTN","ZOSVGUT2",137,0)
 ;I $$VERSION^%ZOSV["arwin" S %CMD="openssl req -x509 -days 365 -sha256 -in /tmp/mycert.csr -subj '/C=US/ST=Washington/L=Seattle/CN=www.smh101.com' -key /tmp/mycert.key -passin pass:monkey1234 -out /tmp/mycert.pem"
"RTN","ZOSVGUT2",138,0)
 N % S %=$$RETURN^%ZOSV(%CMD,1)
"RTN","ZOSVGUT2",139,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVGUT2",140,0)
 N CIPHERTEXT S CIPHERTEXT=$$RSAENCR^XUSHSH(SECRET,"/tmp/mycert.pem")
"RTN","ZOSVGUT2",141,0)
 D CHKTF^%ut($ZL(CIPHERTEXT)>$ZL(SECRET))
"RTN","ZOSVGUT2",142,0)
 N DECRYPTION S DECRYPTION=$$RSADECR^XUSHSH(CIPHERTEXT,"/tmp/mycert.key","monkey1234")
"RTN","ZOSVGUT2",143,0)
 D CHKEQ^%ut(SECRET,DECRYPTION)
"RTN","ZOSVGUT2",144,0)
 QUIT
"RTN","ZOSVGUT2",145,0)
 ;
"RTN","ZOSVGUT2",146,0)
AESENC ; @TEST Test AES Encryption
"RTN","ZOSVGUT2",147,0)
 N SECRET S SECRET="Alice and Bob had Sex!"
"RTN","ZOSVGUT2",148,0)
 N X S X=$$AESENCR^XUSHSH(SECRET,"ABCDABCDABCDABCD","DCBADCBADCBADCBA")
"RTN","ZOSVGUT2",149,0)
 N Y S Y=$$AESDECR^XUSHSH(X,"ABCDABCDABCDABCD","DCBADCBADCBADCBA")
"RTN","ZOSVGUT2",150,0)
 D CHKEQ^%ut(SECRET,Y)
"RTN","ZOSVGUT2",151,0)
 QUIT
"RTN","ZOSVGUT2",152,0)
 ;
"RTN","ZOSVGUT2",153,0)
BROKER ; @TEST Test the new GT.M MTL Broker
"RTN","ZOSVGUT2",154,0)
 ; Old version died after first connection.
"RTN","ZOSVGUT2",155,0)
 ; NB: It DOES NOT WANT anything that's not IPv4.
"RTN","ZOSVGUT2",156,0)
 ; Hard to do on any modern computer that is hardwired to give you IPv6
"RTN","ZOSVGUT2",157,0)
 ; addressed for localhost.
"RTN","ZOSVGUT2",158,0)
 N PORT S PORT=58738
"RTN","ZOSVGUT2",159,0)
 ; ZEXCEPT: ZISTCP,XWBTCPM1
"RTN","ZOSVGUT2",160,0)
 J ZISTCP^XWBTCPM1(58738)
"RTN","ZOSVGUT2",161,0)
 N BROKERJOB S BROKERJOB=$ZJOB
"RTN","ZOSVGUT2",162,0)
 N % S %=$$TEST^XWBTCPMT("127.0.0.1",PORT)
"RTN","ZOSVGUT2",163,0)
 D CHKEQ^%ut(+%,1)
"RTN","ZOSVGUT2",164,0)
 N % S %=$$TEST^XWBTCPMT("127.0.0.1",PORT)
"RTN","ZOSVGUT2",165,0)
 D CHKEQ^%ut(+%,1)
"RTN","ZOSVGUT2",166,0)
 N % S %=$$TEST^XWBTCPMT("127.0.0.1",PORT)
"RTN","ZOSVGUT2",167,0)
 D CHKEQ^%ut(+%,1)
"RTN","ZOSVGUT2",168,0)
 N % S %=$$TEST^XWBTCPMT("127.0.0.1",PORT)
"RTN","ZOSVGUT2",169,0)
 D CHKEQ^%ut(+%,1)
"RTN","ZOSVGUT2",170,0)
 N % S %=$$RETURN^%ZOSV("$gtm_dist/mupip stop "_BROKERJOB)
"RTN","ZOSVGUT2",171,0)
 H .05 ; It doesn't die right away...
"RTN","ZOSVGUT2",172,0)
 D CHKTF^%ut('$ZGETJPI(BROKERJOB,"ISPROCALIVE"))
"RTN","ZOSVGUT2",173,0)
 W ! ; reset $X
"RTN","ZOSVGUT2",174,0)
 QUIT
"RTN","ZOSVGUT2",175,0)
 ;
"RTN","ZOSVGUT2",176,0)
ACTJPEEK ; @TEST Active Jobs using $$^%PEEKBYNAME("node_local.ref_cnt",...)
"RTN","ZOSVGUT2",177,0)
 Q:$T(^%PEEKBYNAME)=""
"RTN","ZOSVGUT2",178,0)
 N % S %=$$^%PEEKBYNAME("node_local.ref_cnt","DEFAULT")
"RTN","ZOSVGUT2",179,0)
 D CHKTF^%ut(%>1)
"RTN","ZOSVGUT2",180,0)
 QUIT
"RTN","ZOSVGUT2",181,0)
ACTJREG ; @TEST Active Jobs using current API
"RTN","ZOSVGUT2",182,0)
 K ^XUTL("XUSYS","CNT")
"RTN","ZOSVGUT2",183,0)
 N % S %=$$ACTJ^%ZOSV
"RTN","ZOSVGUT2",184,0)
 D CHKTF^%ut(%>1)
"RTN","ZOSVGUT2",185,0)
 QUIT
"RTN","ZOSVGUT2",186,0)
XTROU ;;
"RTN","ZOSVGUT2",187,0)
 ;;ZOSVGUT3
"RTN","ZOSVGUT3")
0^17^B182146595
"RTN","ZOSVGUT3",1,0)
ZOSVGUT3 ; VEN/SMH - Unit Tests for GT.M VistA Port;2018-04-20  10:03 AM
"RTN","ZOSVGUT3",2,0)
 ;;8.0;KERNEL;**10002**;;Build 26
"RTN","ZOSVGUT3",3,0)
 ; Submitted to OSEHRA in 2017 by Sam Habiel for OSEHRA
"RTN","ZOSVGUT3",4,0)
 ; Authored by Sam Habiel 2017.
"RTN","ZOSVGUT3",5,0)
STARTUP QUIT
"RTN","ZOSVGUT3",6,0)
 ;
"RTN","ZOSVGUT3",7,0)
SHUTDOWN ; 
"RTN","ZOSVGUT3",8,0)
 S $ZSOURCE="ZOSVGUT3"
"RTN","ZOSVGUT3",9,0)
 QUIT
"RTN","ZOSVGUT3",10,0)
 ;
"RTN","ZOSVGUT3",11,0)
OPENH ; @TEST Read a Text File in w/ Handle
"RTN","ZOSVGUT3",12,0)
 ; OPEN^%ZISH([handle][,path,]filename,mode[,max][,subtype]) 
"RTN","ZOSVGUT3",13,0)
 N POP
"RTN","ZOSVGUT3",14,0)
 K ^TMP($J)
"RTN","ZOSVGUT3",15,0)
 D OPEN^%ZISH("FILE1","/usr/include/","stdio.h","R")
"RTN","ZOSVGUT3",16,0)
 I POP D FAIL^%ut("Couldn't open file") QUIT
"RTN","ZOSVGUT3",17,0)
 D USE^%ZISUTL("FILE1")
"RTN","ZOSVGUT3",18,0)
 F  R ^TMP($J,$I(^TMP($J))):0 Q:$$STATUS^%ZISH()
"RTN","ZOSVGUT3",19,0)
 D CLOSE^%ZISH("FILE1")
"RTN","ZOSVGUT3",20,0)
 W !
"RTN","ZOSVGUT3",21,0)
 D CHKTF^%ut(^TMP($J)>25)
"RTN","ZOSVGUT3",22,0)
 D CHKTF^%ut($D(^TMP($J,^TMP($J)-1)))
"RTN","ZOSVGUT3",23,0)
 QUIT
"RTN","ZOSVGUT3",24,0)
 ;
"RTN","ZOSVGUT3",25,0)
OPENNOH ; @TEST Read a Text File w/o a Handle
"RTN","ZOSVGUT3",26,0)
 N POP
"RTN","ZOSVGUT3",27,0)
 K ^TMP($J)
"RTN","ZOSVGUT3",28,0)
 D OPEN^%ZISH(,"/usr/include/","stdio.h","R")
"RTN","ZOSVGUT3",29,0)
 I POP D FAIL^%ut("Couldn't open file") QUIT
"RTN","ZOSVGUT3",30,0)
 U IO
"RTN","ZOSVGUT3",31,0)
 F  R ^TMP($J,$I(^TMP($J))):0 Q:$$STATUS^%ZISH()
"RTN","ZOSVGUT3",32,0)
 D CLOSE^%ZISH()
"RTN","ZOSVGUT3",33,0)
 W !
"RTN","ZOSVGUT3",34,0)
 D CHKTF^%ut(^TMP($J)>25)
"RTN","ZOSVGUT3",35,0)
 D CHKTF^%ut($D(^TMP($J,^TMP($J)-1)))
"RTN","ZOSVGUT3",36,0)
 QUIT
"RTN","ZOSVGUT3",37,0)
 ;
"RTN","ZOSVGUT3",38,0)
OPENBLOR ; @TEST Read a File as a binary device (FIXED WIDTH)
"RTN","ZOSVGUT3",39,0)
 N POP
"RTN","ZOSVGUT3",40,0)
 K ^TMP($J)
"RTN","ZOSVGUT3",41,0)
 D OPEN^%ZISH(,"/usr/include/","stdio.h","RB")
"RTN","ZOSVGUT3",42,0)
 I POP D FAIL^%ut("Couldn't open file") QUIT
"RTN","ZOSVGUT3",43,0)
 U IO
"RTN","ZOSVGUT3",44,0)
 F  R ^TMP($J,$I(^TMP($J))):0 Q:$$STATUS^%ZISH()
"RTN","ZOSVGUT3",45,0)
 D CLOSE^%ZISH()
"RTN","ZOSVGUT3",46,0)
 W !
"RTN","ZOSVGUT3",47,0)
 D CHKEQ^%ut($ZL(^TMP($J,5)),512,"Blocks are 512 bytes each")
"RTN","ZOSVGUT3",48,0)
 D CHKEQ^%ut($ZL(^TMP($J,5)),$ZL(^TMP($J,6)),"Blocks should all be the same size")
"RTN","ZOSVGUT3",49,0)
 QUIT
"RTN","ZOSVGUT3",50,0)
 ;
"RTN","ZOSVGUT3",51,0)
OPENBLOW ; @TEST Write a File as a binary device (Use Capri zip file in 316.18)
"RTN","ZOSVGUT3",52,0)
 I $O(^AUTTSITE(0)) QUIT  ; RPMS no CAPRI!
"RTN","ZOSVGUT3",53,0)
 N POP
"RTN","ZOSVGUT3",54,0)
 K ^TMP($J)
"RTN","ZOSVGUT3",55,0)
 N SUB S SUB=$O(^DVB(396.18,1,3,0))
"RTN","ZOSVGUT3",56,0)
 N FNNODE S FNNODE=^DVB(396.18,1,3,SUB,0)
"RTN","ZOSVGUT3",57,0)
 N L S L=$P(FNNODE," ",2)
"RTN","ZOSVGUT3",58,0)
 N FN S FN=$P(FNNODE," ",3)
"RTN","ZOSVGUT3",59,0)
 D OPEN^%ZISH(,$$DEFDIR^%ZISH(),FN,"WB",61)
"RTN","ZOSVGUT3",60,0)
 I POP D FAIL^%ut("Couldn't open file") QUIT
"RTN","ZOSVGUT3",61,0)
 U IO
"RTN","ZOSVGUT3",62,0)
 F  S SUB=$O(^DVB(396.18,1,3,SUB)) Q:'SUB  W ^(SUB,0)
"RTN","ZOSVGUT3",63,0)
 D CLOSE^%ZISH()
"RTN","ZOSVGUT3",64,0)
 D OPEN^%ZISH(,$$DEFDIR^%ZISH(),FN,"RB",61)
"RTN","ZOSVGUT3",65,0)
 I POP D FAIL^%ut("Couldn't open file") QUIT
"RTN","ZOSVGUT3",66,0)
 U IO
"RTN","ZOSVGUT3",67,0)
 N X R X:0
"RTN","ZOSVGUT3",68,0)
 D CLOSE^%ZISH()
"RTN","ZOSVGUT3",69,0)
 W !
"RTN","ZOSVGUT3",70,0)
 D CHKTF^%ut($L(X)=61,"record size isn't correct")
"RTN","ZOSVGUT3",71,0)
 QUIT
"RTN","ZOSVGUT3",72,0)
 ;
"RTN","ZOSVGUT3",73,0)
OPENBLOV ; @TEST Write and Read a variable record file
"RTN","ZOSVGUT3",74,0)
 I $O(^AUTTSITE(0)) QUIT  ; RPMS no CAPRI!
"RTN","ZOSVGUT3",75,0)
 N POP
"RTN","ZOSVGUT3",76,0)
 K ^TMP($J)
"RTN","ZOSVGUT3",77,0)
 N SUB S SUB=$O(^DVB(396.18,174,3,0))
"RTN","ZOSVGUT3",78,0)
 N FNNODE S FNNODE=^DVB(396.18,174,3,SUB,0)
"RTN","ZOSVGUT3",79,0)
 N L S L=$P(FNNODE," ",2)
"RTN","ZOSVGUT3",80,0)
 N FN S FN=$P(FNNODE," ",3)
"RTN","ZOSVGUT3",81,0)
 D OPEN^%ZISH(,$$DEFDIR^%ZISH(),FN,"W",61)
"RTN","ZOSVGUT3",82,0)
 I POP D FAIL^%ut("Couldn't open file") QUIT
"RTN","ZOSVGUT3",83,0)
 U IO
"RTN","ZOSVGUT3",84,0)
 F  S SUB=$O(^DVB(396.18,174,3,SUB)) Q:'SUB  W ^(SUB,0),!
"RTN","ZOSVGUT3",85,0)
 D CLOSE^%ZISH()
"RTN","ZOSVGUT3",86,0)
 D OPEN^%ZISH(,$$DEFDIR^%ZISH(),FN,"R")
"RTN","ZOSVGUT3",87,0)
 I POP D FAIL^%ut("Couldn't open file") QUIT
"RTN","ZOSVGUT3",88,0)
 U IO
"RTN","ZOSVGUT3",89,0)
 N X R X:0
"RTN","ZOSVGUT3",90,0)
 D CLOSE^%ZISH()
"RTN","ZOSVGUT3",91,0)
 W !
"RTN","ZOSVGUT3",92,0)
 D CHKTF^%ut($L(X)=61,"record size isn't correct")
"RTN","ZOSVGUT3",93,0)
 QUIT
"RTN","ZOSVGUT3",94,0)
 ;
"RTN","ZOSVGUT3",95,0)
OPENDF ; @TEST Open File from Default HFS Directory
"RTN","ZOSVGUT3",96,0)
 I $O(^AUTTSITE(0)) QUIT  ; RPMS no CAPRI!
"RTN","ZOSVGUT3",97,0)
 ; Uses the file from the last test.
"RTN","ZOSVGUT3",98,0)
 N POP
"RTN","ZOSVGUT3",99,0)
 N SUB S SUB=$O(^DVB(396.18,1,3,0))
"RTN","ZOSVGUT3",100,0)
 N FNNODE S FNNODE=^DVB(396.18,1,3,SUB,0)
"RTN","ZOSVGUT3",101,0)
 N L S L=$P(FNNODE," ",2)
"RTN","ZOSVGUT3",102,0)
 N FN S FN=$P(FNNODE," ",3)
"RTN","ZOSVGUT3",103,0)
 D OPEN^%ZISH(,,FN,"RB",61)
"RTN","ZOSVGUT3",104,0)
 D CHKTF^%ut(POP'=1)
"RTN","ZOSVGUT3",105,0)
 D CLOSE^%ZISH()
"RTN","ZOSVGUT3",106,0)
 QUIT
"RTN","ZOSVGUT3",107,0)
 ;
"RTN","ZOSVGUT3",108,0)
OPENSUB ; @TEST Open file with a Specific Subtype
"RTN","ZOSVGUT3",109,0)
 ; ZEXCEPT: IOM,IOSL
"RTN","ZOSVGUT3",110,0)
 I '$$FIND1^DIC(3.2,,"QX","P-HFS/80/99999") QUIT  ; RPMS again
"RTN","ZOSVGUT3",111,0)
 N POP
"RTN","ZOSVGUT3",112,0)
 K ^TMP($J)
"RTN","ZOSVGUT3",113,0)
 D OPEN^%ZISH(,"/usr/include/","stdio.h","R",,"P-HFS/80/99999")
"RTN","ZOSVGUT3",114,0)
 I POP D FAIL^%ut("Couldn't open file") QUIT
"RTN","ZOSVGUT3",115,0)
 U IO
"RTN","ZOSVGUT3",116,0)
 F  R ^TMP($J,$I(^TMP($J))):0 Q:$$STATUS^%ZISH()
"RTN","ZOSVGUT3",117,0)
 D CHKTF^%ut(^TMP($J)>25)
"RTN","ZOSVGUT3",118,0)
 D CHKTF^%ut($D(^TMP($J,^TMP($J)-1)))
"RTN","ZOSVGUT3",119,0)
 D CHKTF^%ut(IOM=80)
"RTN","ZOSVGUT3",120,0)
 D CHKTF^%ut(IOSL=65500)
"RTN","ZOSVGUT3",121,0)
 D CLOSE^%ZISH()
"RTN","ZOSVGUT3",122,0)
 QUIT
"RTN","ZOSVGUT3",123,0)
 ;
"RTN","ZOSVGUT3",124,0)
OPENDLM ; @TEST Forget delimiter in Path
"RTN","ZOSVGUT3",125,0)
 N POP
"RTN","ZOSVGUT3",126,0)
 K ^TMP($J)
"RTN","ZOSVGUT3",127,0)
 D OPEN^%ZISH(,"/usr/include","stdio.h","R")
"RTN","ZOSVGUT3",128,0)
 I POP D FAIL^%ut("Couldn't open file") QUIT
"RTN","ZOSVGUT3",129,0)
 U IO
"RTN","ZOSVGUT3",130,0)
 F  R ^TMP($J,$I(^TMP($J))):0 Q:$$STATUS^%ZISH()
"RTN","ZOSVGUT3",131,0)
 D CHKTF^%ut(^TMP($J)>25)
"RTN","ZOSVGUT3",132,0)
 D CHKTF^%ut($D(^TMP($J,^TMP($J)-1)))
"RTN","ZOSVGUT3",133,0)
 D CLOSE^%ZISH()
"RTN","ZOSVGUT3",134,0)
 QUIT
"RTN","ZOSVGUT3",135,0)
 ;
"RTN","ZOSVGUT3",136,0)
OPENAPP ; @TEST Open with appending
"RTN","ZOSVGUT3",137,0)
 N POP
"RTN","ZOSVGUT3",138,0)
 D OPEN^%ZISH(,,"test-for-sam.txt","W")
"RTN","ZOSVGUT3",139,0)
 I POP D FAIL^%ut("Couldn't open file") QUIT
"RTN","ZOSVGUT3",140,0)
 U IO
"RTN","ZOSVGUT3",141,0)
 W "TEST 1",!
"RTN","ZOSVGUT3",142,0)
 D CLOSE^%ZISH
"RTN","ZOSVGUT3",143,0)
 D OPEN^%ZISH(,,"test-for-sam.txt","WA")
"RTN","ZOSVGUT3",144,0)
 I POP D FAIL^%ut("Couldn't open file") QUIT
"RTN","ZOSVGUT3",145,0)
 U IO
"RTN","ZOSVGUT3",146,0)
 W "TEST 2",!
"RTN","ZOSVGUT3",147,0)
 D CLOSE^%ZISH
"RTN","ZOSVGUT3",148,0)
 D CHKTF^%ut($$RETURN^%ZOSV("wc -l "_$$DEFDIR^%ZISH()_"test-for-sam.txt | xargs | cut -d' ' -f1")=2)
"RTN","ZOSVGUT3",149,0)
 QUIT
"RTN","ZOSVGUT3",150,0)
 ;
"RTN","ZOSVGUT3",151,0)
PWD ; @TEST Get Current Working Directory
"RTN","ZOSVGUT3",152,0)
 D CHKTF^%ut($$PWD^%ZISH()=$ZD)
"RTN","ZOSVGUT3",153,0)
 QUIT
"RTN","ZOSVGUT3",154,0)
 ;
"RTN","ZOSVGUT3",155,0)
DEFDIR ; @TEST Default Directory
"RTN","ZOSVGUT3",156,0)
 N DEFDIR S DEFDIR=$$DEFDIR^%ZISH
"RTN","ZOSVGUT3",157,0)
 D CHKTF^%ut(DEFDIR["/tmp/"!(DEFDIR["/shm/"),"1")
"RTN","ZOSVGUT3",158,0)
 S DEFDIR=$$DEFDIR^%ZISH(".")
"RTN","ZOSVGUT3",159,0)
 D CHKTF^%ut(DEFDIR=$ZD,"2")
"RTN","ZOSVGUT3",160,0)
 S DEFDIR=$$DEFDIR^%ZISH("/usr/lib")
"RTN","ZOSVGUT3",161,0)
 D CHKTF^%ut($E(DEFDIR,$L(DEFDIR))="/","3")
"RTN","ZOSVGUT3",162,0)
 N OLDD S OLDD=$ZD
"RTN","ZOSVGUT3",163,0)
 S $ZD="/usr/"
"RTN","ZOSVGUT3",164,0)
 S DEFDIR=$$DEFDIR^%ZISH("./lib")
"RTN","ZOSVGUT3",165,0)
 D CHKTF^%ut(DEFDIR="/usr/lib/","4")
"RTN","ZOSVGUT3",166,0)
 S $ZD=OLDD
"RTN","ZOSVGUT3",167,0)
 D
"RTN","ZOSVGUT3",168,0)
 . N $ET,$ES S $ET="S $EC="""" D SUCCEED^%ut,UNWIND^%ZTER"
"RTN","ZOSVGUT3",169,0)
 . S DEFDIR=$$DEFDIR^%ZISH("/LKJASDLJ/ASLKDAIOUWRE/ASLK")
"RTN","ZOSVGUT3",170,0)
 QUIT
"RTN","ZOSVGUT3",171,0)
 ;
"RTN","ZOSVGUT3",172,0)
LIST ; @TEST LIST^%ZISH
"RTN","ZOSVGUT3",173,0)
 N PATH S PATH="/usr/include"
"RTN","ZOSVGUT3",174,0)
 N %ARR S %ARR("std*")=""
"RTN","ZOSVGUT3",175,0)
 N %RET
"RTN","ZOSVGUT3",176,0)
 N % S %=$$LIST^%ZISH(PATH,$NA(%ARR),$NA(%RET))
"RTN","ZOSVGUT3",177,0)
 N CNT,I
"RTN","ZOSVGUT3",178,0)
 S CNT=0,I=""
"RTN","ZOSVGUT3",179,0)
 F  S I=$O(%RET(I)) Q:I=""  S CNT=CNT+1
"RTN","ZOSVGUT3",180,0)
 D CHKTF^%ut(CNT'<3,1)
"RTN","ZOSVGUT3",181,0)
 D CHKTF^%ut(%,2)
"RTN","ZOSVGUT3",182,0)
 ;
"RTN","ZOSVGUT3",183,0)
 N PATH S PATH="/dsdfsadf/klasjdfasdf"
"RTN","ZOSVGUT3",184,0)
 N %ARR S %ARR("*")=""
"RTN","ZOSVGUT3",185,0)
 N %RET
"RTN","ZOSVGUT3",186,0)
 N % S %=$$LIST^%ZISH(PATH,$NA(%ARR),$NA(%RET))
"RTN","ZOSVGUT3",187,0)
 D CHKTF^%ut('%,3)
"RTN","ZOSVGUT3",188,0)
 ;
"RTN","ZOSVGUT3",189,0)
 I $ZPARSE("$vista_home/r/")="" QUIT
"RTN","ZOSVGUT3",190,0)
 N %ARR S %ARR("*")=""
"RTN","ZOSVGUT3",191,0)
 N %RET
"RTN","ZOSVGUT3",192,0)
 N % S %=$$LIST^%ZISH("$vista_home/r/",$NA(%ARR),$NA(%RET))
"RTN","ZOSVGUT3",193,0)
 N CNT,I
"RTN","ZOSVGUT3",194,0)
 S CNT=0,I=""
"RTN","ZOSVGUT3",195,0)
 F  S I=$O(%RET(I)) Q:I=""  S CNT=CNT+1
"RTN","ZOSVGUT3",196,0)
 D CHKTF^%ut(CNT>20000,4)
"RTN","ZOSVGUT3",197,0)
 D CHKTF^%ut(%,5)
"RTN","ZOSVGUT3",198,0)
 QUIT
"RTN","ZOSVGUT3",199,0)
 ;
"RTN","ZOSVGUT3",200,0)
MV ; @TEST MV^%ZISH
"RTN","ZOSVGUT3",201,0)
 N POP
"RTN","ZOSVGUT3",202,0)
 D OPEN^%ZISH(,,"test_for_sam2.txt","W")
"RTN","ZOSVGUT3",203,0)
 I POP D FAIL^%ut("Couldn't open file") QUIT
"RTN","ZOSVGUT3",204,0)
 U IO
"RTN","ZOSVGUT3",205,0)
 W "LINE1",!
"RTN","ZOSVGUT3",206,0)
 W "LINE2",!
"RTN","ZOSVGUT3",207,0)
 D CLOSE^%ZISH
"RTN","ZOSVGUT3",208,0)
 N % S %=$$MV^%ZISH(,"test_for_sam2.txt",,"test_for_sam3.txt")
"RTN","ZOSVGUT3",209,0)
 D OPEN^%ZISH(,,"test_for_sam3.txt","R")
"RTN","ZOSVGUT3",210,0)
 I POP D FAIL^%ut("Couldn't open file") QUIT
"RTN","ZOSVGUT3",211,0)
 E  D SUCCEED^%ut
"RTN","ZOSVGUT3",212,0)
 D CLOSE^%ZISH
"RTN","ZOSVGUT3",213,0)
 D OPEN^%ZISH(,,"test_for_sam2.txt","R")
"RTN","ZOSVGUT3",214,0)
 D CHKTF^%ut(POP)
"RTN","ZOSVGUT3",215,0)
 QUIT
"RTN","ZOSVGUT3",216,0)
 ;
"RTN","ZOSVGUT3",217,0)
FTGGTF ; @TEST $$FTG^%ZISH & $$GTF^%ZISH
"RTN","ZOSVGUT3",218,0)
 K ^TMP($J)
"RTN","ZOSVGUT3",219,0)
 N % S %=$$FTG^%ZISH("/usr/include","stdlib.h",$NA(^TMP($J,1,0)),2,"VVV")
"RTN","ZOSVGUT3",220,0)
 N LASTLINE S LASTLINE=$O(^TMP($J," "),-1)
"RTN","ZOSVGUT3",221,0)
 D CHKTF^%ut(LASTLINE>50,1)
"RTN","ZOSVGUT3",222,0)
 K ^TMP($J)
"RTN","ZOSVGUT3",223,0)
 N I F I=1:1:20 S $P(^TMP($J,I,0),"=",300)="="
"RTN","ZOSVGUT3",224,0)
 N % S %=$$GTF^%ZISH($NA(^TMP($J,1,0)),2,"/tmp/","test_long_records.glo")
"RTN","ZOSVGUT3",225,0)
 D CHKTF^%ut(%,2)
"RTN","ZOSVGUT3",226,0)
 D CHKTF^%ut($$RETURN^%ZOSV("stat /tmp/test_long_records.glo",1)=0,3)
"RTN","ZOSVGUT3",227,0)
 K ^TMP($J)
"RTN","ZOSVGUT3",228,0)
 N % S %=$$FTG^%ZISH("/tmp/","test_long_records.glo",$NA(^TMP($J,1,0)),2,"VVV")
"RTN","ZOSVGUT3",229,0)
 N LASTLINE S LASTLINE=$O(^TMP($J," "),-1)
"RTN","ZOSVGUT3",230,0)
 D CHKTF^%ut(LASTLINE=20,4)
"RTN","ZOSVGUT3",231,0)
 N VVV S VVV=0
"RTN","ZOSVGUT3",232,0)
 N I F I=0:0 S I=$O(^TMP($J,I)) Q:'I  I $D(^(I,"VVV")) S VVV=1
"RTN","ZOSVGUT3",233,0)
 D CHKTF^%ut(VVV=0,5)
"RTN","ZOSVGUT3",234,0)
 ;
"RTN","ZOSVGUT3",235,0)
 ; Test maximum length
"RTN","ZOSVGUT3",236,0)
 N MAX S MAX=$$MAXREC^%ZISH($NA(^TMP($J,1,0)))
"RTN","ZOSVGUT3",237,0)
 N A,B,C
"RTN","ZOSVGUT3",238,0)
 S $P(A,"=",MAX+20)="="
"RTN","ZOSVGUT3",239,0)
 S $P(B,"=",MAX+20)="="
"RTN","ZOSVGUT3",240,0)
 S $P(C,"=",MAX+20)="="
"RTN","ZOSVGUT3",241,0)
 D OPEN^%ZISH(,"/tmp/","test_overflow_records.glo","W")
"RTN","ZOSVGUT3",242,0)
 U IO W A,!,B,!,C,!
"RTN","ZOSVGUT3",243,0)
 D CLOSE^%ZISH()
"RTN","ZOSVGUT3",244,0)
 K ^TMP($J)
"RTN","ZOSVGUT3",245,0)
 N % S %=$$FTG^%ZISH("/tmp/","test_overflow_records.glo",$NA(^TMP($J,1,0)),2,"VVV")
"RTN","ZOSVGUT3",246,0)
 N VVV S VVV=0
"RTN","ZOSVGUT3",247,0)
 N I F I=0:0 S I=$O(^TMP($J,I)) Q:'I  I $D(^(I,"VVV")) S VVV=1
"RTN","ZOSVGUT3",248,0)
 D CHKTF^%ut(VVV=1,6)
"RTN","ZOSVGUT3",249,0)
 QUIT
"RTN","ZOSVGUT3",250,0)
 ;
"RTN","ZOSVGUT3",251,0)
GATF ; @TEST $$GATF^%ZISH
"RTN","ZOSVGUT3",252,0)
 N % S %=$$GATF^%ZISH($NA(^VA(200,1,0)),2,"/tmp/","test_append_records.glo")
"RTN","ZOSVGUT3",253,0)
 D CHKTF^%ut(%=1)
"RTN","ZOSVGUT3",254,0)
 N % S %=$$GATF^%ZISH($NA(^DIC(5,1,0)),2,"/tmp/","test_append_records.glo")
"RTN","ZOSVGUT3",255,0)
 D CHKTF^%ut(%=1)
"RTN","ZOSVGUT3",256,0)
 N % S %=$$GATF^%ZISH($NA(^DIC(4,1,0)),2,"/tmp/","test_append_records.glo")
"RTN","ZOSVGUT3",257,0)
 D CHKTF^%ut(%=1)
"RTN","ZOSVGUT3",258,0)
 N VA200,DIC5,DIC4
"RTN","ZOSVGUT3",259,0)
 S (VA200,DIC5,DIC4)=0
"RTN","ZOSVGUT3",260,0)
 K ^TMP($J)
"RTN","ZOSVGUT3",261,0)
 N % S %=$$FTG^%ZISH("/tmp/","test_append_records.glo",$NA(^TMP($J,1,0)),2)
"RTN","ZOSVGUT3",262,0)
 N I,Z F I=0:0 S I=$O(^TMP($J,I)) Q:'I  S Z=^(I,0) D
"RTN","ZOSVGUT3",263,0)
 . I Z["TASKMAN" S VA200=1 ; Taskman User
"RTN","ZOSVGUT3",264,0)
 . I Z["DOCTOR" S VA200=1  ; ditto, WV
"RTN","ZOSVGUT3",265,0)
 . I Z["CANADA" S DIC5=1   ; State File
"RTN","ZOSVGUT3",266,0)
 . I Z["VISN" S DIC4=1     ; Institution File
"RTN","ZOSVGUT3",267,0)
 . I Z["GALLUP" S DIC4=1   ; Ditto, for RPMS
"RTN","ZOSVGUT3",268,0)
 D CHKTF^%ut(VA200=1)
"RTN","ZOSVGUT3",269,0)
 D CHKTF^%ut(DIC5=1)
"RTN","ZOSVGUT3",270,0)
 D CHKTF^%ut(DIC4=1)
"RTN","ZOSVGUT3",271,0)
 QUIT
"RTN","ZOSVGUT3",272,0)
 ;
"RTN","ZOSVGUT3",273,0)
DEL1 ; @TEST DEL1^%ZISH
"RTN","ZOSVGUT3",274,0)
 ; Diabetes.pnl.zip
"RTN","ZOSVGUT3",275,0)
 ; test_append_records.glo
"RTN","ZOSVGUT3",276,0)
 ; test_for_sam3.txt
"RTN","ZOSVGUT3",277,0)
 ; test_long_records.glo
"RTN","ZOSVGUT3",278,0)
 ; test_overflow_records.glo
"RTN","ZOSVGUT3",279,0)
 ; test.sam
"RTN","ZOSVGUT3",280,0)
 N % S %=$$DEL1^%ZISH("/tmp/Diabetes.pnl.zip")
"RTN","ZOSVGUT3",281,0)
 D CHKTF^%ut(%=1)
"RTN","ZOSVGUT3",282,0)
 N % S %=$$DEL1^%ZISH("/tmp/test_append_records.glo")
"RTN","ZOSVGUT3",283,0)
 D CHKTF^%ut(%=1)
"RTN","ZOSVGUT3",284,0)
 N % S %=$$DEL1^%ZISH("/tmp/test_for_sam3.txt")
"RTN","ZOSVGUT3",285,0)
 D CHKTF^%ut(%=1)
"RTN","ZOSVGUT3",286,0)
 N % S %=$$DEL1^%ZISH("/tmp/test_long_records.glo")
"RTN","ZOSVGUT3",287,0)
 D CHKTF^%ut(%=1)
"RTN","ZOSVGUT3",288,0)
 N % S %=$$DEL1^%ZISH("/tmp/test_overflow_records.glo")
"RTN","ZOSVGUT3",289,0)
 D CHKTF^%ut(%=1)
"RTN","ZOSVGUT3",290,0)
 N % S %=$$RETURN^%ZOSV("stat /tmp/test_overflow_records.glo",1)
"RTN","ZOSVGUT3",291,0)
 D CHKTF^%ut(%'=0)
"RTN","ZOSVGUT3",292,0)
 QUIT
"RTN","ZOSVGUT3",293,0)
 ;
"RTN","ZOSVGUT3",294,0)
DEL ; @TEST Delete files we created in the tests
"RTN","ZOSVGUT3",295,0)
 I $O(^AUTTSITE(0)) QUIT  ; RPMS no CAPRI!
"RTN","ZOSVGUT3",296,0)
 I $$VERSION^%ZOSV(0)<6.1 QUIT  ; $ZCLOSE
"RTN","ZOSVGUT3",297,0)
 ;
"RTN","ZOSVGUT3",298,0)
 N DELARRAY
"RTN","ZOSVGUT3",299,0)
 S DELARRAY("test-for-sam.txt")=""
"RTN","ZOSVGUT3",300,0)
 ;
"RTN","ZOSVGUT3",301,0)
 N SUB S SUB=$O(^DVB(396.18,1,3,0))
"RTN","ZOSVGUT3",302,0)
 N FNNODE S FNNODE=^DVB(396.18,1,3,SUB,0)
"RTN","ZOSVGUT3",303,0)
 N FN S FN=$P(FNNODE," ",3)
"RTN","ZOSVGUT3",304,0)
 S DELARRAY(FN)=""
"RTN","ZOSVGUT3",305,0)
 ;
"RTN","ZOSVGUT3",306,0)
 N DIR S DIR=$$DEFDIR^%ZISH()
"RTN","ZOSVGUT3",307,0)
 ;
"RTN","ZOSVGUT3",308,0)
 N FULLPATH
"RTN","ZOSVGUT3",309,0)
 S FULLPATH=DIR_"test-for-sam.txt"
"RTN","ZOSVGUT3",310,0)
 N STATCMD S STATCMD="stat -t "
"RTN","ZOSVGUT3",311,0)
 I $$VERSION^%ZOSV(1)["Darwin" S STATCMD="stat -q "
"RTN","ZOSVGUT3",312,0)
 N % S %=$$RETURN^%ZOSV(STATCMD_FULLPATH,1)
"RTN","ZOSVGUT3",313,0)
 D CHKTF^%ut(%=0,1)
"RTN","ZOSVGUT3",314,0)
 S FULLPATH=DIR_FN
"RTN","ZOSVGUT3",315,0)
 N % S %=$$RETURN^%ZOSV(STATCMD_FULLPATH,1)
"RTN","ZOSVGUT3",316,0)
 D CHKTF^%ut(%=0,2)
"RTN","ZOSVGUT3",317,0)
 N % S %=$$DEL^%ZISH(DIR,$NA(DELARRAY))
"RTN","ZOSVGUT3",318,0)
 D CHKTF^%ut(%=1,2.5)
"RTN","ZOSVGUT3",319,0)
 S FULLPATH=DIR_"test-for-sam.txt"
"RTN","ZOSVGUT3",320,0)
 N % S %=$$RETURN^%ZOSV(STATCMD_FULLPATH,1)
"RTN","ZOSVGUT3",321,0)
 D CHKTF^%ut(%'=0,3)
"RTN","ZOSVGUT3",322,0)
 S FULLPATH=DIR_FN
"RTN","ZOSVGUT3",323,0)
 N % S %=$$RETURN^%ZOSV(STATCMD_FULLPATH,1)
"RTN","ZOSVGUT3",324,0)
 D CHKTF^%ut(%'=0,4)
"RTN","ZOSVGUT3",325,0)
 QUIT
"RTN","ZOSVGUT3",326,0)
 ;
"RTN","ZOSVGUT3",327,0)
DELERR ; @TEST Delete Error
"RTN","ZOSVGUT3",328,0)
 D
"RTN","ZOSVGUT3",329,0)
 . N $ET,$ES
"RTN","ZOSVGUT3",330,0)
 . D DELERR^%ZISH
"RTN","ZOSVGUT3",331,0)
 D SUCCEED^%ut
"RTN","ZOSVGUT3",332,0)
 QUIT
"RTN","ZOSVGUT3",333,0)
 ;
"RTN","ZOSVGUT3",334,0)
 ;  --- RPMS %ZISH enhancements unit tests ---
"RTN","ZOSVGUT3",335,0)
OPENRPMS ; @TEST Test RPMS OPEN^%ZISH (3 arg open)
"RTN","ZOSVGUT3",336,0)
 N POP
"RTN","ZOSVGUT3",337,0)
 N % S %=$$OPEN^%ZISH("/usr/include/","stdio.h","R")
"RTN","ZOSVGUT3",338,0)
 I POP D FAIL^%ut("Couldn't open file") QUIT
"RTN","ZOSVGUT3",339,0)
 D CHKEQ^%ut(%,0,"0 means success")
"RTN","ZOSVGUT3",340,0)
 U IO
"RTN","ZOSVGUT3",341,0)
 F  R ^TMP($J,$I(^TMP($J))):0 Q:$$STATUS^%ZISH()
"RTN","ZOSVGUT3",342,0)
 D CHKTF^%ut(^TMP($J)>25)
"RTN","ZOSVGUT3",343,0)
 D CHKTF^%ut($D(^TMP($J,^TMP($J)-1)))
"RTN","ZOSVGUT3",344,0)
 K ^TMP($J)
"RTN","ZOSVGUT3",345,0)
 D CLOSE^%ZISH
"RTN","ZOSVGUT3",346,0)
 N %1 S %1=$$OPEN^%ZISH("/usr/include/","stdiolzkjalkjasdlfk.h","R")
"RTN","ZOSVGUT3",347,0)
 D CHKEQ^%ut(%1,1,"1 means failure")
"RTN","ZOSVGUT3",348,0)
 QUIT
"RTN","ZOSVGUT3",349,0)
 ;
"RTN","ZOSVGUT3",350,0)
DELRPMS ; @TEST Test RPMS DEL^%ZISH (reverse success, pass by value)
"RTN","ZOSVGUT3",351,0)
 I $$VERSION^%ZOSV(0)<6.1 QUIT  ; $ZCLOSE
"RTN","ZOSVGUT3",352,0)
 N POP
"RTN","ZOSVGUT3",353,0)
 D OPEN^%ZISH("/tmp/","sam-rpms-text.txt","W")
"RTN","ZOSVGUT3",354,0)
 I POP D FAIL^%ut("Couldn't open file") QUIT
"RTN","ZOSVGUT3",355,0)
 U IO
"RTN","ZOSVGUT3",356,0)
 W "BOO"
"RTN","ZOSVGUT3",357,0)
 D CLOSE^%ZISH
"RTN","ZOSVGUT3",358,0)
 D CHKEQ^%ut($$RETURN^%ZOSV("stat /tmp/sam-rpms-text.txt",1),0)
"RTN","ZOSVGUT3",359,0)
 N %1 S %1=$$DEL^%ZISH("/tmp/","sam-rpms-text.txt")
"RTN","ZOSVGUT3",360,0)
 D CHKEQ^%ut(%1,0)
"RTN","ZOSVGUT3",361,0)
 D CHKEQ^%ut($$RETURN^%ZOSV("stat /tmp/sam-rpms-text.txt",1),1)
"RTN","ZOSVGUT3",362,0)
 ;
"RTN","ZOSVGUT3",363,0)
 ; Try deleting non-sense RPMS style (triggers internal error trap which returns 1)
"RTN","ZOSVGUT3",364,0)
 N %2 S %2=$$DEL^%ZISH("/","pi-ka-boo-pikachu.txt")
"RTN","ZOSVGUT3",365,0)
 D CHKEQ^%ut(%2,1)
"RTN","ZOSVGUT3",366,0)
 QUIT
"RTN","ZOSVGUT3",367,0)
 ;
"RTN","ZOSVGUT3",368,0)
LISTRPMS ; @TEST Test LIST RPMS Version (2nd par is by value not by name)
"RTN","ZOSVGUT3",369,0)
 N PATH S PATH="/usr/include"
"RTN","ZOSVGUT3",370,0)
 N %RET
"RTN","ZOSVGUT3",371,0)
 N % S %=$$LIST^%ZISH(PATH,"std*",.%RET)
"RTN","ZOSVGUT3",372,0)
 N CNT,I
"RTN","ZOSVGUT3",373,0)
 S CNT=0,I=""
"RTN","ZOSVGUT3",374,0)
 F  S I=$O(%RET(I)) Q:I=""  S CNT=CNT+1
"RTN","ZOSVGUT3",375,0)
 D CHKTF^%ut(CNT'<3,1)
"RTN","ZOSVGUT3",376,0)
 D CHKEQ^%ut(%,0) ; Return 0 for success
"RTN","ZOSVGUT3",377,0)
 ;
"RTN","ZOSVGUT3",378,0)
 N PATH S PATH="/dsdfsadf/klasjdfasdf"
"RTN","ZOSVGUT3",379,0)
 N %RET
"RTN","ZOSVGUT3",380,0)
 N % S %=$$LIST^%ZISH(PATH,"*",.%RET)
"RTN","ZOSVGUT3",381,0)
 D CHKEQ^%ut(%,1) ; Return 1 for failure
"RTN","ZOSVGUT3",382,0)
 ;
"RTN","ZOSVGUT3",383,0)
 I $ZPARSE("$vista_home/r/")="" QUIT
"RTN","ZOSVGUT3",384,0)
 N %RET
"RTN","ZOSVGUT3",385,0)
 N % S %=$$LIST^%ZISH("$vista_home/r/","*",.%RET)
"RTN","ZOSVGUT3",386,0)
 N CNT,I
"RTN","ZOSVGUT3",387,0)
 S CNT=0,I=""
"RTN","ZOSVGUT3",388,0)
 F  S I=$O(%RET(I)) Q:I=""  S CNT=CNT+1
"RTN","ZOSVGUT3",389,0)
 D CHKTF^%ut(CNT>20000,4)
"RTN","ZOSVGUT3",390,0)
 D CHKEQ^%ut(%,0) ; Return 0 for success
"RTN","ZOSVGUT3",391,0)
 QUIT
"RTN","ZOSVGUT3",392,0)
 ;
"RTN","ZOSVGUT3",393,0)
SIZE ; @TEST $$SIZE^%ZISH
"RTN","ZOSVGUT3",394,0)
 N % S %=$$SIZE^%ZISH("/usr/include/","stdio.h")
"RTN","ZOSVGUT3",395,0)
 D CHKTF^%ut(%>1000)
"RTN","ZOSVGUT3",396,0)
 QUIT
"RTN","ZOSVGUT3",397,0)
 ;
"RTN","ZOSVGUT3",398,0)
MKDIR ; @TEST $$MKDIR^%ZISH
"RTN","ZOSVGUT3",399,0)
 N % S %=$$RETURN^%ZOSV("rm -r /tmp/foo/boo",1)
"RTN","ZOSVGUT3",400,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVGUT3",401,0)
 N % S %=$$MKDIR^%ZISH("/tmp/foo/boo")
"RTN","ZOSVGUT3",402,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVGUT3",403,0)
 N % S %=$$RETURN^%ZOSV("stat /tmp/foo/boo",1)
"RTN","ZOSVGUT3",404,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVGUT3",405,0)
 QUIT
"RTN","ZOSVGUT3",406,0)
 ;
"RTN","ZOSVGUT3",407,0)
WGETSYNC ; @TEST $$WGETSYNC^%ZISH on NDF DAT files
"RTN","ZOSVGUT3",408,0)
 N SEC1 S SEC1=$P($H,",",2)
"RTN","ZOSVGUT3",409,0)
 N % S %=$$WGETSYNC^%ZISH("foia-vista.osehra.org","Patches_By_Application/PSN-NATIONAL DRUG FILE (NDF)/PPS_DATS/","/tmp/foo/boo","*.DAT*")
"RTN","ZOSVGUT3",410,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVGUT3",411,0)
 N A,CURR S A("*")=""
"RTN","ZOSVGUT3",412,0)
 N % S %=$$LIST^%ZISH("/tmp/foo/boo","A","CURR")
"RTN","ZOSVGUT3",413,0)
 D CHKTF^%ut($D(CURR("PPS_0PRV_1NEW.DAT")))
"RTN","ZOSVGUT3",414,0)
 ; 
"RTN","ZOSVGUT3",415,0)
 ; Do it again. Should be faster.
"RTN","ZOSVGUT3",416,0)
 N SEC2 S SEC2=$P($H,",",2)
"RTN","ZOSVGUT3",417,0)
 N % S %=$$WGETSYNC^%ZISH("foia-vista.osehra.org","Patches_By_Application/PSN-NATIONAL DRUG FILE (NDF)/PPS_DATS/","/tmp/foo/boo","*.DAT*")
"RTN","ZOSVGUT3",418,0)
 N A,CURR S A("*")=""
"RTN","ZOSVGUT3",419,0)
 N % S %=$$LIST^%ZISH("/tmp/foo/boo","A","CURR")
"RTN","ZOSVGUT3",420,0)
 D CHKTF^%ut($D(CURR("PPS_0PRV_1NEW.DAT")))
"RTN","ZOSVGUT3",421,0)
 ;
"RTN","ZOSVGUT3",422,0)
 ; Remove a file and download again
"RTN","ZOSVGUT3",423,0)
 N SEC3 S SEC3=$P($H,",",2)
"RTN","ZOSVGUT3",424,0)
 N % S %=$$RETURN^%ZOSV("rm /tmp/foo/boo/PPS_2PRV_3NEW.DAT",1)
"RTN","ZOSVGUT3",425,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVGUT3",426,0)
 N % S %=$$WGETSYNC^%ZISH("foia-vista.osehra.org","Patches_By_Application/PSN-NATIONAL DRUG FILE (NDF)/PPS_DATS/","/tmp/foo/boo","*.DAT*")
"RTN","ZOSVGUT3",427,0)
 N A,CURR S A("*")=""
"RTN","ZOSVGUT3",428,0)
 N % S %=$$LIST^%ZISH("/tmp/foo/boo","A","CURR")
"RTN","ZOSVGUT3",429,0)
 D CHKTF^%ut($D(CURR("PPS_2PRV_3NEW.DAT")))
"RTN","ZOSVGUT3",430,0)
 ;
"RTN","ZOSVGUT3",431,0)
 D CHKTF^%ut((SEC3-SEC2)'>(SEC2-SEC1))
"RTN","ZOSVGUT3",432,0)
 QUIT
"RTN","ZOSVGUT3",433,0)
 ;
"RTN","ZOSVGUT3",434,0)
SEND ; @TEST Test SEND^%ZISH (NOOP)
"RTN","ZOSVGUT3",435,0)
 N % S %=$$SEND^%ZISH()
"RTN","ZOSVGUT3",436,0)
 D SUCCEED^%ut
"RTN","ZOSVGUT3",437,0)
 QUIT
"RTN","ZOSVGUT3",438,0)
 ;
"RTN","ZOSVGUT3",439,0)
SENDTO1 ; @TEST Test SENDTO1^%ZISH (NOOP)
"RTN","ZOSVGUT3",440,0)
 N % S %=$$SENDTO1^%ZISH()
"RTN","ZOSVGUT3",441,0)
 D SUCCEED^%ut
"RTN","ZOSVGUT3",442,0)
 QUIT
"RTN","ZOSVGUT3",443,0)
 ;
"RTN","ZOSVGUT3",444,0)
DF ; @TEST Test DF^%ZISH (Directory Format)
"RTN","ZOSVGUT3",445,0)
 N D S D="\var\db\vista"
"RTN","ZOSVGUT3",446,0)
 D DF^%ZISH(.D)
"RTN","ZOSVGUT3",447,0)
 D CHKEQ^%ut(D,"/var/db/vista/")
"RTN","ZOSVGUT3",448,0)
 QUIT
"RTN","ZOSVGUT3",449,0)
 ;
"RTN","ZOSVGUX")
0^1^B45533042
"RTN","ZOSVGUX",1,0)
%ZOSV ;VEN/SMH,KRM/CJE,FIS/KSB - View commands & special functions. ;2018-02-26  1:05 PM
"RTN","ZOSVGUX",2,0)
 ;;8.0;KERNEL;**275,425,499,10001,10002**;Jul 10, 1995;Build 26
"RTN","ZOSVGUX",3,0)
 ; Submitted to OSEHRA in 2017 by Sam Habiel for OSEHRA
"RTN","ZOSVGUX",4,0)
 ; Original Routine authored by Department of Veterans Affairs
"RTN","ZOSVGUX",5,0)
 ; Almost the entire routine was rewritten by Sam Habiel, Christopher Edwards, KS Bhaskar
"RTN","ZOSVGUX",6,0)
 ;
"RTN","ZOSVGUX",7,0)
ACTJ() ; # active jobs
"RTN","ZOSVGUX",8,0)
 ; Next call active as of 6.3
"RTN","ZOSVGUX",9,0)
 I $T(^%PEEKBYNAME)]"" Q $$^%PEEKBYNAME("node_local.ref_cnt","DEFAULT")
"RTN","ZOSVGUX",10,0)
 I ($G(^XUTL("XUSYS","CNT"))<1)!($G(^XUTL("XUSYS","CNT","SEC"))>($$SEC^XLFDT($H)+3600)) D
"RTN","ZOSVGUX",11,0)
 . I $$UP^XLFSTR($ZV)["LINUX" D
"RTN","ZOSVGUX",12,0)
 .. N I,IO,LINE
"RTN","ZOSVGUX",13,0)
 .. S IO=$IO
"RTN","ZOSVGUX",14,0)
 .. O "FTOK":(SHELL="/bin/sh":COMMAND="$gtm_dist/mupip ftok "_$V("GVFILE","DEFAULT"):READONLY)::"PIPE" U "FTOK"
"RTN","ZOSVGUX",15,0)
 .. F I=1:1:3 R LINE
"RTN","ZOSVGUX",16,0)
 .. O "IPCS":(SHELL="/bin/sh":COMMAND="ipcs -mi "_$TR($P($P(LINE,"::",3),"[",1)," ",""):READONLY)::"PIPE" U "IPCS"
"RTN","ZOSVGUX",17,0)
 .. F I=1:1 R LINE Q:$ZEO  I 1<$L(LINE,"nattch=") S ^XUTL("XUSYS","CNT")=+$P(LINE,"nattch=",2) Q
"RTN","ZOSVGUX",18,0)
 .. U IO C "FTOK" C "IPCS"
"RTN","ZOSVGUX",19,0)
 . ;
"RTN","ZOSVGUX",20,0)
 . I $$UP^XLFSTR($ZV)["DARWIN" D  ; OSEHRA/SMH - Should work on Linux too!
"RTN","ZOSVGUX",21,0)
 .. N I,IO,LINE
"RTN","ZOSVGUX",22,0)
 .. S IO=$IO
"RTN","ZOSVGUX",23,0)
 .. ; Count number of processes returned by lsof accessing this database; and trim using xargs
"RTN","ZOSVGUX",24,0)
 .. O "LSOF":(SHELL="/bin/sh":COMMAND="lsof -t "_$V("GVFILE","DEFAULT")_" | wc -l | xargs":READONLY)::"PIPE" U "LSOF"
"RTN","ZOSVGUX",25,0)
 .. F  R LINE:1 Q:$ZEOF  Q:LINE
"RTN","ZOSVGUX",26,0)
 .. S ^XUTL("XUSYS","CNT")=LINE
"RTN","ZOSVGUX",27,0)
 .. U IO C "LSOF"
"RTN","ZOSVGUX",28,0)
 . ;
"RTN","ZOSVGUX",29,0)
 . I $$UP^XLFSTR($ZV)["CYGWIN" D
"RTN","ZOSVGUX",30,0)
 .. S ^XUTL("XUSYS","CNT")=+$$RETURN^%ZOSV("ps -as | grep mumps | grep -v grep | wc -l")
"RTN","ZOSVGUX",31,0)
 . ;
"RTN","ZOSVGUX",32,0)
 . S ^XUTL("XUSYS","CNT","SEC")=$$SEC^XLFDT($H)
"RTN","ZOSVGUX",33,0)
 Q ^XUTL("XUSYS","CNT")
"RTN","ZOSVGUX",34,0)
 ;
"RTN","ZOSVGUX",35,0)
AVJ() ; # available jobs, Limit is in the OS.
"RTN","ZOSVGUX",36,0)
 N V,J
"RTN","ZOSVGUX",37,0)
 S V=^%ZOSF("VOL"),J=$O(^XTV(8989.3,1,4,"B",V,0)),J=$P($G(^XTV(8989.3,1,4,J,0),"^^1000"),"^",3)
"RTN","ZOSVGUX",38,0)
 Q J-$$ACTJ ;Use signon Max
"RTN","ZOSVGUX",39,0)
 ;
"RTN","ZOSVGUX",40,0)
RTNDIR() ; primary routine source directory
"RTN","ZOSVGUX",41,0)
 N DIRS
"RTN","ZOSVGUX",42,0)
 D PARSEZRO(.DIRS,$ZRO)
"RTN","ZOSVGUX",43,0)
 N I F I=1:1 Q:'$D(DIRS(I))  I DIRS(I)[".so" K DIRS(I)
"RTN","ZOSVGUX",44,0)
 I '$D(DIRS) S $EC=",U255,"
"RTN","ZOSVGUX",45,0)
 QUIT $$ZRO1ST(.DIRS)
"RTN","ZOSVGUX",46,0)
 ;
"RTN","ZOSVGUX",47,0)
PARSEZRO(DIRS,ZRO) ; Parse $zroutines properly into an array
"RTN","ZOSVGUX",48,0)
 ; Eat spaces
"RTN","ZOSVGUX",49,0)
 F  Q:($E(ZRO)'=" ")  S ZRO=$E(ZRO,2,1024) ; 1023 is the GT.M maximum
"RTN","ZOSVGUX",50,0)
 ;
"RTN","ZOSVGUX",51,0)
 N PIECE
"RTN","ZOSVGUX",52,0)
 N I
"RTN","ZOSVGUX",53,0)
 F I=1:1:$L(ZRO," ") S PIECE(I)=$P(ZRO," ",I)
"RTN","ZOSVGUX",54,0)
 N CNT S CNT=1
"RTN","ZOSVGUX",55,0)
 F I=0:0 S I=$O(PIECE(I)) Q:'I  D
"RTN","ZOSVGUX",56,0)
 . S DIRS(CNT)=$G(DIRS(CNT))_PIECE(I)
"RTN","ZOSVGUX",57,0)
 . I DIRS(CNT)["("&(DIRS(CNT)[")") S CNT=CNT+1 QUIT
"RTN","ZOSVGUX",58,0)
 . I DIRS(CNT)'["("&(DIRS(CNT)'[")") S CNT=CNT+1 QUIT
"RTN","ZOSVGUX",59,0)
 . S DIRS(CNT)=DIRS(CNT)_" " ; prep for next piece
"RTN","ZOSVGUX",60,0)
 QUIT
"RTN","ZOSVGUX",61,0)
 ;
"RTN","ZOSVGUX",62,0)
ZRO1ST(DIRS) ; $$ Get first usable routine directory
"RTN","ZOSVGUX",63,0)
 N OUT S OUT="" ; $$ Return; default empty
"RTN","ZOSVGUX",64,0)
 N I F I=0:0 S I=$O(DIRS(I)) Q:'I  D  Q:OUT]""  ; 1st directory
"RTN","ZOSVGUX",65,0)
 . N %1 S %1=DIRS(I)
"RTN","ZOSVGUX",66,0)
 . N SO S SO=$E(%1,$L(%1)-2,$L(%1))
"RTN","ZOSVGUX",67,0)
 . S SO=$$UP^XLFSTR(SO)
"RTN","ZOSVGUX",68,0)
 . I SO=".SO" QUIT
"RTN","ZOSVGUX",69,0)
 . ;
"RTN","ZOSVGUX",70,0)
 . ; Parse with (...)
"RTN","ZOSVGUX",71,0)
 . I %1["(" DO
"RTN","ZOSVGUX",72,0)
 . . S OUT=$P(%1,"(",2)
"RTN","ZOSVGUX",73,0)
 . . I OUT[" " S OUT=$P(OUT," ")
"RTN","ZOSVGUX",74,0)
 . . E  S OUT=$P(OUT,")")
"RTN","ZOSVGUX",75,0)
 . ; no parens
"RTN","ZOSVGUX",76,0)
 . E  S OUT=%1
"RTN","ZOSVGUX",77,0)
 ;
"RTN","ZOSVGUX",78,0)
 ; Add trailing slash
"RTN","ZOSVGUX",79,0)
 I OUT]"",$E(OUT,$L(OUT))'="/" S OUT=OUT_"/"
"RTN","ZOSVGUX",80,0)
 QUIT OUT
"RTN","ZOSVGUX",81,0)
 ;
"RTN","ZOSVGUX",82,0)
TEMP() ; Return path to temp directory
"RTN","ZOSVGUX",83,0)
 ;N %TEMP S %TEMP=$P($$RTNDIR," "),%TEMP=$P(%TEMP,"/",1,$L(%TEMP,"/")-2)_"/t/"
"RTN","ZOSVGUX",84,0)
 Q $G(^%ZOSF("TMP"),$P($G(^XTV(8989.3,1,"DEV"),"/tmp/"),U))
"RTN","ZOSVGUX",85,0)
 ;
"RTN","ZOSVGUX",86,0)
PASSALL ;
"RTN","ZOSVGUX",87,0)
 U $I:(NOESCAPE:NOTERMINATOR:PASTHRU) Q
"RTN","ZOSVGUX",88,0)
NOPASS ;
"RTN","ZOSVGUX",89,0)
 U $I:(ESCAPE:TERMINATOR="":NOPASTHRU) Q
"RTN","ZOSVGUX",90,0)
 ;
"RTN","ZOSVGUX",91,0)
GETPEER() ;Get the IP address of a connection peer
"RTN","ZOSVGUX",92,0)
 N PEER
"RTN","ZOSVGUX",93,0)
 S PEER=$P($ZTRNLNM("SSH_CLIENT")," ") S:PEER="" PEER=$ZTRNLNM("REMOTEHOST")
"RTN","ZOSVGUX",94,0)
 S PEER=$S($L(PEER):PEER,$L($G(IO("IP"))):IO("IP"),$L($G(IO("GTM-IP"))):IO("GTM-IP"),1:"")
"RTN","ZOSVGUX",95,0)
 I $G(^XTV(8989.3,1,"PEER"))[PEER S PEER="" ;p499
"RTN","ZOSVGUX",96,0)
 Q PEER
"RTN","ZOSVGUX",97,0)
 ;
"RTN","ZOSVGUX",98,0)
PRGMODE ;Drop into direct mode
"RTN","ZOSVGUX",99,0)
 N X,XUCI,XUSLNT
"RTN","ZOSVGUX",100,0)
 W ! S ZTPAC=$P($G(^VA(200,+DUZ,.1)),"^",5),XUVOL=^%ZOSF("VOL")
"RTN","ZOSVGUX",101,0)
 S X="" X ^%ZOSF("EOFF") R:ZTPAC]"" !,"PAC: ",X:60 D LC^XUS X ^%ZOSF("EON") I X'=ZTPAC W "??",$C(7) Q
"RTN","ZOSVGUX",102,0)
 N XMB,XMTEXT,XMY S XMB="XUPROGMODE",XMB(1)=DUZ,XMB(2)=$I D ^XMB:$L($T(^XMB)) D BYE^XUSCLEAN K ZTPAC,X,XMB
"RTN","ZOSVGUX",103,0)
 D UCI S XUCI=Y D PRGM^ZUA
"RTN","ZOSVGUX",104,0)
 I $D(%ut) QUIT
"RTN","ZOSVGUX",105,0)
 F  BREAK
"RTN","ZOSVGUX",106,0)
 HALT
"RTN","ZOSVGUX",107,0)
 ;
"RTN","ZOSVGUX",108,0)
PROGMODE() ; In Application mode
"RTN","ZOSVGUX",109,0)
 Q 1 ; This was used to control UCI switching, has no meaning in GT.M
"RTN","ZOSVGUX",110,0)
 ;
"RTN","ZOSVGUX",111,0)
UCI ;
"RTN","ZOSVGUX",112,0)
 S Y=^%ZOSF("PROD") Q
"RTN","ZOSVGUX",113,0)
 ;
"RTN","ZOSVGUX",114,0)
UCICHECK(X) ;
"RTN","ZOSVGUX",115,0)
 Q X
"RTN","ZOSVGUX",116,0)
 ;
"RTN","ZOSVGUX",117,0)
JOBPAR ; <=====
"RTN","ZOSVGUX",118,0)
 N CMD,COMM,IO
"RTN","ZOSVGUX",119,0)
 S IO=$IO,COMM="/proc/"_X_"/comm"
"RTN","ZOSVGUX",120,0)
 O COMM:(READONLY:EXCEPTION="S Y="""" Q") U COMM R CMD U IO C COMM
"RTN","ZOSVGUX",121,0)
 S Y=$S("mumps"=$G(CMD):^%ZOSF("PROD"),1:"")
"RTN","ZOSVGUX",122,0)
 Q
"RTN","ZOSVGUX",123,0)
 ;
"RTN","ZOSVGUX",124,0)
SHARELIC(TYPE) ;Used by Cache implementations
"RTN","ZOSVGUX",125,0)
 Q
"RTN","ZOSVGUX",126,0)
 ;
"RTN","ZOSVGUX",127,0)
PRIORITY ;
"RTN","ZOSVGUX",128,0)
 K Y ; VA has this disabled in general.
"RTN","ZOSVGUX",129,0)
 Q
"RTN","ZOSVGUX",130,0)
 ;
"RTN","ZOSVGUX",131,0)
PRIINQ() ;
"RTN","ZOSVGUX",132,0)
 Q 5 ; for now, we're always middle of the road
"RTN","ZOSVGUX",133,0)
 ;
"RTN","ZOSVGUX",134,0)
BAUD S X="UNKNOWN"
"RTN","ZOSVGUX",135,0)
 Q
"RTN","ZOSVGUX",136,0)
 ;
"RTN","ZOSVGUX",137,0)
LGR() ; Last global reference ($REFERENCE)
"RTN","ZOSVGUX",138,0)
 Q $R
"RTN","ZOSVGUX",139,0)
 ;
"RTN","ZOSVGUX",140,0)
EC() ; Error Code: returning $ZS in format more like $ZE from DSM
"RTN","ZOSVGUX",141,0)
 N %ZE
"RTN","ZOSVGUX",142,0)
 I $ZS="" S %ZE=""
"RTN","ZOSVGUX",143,0)
 S %ZE=$P($ZS,",",2)_","_$P($ZS,",",4)_","_$P($ZS,",")_",-"_$P($ZS,",",3)
"RTN","ZOSVGUX",144,0)
 Q %ZE
"RTN","ZOSVGUX",145,0)
 ;
"RTN","ZOSVGUX",146,0)
DOLRO ;SAVE ENTIRE SYMBOL TABLE IN LOCATION SPECIFIED BY X
"RTN","ZOSVGUX",147,0)
 ; Old Algorithm
"RTN","ZOSVGUX",148,0)
 S Y="%" F  M @(X_"Y)="_Y) S Y=$O(@Y) Q:Y=""
"RTN","ZOSVGUX",149,0)
 QUIT
"RTN","ZOSVGUX",150,0)
 ;
"RTN","ZOSVGUX",151,0)
 ; New Algorithm; faster by 2-6ms
"RTN","ZOSVGUX",152,0)
 ;N %11111,Y
"RTN","ZOSVGUX",153,0)
 ;ZSHOW "V":%11111
"RTN","ZOSVGUX",154,0)
 ;N %00000 F %00000=0:0 S %00000=$O(%11111("V",%00000)) Q:'%00000  S Y=$P(%11111("V",%00000),"=") I Y'["(" M @(X_"Y)="_Y)
"RTN","ZOSVGUX",155,0)
 ;QUIT
"RTN","ZOSVGUX",156,0)
 ;
"RTN","ZOSVGUX",157,0)
ORDER ;SAVE PART OF SYMBOL TABLE IN LOCATION SPECIFIED BY X
"RTN","ZOSVGUX",158,0)
 N %
"RTN","ZOSVGUX",159,0)
 S (Y,%)=$P(Y,"*",1) ;I $D(@Y)=0 F  S Y=$O(@Y) Q:Y=""!(Y[Y1)
"RTN","ZOSVGUX",160,0)
 Q:Y=""
"RTN","ZOSVGUX",161,0)
 ;S %=$D(@Y) S:%#2 @(X_"Y)="_Y) I %>9 S %X=Y_"(",%Y=X_"Y," D %XY^%RCR
"RTN","ZOSVGUX",162,0)
 ;F  S Y=$O(@Y) Q:Y=""!(Y'[Y1)  S %=$D(@Y) S:%#2 @(X_"Y)="_Y) I %>9 S %X=Y_"(",%Y=X_"Y," D %XY^%RCR
"RTN","ZOSVGUX",163,0)
 F  M:$D(@Y) @(X_"Y)="_Y) S Y=$O(@Y) Q:Y=""!(Y'[%)
"RTN","ZOSVGUX",164,0)
 Q
"RTN","ZOSVGUX",165,0)
 ;
"RTN","ZOSVGUX",166,0)
PARSIZ ;
"RTN","ZOSVGUX",167,0)
 S X=3 Q
"RTN","ZOSVGUX",168,0)
 ;
"RTN","ZOSVGUX",169,0)
NOLOG ;
"RTN","ZOSVGUX",170,0)
 S Y=0 Q
"RTN","ZOSVGUX",171,0)
 ;
"RTN","ZOSVGUX",172,0)
GETENV ;Get environment Return Y='UCI^VOL^NODE^BOX LOOKUP'
"RTN","ZOSVGUX",173,0)
 N %HOST,%V S %V=^%ZOSF("PROD"),%HOST=$P($SYSTEM,",",2) ; Uses env variable gtm_sysid
"RTN","ZOSVGUX",174,0)
 S Y=$TR(%V,",","^")_"^"_%HOST_"^"_$P(%V,",",2)_":"_%HOST
"RTN","ZOSVGUX",175,0)
 Q
"RTN","ZOSVGUX",176,0)
 ;
"RTN","ZOSVGUX",177,0)
VERSION(X) ;return OS version, X=1 - return OS
"RTN","ZOSVGUX",178,0)
 Q $S($G(X):$P($ZV," ",3,99),1:$P($P($ZV," V",2)," "))
"RTN","ZOSVGUX",179,0)
 ;
"RTN","ZOSVGUX",180,0)
OS() ;
"RTN","ZOSVGUX",181,0)
 Q "UNIX"
"RTN","ZOSVGUX",182,0)
 ;
"RTN","ZOSVGUX",183,0)
SETNM(X) ;Set name, Trap dup's, Fall into SETENV
"RTN","ZOSVGUX",184,0)
 N $ETRAP S $ETRAP="S $ECODE="""" Q"
"RTN","ZOSVGUX",185,0)
SETENV ;Set environment X='PROCESS NAME^ '
"RTN","ZOSVGUX",186,0)
 S ^XUTL("XUSYS",$J,0)=$H,^("NM")=X ; workaround
"RTN","ZOSVGUX",187,0)
 Q
"RTN","ZOSVGUX",188,0)
 ;
"RTN","ZOSVGUX",189,0)
SID() ;System ID
"RTN","ZOSVGUX",190,0)
 N J1,T S T="~"
"RTN","ZOSVGUX",191,0)
 S J1(1)=$ZROUTINES,J1(1)=$P(J1(1)," ")
"RTN","ZOSVGUX",192,0)
 S J1(2)=$ZGBLDIR
"RTN","ZOSVGUX",193,0)
 Q "1~"_J1(1)_T_J1(2)
"RTN","ZOSVGUX",194,0)
 ;
"RTN","ZOSVGUX",195,0)
PRI() ;Check if a mixed OS enviroment.
"RTN","ZOSVGUX",196,0)
 ;Default return 1 unless we are on the secondary OS.
"RTN","ZOSVGUX",197,0)
 ;Only Cache on a VMS/Linux mix is supported now.
"RTN","ZOSVGUX",198,0)
 Q 1
"RTN","ZOSVGUX",199,0)
 ;
"RTN","ZOSVGUX",200,0)
T0 ; start RT clock
"RTN","ZOSVGUX",201,0)
 N V S V=$$VERSION(0)
"RTN","ZOSVGUX",202,0)
 I +V'<6.2 S %ZH0=$ZH QUIT
"RTN","ZOSVGUX",203,0)
 S %ZH0=$S(""'=$T(ZHOROLOG^%POSIX):$$ZHOROLOG^%POSIX,1:$H)
"RTN","ZOSVGUX",204,0)
 Q
"RTN","ZOSVGUX",205,0)
 ;
"RTN","ZOSVGUX",206,0)
T1 ; store RT datum w/ZHDIF
"RTN","ZOSVGUX",207,0)
 N V S V=$$VERSION(0)
"RTN","ZOSVGUX",208,0)
 I +V'<6.2 S %ZH1=$ZH QUIT
"RTN","ZOSVGUX",209,0)
 S %ZH1=$S(""'=$T(ZHOROLOG^%POSIX):$$ZHOROLOG^%POSIX,1:$H)
"RTN","ZOSVGUX",210,0)
 Q
"RTN","ZOSVGUX",211,0)
 ;
"RTN","ZOSVGUX",212,0)
ZHDIF ;Display dif of two $ZH's
"RTN","ZOSVGUX",213,0)
 N SC0 S SC0=$P(%ZH0,",",2)
"RTN","ZOSVGUX",214,0)
 N SC1 S SC1=$P(%ZH1,",",2)
"RTN","ZOSVGUX",215,0)
 N DC0 S DC0=$P(%ZH0,",")*86400
"RTN","ZOSVGUX",216,0)
 N DC1 S DC1=$P(%ZH1,",")*86400
"RTN","ZOSVGUX",217,0)
 N MCS0 S MCS0=$P(%ZH0,",",3)/1000000
"RTN","ZOSVGUX",218,0)
 N MCS1 S MCS1=$P(%ZH1,",",3)/1000000
"RTN","ZOSVGUX",219,0)
 ;
"RTN","ZOSVGUX",220,0)
 N T0 S T0=SC0+DC0+MCS0
"RTN","ZOSVGUX",221,0)
 N T1 S T1=SC1+DC1+MCS1
"RTN","ZOSVGUX",222,0)
 ;
"RTN","ZOSVGUX",223,0)
 S %ZH2=T1-T0
"RTN","ZOSVGUX",224,0)
 QUIT
"RTN","ZOSVGUX",225,0)
 ;
"RTN","ZOSVGUX",226,0)
 ;Code moved to %ZOSVKR, Comment out if needed.
"RTN","ZOSVGUX",227,0)
LOGRSRC(OPT,TYPE,STATUS) ;record resource usage in ^XTMP("KMPR"
"RTN","ZOSVGUX",228,0)
 Q:'$G(^%ZTSCH("LOGRSRC"))  ; quit if RUM not turned on.
"RTN","ZOSVGUX",229,0)
 ; call to RUM routine.
"RTN","ZOSVGUX",230,0)
 D RU^%ZOSVKR($G(OPT),$G(TYPE),$G(STATUS))
"RTN","ZOSVGUX",231,0)
 Q
"RTN","ZOSVGUX",232,0)
 ;
"RTN","ZOSVGUX",233,0)
SETTRM(X) ;Turn on specified terminators.
"RTN","ZOSVGUX",234,0)
 U $I:(TERMINATOR=X)
"RTN","ZOSVGUX",235,0)
 Q 1
"RTN","ZOSVGUX",236,0)
 ;
"RTN","ZOSVGUX",237,0)
DEVOK ;
"RTN","ZOSVGUX",238,0)
 ;use lsof (list open files)
"RTN","ZOSVGUX",239,0)
 ; given a device name in X
"RTN","ZOSVGUX",240,0)
 ;INPUT:  X=Device $I, X1=IOT -- X1 needed for resources
"RTN","ZOSVGUX",241,0)
 ;OUTPUT: Y=0 if available, Y=job # if owned
"RTN","ZOSVGUX",242,0)
 ; Y=-1 if device does not exists.
"RTN","ZOSVGUX",243,0)
 ; return Y=0 if not owned, Y=$J of owning job, Y=999 if dev cycling
"RTN","ZOSVGUX",244,0)
 ;
"RTN","ZOSVGUX",245,0)
 I $G(X1)="RES" G RESOK^%ZIS6
"RTN","ZOSVGUX",246,0)
 S Y=0
"RTN","ZOSVGUX",247,0)
 Q  ;Let ZIS deal with it.
"RTN","ZOSVGUX",248,0)
 ;
"RTN","ZOSVGUX",249,0)
DEVOPN ;List of Devices opened.  Linux only
"RTN","ZOSVGUX",250,0)
 ;Returns variable Y. Y=Devices owned separated by a comma
"RTN","ZOSVGUX",251,0)
 N %I,%X,%Y
"RTN","ZOSVGUX",252,0)
 ZSHOW "D":%Y
"RTN","ZOSVGUX",253,0)
 S %I=0,Y="",%X=""
"RTN","ZOSVGUX",254,0)
 F  S %I=$O(%Y("D",%I)) Q:'%I  I %Y("D",%I)'["CLOSED" S Y=Y_%X_$P(%Y("D",%I)," "),%X=","
"RTN","ZOSVGUX",255,0)
 Q
"RTN","ZOSVGUX",256,0)
 ;
"RTN","ZOSVGUX",257,0)
RETURN(%COMMAND,JUSTSTATUS) ; [Public] execute a shell command 
"RTN","ZOSVGUX",258,0)
 ; - return the last line; or just the status of the command.
"RTN","ZOSVGUX",259,0)
 ; %COMMAND is the string value of the Linux command
"RTN","ZOSVGUX",260,0)
 N IO,LINE,TMP
"RTN","ZOSVGUX",261,0)
 S IO=$IO
"RTN","ZOSVGUX",262,0)
 O "COMMAND":(SHELL="/bin/sh":COMMAND=%COMMAND:READONLY)::"PIPE" U "COMMAND"
"RTN","ZOSVGUX",263,0)
 F  R TMP:1 Q:$ZEO  S LINE=TMP
"RTN","ZOSVGUX",264,0)
 U IO C "COMMAND"
"RTN","ZOSVGUX",265,0)
 I $G(JUSTSTATUS) Q $ZCLOSE
"RTN","ZOSVGUX",266,0)
 Q $G(LINE)
"RTN","ZOSVONT")
0^22^B26568303
"RTN","ZOSVONT",1,0)
%ZOSV ;SFISC/AC - $View commands for Open M for NT.  ; 6/5/18 3:23pm
"RTN","ZOSVONT",2,0)
 ;;8.0;KERNEL;**34,94,107,118,136,215,293,284,385,425,440,499,10002**;Jul 10, 1995;Build 26
"RTN","ZOSVONT",3,0)
 ;
"RTN","ZOSVONT",4,0)
 ; *10002 changes (c) 2018 Sam Habiel
"RTN","ZOSVONT",5,0)
 ; Licensed under Apache 2
"RTN","ZOSVONT",6,0)
 ;
"RTN","ZOSVONT",7,0)
ACTJ() ;# Active jobs
"RTN","ZOSVONT",8,0)
 N %,V,Y S V=$$VERSION()
"RTN","ZOSVONT",9,0)
 I V<5 D  Q Y
"RTN","ZOSVONT",10,0)
 . S %=0 F Y=0:1 S %=$ZJOB(%) Q:%=""
"RTN","ZOSVONT",11,0)
 S Y=$system.License.LUConsumed() ;Cache 5 up
"RTN","ZOSVONT",12,0)
 Q Y
"RTN","ZOSVONT",13,0)
AVJ() ;# available jobs
"RTN","ZOSVONT",14,0)
 N %,AVJ,V,ZOSV,$ET
"RTN","ZOSVONT",15,0)
 S V=+$$VERSION()
"RTN","ZOSVONT",16,0)
 ;Cache 3 and 4
"RTN","ZOSVONT",17,0)
 ;maxpid: from %SS
"RTN","ZOSVONT",18,0)
 I V<5 D  Q AVJ
"RTN","ZOSVONT",19,0)
 . N PORT,T,X,MAXPID,LMFLIM
"RTN","ZOSVONT",20,0)
 . S $ET="",MAXPID=$V($ZU(40,2,118),-2,4)
"RTN","ZOSVONT",21,0)
 . X "S ZOSV=$ZU(5),%=$ZU(5,""%SYS"") S LMFLIM=$$inquire^LMFCLI,%=$ZU(5,ZOSV)" ;Get the license info
"RTN","ZOSVONT",22,0)
 . ;Add together the enterprise and division licenses avaliable
"RTN","ZOSVONT",23,0)
 . S X=$P(LMFLIM,";",2)+$P($P(LMFLIM,"|",2),";",2)
"RTN","ZOSVONT",24,0)
 . S T=+LMFLIM+$P(LMFLIM,"|",2) ;Check the license total
"RTN","ZOSVONT",25,0)
 . S AVJ=$S(T<MAXPID:X,1:MAXPID-$$ACTJ) ;Return the smaller of license or pid
"RTN","ZOSVONT",26,0)
 ;To get available jobs from Cache 5.0 up
"RTN","ZOSVONT",27,0)
 I V'<5 D  Q AVJ
"RTN","ZOSVONT",28,0)
 . X "S AVJ=$system.License.LUAvailable()"
"RTN","ZOSVONT",29,0)
 ;Return fixed value not known version
"RTN","ZOSVONT",30,0)
 Q 15
"RTN","ZOSVONT",31,0)
 ;
"RTN","ZOSVONT",32,0)
PRIINQ() ;
"RTN","ZOSVONT",33,0)
 Q 8
"RTN","ZOSVONT",34,0)
 ;
"RTN","ZOSVONT",35,0)
UCI ;Current UCI,VOL
"RTN","ZOSVONT",36,0)
 S Y=$ZU(5)_","_^%ZOSF("VOL") Q
"RTN","ZOSVONT",37,0)
 ;
"RTN","ZOSVONT",38,0)
UCICHECK(X) ;Check if valid namespace (UCI)
"RTN","ZOSVONT",39,0)
 N Y,%
"RTN","ZOSVONT",40,0)
 S %=$P(X,",",1),Y=0 I $ZU(90,10,%) S Y=%
"RTN","ZOSVONT",41,0)
 Q Y
"RTN","ZOSVONT",42,0)
 ;
"RTN","ZOSVONT",43,0)
GETPEER() ;Get the PEER tcp/ip address
"RTN","ZOSVONT",44,0)
 N PEER,NL,$ET S NL="",PEER="",$ET="S $EC=NL Q NL"
"RTN","ZOSVONT",45,0)
 I $$OS="VMS" S PEER=$ZF("TRNLNM","VISTA$IP")
"RTN","ZOSVONT",46,0)
 I '$L(PEER) S PEER=$ZU(111,0) S:$L(PEER) PEER=$A(PEER,1)_"."_$A(PEER,2)_"."_$A(PEER,3)_"."_$A(PEER,4)
"RTN","ZOSVONT",47,0)
 I $G(^XTV(8989.3,1,"PEER"))[PEER S PEER="" ;p499
"RTN","ZOSVONT",48,0)
 Q PEER
"RTN","ZOSVONT",49,0)
 ;
"RTN","ZOSVONT",50,0)
SHARELIC(TYPE) ;See if can share a C/S license
"RTN","ZOSVONT",51,0)
 ;Per Sandy Waal 10/18/2003: With Cache 5.0, your telnet and IP connections are now handled properly.
"RTN","ZOSVONT",52,0)
 ;N %,%N,%2,UID,%V,$ET S $ET="S $EC="""" Q",%V=$$VERSION()
"RTN","ZOSVONT",53,0)
 ;I %V'<5 Q
"RTN","ZOSVONT",54,0)
 ;Type is 1 for C/S and 0 for Telnet
"RTN","ZOSVONT",55,0)
 ;I %V<3.1 X:TYPE "S %N=$ZU(5),%2=$ZU(5,""%SYS""),%2=$$GetLic^LMFCLI,%N=$ZU(5,%N)" Q
"RTN","ZOSVONT",56,0)
 ;I %V<5 S:TYPE %=$$GetCSLic^%LICENSE S:'TYPE %=$$ShareLic^%LICENSE
"RTN","ZOSVONT",57,0)
 ;S $EC=""
"RTN","ZOSVONT",58,0)
 Q
"RTN","ZOSVONT",59,0)
 ;
"RTN","ZOSVONT",60,0)
JOBPAR ;See if X points to a valid Job. Return its UCI.
"RTN","ZOSVONT",61,0)
 N NL,$ET S Y="",NL="",$ET="S $EC=NL Q"
"RTN","ZOSVONT",62,0)
 I $D(^$JOB(X)) S Y=$V(-1,X),Y=$P(Y,"^",14)_","_^%ZOSF("VOL")
"RTN","ZOSVONT",63,0)
 Q
"RTN","ZOSVONT",64,0)
 ;
"RTN","ZOSVONT",65,0)
NOLOG ;4096 is switch 12 - sign on inhibited.
"RTN","ZOSVONT",66,0)
 S Y="$V(0,-2,4)\4096#2" Q
"RTN","ZOSVONT",67,0)
 ;
"RTN","ZOSVONT",68,0)
PROGMODE() ;Check if in PROG mode
"RTN","ZOSVONT",69,0)
 Q $ZJOB#2
"RTN","ZOSVONT",70,0)
 ;
"RTN","ZOSVONT",71,0)
PRGMODE ;
"RTN","ZOSVONT",72,0)
 N X,XMB,XQZ,XUCI,XUSLNT,XUVOL,Y,ZTPAC
"RTN","ZOSVONT",73,0)
 W ! S ZTPAC=$S('$D(^VA(200,+DUZ,.1)):"",1:$P(^(.1),U,5)),XUVOL=^%ZOSF("VOL")
"RTN","ZOSVONT",74,0)
 S X="" X ^%ZOSF("EOFF") R:ZTPAC]"" !,"PAC: ",X:60 D LC^XUS X ^%ZOSF("EON") I X'=ZTPAC W "??"_$C(7) Q
"RTN","ZOSVONT",75,0)
 S XMB="XUPROGMODE",XMB(1)=DUZ,XMB(2)=$I D ^XMB:$L($T(^XMB)) D BYE^XUSCLEAN K ZTPAC,X,XMB
"RTN","ZOSVONT",76,0)
 D UCI S XUCI=Y,XQZ="PRGM^ZUA[MGR]",XUSLNT=1 D DO^%XUCI D ^%PMODE U $I:(:"+B+C+R") S $ZT="" Q
"RTN","ZOSVONT",77,0)
 Q
"RTN","ZOSVONT",78,0)
LGR() ;Last Global ref.
"RTN","ZOSVONT",79,0)
 N $ET,NL S NL="",$ET="S $EC=NL Q NL"
"RTN","ZOSVONT",80,0)
 Q $ZR
"RTN","ZOSVONT",81,0)
 ;
"RTN","ZOSVONT",82,0)
EC() ;Error code
"RTN","ZOSVONT",83,0)
 Q $ZE
"RTN","ZOSVONT",84,0)
 ;
"RTN","ZOSVONT",85,0)
DOLRO ;SAVE ENTIRE SYMBOL TABLE IN LOCATION SPECIFIED BY X
"RTN","ZOSVONT",86,0)
 ;S Y="%" F  S Y=$O(@Y) Q:Y=""  D
"RTN","ZOSVONT",87,0)
 ;. I $D(@Y)#2 S @(X_"Y)="_Y)
"RTN","ZOSVONT",88,0)
 ;. I $D(@Y)>9 S %X=Y_"(",%Y=X_"Y," D %XY^%RCR
"RTN","ZOSVONT",89,0)
 S Y="%" F  M:$D(@Y) @(X_"Y)="_Y) S Y=$O(@Y) Q:Y=""
"RTN","ZOSVONT",90,0)
 Q
"RTN","ZOSVONT",91,0)
 ;
"RTN","ZOSVONT",92,0)
ORDER ;SAVE PART OF SYMBOL TABLE IN LOCATION SPECIFIED BY X
"RTN","ZOSVONT",93,0)
 N %
"RTN","ZOSVONT",94,0)
 S (Y,%)=$P(Y,"*",1) ;I $D(@Y)=0 F  S Y=$O(@Y) Q:Y=""!(Y[Y1)
"RTN","ZOSVONT",95,0)
 Q:Y=""
"RTN","ZOSVONT",96,0)
 ;S %=$D(@Y) S:%#2 @(X_"Y)="_Y) I %>9 S %X=Y_"(",%Y=X_"Y," D %XY^%RCR
"RTN","ZOSVONT",97,0)
 ;F  S Y=$O(@Y) Q:Y=""!(Y'[Y1)  S %=$D(@Y) S:%#2 @(X_"Y)="_Y) I %>9 S %X=Y_"(",%Y=X_"Y," D %XY^%RCR
"RTN","ZOSVONT",98,0)
 F  M:$D(@Y) @(X_"Y)="_Y) S Y=$O(@Y) Q:Y=""!(Y'[%)
"RTN","ZOSVONT",99,0)
 Q
"RTN","ZOSVONT",100,0)
 ;
"RTN","ZOSVONT",101,0)
PARSIZ ;Old and not used.
"RTN","ZOSVONT",102,0)
 S X=3
"RTN","ZOSVONT",103,0)
 Q
"RTN","ZOSVONT",104,0)
 ;
"RTN","ZOSVONT",105,0)
DEVOPN ;List of Devices opened, Not used
"RTN","ZOSVONT",106,0)
 ;Returns variable Y. Y=Devices owned separated by a comma
"RTN","ZOSVONT",107,0)
 Q
"RTN","ZOSVONT",108,0)
 ;
"RTN","ZOSVONT",109,0)
DEVOK ;
"RTN","ZOSVONT",110,0)
 S Y=0,X1=$G(X1) Q:X=2  Q:(X1="HFS")!(X1="SPL")!(X1="MT")!(X1="CHAN")  ;Quit w/ OK for HFS, Spool, MT, TCP/IP
"RTN","ZOSVONT",111,0)
 G:X1="RES" RESOK^%ZIS6
"RTN","ZOSVONT",112,0)
 N $ET S $ET="D OPNERR Q"
"RTN","ZOSVONT",113,0)
 O X::$S($D(%ZISTO):%ZISTO,1:0) E  S Y=999 Q  ;G NOPN
"RTN","ZOSVONT",114,0)
 S Y=0 I '$D(%ZISCHK)!($G(%ZIS)["T") C X Q
"RTN","ZOSVONT",115,0)
 S:X]"" IO(1,X)="" Q
"RTN","ZOSVONT",116,0)
 Q
"RTN","ZOSVONT",117,0)
 ;
"RTN","ZOSVONT",118,0)
OPNERR S $EC="",Y=-1 Q
"RTN","ZOSVONT",119,0)
 ;
"RTN","ZOSVONT",120,0)
GETENV ;Get environment  (UCI^VOL^NODE^BOX:VOLUME)
"RTN","ZOSVONT",121,0)
 N %,%1 S %=$$VERSION,%1=$ZU(86),%1=$S(%<3.1:$P(%1,"*",3),1:$P(%1,"*",2))
"RTN","ZOSVONT",122,0)
 D UCI S Y=$P(Y,",")_"^"_^%ZOSF("VOL")_"^"_$ZU(110)_"^"_^%ZOSF("VOL")_":"_%1
"RTN","ZOSVONT",123,0)
 Q
"RTN","ZOSVONT",124,0)
VERSION(X) ;return Cache version, X=1 - return full name
"RTN","ZOSVONT",125,0)
 Q $S($G(X):$P($ZV,")")_")",1:$P($P($ZV,") ",2),"("))
"RTN","ZOSVONT",126,0)
 ;
"RTN","ZOSVONT",127,0)
OS() ;Return the OS NT, VMS, Unix
"RTN","ZOSVONT",128,0)
 Q $S($ZV["VMS":"VMS",$ZV["UNIX":"UNIX",$ZV["Linux":"UNIX",$ZV["Windows":"NT",$ZV["NT":"NT",1:"UNK")
"RTN","ZOSVONT",129,0)
 ;
"RTN","ZOSVONT",130,0)
SETNM(X) ;Set name, Fall into SETENV
"RTN","ZOSVONT",131,0)
SETENV ;Set environment
"RTN","ZOSVONT",132,0)
 N Q,$ET,$ES S $ET="S $EC="""" Q"
"RTN","ZOSVONT",133,0)
 I $$OS="VMS" S Q=$ZF("SETPRN",$E(X,1,15))
"RTN","ZOSVONT",134,0)
 Q
"RTN","ZOSVONT",135,0)
 ;
"RTN","ZOSVONT",136,0)
SID() ;System ID Ver 1
"RTN","ZOSVONT",137,0)
 N %1,%2,%3,%4,%5,T S T="~"
"RTN","ZOSVONT",138,0)
 S %1=$ZU(5) ;namespace
"RTN","ZOSVONT",139,0)
 S %2=$ZU(12,"") ;directory
"RTN","ZOSVONT",140,0)
 I '$L(%2),$$VERSION'<5.2 S %2=$$defdir^%SYS.GLO(%1) ;remote directory
"RTN","ZOSVONT",141,0)
 S %3=$G(^XTV(8989.3,1,"SID")),%4=$P(%3,"^",4),%5=$P(%3,"^",5)
"RTN","ZOSVONT",142,0)
 I $L(%4),$L(%5),%2[%4 S %2=$P(%2,%4)_%5_$P(%2,%4,2,9)
"RTN","ZOSVONT",143,0)
 S %3=%1_T_%2 ;namespace~directory
"RTN","ZOSVONT",144,0)
 Q "1~"_%3
"RTN","ZOSVONT",145,0)
 ;
"RTN","ZOSVONT",146,0)
PRI() ;Check if a mixed OS enviroment.
"RTN","ZOSVONT",147,0)
 ;Default return 1 unless we are on the secondary OS.
"RTN","ZOSVONT",148,0)
 ;Only Cache on a VMS(1)/Linux or NT(2) mix is supported now.
"RTN","ZOSVONT",149,0)
 N % S %=1
"RTN","ZOSVONT",150,0)
 I $P(^XTV(8989.3,1,0),"^",5),$$OS'="VMS" S %=2
"RTN","ZOSVONT",151,0)
 Q %
"RTN","ZOSVONT",152,0)
 ;
"RTN","ZOSVONT",153,0)
HFSREW(IO,IOPAR) ;Rewind Host File.
"RTN","ZOSVONT",154,0)
 S $ZT="HFSRWERR"
"RTN","ZOSVONT",155,0)
 C IO O @(""""_IO_""""_$S(IOPAR]"":":"_IOPAR_":1",1:":1")) I '$T Q 0
"RTN","ZOSVONT",156,0)
 Q 1
"RTN","ZOSVONT",157,0)
HFSRWERR ;Error encountered
"RTN","ZOSVONT",158,0)
 Q 0
"RTN","ZOSVONT",159,0)
LOGRSRC(OPT,TYPE,STATUS) ;record resource usage in ^XTMP("KMPR"
"RTN","ZOSVONT",160,0)
 Q:'$G(^%ZTSCH("LOGRSRC"))  ; quit if RUM not turned on.
"RTN","ZOSVONT",161,0)
 ; call to RUM routine.
"RTN","ZOSVONT",162,0)
 D RU^%ZOSVKR($G(OPT),$G(TYPE),$G(STATUS))
"RTN","ZOSVONT",163,0)
 Q
"RTN","ZOSVONT",164,0)
SETTRM(X) ;Turn on specified terminators.
"RTN","ZOSVONT",165,0)
 U $I:(:"+T":X)
"RTN","ZOSVONT",166,0)
 Q 1
"RTN","ZOSVONT",167,0)
 ;
"RTN","ZOSVONT",168,0)
T0 ; start RT clock, obsolete
"RTN","ZOSVONT",169,0)
 ;S XRT0=$H
"RTN","ZOSVONT",170,0)
 Q
"RTN","ZOSVONT",171,0)
T1 ; store RT datum, obsolete
"RTN","ZOSVONT",172,0)
 ;S ^%ZRTL(3,XRTL,+$H,XRTN,$P($H,",",2))=XRT0 K XRT0
"RTN","ZOSVONT",173,0)
 Q
"RTN","ZOSVONT",174,0)
RETURN(%COMMAND,JUSTSTATUS) ; [Public] execute a shell command - *10002* OSE/SMH
"RTN","ZOSVONT",175,0)
 ; - return the last line; or just the status of the command.
"RTN","ZOSVONT",176,0)
 ; %COMMAND is the string value of the Linux/Windows command
"RTN","ZOSVONT",177,0)
 ;
"RTN","ZOSVONT",178,0)
 ; OSE/SMH: Cache implementation notes:
"RTN","ZOSVONT",179,0)
 ;
"RTN","ZOSVONT",180,0)
 ; - I don't see a way for Cache to suppress output of $ZF or
"RTN","ZOSVONT",181,0)
 ; alternately to return the status of "QR" open. That's why
"RTN","ZOSVONT",182,0)
 ; we have two different implentations for status vs no status.
"RTN","ZOSVONT",183,0)
 ;
"RTN","ZOSVONT",184,0)
 ; "QR" open note: The default timeout for close is 30 seconds. If the
"RTN","ZOSVONT",185,0)
 ; process is long-lived, we will not close. I don't know if that's
"RTN","ZOSVONT",186,0)
 ; the best way to do things right now.
"RTN","ZOSVONT",187,0)
 ;
"RTN","ZOSVONT",188,0)
 I $G(JUSTSTATUS) Q $ZF(-1,%COMMAND)
"RTN","ZOSVONT",189,0)
 ;
"RTN","ZOSVONT",190,0)
 N OLDIO S OLDIO=$IO
"RTN","ZOSVONT",191,0)
 O %COMMAND:"QR":2
"RTN","ZOSVONT",192,0)
 E  Q -1
"RTN","ZOSVONT",193,0)
 N % S %=$System.Process.SetZEOF(1) ; Prevent Cache from throwing an error at EOF
"RTN","ZOSVONT",194,0)
 U %COMMAND
"RTN","ZOSVONT",195,0)
 N OUT R OUT:2
"RTN","ZOSVONT",196,0)
 U OLDIO C %COMMAND
"RTN","ZOSVONT",197,0)
 Q OUT
"RTN","ZOSVONUT")
0^20^B31454787
"RTN","ZOSVONUT",1,0)
ZOSVONUT ; VEN/SMH - Unit Tests for Cache Encryption Functions XUSHSH;2017-10-30  5:32 pm ; 6/6/18 6:46am
"RTN","ZOSVONUT",2,0)
 ;;8.0;KERNEL;**10001,10002**;;Build 26
"RTN","ZOSVONUT",3,0)
 ; Submitted to OSEHRA in 2017 by Sam Habiel for OSEHRA
"RTN","ZOSVONUT",4,0)
 ; Authored by Sam Habiel 2017
"RTN","ZOSVONUT",5,0)
 ; This is a copy of ZOSVGUT2 modified to work on Cache
"RTN","ZOSVONUT",6,0)
 ;
"RTN","ZOSVONUT",7,0)
 ; Windows Users:
"RTN","ZOSVONUT",8,0)
 ; Openssl for Windows: https://slproweb.com/products/Win32OpenSSL.html - Restart Cache after install
"RTN","ZOSVONUT",9,0)
 ; Wget for Windows: https://eternallybored.org/misc/wget/
"RTN","ZOSVONUT",10,0)
 ;
"RTN","ZOSVONUT",11,0)
 D EN^%ut($t(+0),3)
"RTN","ZOSVONUT",12,0)
 quit
"RTN","ZOSVONUT",13,0)
 ;
"RTN","ZOSVONUT",14,0)
XUSHSH ; @TEST Top of XUSHSH
"RTN","ZOSVONUT",15,0)
 N X S X="TEST"
"RTN","ZOSVONUT",16,0)
 D ^XUSHSH
"RTN","ZOSVONUT",17,0)
 D CHKTF^%ut(X="TEST")
"RTN","ZOSVONUT",18,0)
 QUIT
"RTN","ZOSVONUT",19,0)
 ;
"RTN","ZOSVONUT",20,0)
SHA ; @TEST SHA-1 and SHA-256 in Hex and Base64
"RTN","ZOSVONUT",21,0)
 D CHKEQ^%ut($$SHAHASH^XUSHSH(160,"test"),"A94A8FE5CCB19BA61C4C0873D391E987982FBBD3")
"RTN","ZOSVONUT",22,0)
 D CHKEQ^%ut($$SHAHASH^XUSHSH(160,"test","H"),"A94A8FE5CCB19BA61C4C0873D391E987982FBBD3")
"RTN","ZOSVONUT",23,0)
 D CHKEQ^%ut($$SHAHASH^XUSHSH(160,"test","B"),"qUqP5cyxm6YcTAhz05Hph5gvu9M=")
"RTN","ZOSVONUT",24,0)
 D CHKEQ^%ut($$SHAHASH^XUSHSH(256,"test"),"9F86D081884C7D659A2FEAA0C55AD015A3BF4F1B2B0B822CD15D6C15B0F00A08")
"RTN","ZOSVONUT",25,0)
 QUIT
"RTN","ZOSVONUT",26,0)
 ;
"RTN","ZOSVONUT",27,0)
BASE64 ; @TEST Base 64 Encode and Decode
"RTN","ZOSVONUT",28,0)
 D CHKEQ^%ut($$B64ENCD^XUSHSH("test"),"dGVzdA==")
"RTN","ZOSVONUT",29,0)
 D CHKEQ^%ut($$B64DECD^XUSHSH("dGVzdA=="),"test")
"RTN","ZOSVONUT",30,0)
 QUIT
"RTN","ZOSVONUT",31,0)
 ;
"RTN","ZOSVONUT",32,0)
RSAENC ; @TEST Test RSA Encryption
"RTN","ZOSVONUT",33,0)
 N SECRET S SECRET="Alice and Bob had Sex!"
"RTN","ZOSVONUT",34,0)
 ;
"RTN","ZOSVONUT",35,0)
 N TD S TD=$$DEFDIR^%ZISH()
"RTN","ZOSVONUT",36,0)
 ;
"RTN","ZOSVONUT",37,0)
 ; Create RSA certificate and private key w/ no password
"RTN","ZOSVONUT",38,0)
 N %CMD
"RTN","ZOSVONUT",39,0)
 S %CMD="openssl req -x509 -nodes -days 365 -sha256 -subj ""/C=US/ST=Washington/L=Seattle/CN=www.smh101.com"" -newkey rsa:2048 -keyout "_TD_"mycert.key -out "_TD_"mycert.pem"
"RTN","ZOSVONUT",40,0)
 N % S %=$ZF(-1,%CMD)
"RTN","ZOSVONUT",41,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVONUT",42,0)
 N CIPHERTEXT S CIPHERTEXT=$$RSAENCR^XUSHSH(SECRET,TD_"mycert.pem")
"RTN","ZOSVONUT",43,0)
 D CHKTF^%ut($L(CIPHERTEXT)>$L(SECRET))
"RTN","ZOSVONUT",44,0)
 N DECRYPTION S DECRYPTION=$$RSADECR^XUSHSH(CIPHERTEXT,TD_"mycert.key")
"RTN","ZOSVONUT",45,0)
 D CHKEQ^%ut(SECRET,DECRYPTION)
"RTN","ZOSVONUT",46,0)
 ;
"RTN","ZOSVONUT",47,0)
 ; Create RSA certificate and private key with a password
"RTN","ZOSVONUT",48,0)
 ; Apparently, no way to do all of this in a single line in openssl; have to do
"RTN","ZOSVONUT",49,0)
 ; it the traditional way: key, CSR, Cert.
"RTN","ZOSVONUT",50,0)
 ; VEN/SMH - For some reason, the darwin command doesn't create the
"RTN","ZOSVONUT",51,0)
 ; certificate when running from inside GT.M; it does okay in Bash.
"RTN","ZOSVONUT",52,0)
 ; So, for now, let's just disable this check on Darwin; I don't have time
"RTN","ZOSVONUT",53,0)
 ; for this shit.
"RTN","ZOSVONUT",54,0)
 I $$VERSION^%ZOSV(1)["Darwin" QUIT
"RTN","ZOSVONUT",55,0)
 I $$VERSION^%ZOSV(1)["CYGWIN" QUIT
"RTN","ZOSVONUT",56,0)
 ;
"RTN","ZOSVONUT",57,0)
 N %CMD
"RTN","ZOSVONUT",58,0)
 S %CMD="openssl genrsa -aes128 -passout pass:monkey1234 -out "_TD_"mycert.key 2048"
"RTN","ZOSVONUT",59,0)
 N % S %=$ZF(-1,%CMD)
"RTN","ZOSVONUT",60,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVONUT",61,0)
 S %CMD="openssl req -new -key "_TD_"mycert.key -passin pass:monkey1234 -subj ""/C=US/ST=Washington/L=Seattle/CN=www.smh101.com"" -out "_TD_"mycert.csr"
"RTN","ZOSVONUT",62,0)
 N % S %=$ZF(-1,%CMD)
"RTN","ZOSVONUT",63,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVONUT",64,0)
 S %CMD="openssl req -x509 -days 365 -sha256 -in "_TD_"mycert.csr -key "_TD_"mycert.key -passin pass:monkey1234 -out "_TD_"mycert.pem"
"RTN","ZOSVONUT",65,0)
 ;I $$VERSION^%ZOSV["arwin" S %CMD="openssl req -x509 -days 365 -sha256 -in /tmp/mycert.csr -subj '/C=US/ST=Washington/L=Seattle/CN=www.smh101.com' -key /tmp/mycert.key -passin pass:monkey1234 -out /tmp/mycert.pem"
"RTN","ZOSVONUT",66,0)
 N % S %=$ZF(-1,%CMD)
"RTN","ZOSVONUT",67,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVONUT",68,0)
 N CIPHERTEXT S CIPHERTEXT=$$RSAENCR^XUSHSH(SECRET,TD_"mycert.pem")
"RTN","ZOSVONUT",69,0)
 D CHKTF^%ut($L(CIPHERTEXT)>$L(SECRET))
"RTN","ZOSVONUT",70,0)
 N DECRYPTION S DECRYPTION=$$RSADECR^XUSHSH(CIPHERTEXT,TD_"mycert.key","monkey1234")
"RTN","ZOSVONUT",71,0)
 D CHKEQ^%ut(SECRET,DECRYPTION)
"RTN","ZOSVONUT",72,0)
 QUIT
"RTN","ZOSVONUT",73,0)
 ;
"RTN","ZOSVONUT",74,0)
AESENC ; @TEST Test AES Encryption
"RTN","ZOSVONUT",75,0)
 N SECRET S SECRET="Alice and Bob had Sex!"
"RTN","ZOSVONUT",76,0)
 N X S X=$$AESENCR^XUSHSH(SECRET,"ABCDABCDABCDABCD","DCBADCBADCBADCBA")
"RTN","ZOSVONUT",77,0)
 N Y S Y=$$AESDECR^XUSHSH(X,"ABCDABCDABCDABCD","DCBADCBADCBADCBA")
"RTN","ZOSVONUT",78,0)
 D CHKEQ^%ut(SECRET,Y)
"RTN","ZOSVONUT",79,0)
 QUIT
"RTN","ZOSVONUT",80,0)
 ;
"RTN","ZOSVONUT",81,0)
SIZE ; @TEST $$SIZE^%ZISH
"RTN","ZOSVONUT",82,0)
 N OS S OS=$$OS^%ZOSV
"RTN","ZOSVONUT",83,0)
 N %
"RTN","ZOSVONUT",84,0)
 I OS="UNIX" S %=$$SIZE^%ZISH("/usr/include/","stdio.h")
"RTN","ZOSVONUT",85,0)
 I OS="NT"   S %=$$SIZE^%ZISH("c:\windows\system32\","cmd.exe")
"RTN","ZOSVONUT",86,0)
 D CHKTF^%ut(%>1000)
"RTN","ZOSVONUT",87,0)
 QUIT
"RTN","ZOSVONUT",88,0)
 ;
"RTN","ZOSVONUT",89,0)
MKDIR ; @TEST $$MKDIR^%ZISH for Unix
"RTN","ZOSVONUT",90,0)
 N OS S OS=$$OS^%ZOSV
"RTN","ZOSVONUT",91,0)
 I OS'="UNIX" QUIT
"RTN","ZOSVONUT",92,0)
 N % S %=$$RETURN^%ZOSV("rm -r /tmp/foo/boo",1)
"RTN","ZOSVONUT",93,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVONUT",94,0)
 N % S %=$$MKDIR^%ZISH("/tmp/foo/boo")
"RTN","ZOSVONUT",95,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVONUT",96,0)
 N % S %=$$RETURN^%ZOSV("stat /tmp/foo/boo",1)
"RTN","ZOSVONUT",97,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVONUT",98,0)
 QUIT
"RTN","ZOSVONUT",99,0)
 ;
"RTN","ZOSVONUT",100,0)
MDWIN ; @TEST $$MKDIR^%ZISH for Windows
"RTN","ZOSVONUT",101,0)
 N OS S OS=$$OS^%ZOSV
"RTN","ZOSVONUT",102,0)
 I OS'="NT" QUIT
"RTN","ZOSVONUT",103,0)
 N % S %=$$RETURN^%ZOSV("rmdir /s /q %temp%\foo",1)
"RTN","ZOSVONUT",104,0)
 N % S %=$$MKDIR^%ZISH("%temp%\foo\boo")
"RTN","ZOSVONUT",105,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVONUT",106,0)
 N % S %=$$RETURN^%ZOSV("dir %temp%\foo\boo",1)
"RTN","ZOSVONUT",107,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVONUT",108,0)
 QUIT
"RTN","ZOSVONUT",109,0)
 ;
"RTN","ZOSVONUT",110,0)
WGETSYNC ; @TEST $$WGETSYNC^%ZISH on NDF DAT files for Unix and Windows
"RTN","ZOSVONUT",111,0)
 N OS S OS=$$OS^%ZOSV
"RTN","ZOSVONUT",112,0)
 N FOLDER
"RTN","ZOSVONUT",113,0)
 I OS="UNIX" S FOLDER="/tmp/foo/boo"
"RTN","ZOSVONUT",114,0)
 n temp s temp=$System.Util.GetEnviron("TEMP")
"RTN","ZOSVONUT",115,0)
 I OS="NT" S FOLDER=temp_"\foo\boo"
"RTN","ZOSVONUT",116,0)
 N SEC1 S SEC1=$P($H,",",2)
"RTN","ZOSVONUT",117,0)
 N % S %=$$WGETSYNC^%ZISH("foia-vista.osehra.org","Patches_By_Application/PSN-NATIONAL DRUG FILE (NDF)/PPS_DATS/",FOLDER,"*.DAT*")
"RTN","ZOSVONUT",118,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVONUT",119,0)
 N A,CURR S A("*")=""
"RTN","ZOSVONUT",120,0)
 N % S %=$$LIST^%ZISH(FOLDER,"A","CURR")
"RTN","ZOSVONUT",121,0)
 D CHKTF^%ut($D(CURR("PPS_0PRV_1NEW.DAT")))
"RTN","ZOSVONUT",122,0)
 ;
"RTN","ZOSVONUT",123,0)
 ; Do it again. Should be faster.
"RTN","ZOSVONUT",124,0)
 N SEC2 S SEC2=$P($H,",",2)
"RTN","ZOSVONUT",125,0)
 N % S %=$$WGETSYNC^%ZISH("foia-vista.osehra.org","Patches_By_Application/PSN-NATIONAL DRUG FILE (NDF)/PPS_DATS/",FOLDER,"*.DAT*")
"RTN","ZOSVONUT",126,0)
 N A,CURR S A("*")=""
"RTN","ZOSVONUT",127,0)
 N % S %=$$LIST^%ZISH(FOLDER,"A","CURR")
"RTN","ZOSVONUT",128,0)
 D CHKTF^%ut($D(CURR("PPS_0PRV_1NEW.DAT")))
"RTN","ZOSVONUT",129,0)
 ;
"RTN","ZOSVONUT",130,0)
 ; Remove a file and download again
"RTN","ZOSVONUT",131,0)
 N SEC3 S SEC3=$P($H,",",2)
"RTN","ZOSVONUT",132,0)
 I OS="UNIX" N % S %=$$RETURN^%ZOSV("rm /tmp/foo/boo/PPS_2PRV_3NEW.DAT",1)
"RTN","ZOSVONUT",133,0)
 I OS="NT"   N % S %=$$RETURN^%ZOSV("del /q /f %temp%\foo\boo\PPS_2PRV_3NEW.DAT",1)
"RTN","ZOSVONUT",134,0)
 D CHKTF^%ut(%=0)
"RTN","ZOSVONUT",135,0)
 N % S %=$$WGETSYNC^%ZISH("foia-vista.osehra.org","Patches_By_Application/PSN-NATIONAL DRUG FILE (NDF)/PPS_DATS/",FOLDER,"*.DAT*")
"RTN","ZOSVONUT",136,0)
 N A,CURR S A("*")=""
"RTN","ZOSVONUT",137,0)
 N % S %=$$LIST^%ZISH(FOLDER,"A","CURR")
"RTN","ZOSVONUT",138,0)
 D CHKTF^%ut($D(CURR("PPS_2PRV_3NEW.DAT")))
"RTN","ZOSVONUT",139,0)
 ;
"RTN","ZOSVONUT",140,0)
 D CHKTF^%ut((SEC3-SEC2)'>(SEC2-SEC1))
"RTN","ZOSVONUT",141,0)
 QUIT
"RTN","ZSY")
0^19^B420055711
"RTN","ZSY",1,0)
ZSY ;ISF/RWF,VEN/SMH - GT.M/VA system status display ;2018-06-06  1:27 PM
"RTN","ZSY",2,0)
 ;;8.0;KERNEL;**349,10001,10002**;Jul 10, 1995;Build 26
"RTN","ZSY",3,0)
 ; Submitted to OSEHRA in 2017 by Sam Habiel for OSEHRA
"RTN","ZSY",4,0)
 ; Original Routine of unknown provenance -- was in unreleased VA patch XU*8.0*349 and thus perhaps in the public domain.
"RTN","ZSY",5,0)
 ; Rewritten by KS Bhaskar and Sam Habiel 2005-2015
"RTN","ZSY",6,0)
 ; Sam: JOBEXAM, WORK, USHOW, UNIX, UNIXLSOF, INTRPT, INTRPTALL, HALTALL, ZJOBff
"RTN","ZSY",7,0)
 ; Bhaskar provided pipe implementations of various commands.
"RTN","ZSY",8,0)
 ;GT.M/VA %SY utility - status display
"RTN","ZSY",9,0)
 ;
"RTN","ZSY",10,0)
EN ; [Public] Main Entry Point
"RTN","ZSY",11,0)
 ;From the top just show by PID
"RTN","ZSY",12,0)
 N MODE
"RTN","ZSY",13,0)
 L +^XUTL("XUSYS","COMMAND"):1 I '$T G LW
"RTN","ZSY",14,0)
 S MODE=0 D WORK(MODE)
"RTN","ZSY",15,0)
 Q
"RTN","ZSY",16,0)
 ;
"RTN","ZSY",17,0)
QUERY ; [Public] Alternate Entry Point
"RTN","ZSY",18,0)
 N MODE,X
"RTN","ZSY",19,0)
 L +^XUTL("XUSYS","COMMAND"):1 I '$T G LW
"RTN","ZSY",20,0)
 S X=$$ASK W ! I X=-1 L -^XUTL("XUSYS","COMMAND") Q
"RTN","ZSY",21,0)
 S MODE=+X D WORK(MODE)
"RTN","ZSY",22,0)
 Q
"RTN","ZSY",23,0)
 ;
"RTN","ZSY",24,0)
TMMGR ; [Public] Show only taskman manager tasks
"RTN","ZSY",25,0)
 N MODE
"RTN","ZSY",26,0)
 L +^XUTL("XUSYS","COMMAND"):1 I '$T G LW
"RTN","ZSY",27,0)
 N FILTER S FILTER("%ZTM")="",FILTER("%ZTM0")=""
"RTN","ZSY",28,0)
 S MODE=0 D WORK(MODE,.FILTER)
"RTN","ZSY",29,0)
 QUIT
"RTN","ZSY",30,0)
 ;
"RTN","ZSY",31,0)
TMSUB ; [Public] Show only taskman submanager tasks
"RTN","ZSY",32,0)
 N MODE
"RTN","ZSY",33,0)
 L +^XUTL("XUSYS","COMMAND"):1 I '$T G LW
"RTN","ZSY",34,0)
 N FILTER S FILTER("%ZTMS1")=""
"RTN","ZSY",35,0)
 S MODE=0 D WORK(MODE,.FILTER)
"RTN","ZSY",36,0)
 QUIT
"RTN","ZSY",37,0)
 ;
"RTN","ZSY",38,0)
ASK() ;Ask sort item
"RTN","ZSY",39,0)
 ; ZEXCEPT: %utAnswer
"RTN","ZSY",40,0)
 I $D(%utAnswer) Q %utAnswer
"RTN","ZSY",41,0)
 N RES,X,GROUP
"RTN","ZSY",42,0)
 S RES=0,GROUP=2
"RTN","ZSY",43,0)
 W !,"1 pid",!,"2 cpu time"
"RTN","ZSY",44,0)
 F  R !,"1// ",X:600 S:X="" X=1 Q:X["^"  Q:(X>0)&(X<3)  W " not valid"
"RTN","ZSY",45,0)
 Q:X["^" -1
"RTN","ZSY",46,0)
 S X=X-1,RES=(X#GROUP)_"~"_(X\GROUP)
"RTN","ZSY",47,0)
 Q RES
"RTN","ZSY",48,0)
 ;
"RTN","ZSY",49,0)
 ;
"RTN","ZSY",50,0)
JOBEXAM(%ZPOS) ; [Public; Called by ^ZU]
"RTN","ZSY",51,0)
 ; Preserve old state for process
"RTN","ZSY",52,0)
 N OLDIO S OLDIO=$IO
"RTN","ZSY",53,0)
 N %reference S %reference=$REFERENCE
"RTN","ZSY",54,0)
 K ^XUTL("XUSYS",$J,"JE")
"RTN","ZSY",55,0)
 ;
"RTN","ZSY",56,0)
 ; Halt the Job if requested - no need to do other work
"RTN","ZSY",57,0)
 I $G(^XUTL("XUSYS",$J,"CMD"))="HALT" D H2^XUSCLEAN G HALT^ZU
"RTN","ZSY",58,0)
 ;
"RTN","ZSY",59,0)
 ;
"RTN","ZSY",60,0)
 ; Save these
"RTN","ZSY",61,0)
 S ^XUTL("XUSYS",$J,0)=$H
"RTN","ZSY",62,0)
 S ^XUTL("XUSYS",$J,"JE","INTERRUPT")=$G(%ZPOS)
"RTN","ZSY",63,0)
 S ^XUTL("XUSYS",$J,"JE","ZMODE")=$ZMODE ; SMH - INTERACTIVE or OTHER
"RTN","ZSY",64,0)
 I %ZPOS'["GTM$DMOD" S ^XUTL("XUSYS",$J,"JE","codeline")=$T(@%ZPOS)
"RTN","ZSY",65,0)
 I $G(DUZ) S ^XUTL("XUSYS",$J,"JE","UNAME")=$P($G(^VA(200,DUZ,0)),"^")
"RTN","ZSY",66,0)
 E           S ^XUTL("XUSYS",$J,"JE","UNAME")=$G(^XUTL("XUSYS",$J,"NM"))
"RTN","ZSY",67,0)
 ;
"RTN","ZSY",68,0)
 ;
"RTN","ZSY",69,0)
 ; Default System Status.
"RTN","ZSY",70,0)
 ; S -> Stack
"RTN","ZSY",71,0)
 ; D -> Devices
"RTN","ZSY",72,0)
 ; G -> Global Stats
"RTN","ZSY",73,0)
 ; L -> Locks
"RTN","ZSY",74,0)
 I '$D(^XUTL("XUSYS",$J,"CMD")) ZSHOW "SGDL":^XUTL("XUSYS",$J,"JE") ; Default case -- most of the time this is what happens.
"RTN","ZSY",75,0)
 ;
"RTN","ZSY",76,0)
 ; Examine the Job
"RTN","ZSY",77,0)
 ; ZSHOW "*" is "BDGILRV"
"RTN","ZSY",78,0)
 ; B is break points
"RTN","ZSY",79,0)
 ; D is Devices
"RTN","ZSY",80,0)
 ; G are global stats
"RTN","ZSY",81,0)
 ; I is ISVs
"RTN","ZSY",82,0)
 ; L is Locks
"RTN","ZSY",83,0)
 ; R is Routines with Hash (similar to S)
"RTN","ZSY",84,0)
 ; V is Variables
"RTN","ZSY",85,0)
 ; ZSHOW "*" does not include:
"RTN","ZSY",86,0)
 ; A -> Autorelink information
"RTN","ZSY",87,0)
 ; C -> External programs that are loaded (presumable with D &)
"RTN","ZSY",88,0)
 ; S -> Stack (use R instead)
"RTN","ZSY",89,0)
 I $G(^XUTL("XUSYS",$J,"CMD"))="EXAM"!($P($G(^("CMD")),U)="DEBUG") ZSHOW "*":^XUTL("XUSYS",$J,"JE")
"RTN","ZSY",90,0)
 ;
"RTN","ZSY",91,0)
 ; ^XUTL("XUSYS",8563,"JE","G",0)="GLD:*,REG:*,SET:25610,KIL:593,GET:12284,...
"RTN","ZSY",92,0)
 ; Just grab the default region only. Decreases the stats as a side effect from this utility
"RTN","ZSY",93,0)
 N GLOSTAT
"RTN","ZSY",94,0)
 N I F I=0:0 S I=$O(^XUTL("XUSYS",$J,"JE","G",I)) Q:'I  I ^(I)[$ZGLD,^(I)["DEFAULT" S GLOSTAT=^(I)
"RTN","ZSY",95,0)
 I GLOSTAT]"" N I F I=1:1:$L(GLOSTAT,",") D
"RTN","ZSY",96,0)
 . N EACHSTAT S EACHSTAT=$P(GLOSTAT,",",I)
"RTN","ZSY",97,0)
 . N SUB,OBJ S SUB=$P(EACHSTAT,":"),OBJ=$P(EACHSTAT,":",2)
"RTN","ZSY",98,0)
 . S ^XUTL("XUSYS",$J,"JE","GSTAT",SUB)=OBJ
"RTN","ZSY",99,0)
 ;
"RTN","ZSY",100,0)
 ; Capture IO statistics for this process
"RTN","ZSY",101,0)
 ; ZEXCEPT: READONLY,REWIND
"RTN","ZSY",102,0)
 I $ZV["Linux" D
"RTN","ZSY",103,0)
 . N F S F="/proc/"_$J_"/io"
"RTN","ZSY",104,0)
 . O F:(READONLY:REWIND):0 E  Q
"RTN","ZSY",105,0)
 . U F
"RTN","ZSY",106,0)
 . N DONE S DONE=0 ; $ZEOF doesn't seem to work (https://github.com/YottaDB/YottaDB/issues/120)
"RTN","ZSY",107,0)
 . N X F  R X:0 U F D  Q:DONE
"RTN","ZSY",108,0)
 .. I X["read_bytes"  S ^XUTL("XUSYS",$J,"JE","RBYTE")=$P(X,": ",2)
"RTN","ZSY",109,0)
 .. I X["write_bytes" S ^XUTL("XUSYS",$J,"JE","WBYTE")=$P(X,": ",2) S DONE=1
"RTN","ZSY",110,0)
 . U OLDIO C F
"RTN","ZSY",111,0)
 ;
"RTN","ZSY",112,0)
 ; Capture String Pool Stats: Full size - Freed Data
"RTN","ZSY",113,0)
 ; spstat 2nd piece is the actual size--but that fluctuates wildly
"RTN","ZSY",114,0)
 ; I use the full size allocated (defaults at 0.10 MB) - the size freed.
"RTN","ZSY",115,0)
 n spstat s spstat=$view("spsize")
"RTN","ZSY",116,0)
 ;
"RTN","ZSY",117,0)
 S ^XUTL("XUSYS",$J,"JE","SPOOL")=spstat
"RTN","ZSY",118,0)
 S ^XUTL("XUSYS",$J,"JE","HEAP_MEM")=$p(spstat,",",1)-$p(spstat,",",3)
"RTN","ZSY",119,0)
 ;
"RTN","ZSY",120,0)
 ; Done. We can tell others we are ready
"RTN","ZSY",121,0)
 SET ^XUTL("XUSYS",$J,"JE","COMPLETE")=1
"RTN","ZSY",122,0)
 ;
"RTN","ZSY",123,0)
 ; TODO: IMPLEMENT DEBUG
"RTN","ZSY",124,0)
 I $P($G(^XUTL("XUSYS",$J,"CMD")),U)="DEBUG" QUIT  ; **NOT IMPLEMENTED**
"RTN","ZSY",125,0)
 ;
"RTN","ZSY",126,0)
 ; Restore old IO and $R
"RTN","ZSY",127,0)
 U OLDIO
"RTN","ZSY",128,0)
 I %reference
"RTN","ZSY",129,0)
 Q 1
"RTN","ZSY",130,0)
 ;
"RTN","ZSY",131,0)
WORK(MODE,FILTER) ; [Private] Main driver, Will release lock
"RTN","ZSY",132,0)
 ; int MODE
"RTN","ZSY",133,0)
 ; FILTER ref
"RTN","ZSY",134,0)
 N USERS,GROUP,PROCID
"RTN","ZSY",135,0)
 N TNAME,I,SORT,TAB
"RTN","ZSY",136,0)
 N $ES,$ET
"RTN","ZSY",137,0)
 n %PS,RTN,%OS,DONE
"RTN","ZSY",138,0)
 ;
"RTN","ZSY",139,0)
 ;Save $ZINTERRUPT, set new one
"RTN","ZSY",140,0)
 N OLDINT
"RTN","ZSY",141,0)
 S OLDINT=$ZINTERRUPT,$ZINTERRUPT="I $$JOBEXAM^ZU($ZPOSITION) S DONE=1"
"RTN","ZSY",142,0)
 ;
"RTN","ZSY",143,0)
 ;Clear old data
"RTN","ZSY",144,0)
 S ^XUTL("XUSYS","COMMAND")="Status"
"RTN","ZSY",145,0)
 ;
"RTN","ZSY",146,0)
 S I=0 F  S I=$O(^XUTL("XUSYS",I)) Q:'I  K ^XUTL("XUSYS",I,"CMD"),^("JE")
"RTN","ZSY",147,0)
 ;
"RTN","ZSY",148,0)
 ; Counts; Turn on Ctrl-C.
"RTN","ZSY",149,0)
 ; ZEXCEPT: CTRAP,NOESCAPE,NOFILTER
"RTN","ZSY",150,0)
 N USERS S USERS=0
"RTN","ZSY",151,0)
 U $P:(CTRAP=$C(3):NOESCAPE:NOFILTER)
"RTN","ZSY",152,0)
 ;
"RTN","ZSY",153,0)
 ;Go get the data
"RTN","ZSY",154,0)
 D UNIX(MODE,.USERS,.SORT)
"RTN","ZSY",155,0)
 ;
"RTN","ZSY",156,0)
 ;Now show the results
"RTN","ZSY",157,0)
 I USERS D
"RTN","ZSY",158,0)
 . D HEADER(.TAB),USHOW(.TAB,.SORT,.FILTER)
"RTN","ZSY",159,0)
 . W !!,"Total ",USERS," user",$S(USERS>1:"s.",1:"."),!
"RTN","ZSY",160,0)
 . Q
"RTN","ZSY",161,0)
 E  W !,"No current GT.M users.",!
"RTN","ZSY",162,0)
 ;
"RTN","ZSY",163,0)
 ;
"RTN","ZSY",164,0)
EXIT ;
"RTN","ZSY",165,0)
 L -^XUTL("XUSYS","COMMAND") ;Release lock and let others in
"RTN","ZSY",166,0)
 I $L($G(OLDINT)) S $ZINTERRUPT=OLDINT
"RTN","ZSY",167,0)
 U $P:CTRAP=""
"RTN","ZSY",168,0)
 Q
"RTN","ZSY",169,0)
 ;
"RTN","ZSY",170,0)
ERR ;
"RTN","ZSY",171,0)
 U $P W !,$P($ZS,",",2,99),!
"RTN","ZSY",172,0)
 D EXIT
"RTN","ZSY",173,0)
 Q
"RTN","ZSY",174,0)
 ;
"RTN","ZSY",175,0)
LW ;Lock wait
"RTN","ZSY",176,0)
 W !,"Someone else is running the System status now."
"RTN","ZSY",177,0)
 Q
"RTN","ZSY",178,0)
 ;
"RTN","ZSY",179,0)
HEADER(TAB) ;Display Header
"RTN","ZSY",180,0)
 ; ZEXCEPT: AB
"RTN","ZSY",181,0)
 W #
"RTN","ZSY",182,0)
 S IOM=+$$AUTOMARG
"RTN","ZSY",183,0)
 W !,"GT.M System Status users on ",$$DATETIME($H)
"RTN","ZSY",184,0)
 W:IOM>80 " - (stats reflect accessing DEFAULT region ONLY except *)"
"RTN","ZSY",185,0)
 S TAB(0)=0,TAB(1)=6,TAB(2)=14,TAB(3)=18,TAB(4)=27,TAB(5)=46,TAB(6)=66
"RTN","ZSY",186,0)
 S TAB(7)=75,TAB(8)=85,TAB(9)=100,TAB(10)=110,TAB(11)=115,TAB(12)=123
"RTN","ZSY",187,0)
 S TAB(13)=130,TAB(14)=141,TAB(15)=150
"RTN","ZSY",188,0)
 U 0:FILTER="ESCAPE"
"RTN","ZSY",189,0)
 W !
"RTN","ZSY",190,0)
 D EACHHEADER("PID",TAB(0))
"RTN","ZSY",191,0)
 D EACHHEADER("PName",TAB(1))
"RTN","ZSY",192,0)
 D EACHHEADER("Device",TAB(2))
"RTN","ZSY",193,0)
 D EACHHEADER("Routine",TAB(4))
"RTN","ZSY",194,0)
 D EACHHEADER("Name",TAB(5))
"RTN","ZSY",195,0)
 D EACHHEADER("CPU Time",TAB(6))
"RTN","ZSY",196,0)
 I IOM>80 D
"RTN","ZSY",197,0)
 . D EACHHEADER("OP/READ",TAB(7))
"RTN","ZSY",198,0)
 . D EACHHEADER("NTR/NTW",TAB(8))
"RTN","ZSY",199,0)
 . D EACHHEADER("NR0123",TAB(9))
"RTN","ZSY",200,0)
 . D EACHHEADER("#L",TAB(10))
"RTN","ZSY",201,0)
 . D EACHHEADER("%LSUCC",TAB(11))
"RTN","ZSY",202,0)
 . D EACHHEADER("%CFAIL",TAB(12))
"RTN","ZSY",203,0)
 I IOM>130 D
"RTN","ZSY",204,0)
 . D EACHHEADER("R MB*",TAB(13))
"RTN","ZSY",205,0)
 . D EACHHEADER("W MB*",TAB(14))
"RTN","ZSY",206,0)
 . D EACHHEADER("SP MB*",TAB(15))
"RTN","ZSY",207,0)
 Q
"RTN","ZSY",208,0)
EACHHEADER(H,TAB) ; [Internal]
"RTN","ZSY",209,0)
 ; ZEXCEPT: AB
"RTN","ZSY",210,0)
 N BOLD S BOLD=$C(27,91,49,109)
"RTN","ZSY",211,0)
 N RESET S RESET=$C(27,91,109)
"RTN","ZSY",212,0)
 W ?TAB,BOLD,H,RESET
"RTN","ZSY",213,0)
 QUIT
"RTN","ZSY",214,0)
USHOW(TAB,SORT,FILTER) ;Display job info, sorted by pid
"RTN","ZSY",215,0)
 ; ZEXCEPT: AB
"RTN","ZSY",216,0)
 N SI,I
"RTN","ZSY",217,0)
 S SI=""
"RTN","ZSY",218,0)
 F  S SI=$ORDER(SORT(SI)) Q:SI=""  F I=1:1:SORT(SI) D
"RTN","ZSY",219,0)
 . N X,TNAME,PROCID,PROCNAME,CTIME,PS,PID,PLACE
"RTN","ZSY",220,0)
 . S X=SORT(SI,I)
"RTN","ZSY",221,0)
 . S PID=$P(X,"~",8)
"RTN","ZSY",222,0)
 . S PLACE=$G(^XUTL("XUSYS",PID,"JE","INTERRUPT"))
"RTN","ZSY",223,0)
 . ; Debug
"RTN","ZSY",224,0)
 . ; I $D(^XUTL("XUSYS",PID)) ZWRITE ^(PID,*)
"RTN","ZSY",225,0)
 . ; debug
"RTN","ZSY",226,0)
 . N RTNNAME S RTNNAME=$P(PLACE,"^",2)
"RTN","ZSY",227,0)
 . I $D(FILTER)=10 Q:$$FILTROUT(.FILTER,RTNNAME,PID)
"RTN","ZSY",228,0)
 . N DEV D DEV(.DEV,PID)
"RTN","ZSY",229,0)
 . S TNAME=$$DEVSEL(.DEV),PROCID=$P(X,"~",1) ; TNAME is Terminal Name, i.e. the device.
"RTN","ZSY",230,0)
 . S PROCNAME=$P(X,"~",5),CTIME=$P(X,"~",6)
"RTN","ZSY",231,0)
 . I $G(^XUTL("XUSYS",PID,"JE","ZMODE"))="OTHER" S TNAME="BG-"_TNAME
"RTN","ZSY",232,0)
 . N UNAME S UNAME=$G(^XUTL("XUSYS",PID,"JE","UNAME"))
"RTN","ZSY",233,0)
 . W !,PROCID,?TAB(1),PROCNAME,?TAB(2),TNAME,?TAB(4),PLACE,?TAB(5),UNAME,?TAB(6),$J(CTIME,6)
"RTN","ZSY",234,0)
 . I IOM>80 D
"RTN","ZSY",235,0)
 .. I '$D(^XUTL("XUSYS",PID,"JE","GSTAT","DRD")) W ?TAB(7),"PROCESS NOT RESPONDING" QUIT
"RTN","ZSY",236,0)
 .. N DRD,DTA,GET,ORD,ZPR,QRY
"RTN","ZSY",237,0)
 .. S DRD=^XUTL("XUSYS",PID,"JE","GSTAT","DRD"),DTA=^("DTA"),GET=^("GET"),ORD=^("ORD"),ZPR=^("ZPR"),QRY=^("QRY")
"RTN","ZSY",238,0)
 .. N opPerRead
"RTN","ZSY",239,0)
 .. i DRD=0 s opPerRead=0
"RTN","ZSY",240,0)
 .. e  S opPerRead=(DTA+GET+ORD+ZPR+QRY)/DRD
"RTN","ZSY",241,0)
 .. W ?TAB(7),$J(opPerRead,"",2)
"RTN","ZSY",242,0)
 .. N NTR,NTW S NTR=^XUTL("XUSYS",PID,"JE","GSTAT","NTR"),NTW=^("NTW") ; **NAKED**
"RTN","ZSY",243,0)
 .. I NTR>9999 S NTR=$J(NTR/1024,"",0)_"k",NTW=$J(NTW/1024,"",0)_"k"
"RTN","ZSY",244,0)
 .. W ?TAB(8),NTR,"/",NTW
"RTN","ZSY",245,0)
 .. W ?TAB(9),^XUTL("XUSYS",PID,"JE","GSTAT","NR0"),"/",^("NR1"),"/",^("NR2"),"/",^("NR3")
"RTN","ZSY",246,0)
 .. ; ^XUTL("XUSYS",14295,"JE","L",1)="LOCK ^XUTL(""XUSYS"",""COMMAND"") LEVEL=2"
"RTN","ZSY",247,0)
 .. N numLocks s numLocks=0
"RTN","ZSY",248,0)
 .. N I F I=0:0 S I=$O(^XUTL("XUSYS",PID,"JE","L",I)) Q:'I  N S S S=^(I) D  ; **NAKED**
"RTN","ZSY",249,0)
 ... N levelLocation S levelLocation=$find(S,"LEVEL=")
"RTN","ZSY",250,0)
 ... n level s level=+$E(S,levelLocation,999)
"RTN","ZSY",251,0)
 ... s numLocks=numLocks+level
"RTN","ZSY",252,0)
 .. W ?TAB(10),numLocks
"RTN","ZSY",253,0)
 .. N LKS,LKF S LKS=^XUTL("XUSYS",PID,"JE","GSTAT","LKS"),LKF=^("LKF")
"RTN","ZSY",254,0)
 .. N lockSuccess
"RTN","ZSY",255,0)
 .. I LKS+LKF'=0 S lockSuccess=LKS/(LKS+LKF)
"RTN","ZSY",256,0)
 .. e  s lockSuccess=0
"RTN","ZSY",257,0)
 .. W ?TAB(11)
"RTN","ZSY",258,0)
 .. i (LKS+LKF)<100 W LKS,"/",LKS+LKF
"RTN","ZSY",259,0)
 .. e  w $J(lockSuccess*100,"",2)_"%"
"RTN","ZSY",260,0)
 .. N CFT,CAT S CFT=$g(^XUTL("XUSYS",PID,"JE","GSTAT","CFT")),CAT=$g(^("CAT"))
"RTN","ZSY",261,0)
 .. N critAcqFailure
"RTN","ZSY",262,0)
 .. I CFT+CAT'=0 S critAcqFailure=CFT/(CFT+CAT)
"RTN","ZSY",263,0)
 .. e  s critAcqFailure=0
"RTN","ZSY",264,0)
 .. W ?TAB(12)
"RTN","ZSY",265,0)
 .. i (CFT+CAT)<100 W CFT,"/",CFT+CAT
"RTN","ZSY",266,0)
 .. e  w $J(critAcqFailure*100,"",2)_"%"
"RTN","ZSY",267,0)
 . I IOM>130 D
"RTN","ZSY",268,0)
 .. W ?TAB(13),$J($G(^XUTL("XUSYS",PID,"JE","RBYTE"))/(1024*1024),"",2)
"RTN","ZSY",269,0)
 .. W ?TAB(14),$J($G(^XUTL("XUSYS",PID,"JE","WBYTE"))/(1024*1024),"",2)
"RTN","ZSY",270,0)
 .. W ?TAB(15),$J($G(^XUTL("XUSYS",PID,"JE","HEAP_MEM"))/(1024*1024),"",2)
"RTN","ZSY",271,0)
 . ;
"RTN","ZSY",272,0)
 . ; Device print - Extract Info
"RTN","ZSY",273,0)
 . ; F DI=0:0 S DI=$O(DEV(DI)) Q:'DI  D
"RTN","ZSY",274,0)
 . ; W DEV(DI)
"RTN","ZSY",275,0)
 . ;I $O(DEV("")) D
"RTN","ZSY",276,0)
 .;. W !
"RTN","ZSY",277,0)
 .;. I IOM>130 W " " F DI=0:0 S DI=$O(DEV(DI)) Q:'DI
"RTN","ZSY",278,0)
 .;. E  W DEV(DI)  
"RTN","ZSY",279,0)
 .;.. W:$E(DEV(DI))=" " !
"RTN","ZSY",280,0)
 .;.. W ?TAB(1),DEV(DI)
"RTN","ZSY",281,0)
 Q
"RTN","ZSY",282,0)
 ;
"RTN","ZSY",283,0)
FILTROUT(FILTER,RTNNAME,PID) ; [Private] Should this item be filtered out?
"RTN","ZSY",284,0)
 I RTNNAME="" QUIT 1  ; yes, filter out processes that didn't respond
"RTN","ZSY",285,0)
 ; ^XUTL("XUSYS",24754,"JE","S",1)="JOBEXAM+22^ZSY"
"RTN","ZSY",286,0)
 ; ^XUTL("XUSYS",24754,"JE","S",2)="JOBEXAM+2^ZU"
"RTN","ZSY",287,0)
 ; ^XUTL("XUSYS",24754,"JE","S",3)="GETTASK+3^%ZTMS1    ($ZINTERRUPT) "
"RTN","ZSY",288,0)
 ; ^XUTL("XUSYS",24754,"JE","S",4)="SUBMGR+1^%ZTMS1"
"RTN","ZSY",289,0)
 n found s found=0
"RTN","ZSY",290,0)
 N I F I=1:1 Q:'$D(^XUTL("XUSYS",PID,"JE","S",I))  do  q:found
"RTN","ZSY",291,0)
 . i ^XUTL("XUSYS",PID,"JE","S",I)["Call-In" quit
"RTN","ZSY",292,0)
 . i ^XUTL("XUSYS",PID,"JE","S",I)["GTM$DMOD" quit
"RTN","ZSY",293,0)
 . n rtnName s rtnName=$p(^XUTL("XUSYS",PID,"JE","S",I),"^",2)
"RTN","ZSY",294,0)
 . i rtnName[" " s rtnName=$p(rtnName," ")
"RTN","ZSY",295,0)
 . n each s each=""
"RTN","ZSY",296,0)
 . f  s each=$o(FILTER(each)) q:each=""  do  q:found
"RTN","ZSY",297,0)
 .. i $d(FILTER(rtnName)) s found=1
"RTN","ZSY",298,0)
 ;
"RTN","ZSY",299,0)
 ; If we find it, we don't want to filter it out.
"RTN","ZSY",300,0)
 QUIT 'found
"RTN","ZSY",301,0)
 ;
"RTN","ZSY",302,0)
DEV(DEV,PID) ; [Private] Device Processing
"RTN","ZSY",303,0)
 ; Input: Global ^XUTL("XUSYS",PID,"JE","D"), PID
"RTN","ZSY",304,0)
 ; Output: .DEV
"RTN","ZSY",305,0)
 ; Device processing
"RTN","ZSY",306,0)
 ; First pass, normalize output into single lines
"RTN","ZSY",307,0)
 N DEVCNT,X
"RTN","ZSY",308,0)
 S DEVCNT=0
"RTN","ZSY",309,0)
 N DI F DI=1:1 Q:'$D(^XUTL("XUSYS",PID,"JE","D",DI))  S X=^(DI) D
"RTN","ZSY",310,0)
 . I X["CLOSED" QUIT  ; Don't print closed devices
"RTN","ZSY",311,0)
 . I PID=$J,$E(X,1,2)="ps" QUIT  ; Don't print our ps device
"RTN","ZSY",312,0)
 . I $E(X)'=" " S DEVCNT=DEVCNT+1,DEV(DEVCNT)=X
"RTN","ZSY",313,0)
 . E  S DEV(DEVCNT)=DEV(DEVCNT)_" "_$$TRIM(X)
"RTN","ZSY",314,0)
 ;
"RTN","ZSY",315,0)
 ; Second Pass, identify Devices
"RTN","ZSY",316,0)
 S DEVCNT="" F  S DEVCNT=$O(DEV(DEVCNT)) Q:DEVCNT=""  D
"RTN","ZSY",317,0)
 . S X=DEV(DEVCNT)
"RTN","ZSY",318,0)
 . N UPX S UPX=$ZCO(X,"U")
"RTN","ZSY",319,0)
 . I $E(X)=0 S DEV("4JOB")="0"
"RTN","ZSY",320,0)
 . I $P(X," ")["/dev/" S DEV("3TERM")=$P(X," ")
"RTN","ZSY",321,0)
 . I $P(X," ")["/",$P(X," ")'["/dev/" S DEV("1FILE")=$P(X," ")
"RTN","ZSY",322,0)
 . I UPX["SOCKET",UPX["SERVER" S DEV("2SOCK")=+$P(UPX,"PORT=",2)
"RTN","ZSY",323,0)
 QUIT
"RTN","ZSY",324,0)
 ;
"RTN","ZSY",325,0)
DEVSEL(DEV) ; [Private] Select Device to Print
"RTN","ZSY",326,0)
 N DEVTYP S DEVTYP=$O(DEV(" "))
"RTN","ZSY",327,0)
 Q:DEVTYP="" ""
"RTN","ZSY",328,0)
 I DEVTYP="4JOB" Q "0"
"RTN","ZSY",329,0)
 I DEVTYP="2SOCK" Q "S"_DEV(DEVTYP)
"RTN","ZSY",330,0)
 I DEVTYP="3TERM" Q DEV(DEVTYP)
"RTN","ZSY",331,0)
 I DEVTYP="1FILE" Q DEV(DEVTYP)
"RTN","ZSY",332,0)
 Q "ERROR"
"RTN","ZSY",333,0)
 ;
"RTN","ZSY",334,0)
TRIM(STR) ; [Private] Trim spaces
"RTN","ZSY",335,0)
 Q $$FUNC^%TRIM(STR)
"RTN","ZSY",336,0)
 ;
"RTN","ZSY",337,0)
DATETIME(HOROLOG) ;
"RTN","ZSY",338,0)
 Q $ZDATE(HOROLOG,"DD-MON-YY 24:60:SS")
"RTN","ZSY",339,0)
 ;
"RTN","ZSY",340,0)
UNIX(MODE,USERS,SORT) ;PUG/TOAD,FIS/KSB,VEN/SMH - Kernel System Status Report for GT.M
"RTN","ZSY",341,0)
 N %I,U,$ET,$ES
"RTN","ZSY",342,0)
 S $ET="D UERR^ZSY"
"RTN","ZSY",343,0)
 S %I=$I,U="^"
"RTN","ZSY",344,0)
 n procs
"RTN","ZSY",345,0)
 D INTRPTALL(.procs)
"RTN","ZSY",346,0)
 H .205 ; 200ms for TCP Read processes; 5ms b/c I am nice.
"RTN","ZSY",347,0)
 n procgrps
"RTN","ZSY",348,0)
 n done s done=0
"RTN","ZSY",349,0)
 n j s j=1
"RTN","ZSY",350,0)
 n i s i=0 f  s i=$o(procs(i)) q:'i  d
"RTN","ZSY",351,0)
 . s procgrps(j)=$g(procgrps(j))_procs(i)_" "
"RTN","ZSY",352,0)
 . i $l(procgrps(j))>220 s j=j+1 ; Max GT.M pipe len is 255
"RTN","ZSY",353,0)
 f j=1:1 q:'$d(procgrps(j))  d
"RTN","ZSY",354,0)
 . N %LINE,%TEXT,CMD
"RTN","ZSY",355,0)
 . I $ZV["Linux" S CMD="ps o pid,tty,stat,time,cmd -p"_procgrps(j)
"RTN","ZSY",356,0)
 . I $ZV["Darwin" S CMD="ps o pid,tty,stat,time,args -p"_procgrps(j)
"RTN","ZSY",357,0)
 . I $ZV["CYGWIN" S CMD="for p in "_procgrps(j)_"; do ps -p $p; done | awk '{print $1"" ""$5"" n/a ""$7"" ""$8"" n/a ""}'"
"RTN","ZSY",358,0)
 . ; ZEXCEPT: COMMAND,READONLY,SHELL
"RTN","ZSY",359,0)
 . O "ps":(SHELL="/bin/sh":COMMAND=CMD:READONLY)::"PIPE" U "ps"
"RTN","ZSY",360,0)
 . F  R %TEXT Q:$ZEO  D
"RTN","ZSY",361,0)
 .. S %LINE=$$VPE(%TEXT," ",U) ; parse each line of the ps output
"RTN","ZSY",362,0)
 .. Q:$P(%LINE,U)="PID"  ; header line
"RTN","ZSY",363,0)
 .. D JOBSET(%LINE,MODE,.USERS,.SORT)
"RTN","ZSY",364,0)
 . U %I C "ps"
"RTN","ZSY",365,0)
 Q
"RTN","ZSY",366,0)
 ;
"RTN","ZSY",367,0)
UERR ;Linux Error
"RTN","ZSY",368,0)
 N ZE S ZE=$ZS,$EC="" U $P
"RTN","ZSY",369,0)
 ZSHOW "*"
"RTN","ZSY",370,0)
 Q  ;halt
"RTN","ZSY",371,0)
 ;
"RTN","ZSY",372,0)
JOBSET(%LINE,MODE,USERS,SORT) ;Get data from a Linux job
"RTN","ZSY",373,0)
 N %J
"RTN","ZSY",374,0)
 N UNAME,PS,TNAME,CTIME
"RTN","ZSY",375,0)
 S (UNAME,PS,TNAME,CTIME)=""
"RTN","ZSY",376,0)
 N %J,PID,PROCID S (%J,PID,PROCID)=$P(%LINE,U)
"RTN","ZSY",377,0)
 S TNAME=$P(%LINE,U,2) S:TNAME="?" TNAME="" ; TTY, ? if none
"RTN","ZSY",378,0)
 S PS=$P(%LINE,U,3) ; process STATE
"RTN","ZSY",379,0)
 S CTIME=$P(%LINE,U,4) ;cpu time
"RTN","ZSY",380,0)
 N PROCNAME S PROCNAME=$P(%LINE,U,5) ; process name
"RTN","ZSY",381,0)
 I PROCNAME["/" S PROCNAME=$P(PROCNAME,"/",$L(PROCNAME,"/")) ; get actual image name if path
"RTN","ZSY",382,0)
 I $D(^XUTL("XUSYS",%J)) S UNAME=$G(^XUTL("XUSYS",%J,"NM"))
"RTN","ZSY",383,0)
 E  S UNAME="unknown"
"RTN","ZSY",384,0)
 N SI S SI=$S(MODE=0:PID,MODE=1:CTIME,1:PID)
"RTN","ZSY",385,0)
 N I S I=$GET(SORT(SI))+1
"RTN","ZSY",386,0)
 S SORT(SI)=I
"RTN","ZSY",387,0)
 S SORT(SI,I)=PROCID_"~"_UNAME_"~"_PS_"~"_TNAME_"~"_PROCNAME_"~"_CTIME_"~"_""_"~"_PID
"RTN","ZSY",388,0)
 S USERS=USERS+1
"RTN","ZSY",389,0)
 Q
"RTN","ZSY",390,0)
 ;
"RTN","ZSY",391,0)
VPE(%OLDSTR,%OLDDEL,%NEWDEL) ; $PIECE extract based on variable length delimiter
"RTN","ZSY",392,0)
 N %LEN,%PIECE,%NEWSTR
"RTN","ZSY",393,0)
 S %OLDDEL=$G(%OLDDEL) I %OLDDEL="" S %OLDDEL=" "
"RTN","ZSY",394,0)
 S %LEN=$L(%OLDDEL)
"RTN","ZSY",395,0)
 ; each %OLDDEL-sized chunk of %OLDSTR that might be delimiter
"RTN","ZSY",396,0)
 S %NEWDEL=$G(%NEWDEL) I %NEWDEL="" S %NEWDEL="^"
"RTN","ZSY",397,0)
 ; each piece of the old string
"RTN","ZSY",398,0)
 S %NEWSTR="" ; new reformatted string to retun
"RTN","ZSY",399,0)
 F  Q:%OLDSTR=""  D
"RTN","ZSY",400,0)
 . S %PIECE=$P(%OLDSTR,%OLDDEL)
"RTN","ZSY",401,0)
 . S $P(%OLDSTR,%OLDDEL)=""
"RTN","ZSY",402,0)
 . S %NEWSTR=%NEWSTR_$S(%NEWSTR="":"",1:%NEWDEL)_%PIECE
"RTN","ZSY",403,0)
 . F  Q:%OLDDEL'=$E(%OLDSTR,1,%LEN)  S $E(%OLDSTR,1,%LEN)=""
"RTN","ZSY",404,0)
 Q %NEWSTR
"RTN","ZSY",405,0)
 ;
"RTN","ZSY",406,0)
 ; Sam's entry points
"RTN","ZSY",407,0)
UNIXLSOF(procs) ; [Public] - Get all processes accessing THIS database (only!)
"RTN","ZSY",408,0)
 ; (return) .procs(n)=unix process number
"RTN","ZSY",409,0)
 ; ZEXCEPT: shell,parse
"RTN","ZSY",410,0)
 n %cmd s %cmd="lsof -t "_$view("gvfile","DEFAULT")
"RTN","ZSY",411,0)
 i $ZV["CYGWIN" s %cmd="ps -a | grep mumps | grep -v grep | awk '{print $1}'"
"RTN","ZSY",412,0)
 n oldio s oldio=$IO
"RTN","ZSY",413,0)
 o "lsof":(shell="/bin/bash":command=%cmd:parse)::"pipe"
"RTN","ZSY",414,0)
 u "lsof"
"RTN","ZSY",415,0)
 n i f i=1:1 q:$ZEOF  r procs(i):1  i procs(i)="" k procs(i)
"RTN","ZSY",416,0)
 u oldio c "lsof"
"RTN","ZSY",417,0)
 n cnt s cnt=0
"RTN","ZSY",418,0)
 n i f i=0:0 s i=$o(procs(i)) q:'i  i $i(cnt)
"RTN","ZSY",419,0)
 quit:$Q cnt quit
"RTN","ZSY",420,0)
 ;
"RTN","ZSY",421,0)
INTRPT(%J) ; [Public] Send mupip interrupt (currently SIGUSR1)
"RTN","ZSY",422,0)
 N SIGUSR1
"RTN","ZSY",423,0)
 I $ZV["Linux" S SIGUSR1=10
"RTN","ZSY",424,0)
 I $ZV["Darwin" S SIGUSR1=30
"RTN","ZSY",425,0)
 I $ZV["CYGWIN" S SIGUSR1=30
"RTN","ZSY",426,0)
 N % S %=$ZSIGPROC(%J,SIGUSR1)
"RTN","ZSY",427,0)
 QUIT
"RTN","ZSY",428,0)
 ;
"RTN","ZSY",429,0)
INTRPTALL(procs) ; [Public] Send mupip interrupt to every single database process
"RTN","ZSY",430,0)
 N SIGUSR1
"RTN","ZSY",431,0)
 I $ZV["Linux" S SIGUSR1=10
"RTN","ZSY",432,0)
 I $ZV["Darwin" S SIGUSR1=30
"RTN","ZSY",433,0)
 I $ZV["CYGWIN" S SIGUSR1=30
"RTN","ZSY",434,0)
 ; Collect processes
"RTN","ZSY",435,0)
 D UNIXLSOF(.procs)
"RTN","ZSY",436,0)
 ; Signal all processes
"RTN","ZSY",437,0)
 N i,% s i=0 f  s i=$o(procs(i)) q:'i  S %=$ZSIGPROC(procs(i),SIGUSR1)
"RTN","ZSY",438,0)
 QUIT
"RTN","ZSY",439,0)
 ;
"RTN","ZSY",440,0)
HALTALL ; [Public] Gracefully halt all jobs accessing current database
"RTN","ZSY",441,0)
 ; Calls ^XUSCLEAN then HALT^ZU
"RTN","ZSY",442,0)
 ;Clear old data
"RTN","ZSY",443,0)
 S ^XUTL("XUSYS","COMMAND")="Status"
"RTN","ZSY",444,0)
 N I F I=0:0 S I=$O(^XUTL("XUSYS",I)) Q:'I  K ^XUTL("XUSYS",I,"JE"),^("INTERUPT")
"RTN","ZSY",445,0)
 ;
"RTN","ZSY",446,0)
 ; Get jobs accessing this database
"RTN","ZSY",447,0)
 n procs d UNIXLSOF(.procs)
"RTN","ZSY",448,0)
 ;
"RTN","ZSY",449,0)
 ; Tell them to stop
"RTN","ZSY",450,0)
 n i f i=1:1 q:'$d(procs(i))  s ^XUTL("XUSYS",procs(i),"CMD")="HALT"
"RTN","ZSY",451,0)
 K ^XUTL("XUSYS",$J,"CMD")  ; but not us
"RTN","ZSY",452,0)
 ;
"RTN","ZSY",453,0)
 ; Sayonara
"RTN","ZSY",454,0)
 N J F J=0:0 S J=$O(^XUTL("XUSYS",J)) Q:'J  D INTRPT(J)
"RTN","ZSY",455,0)
 ;
"RTN","ZSY",456,0)
 ; Wait; Long hang for TCP jobs that can't receive interrupts for .2 seconds
"RTN","ZSY",457,0)
 H .25
"RTN","ZSY",458,0)
 ;
"RTN","ZSY",459,0)
 ; Check that they are all dead. If not, kill it "softly".
"RTN","ZSY",460,0)
 ; Need to do this for node and java processes that won't respond normally.
"RTN","ZSY",461,0)
 N J F J=0:0 S J=$O(^XUTL("XUSYS",J)) Q:'J  I $zgetjpi(J,"isprocalive"),J'=$J D KILL(J)
"RTN","ZSY",462,0)
 ;
"RTN","ZSY",463,0)
 quit
"RTN","ZSY",464,0)
 ;
"RTN","ZSY",465,0)
HALTONE(%J) ; [Public] Halt a single process
"RTN","ZSY",466,0)
 S ^XUTL("XUSYS",%J,"CMD")="HALT"
"RTN","ZSY",467,0)
 D INTRPT(%J)
"RTN","ZSY",468,0)
 H .25 ; Long hang for TCP jobs that can't receive interrupts
"RTN","ZSY",469,0)
 I $zgetjpi(%J,"isprocalive") D KILL(%J)
"RTN","ZSY",470,0)
 QUIT
"RTN","ZSY",471,0)
 ;
"RTN","ZSY",472,0)
KILL(%J) ; [Private] Kill %J
"RTN","ZSY",473,0)
 ; ZEXCEPT: shell
"RTN","ZSY",474,0)
 n %cmd s %cmd="kill "_%J
"RTN","ZSY",475,0)
 o "kill":(shell="/bin/sh":command=%cmd)::"pipe" u "kill" c "kill"
"RTN","ZSY",476,0)
 quit
"RTN","ZSY",477,0)
 ;
"RTN","ZSY",478,0)
ZJOB(PID) G JOBVIEWZ ; [Public, Interactive] Examine a specific job -- written by OSEHRA/SMH
"RTN","ZSY",479,0)
EXAMJOB(PID) G JOBVIEWZ ;
"RTN","ZSY",480,0)
VIEWJOB(PID) G JOBVIEWZ ;
"RTN","ZSY",481,0)
JOBVIEW(PID) G JOBVIEWZ ;
"RTN","ZSY",482,0)
JOBVIEWZ ;
"RTN","ZSY",483,0)
 ; ZEXCEPT: CTRAP,NOESCAPE,NOFILTER,PID
"RTN","ZSY",484,0)
 U $P:(CTRAP=$C(3):NOESCAPE:NOFILTER)
"RTN","ZSY",485,0)
 I $G(PID) D JOBVIEWZ2(PID) QUIT
"RTN","ZSY",486,0)
 D ^ZSY
"RTN","ZSY",487,0)
 N X,DONE
"RTN","ZSY",488,0)
 S DONE=0
"RTN","ZSY",489,0)
 ; Nasty read loop. I hate read loops
"RTN","ZSY",490,0)
 F  D  Q:DONE
"RTN","ZSY",491,0)
 . R !,"Enter a job number to examine (^ to quit): ",X:$G(DTIME,300)
"RTN","ZSY",492,0)
 . E  S DONE=1 QUIT
"RTN","ZSY",493,0)
 . I X="^" S DONE=1 QUIT
"RTN","ZSY",494,0)
 . I X="" D ^ZSY QUIT
"RTN","ZSY",495,0)
 . I X["?" D ^ZSY QUIT
"RTN","ZSY",496,0)
 . ;
"RTN","ZSY",497,0)
 . D JOBVIEWZ2(X)
"RTN","ZSY",498,0)
 . D ^ZSY
"RTN","ZSY",499,0)
 QUIT
"RTN","ZSY",500,0)
 ;
"RTN","ZSY",501,0)
JOBVIEWZ2(X) ; [Private] View Job Information
"RTN","ZSY",502,0)
 I X'?1.N W !,"Not a valid job number." Q
"RTN","ZSY",503,0)
 I '$zgetjpi(X,"isprocalive") W !,"This process does not exist" Q
"RTN","ZSY",504,0)
 ;
"RTN","ZSY",505,0)
 N EXAMREAD
"RTN","ZSY",506,0)
 N DONEONE S DONEONE=0
"RTN","ZSY",507,0)
 F  D  Q:DONEONE  ; This is an inner read loop to refresh a process.
"RTN","ZSY",508,0)
 . N % S %=$$EXAMINEJOBBYPID(X)
"RTN","ZSY",509,0)
 . I %'=0 W !,"The job didn't respond to examination for 305 ms. You may try again." S DONEONE=1 QUIT
"RTN","ZSY",510,0)
 . D PRINTEXAMDATA(X,$G(EXAMREAD))
"RTN","ZSY",511,0)
 . W "Enter to Refersh, V for variables, I for ISVs, K to kill",!
"RTN","ZSY",512,0)
 . W "L to load variables into your ST and quit, ^ to go back: ",!
"RTN","ZSY",513,0)
 . W "D to debug (broken), Z to zshow all data for debugging."
"RTN","ZSY",514,0)
 . R EXAMREAD:$G(DTIME,300)
"RTN","ZSY",515,0)
 . E  S DONEONE=1
"RTN","ZSY",516,0)
 . I EXAMREAD="^" S DONEONE=1
"RTN","ZSY",517,0)
 . I $TR(EXAMREAD,"k","K")="K" D HALTONE(X) S DONEONE=1
"RTN","ZSY",518,0)
 QUIT
"RTN","ZSY",519,0)
 ;
"RTN","ZSY",520,0)
EXAMINEJOBBYPID(%J) ; [$$, Public, Silent] Examine Job by PID; Non-zero output failure
"RTN","ZSY",521,0)
 Q:'$ZGETJPI(%J,"isprocalive") -1
"RTN","ZSY",522,0)
 K ^XUTL("XUSYS",%J,"CMD"),^("JE")
"RTN","ZSY",523,0)
 S ^XUTL("XUSYS",%J,"CMD")="EXAM"
"RTN","ZSY",524,0)
 D INTRPT(%J)
"RTN","ZSY",525,0)
 N I F I=1:1:5 H .001 Q:$G(^XUTL("XUSYS",%J,"JE","COMPLETE"))
"RTN","ZSY",526,0)
 I '$G(^XUTL("XUSYS",%J,"JE","COMPLETE")) H .2
"RTN","ZSY",527,0)
 I '$G(^XUTL("XUSYS",%J,"JE","COMPLETE")) H .2
"RTN","ZSY",528,0)
 I '$G(^XUTL("XUSYS",%J,"JE","COMPLETE")) Q -1
"RTN","ZSY",529,0)
 QUIT 0
"RTN","ZSY",530,0)
 ;
"RTN","ZSY",531,0)
PRINTEXAMDATA(%J,FLAG) ; [Private] Print the exam data
"RTN","ZSY",532,0)
 ; ^XUTL("XUSYS",8563,"JE","INTERRUPT")="GETTASK+3^%ZTMS1"
"RTN","ZSY",533,0)
 ; ^XUTL("XUSYS",8563,"JE","G",0)="GLD:*,REG:*,SET:25610,KIL:593,GET:12284,...
"RTN","ZSY",534,0)
 ; ^XUTL("XUSYS",8563,"JE","ZMODE")="OTHER"
"RTN","ZSY",535,0)
 N ZSY M ZSY=^XUTL("XUSYS",%J)
"RTN","ZSY",536,0)
 ;
"RTN","ZSY",537,0)
 N BOLD S BOLD=$C(27,91,49,109)
"RTN","ZSY",538,0)
 N RESET S RESET=$C(27,91,109)
"RTN","ZSY",539,0)
 N UNDER S UNDER=$C(27,91,52,109)
"RTN","ZSY",540,0)
 N DIM S DIM=$$AUTOMARG()
"RTN","ZSY",541,0)
 ;
"RTN","ZSY",542,0)
 ; Debug
"RTN","ZSY",543,0)
 I $TR(FLAG,"d","D")="D" D DEBUG(%J)
"RTN","ZSY",544,0)
 ;
"RTN","ZSY",545,0)
 ; Show all data
"RTN","ZSY",546,0)
 I $TR(FLAG,"z","Z")="Z" ZWRITE ZSY QUIT
"RTN","ZSY",547,0)
 ;
"RTN","ZSY",548,0)
 ; List Variables?
"RTN","ZSY",549,0)
 I $TR(FLAG,"v","V")="V" D  QUIT
"RTN","ZSY",550,0)
 . W !!,BOLD,"Variables: ",RESET,!
"RTN","ZSY",551,0)
 . N V F V=0:0 S V=$O(ZSY("JE","V",V)) Q:'V  W ZSY("JE","V",V),!
"RTN","ZSY",552,0)
 ;
"RTN","ZSY",553,0)
 ; Load Variables into my Symbol Table?
"RTN","ZSY",554,0)
 ; ZGOTO pops the stack and drops you to direct mode ($ZLEVEL is 2 to exit one above direct mode)
"RTN","ZSY",555,0)
 I $TR(FLAG,"l","L")="L" D  ZGOTO 2:LOADST
"RTN","ZSY",556,0)
 . K ^TMP("ZSY",$J)
"RTN","ZSY",557,0)
 . M ^TMP("ZSY",$J)=ZSY("JE","V")
"RTN","ZSY",558,0)
 ;
"RTN","ZSY",559,0)
 ; List ISVs?
"RTN","ZSY",560,0)
 I $TR(FLAG,"i","I")="I" D  QUIT
"RTN","ZSY",561,0)
 . W !!,BOLD,"ISVs: ",RESET,!
"RTN","ZSY",562,0)
 . N I F I=0:0 S I=$O(ZSY("JE","I",I)) Q:'I  W ZSY("JE","I",I),!
"RTN","ZSY",563,0)
 ;
"RTN","ZSY",564,0)
 ; Normal Display: Job Info, Stack, Locks, Devices
"RTN","ZSY",565,0)
 W #
"RTN","ZSY",566,0)
 W UNDER,"JOB INFORMATION FOR "_%J," (",$ZDATE(ZSY(0),"YYYY-MON-DD 24:60:SS"),")",RESET,!
"RTN","ZSY",567,0)
 W BOLD,"AT: ",RESET,ZSY("JE","INTERRUPT"),": ",$G(ZSY("JE","codeline")),!!
"RTN","ZSY",568,0)
 ;
"RTN","ZSY",569,0)
 N CNT S CNT=1
"RTN","ZSY",570,0)
 W BOLD,"Stack: ",RESET,!
"RTN","ZSY",571,0)
 ; Stack is funny -- print just to $ZINTERRUPT
"RTN","ZSY",572,0)
 N S F S=$O(ZSY("JE","R"," "),-1):-1:1 Q:ZSY("JE","R",S)["$ZINTERRUPT"  D
"RTN","ZSY",573,0)
 . N PLACE S PLACE=$P(ZSY("JE","R",S),":")
"RTN","ZSY",574,0)
 . I $E(PLACE)=" " QUIT  ; GTM adds an extra level sometimes for display -- messes me up
"RTN","ZSY",575,0)
 . W CNT,". "
"RTN","ZSY",576,0)
 . I PLACE'["GTM$DMOD" W PLACE,?40,$T(@PLACE)
"RTN","ZSY",577,0)
 . W !
"RTN","ZSY",578,0)
 . S CNT=CNT+1
"RTN","ZSY",579,0)
 W CNT,". ",ZSY("JE","INTERRUPT"),":",?40,$G(ZSY("JE","codeline")),!
"RTN","ZSY",580,0)
 ;
"RTN","ZSY",581,0)
 W !
"RTN","ZSY",582,0)
 W BOLD,"Locks: ",RESET,!
"RTN","ZSY",583,0)
 N L F L=0:0 S L=$O(ZSY("JE","L",L)) Q:'L  W ZSY("JE","L",L),!
"RTN","ZSY",584,0)
 ;
"RTN","ZSY",585,0)
 W !
"RTN","ZSY",586,0)
 W BOLD,"Devices: ",RESET,!
"RTN","ZSY",587,0)
 N D F D=0:0 S D=$O(ZSY("JE","D",D)) Q:'D  W ZSY("JE","D",D),!
"RTN","ZSY",588,0)
 ;
"RTN","ZSY",589,0)
 W !
"RTN","ZSY",590,0)
 W BOLD,"Breakpoints: ",RESET,!
"RTN","ZSY",591,0)
 N B F B=0:0 S B=$O(ZSY("JE","B",B)) Q:'B  W ZSY("JE","B",B),!
"RTN","ZSY",592,0)
 ;
"RTN","ZSY",593,0)
 W !
"RTN","ZSY",594,0)
 W BOLD,"Global Stats for default region: ",RESET,!
"RTN","ZSY",595,0)
 N G S G=""
"RTN","ZSY",596,0)
 N SLOTS S SLOTS=+DIM\15
"RTN","ZSY",597,0)
 N SLOT S SLOT=0
"RTN","ZSY",598,0)
 F  S G=$O(ZSY("JE","GSTAT",G)) Q:G=""  D
"RTN","ZSY",599,0)
 . I G="GLD" QUIT
"RTN","ZSY",600,0)
 . N V S V=ZSY("JE","GSTAT",G)
"RTN","ZSY",601,0)
 . I V>9999 S V=$J(V/1024,"",0)_"k"
"RTN","ZSY",602,0)
 . I V>9999,V["k" S V=$J(V/1024,"",0)_"m"
"RTN","ZSY",603,0)
 . W ?(SLOT*15),G,": ",V," "
"RTN","ZSY",604,0)
 . S SLOT=SLOT+1
"RTN","ZSY",605,0)
 . I SLOT+1>SLOTS S SLOT=0 W !
"RTN","ZSY",606,0)
 W !!
"RTN","ZSY",607,0)
 ;
"RTN","ZSY",608,0)
 W BOLD,"String Pool (size,currently used,freed): ",RESET,ZSY("JE","SPOOL"),!!
"RTN","ZSY",609,0)
 QUIT
"RTN","ZSY",610,0)
 ;
"RTN","ZSY",611,0)
LOADST ; [Private] Load the symbol table into the current process
"RTN","ZSY",612,0)
 KILL
"RTN","ZSY",613,0)
 N V F V=0:0 S V=$O(^TMP("ZSY",$J,V)) Q:'V  S @^(V)
"RTN","ZSY",614,0)
 K ^TMP("ZSY",$J)
"RTN","ZSY",615,0)
 QUIT
"RTN","ZSY",616,0)
 ;
"RTN","ZSY",617,0)
DEBUG(%J) ; [Private] Debugging logic
"RTN","ZSY",618,0)
 Q:'$ZGETJPI(%J,"isprocalive") -1
"RTN","ZSY",619,0)
 K ^XUTL("XUSYS",%J,"CMD"),^("JE")
"RTN","ZSY",620,0)
 S ^XUTL("XUSYS",%J,"CMD")="DEBUG"
"RTN","ZSY",621,0)
 D INTRPT(%J)
"RTN","ZSY",622,0)
 N I F I=1:1:5 H .001 Q:$G(^XUTL("XUSYS",%J,"JE","COMPLETE"))
"RTN","ZSY",623,0)
 I '$G(^XUTL("XUSYS",%J,"JE","COMPLETE")) H .2
"RTN","ZSY",624,0)
 I '$G(^XUTL("XUSYS",%J,"JE","COMPLETE")) H .1
"RTN","ZSY",625,0)
 I '$G(^XUTL("XUSYS",%J,"JE","COMPLETE")) Q -1
"RTN","ZSY",626,0)
 N ZSY M ZSY=^XUTL("XUSYS",%J)
"RTN","ZSY",627,0)
 ;
"RTN","ZSY",628,0)
 N BOLD S BOLD=$C(27,91,49,109)
"RTN","ZSY",629,0)
 N RESET S RESET=$C(27,91,109)
"RTN","ZSY",630,0)
 N UNDER S UNDER=$C(27,91,52,109)
"RTN","ZSY",631,0)
 N DIM S DIM=$$AUTOMARG()
"RTN","ZSY",632,0)
 ;
"RTN","ZSY",633,0)
 ; Normal Display: Job Info, Stack, Locks, Devices
"RTN","ZSY",634,0)
 W #
"RTN","ZSY",635,0)
 W UNDER,"JOB INFORMATION FOR "_%J," (",$ZDATE(ZSY(0),"YYYY-MON-DD 24:60:SS"),")",RESET,!
"RTN","ZSY",636,0)
 W BOLD,"AT: ",RESET,ZSY("JE","INTERRUPT"),": ",ZSY("JE","codeline"),!!
"RTN","ZSY",637,0)
 ;
"RTN","ZSY",638,0)
 N CNT S CNT=1
"RTN","ZSY",639,0)
 W BOLD,"Stack: ",RESET,!
"RTN","ZSY",640,0)
 ; Stack is funny -- print just to $ZINTERRUPT
"RTN","ZSY",641,0)
 N S F S=$O(ZSY("JE","R"," "),-1):-1:1 Q:ZSY("JE","R",S)["$ZINTERRUPT"  D
"RTN","ZSY",642,0)
 . N PLACE S PLACE=$P(ZSY("JE","R",S),":")
"RTN","ZSY",643,0)
 . I $E(PLACE)=" " QUIT  ; GTM adds an extra level sometimes for display -- messes me up
"RTN","ZSY",644,0)
 . W CNT,". "
"RTN","ZSY",645,0)
 . I PLACE'["GTM$DMOD" W PLACE,?40,$T(@PLACE)
"RTN","ZSY",646,0)
 . W !
"RTN","ZSY",647,0)
 . S CNT=CNT+1
"RTN","ZSY",648,0)
 W CNT,". ",ZSY("JE","INTERRUPT"),":",?40,ZSY("JE","codeline"),!
"RTN","ZSY",649,0)
 ;
"RTN","ZSY",650,0)
 W !
"RTN","ZSY",651,0)
 W BOLD,"Locks: ",RESET,!
"RTN","ZSY",652,0)
 N L F L=0:0 S L=$O(ZSY("JE","L",L)) Q:'L  W ZSY("JE","L",L),!
"RTN","ZSY",653,0)
 ;
"RTN","ZSY",654,0)
 W !
"RTN","ZSY",655,0)
 W BOLD,"Devices: ",RESET,!
"RTN","ZSY",656,0)
 N D F D=0:0 S D=$O(ZSY("JE","D",D)) Q:'D  W ZSY("JE","D",D),!
"RTN","ZSY",657,0)
 W !
"RTN","ZSY",658,0)
 W BOLD,"Breakpoints: ",RESET,!
"RTN","ZSY",659,0)
 N B F B=0:0 S B=$O(ZSY("JE","B",B)) Q:'B  W ZSY("JE","B",B),!
"RTN","ZSY",660,0)
 ;
"RTN","ZSY",661,0)
 n x r "press key to continue",x
"RTN","ZSY",662,0)
 QUIT
"RTN","ZSY",663,0)
 ;
"RTN","ZSY",664,0)
AUTOMARG() ;RETURNS IOM^IOSL IF IT CAN and resets terminal to those dimensions; GT.M
"RTN","ZSY",665,0)
 ; ZEXCEPT: APC,TERM,NOECHO,WIDTH
"RTN","ZSY",666,0)
 I $PRINCIPAL'["/dev/" quit:$Q "" quit
"RTN","ZSY",667,0)
 U $PRINCIPAL:(WIDTH=0)
"RTN","ZSY",668,0)
 N %I,%T,ESC,DIM S %I=$I,%T=$T D
"RTN","ZSY",669,0)
 . ; resize terminal to match actual dimensions
"RTN","ZSY",670,0)
 . S ESC=$C(27)
"RTN","ZSY",671,0)
 . U $P:(TERM="R":NOECHO)
"RTN","ZSY",672,0)
 . W ESC,"7",ESC,"[r",ESC,"[999;999H",ESC,"[6n"
"RTN","ZSY",673,0)
 . R DIM:1 E  Q
"RTN","ZSY",674,0)
 . W ESC,"8"
"RTN","ZSY",675,0)
 . I DIM?.APC U $P:(TERM="":ECHO) Q
"RTN","ZSY",676,0)
 . I $L($G(DIM)) S DIM=+$P(DIM,";",2)_"^"_+$P(DIM,"[",2)
"RTN","ZSY",677,0)
 . U $P:(TERM="":ECHO:WIDTH=+$P(DIM,";",2):LENGTH=+$P(DIM,"[",2))
"RTN","ZSY",678,0)
 ; restore state
"RTN","ZSY",679,0)
 U %I I %T
"RTN","ZSY",680,0)
 ; Extra just for ^ZJOB - don't wrap
"RTN","ZSY",681,0)
 U $PRINCIPAL:(WIDTH=0)
"RTN","ZSY",682,0)
 Q:$Q $S($G(DIM):DIM,1:"") Q
"VER")
8.0^22.2
**END**
**END**
