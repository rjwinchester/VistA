Adding to the OSEHRA Testing Harness
====================================

.. role:: usertype
    :class: usertype

The OSEHRA testing harness contains a series of tests which attempt to cover
as much of the VistA functionality as possible through a few types of
interaction methods.  The current tests fall under one of six categories:

* XINDEX
* MUnit
* RAS functional
* GUI tests (via Sikuli_)
* PyUnitTests
* Other

This document will walk through the process of adding a new entry to each facet
of the testing environment.

XINDEX
------

The XINDEX tests are not controlled by the contents of a folder in the
source tree, but are instead determined by the contents of the
``Packages.csv`` file. To add an XINDEX test for a newly created package,
create a new entry in the ``Packages.csv`` file which uses the following
template for each line:::

  Package Name,Directory Name,Prefix,File Number,File Name,Global Name,VDL_ID

There may be a need to create multiple lines in the CSV file.  This is
necessary if there is more than one prefix for the new package or a subset of
the routines from another prefix need to be excluded. To denote a routine
prefix is to be excluded, include a ``!`` before the prefix in the line. The
``Package Name`` and ``Directory Name`` should not be repeated on each new line
within a single package.

For Example, a ``New Package`` with the prefix ``NPK`` but not ``NPKG`` would
be entered into ``Packages.csv`` by adding the following lines:

.. parsed-literal::

  NEW PACKAGE,New Package,NPK,,,,
  ,,!NPKG,,,,

During a ``Configure`` step, CMake will read the ``Packages.csv`` file and pull
the package name from the second column of data when it is found.  It will also
pull in the routine prefixes to be used as the selections in the XINDEX run.

XINDEX Exceptions
^^^^^^^^^^^^^^^^^

Adding an exception for an error in the XINDEX results is another potential
update to the OSEHRA testing harness.

Exceptions are granted when an error is reported by XINDEX, but the error is
deemed acceptable and should not cause the test to fail.  Examples of this
include an error reported about a call to a 'missing' routine.  If the routine
checks to see if the routine exists prior to the call, the error can be granted
an exception.

If an exception is needed for a new package, we add an ``XINDEXException``
folder within the package directory.  Within this directory, there should be a
set of files.  Each exception file name should follow the naming structure:

  ``GTM`` or ``Cache`` for the platform the error is reported on,
  followed by a period, followed by the name of the routine.

See below for an example folder with exceptions for the fictional package
``New Package`` which has two errors in the ``NPKRTN`` routine:

.. parsed-literal::

  Packages/
  \\
   \\--- New Package/
         \\
          \\--- XINDEXException/
                \\
                 \\--- Cache.NPKRTN
                  \\--- GTM.NPKRTN



Within these files, list each error message with its location offset, if a
specific location is available.  Each error should be placed on a new line
within the file.  An example of the ``NPKRTN`` exceptions can be found below:

.. parsed-literal::

  EN+2        F - Reference to routine '^NPKRTN2'. That isn't in this UCI.
  EN+7        F - Block structure mismatch.

M-UNIT
------

The MUNit tests are also generated by CMake due to the folder structure of a
package. To generate an MUNit test, CMake searches for a ``Testing/MUnit``
directory within each package directory and, if found,  creates the necessary
files to import routines and run them based upon the content of that directory.

For Example, to generate MUnit tests in the ``New Package`` folder, generate a
``Testing/MUnit`` directory within ``Packages/New Package/`` and populate it
with the testing routines and a ``TestList`` file:


.. parsed-literal::

  Packages/
  \\
   \\--- New Package/
         \\
          \\--- XINDEXException/
           \\--- Testing/
                 \\
                  \\--- MUnit/
                        \\--- TestList
                         \\--- ZZUT1.m
                          \\--- ZZUT2.m

Each ``Testing/MUnit`` directory contains all source (.m) files necessary to
execute the contained tests. These files will be imported before the test is
run. The other file in the directory is the ``TestList`` file.  The
``TestList`` file is text only and contains the commands that will be
executed by the M[UMPS] command line to run each routine.

For Example, the above directory will have the following command lines in
the ``TestList`` file:

.. parsed-literal::

  D ^ZZUT1
  D TEST^ZZUT2

To add to an already existing MUnit suite, add the test routines to the MUnit
directory and add the necessary command[s] to execute them to the ``TestList``
file in that directory.


Roll-and-Scroll
---------------

The Roll-and-Scroll (RAS) tests are used to test what a user sitting at the
keyboard of a terminal would interact with.  We accomplish this by connecting
to VistA and using a call-and-response setup to read and answer prompts.

Like the MUnit tests, the RAS tests are also automatically generated by finding
certain content within each package's folder. In this case, it looks for the
existance of a ``RAS`` directory with some particular content.

The content of each current RAS test directory are as follows:

* TestName_suite.py : Contains the Python functions that perform each test

* TestName_test.py : Contains a single Python ``main`` function which calls all other tests.

* TestName.cfg : Contains configuration information about remote connections, if applicable.

The ``.cfg`` files are used to determine where these tests are to be run.  If
the ``RemoteConnect`` variable is set to ``1``, it will attempt to run the test
on the machine described in the other entries.  For inclusion into the VistA
repository, the ``RemoteConnect`` entry should be set to ``0``.


For examples of each file, see the `Registration`_, `Scheduling`_, or
`Problem List`_ packages.


The files that are currently in the respository have some caveats which
is recommended to follow to maintain consistency among the tests:

* Each test file ``*_test.py`` will be provided certain information as default
  arguments using the following command line flags:

  [-l LOGGING_LEVEL]
    How much information should be logged, set to be "INFO"
  [-n NAMESPACE]
    String of Cache namespace, if available, from ``VISTA_CACHE_NAMESPACE`` CMake variable
  [-c COVERAGE_TYPE]
    ON/OFF value to output human-readable coverage, from ``TEST_VISTA_COVERAGE_READABLE``
  [-cs COVERAGE_SUBSET]
    Name of routines to calculate coverage over, from ``TEST_VISTA_COVERAGE_SUBSET``
  resultdir
    Directory to store log and result files, from ``TEST_VISTA_OUTPUT_DIR``


* Each test will be run from the top level ``Testing`` directory of VistA
  source tree.

A properly populated folder would look like the structure below:

.. parsed-literal::

  Packages/
  \\
   \\--- New Package/
         \\
          \\--- XINDEXException/
           \\--- Testing/
                 \\
                  \\--- MUnit/
                   \\
                    \\--- RAS/
                          \\
                           \\--- TestName_suite.py
                            \\--- TestName_test.py
                             \\--- TestName.cfg

RaSR
^^^^^

The PriceWaterhouseCooper team has generated a tool called the
`Roll and Scroll Recorder`_ which is installed into an instance of the Eclipse
IDE and will generate the correct file and test structure while a user connects
to a live VistA instance.  To see another example on how to use the RaSR tool,
see the tutorial ``Creating Roll-and-Scroll tests`` from the Certification Work
Group under the ``Certification`` header of the `OSEHRA Education`_ page.

Sikuli
------

OSEHRA also has developed a test for two of the most used GUIs around the VistA
EHR: CPRS and Vitals.  The test uses a program called Sikuli_ to follow a script
with screenshots of items to interact with.

To add a new Sikuli-based test program, the necessary files are not placed in a
package specific directory. Instead, the necessary items are placed into the
``Testing/Functional/Sikuli`` directory.

Each entry into this folder should be a ``.sikuli`` folder which contains
two Sikuli scripts (One HTML, the other Python) and all of the images that are
needed in the script.

.. parsed-literal::

  Testing/
  \\
   \\--- Functional/
         \\
           \\--- Sikuli/
                 \\
                  \\--- newPackageGUI.sikuli/
                        \\
                         \\--- newPackageGUI.html.in
                          \\--- newPackageGUI.py.in
                           \\--- 1326480962420.png
                            \\--- Acutebronchi.png
                             \\--- ...

These two script files will require modification before the test is able to be
run from CMake.


Modification to Sikuli Files
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

The two script files will need to be configured prior to the test running.
Through the ``configure_file`` command, CMake has the ability to generate a
new file with the content of a specified file while replacing marked CMake
variables with their value in the CMakeCache file.  This is typically denoted
in the file name by having the ``.in`` extension on a file that is going to
be configured before being used.

This configuration is used in these test files to supply information about the
local system to the test. We look to configure two bits of information:

* Sikuli command with path to the original test folder: **required**

* Local information: paths to tested executables, port, or host name values:
  **if necessary**

Since the files with the variables replaced are created in the build directory,
A Sikuli command is used in each of the files to tell Sikuli where the image
files for the script are found, ``addImagePath``:

Add the following line to the ``.py.in`` file before the first image match is
called:::

  addImagePath("${sikuli}")

Add the following line to the ``.html.in`` in the same location as in the
python script:::

  addImagePath(<span class="str">"${sikuli}"</span>)

The string ``${sikuli}`` will be automatically replaced with the full path to
the original .sikuli folder by CMake during the ``configure`` step.

This ``${ }`` notation is needed for any CMake variables in the
script which need to be replaced.  Another example from the current Sikuli test
which shows other local information being entered is found in the call to open
the Vitals Manager executable below:::

  openApp(r'${VITALS_MANAGER_EXECUTABLE} /port=${VISTA_TCP_PORT} /server=${VISTA_TCP_HOST} /ccow=disable')

During Configuration, CMake will replace ``VITALS_MANAGER_EXECUTABLE``,
``VISTA_TCP_PORT``, and ``VISTA_TCP_HOST`` variables with their corresponding
value, leading to this line in the new file:::

  openApp(r'C:/Program Files (x86)/Vista/Vitals/VitalsManager.exe /port=9210 /server=127.0.0.1 /ccow=disable')

Each executable will likely need a CMake variable to open if the icon cannot be
found on the screen during the test.  An example of adding a variable for
executables is below and can also be found in the
``Testing/Functional/CMakeLists.txt`` file: ::

  find_program(CPRS_EXECUTABLE CPRSChart.exe DOC "Path to the CPRSChart.exe file")


To see another example on how to generate and modify a Sikuli test, see
the tutorial ``Creating GUI tests`` from the Certification Work
Group under the ``Certification`` header of the `OSEHRA Education`_ page.

PyUnitTests
--------------

As more of a general test framework,  `Python Unit Tests`_ have
been generated to test a variety of aspects of the VistA repository.  Some are
used to test the harness itself, while others are used to perform some external
checks to the VistA environment:

* A test for the VistATestClient

* A test for the M2M broker utility of the VistA EHR

* A test for the Patch order generator of the auto-patching utility

The tests are generated by capturing all Python (``.py``)  files within the
``Scripts/Testing/PyUnit`` directory that have ``Test`` as the first word of
the file name.

These files are not configured, so all necessary variables should be passed as
arguments to the file.  See the ``Testing/CMakeLists.txt`` file for an example
of passing arguments to these tests.

Other Tests
-----------

For tests that don't seem to fit into any of the above categories, OSEHRA has
a separate CMakeLists.txt file in the ``Testing/UserTest/`` directory  where
tests of any type can be added.  The tests here should be added using the
`add_test`_ CMake command. A quick example for adding a test using a file
named ``TestFile.cmake`` and executing it with the CMake executable would look
like this:

.. parsed-literal::

  add_test(UsrTest1 "${CMAKE_COMMAND}" "${CMAKE_CURRENT_SOURCE_DIR}/TestFile.cmake")

Once the test has been added to the CMakeLists.txt file, you will need to
configure the build environment with the ``TEST_VISTA_USERTEST`` option in
order to run the test from the command line.

.. _`Registration`: ../Packages/Registration/Testing/RAS/
.. _`Scheduling`: ../Packages/Scheduling/Testing/RAS/
.. _`Problem List`: ../Packages/Problem%20List/Testing/RAS/
.. _`Python Unit Tests`: http://pyunit.sourceforge.net/pyunit.html
.. _`add_test`: http://www.cmake.org/cmake/help/v2.8.12/cmake.html#command:add_test
.. _Sikuli: http://www.sikuli.org/
.. _`Roll and Scroll Recorder`: https://github.com/OSEHRA-Sandbox/RASR
.. _`OSEHRA Education`: http://www.osehra.org/content/education-training
