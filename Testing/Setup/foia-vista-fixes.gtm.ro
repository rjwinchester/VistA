Routines

DIUTL
DIUTL ;GFT  TIMSON'S UTILITIES;9MAY2018
 ;;22.2;VA FileMan;;Jan 05, 2015;
 ;;Submitted to OSEHRA 5 January 2015 by the VISTA Expertise Network.
 ;;Based on Medsphere Systems Corporation's MSC Fileman 1051.
 ;;Licensed under the terms of the Apache License, Version 2.0.
 ;;GFT;**76,999,1003,1004,1023,1055,1057,1058,1059,1060**
 ;
TRIME(Y) ;
 F  Q:$E(Y,$L(Y))'=" "  S Y=$E(Y,1,$L(Y)-1) ;IF STORED BY $EXTRACT, TRIM TRAILING SPACES
 Q Y
 ;
 ;
PLUS(Y) ;
 S:Y'<0 Y="+"_Y
 Q Y
 ;
 ;
NAKED(DIUTLREF) ;The argument is evaluated and returned, while keeping the naked reference as it was!
 N DIUTLNKD ;THIS WILL BE THE NAME OF THE NAKED
 I 0 ;X "I $ZREFERENCE=""""" I  S DIUTLNKD="^TMP(""DI DUMMY"",0)"
 E  S DIUTLNKD=$NA(^(0))
 X "S DIUTLREF="_DIUTLREF
 D  Q DIUTLREF
 .I $D(@DIUTLNKD)
 ;
 ;
DATE(Y) ;**CCO/NI   RETURN A DATE   22.2 CHANGED THIS BACK
 I Y X ^DD("DD")
 Q Y
 ;
 ;
NOWINT() ;INTERNAL VERSION OF NOW
 N %,%I,%H,%M,%D,%Y,X
 D NOW^%DTC Q %
 ;
 ;
NOW() ;EXTERNAL NOW
 N X S X=$$NOWINT Q $$DATE(X-(X#.0001))
 ;
 ;
WP(DIRF,DIWL,DIWR,DIWPUT) ;Write out WP field (if any) stored at DIRF, or put it in DIWPUT array
 N DIWF,Z,A1,D,X,DIW,DIWT,DN,I,DIWI,DIWTC,DIWX
 K ^UTILITY($J,"W")
 S DIWF=$E("W",'$D(DIWPUT))_"|" S:'$G(IOM) IOM=80 S:'$G(DIWR) DIWR=IOM S:'$G(DIWL) DIWL=1
 S A1=$P($G(@DIRF@(0)),U,3) F D=0:0 S D=$O(@DIRF@(D)) Q:D>A1&A1!'D  S X=^(D,0) D ^DIWP G QWP:$G(DN)=0
 I $G(DIWPUT)]"" D  Q 1
 .K @DIWPUT M @DIWPUT=^UTILITY($J,"W")
 D ^DIWW
QWP I $G(DN)'=0 Q 1
 K DIOEND Q 0
 ;
IJ(N) ;build I & J arrays given subfile number N
 N A K I,J
 S J(0)=N,N=0
0 I $D(^DIC(J(0),0,"GL")) S I(0)=^("GL") Q
 S A=$G(^DD(J(0),0,"UP")) Q:A=""
 S I=$O(^DD(A,"SB",J(0),0)) Q:'I
 S I=$P($P($G(^DD(A,I,0)),U,4),";") Q:I=""
 I +I'=I S I=""""_I_""""
 F J=N:-1:0 S J(J+1)=J(J) S:J I(J+1)=I(J)
 S J(0)=A,I(1)=I,N=N+1 G 0
 ;
 ;
DIVR(DI,DIFLD) ;verify
 N DIVZ,S,A,DA,DICL,V,Z,DDC,DR,N,Y,I,J,Q,W,V,T,DQI
 K ^UTILITY("DIVR",$J),^DD(U,$J)
 D IJ(DI)
 I '$O(@(I(0)_"0)")) Q  ;File must have some entries!
 S S=";",Q="""",V=$O(J(""),-1),A=DI,DA=DIFLD
 S DR=$P(^DD(DI,DIFLD,0),U,2),Z=$P(^(0),U,3),$P(Y(0),U,4)=$P(^(0),U,4),DDC=$P(^(0),U,5,999)
 Q:DR["W"!(DR["C")
 F T="N","S","V","P","K","F" Q:DR[T
 W !!,"SINCE YOU HAVE CHANGED THE FIELD DEFINITION,",!,"EXISTING '",$P(^(0),U),"' DATA WILL NOW BE CHECKED FOR INCONSISTENCIES",!,"OK"
 S %=1 D YN^DICN Q:%-1
 ;D ^%ZIS Q:POP
 ;U IO   WON'T WORK BECAUSE Q+3^DIVR ASKS TO STORE IN TEMPLATE
 D EN^DIVR(DI,DIFLD)
 ;D ^%ZISC
 Q
 ;
 ;
CHKPT(DIFILE,DA,DIMSG) ;check if any entries points to this entry(DA) in file (DIFILE)
 ;INPUT: DIFILE=file number, DA=ien of record, DIMSG=closed global root or local array
 ;OUTPUT: DIMSG(0)=line count, DISMG(#)="Entry ien in FILE (file #) refers to it."
 ;CODE CAME FROM DEL^DPTLK2
 Q:$G(DIMSG)=""  S @DIMSG@(0)=0
 Q:'$G(DA)  Q:$G(^DIC(+$G(DIFILE),0))=""
 N I,J,K,L,A,B,C,G,T,Q S Q="""",C=0
 ;find all files and fields that point to this file
 F I=0:0 S I=$O(^DD(DIFILE,0,"PT",I)) Q:'I  F J=0:0 S J=+$O(^DD(DIFILE,0,"PT",I,J)),(B,T)=I Q:'J  D
 .;check if multiple, find top file level = T
 . F  S B=+$G(^DD(B,0,"UP")) S:B T=B I 'B S G=$G(^DIC(+T,0,"GL")) Q
 .;pointing to file must have file level cross reference; file level (+A=T), not mumps
 . F K=0:0 S K=$O(^DD(I,J,1,K)) Q:'K  S A=$G(^(K,0)) I +A=T,$L($P(A,U,2)),'$L($P(A,U,3)) D
  .. Q:'$L(G)
  ..; if variable pointer, then reset DA to contain global ref.  DA;gr
  .. I $P(^DD(I,J,0),U,2)["V" S L=DA N DA S DA=Q_L_";"_$P($G(^DIC(DIFILE,0,"GL")),"^",2)_Q
  .. F L=0:0 S L=$O(@(G_Q_$P(A,U,2)_Q_","_DA_",L)")) Q:'L  D
  ... S C=C+1,@DIMSG@(C)="Entry "_L_" in "_$P($G(^DIC(T,0)),U)_" ("_T_") refers to it."
  .. Q
 . Q
 S @DIMSG@(0)=C
 Q

HLCSTCP3
HLCSTCP3 ;SFIRMFO/RSD - BI-DIRECTIONAL TCP ;2018-09-06  10:24 AM
 ;;1.6;HEALTH LEVEL SEVEN;**76,77,133,122,153,157,OSEHRA**;OCT 13, 1995;Build 8
 ;
 ; Changes **OSEHRA** by Sam Habiel (c) 2018
 ;
OPENA ;
 ; called from $$OPEN^HLCSTCP2 and this sub-routine OPENA
 ;
 ; **P153 START CJM
 ; Reset the TCP Address incase DNS changed it without a successful connection
 K HLDOM
 S HLTCPADD=$P(^HLCS(870,HLDP,400),U)
 ;
RETRY ;
 ; **P153 END CJM
 ;
 I $G(HLMSG),$D(^HLMA(HLMSG,"P")) S HLPORTA=+$P(^("P"),U,6)
 S POP=1
 ;
 ; patch HL*1.6*122 start
 ; variable HLDRETR=re-transmit attemps (#870,200.02)
 ; variable HLTCPLNK("TIMEOUT")=timeout for 3rd parameter of CALL^%ZISTCP()
 ; defined in HLCSTCP routine
 ;
 I '$G(HLDRETR("COUNT")) S HLDRETR("COUNT")=1
 I '$G(HLTCPLNK("TIMEOUT")) S HLTCPLNK("TIMEOUT")=5
 S HLDRETR("COUNT-2")=HLDRETR("COUNT")+HLDRETR
 ; patch 133
 ; I $G(HLDIRECT("OPEN TIMEOUT")) D
 ; .S HLI=1
 ; .D CALL^%ZISTCP(HLTCPADD,HLTCPORT,HLDIRECT("OPEN TIMEOUT"))
 ; E  D
 ; .F HLI=1:1:HLDRETR D CALL^%ZISTCP(HLTCPADD,HLTCPORT) Q:'POP
 I $G(HLDIRECT("OPEN TIMEOUT")) D
 . D MON^HLCSTCP("Open")
 . D CALL^%ZISTCP(HLTCPADD,HLTCPORT,HLDIRECT("OPEN TIMEOUT"))
 . ; give site one more chance to override the application setup
 . I $G(POP),(HLTCPLNK("TIMEOUT")>HLDIRECT("OPEN TIMEOUT")) D
 .. D CALL^%ZISTCP(HLTCPADD,HLTCPORT,HLTCPLNK("TIMEOUT"))
 E  D
 . N COUNT
 . ; try to connect HLDRETR times
 . F HLDRETR("COUNT")=HLDRETR("COUNT"):1:HLDRETR("COUNT-2") D  Q:('POP)!($$STOP^HLCSTCP)
 .. D MON^HLCSTCP("Open")
 .. ; D CALL^%ZISTCP(HLTCPADD,HLTCPORT)
 .. D CALL^%ZISTCP(HLTCPADD,HLTCPORT,HLTCPLNK("TIMEOUT"))
 .. ;open error
 .. I POP D
 ... D CC^HLCSTCP2("Openfail")
 ... H $S(HLDRETR("COUNT")=1:0,HLDRETR("COUNT")<10:1,1:8)
 ... I '$D(^XTMP("HL7-Openfail",$J)) D
 .... S ^XTMP("HL7-Openfail",0)=$$FMADD^XLFDT($$NOW^XLFDT,3)_"^"_$$NOW^XLFDT
 .... S ^XTMP("HL7-Openfail",$J,"COUNT","FIRST")=HLDRETR("COUNT")_"^"_$$NOW^XLFDT
 ... S COUNT=$P($G(^XTMP("HL7-Openfail",$J,"COUNT","LAST")),"^")+1
 ... S ^XTMP("HL7-Openfail",$J,"COUNT","LAST")=COUNT_"^"_$$NOW^XLFDT
 ;
 ;set # of opens back in msg
 ; I $G(HLMSG),$D(^HLMA(HLMSG,"P")) S $P(^("P"),U,6)=HLPORTA+HLI
 I $G(HLMSG),$D(^HLMA(HLMSG,"P")) S $P(^("P"),U,6)=HLDRETR("COUNT")
 ; patch HL*1.6*122 end
 ;
 ;device open
 I 'POP S HLPORT=IO D  Q $S($G(HLERROR)]"":0,1:1)
 . N $ETRAP,$ESTACK S $ETRAP="D ERROR^HLCSTCP2" ;HL*1.6*77
 . ;if address came from DNS, set back into LL
 . I $D(HLIP) S $P(^HLCS(870,HLDP,400),U)=HLTCPADD
 . ; write and read to check if still open
 . ; patch HL*1.6*157: HLOS is from calling $$OS^%ZOSV
 . ; Q:HLOS'["OpenM"  X "U IO:(::""-M"")" ; must be Cache/NT + use packet mode
 . ; Q:(HLOS'["VMS")&(HLOS'["UNIX")  X "U IO:(::""-M"")" ; must be Cache + packet mode  ; **OSEHRA** -> This line crashes on GTM/YDB
 . ; **OSEHRA** - begin replacement code
 . Q:(HLOS'["VMS")&(HLOS'["UNIX")
 . I ^%ZOSF("OS")["OpenM" U IO:(::"-M")
 . E  I ^%ZOSF("OS")["GT.M"  U IO:(nowrap:nodelimiter)
 . E  U IO
 . Q:$P(^HLCS(870,HLDP,400),U,7)'="Y"  ; must want to SAY HELO
 . U IO W "HELO "_$$KSP^XUPARAM("WHERE"),! R X:1
 ;openfail-try DNS lookup
 ;
 ; patch HL*1.6*122 start
 ;I '$D(HLDOM) S HLDOM=+$P(^HLCS(870,HLDP,0),U,7),HLDOM=$P($G(^DIC(4.2,HLDOM,0)),U) D:HLDOM]"" DNS
 I '$D(HLDOM) D
 . S HLDOM=+$P(^HLCS(870,HLDP,0),U,7),HLDOM=$P($G(^DIC(4.2,HLDOM,0)),U)
 . S HLDOM("DNS")=$P($G(^HLCS(870,+$G(HLDP),0)),"^",8)
 . D:HLDOM]""!($L(HLDOM("DNS"),".")>2) DNS
 ;
 Q:$$STOP^HLCSTCP 0
 ;HLIP=ip add. from DNS call, get first one and try open again
 ;
 ; **P153 START CJM
 ;I $D(HLIP) S HLTCPADD=$P(HLIP,","),HLIP=$P(HLIP,",",2,99) G:HLTCPADD OPENA
 I $D(HLIP) S HLTCPADD=$P(HLIP,","),HLIP=$P(HLIP,",",2,99) G:HLTCPADD RETRY
 ; **P153 END CJM
 ;
 ; open error
 ;cleanup and close
 ; patch 133
 I $G(HLDIRECT("OPEN TIMEOUT")) D
 . D MON^HLCSTCP("Openfail")
 . I $D(HLPORT) D CLOSE^%ZISTCP K HLPORT
 E  D
 . D CC^HLCSTCP2("Openfail")
 Q 0
 ; patch HL*1.6*122 end
 ;
 ;
 ;following code was removed, site's complained of to many alerts
 ;couldn't open, send 1 alert
 ;I '$G(HLPORTA) D
 ;. ;send alert
 ;. N XQA,XQAMSG,XQAOPT,XQAROU,XQAID,Z
 ;. ;get mailgroup from file 869.3
 ;. S Z=$P($$PARAM^HLCS2,U,8),HLPORTA="" Q:Z=""
 ;. S XQA("G."_Z)="",XQAMSG=$$HTE^XLFDT($H,2)_" Logical Link "_$P(^HLCS(870,HLDP,0),U)_" exceeded Open Retries."
 ;. D SETUP^XQALERT
 ;open error
 ;D CC("Openfail") H 3
 ;Q 0
 ;
 ;
DNS ;VA domains must have "med" inserted.
 ;All domains must use port 5000 and are prepended with "HL7"
 ;non-VA DNS lookups will succeed if site uses port 5000 and 
 ;configure their local DNS with "HL7.yourdomain.com" and entries
 ;are created in the logical link file and domain file.
 D MON^HLCSTCP("DNS Lkup")
 I HLDOM["DOMAIN.EXT"&(HLDOM'[".MED.") S HLDOM=$P(HLDOM,".DOMAIN.EXT")_".DOMAIN.EXT"
 I HLTCPORT=5000 S HLDOM="HL7."_HLDOM
 I HLTCPORT=5500 S HLDOM="MPI."_HLDOM
 ;
 ; patch HL*1.6*122 start
 I $L($G(HLDOM("DNS")),".")>2 D
 . S HLDOM=HLDOM("DNS")
 ; patch HL*1.6*122 end
 ;
 S HLIP=$$ADDRESS^XLFNSLK(HLDOM)
 K:HLIP="" HLIP
 Q
 ;

ICDEXA2
ICDEXA2 ;SLC/KER - ICD Extractor - APIs/Utilities (cont) ;2018-06-21  3:57 PM
 ;;18.0;DRG Grouper;**57,WVEHR**;Oct 20, 2000;Build 1
 ; * WVEHR change (c) George Lilly and David Whitten 2015
 ;                (c) Sam Habiel 2018 (bug fixes to $$PREV)
 ; Licensed under Apache 2
 ;               
 ; Global Variables
 ;    ^ICD0("AVA"         N/A
 ;    ^ICD9("AVA"         N/A
 ;               
 ; External References
 ;    $$DT^XLFDT          ICR  10103
 ;
 Q
NEXT(CODE,SYS,CDT) ; Next ICD Code (active or inactive)
 ;
 ; Input:
 ; 
 ;    CODE   ICD Code or Null for the first code
 ;    SYS    Coding System - see ^ICDS
 ;              
 ;              1 = ICD-9-CM
 ;              2 = ICD-9-PCS
 ;             30 = ICD-10-CM
 ;             31 = ICD-10-PCS
 ;             
 ;   CDT   Code Date to check
 ;         If CDT is passed, then the code
 ;         returned is the next active code
 ;         based on date.  If it is not 
 ;         passed then the next code is
 ;         returned regardless of status.
 ;         
 ; Output:
 ; 
 ;    The Next ICD Code, Null if none
 ;
 N ICDB,ICDC,ICDG,ICDF,ICDD,ICDE,ICDI,ICDR,ICDS,ICDO,ICDN,ICDY
 S ICDC=$TR($G(CODE)," ",""),ICDD=$G(CDT),ICDB=ICDD?7N
 S ICDY=$$SYS^ICDEX(+($G(SYS)))
 S:ICDY'>0&($L(ICDC)) ICDY=$$SYS^ICDEX(ICDC)
 S ICDF=$$FILE^ICDEX(+ICDY)
 Q:'$L(ICDC)&(ICDY'>0) "" S ICDS=0,ICDE=""
 S:+ICDY>0 ICDS=+ICDY I $L(ICDC) D
 . S:"^80^80.1^"'[("^"_ICDF_"^") ICDF=$$CODEFI^ICDEX(ICDC)
 . S ICDE=$P($$CODECS^ICDEX(ICDC,ICDF),"^",1) S:ICDS>0 ICDE=ICDS
 Q:+ICDY>0&(+($G(ICDE))>0)&(+ICDY'=+($G(ICDE))) ""
 S:+ICDS'>0&(+($G(ICDE))>0) ICDS=+($G(ICDE))
 Q:+ICDS'>0 ""  S ICDR=$$ROOT^ICDEX(ICDS) Q:'$L(ICDR) ""
 S ICDO=$$NUM^ICDEX(ICDC) Q:$L(ICDC)&(+ICDO'>0) ""
 I 'ICDB S ICDC="" D  Q $S(ICDC="":"",1:ICDC)
 . ;;Begin WorldVistA Change 8/2015 DJW - treat code as string
 . ;was; S ICDN=$O(@(ICDR_"""AN"","_+ICDS_","_+ICDO_")"))
 . S ICDN=$O(@(ICDR_"""AN"","_+ICDS_","""_ICDO_""")"))
 . ;was; S ICDC=$S(+ICDN>0:$$COD^ICDEX(+ICDN),1:"")
 . S ICDC=$S($L(ICDN):$$COD^ICDEX(ICDN),1:"")
 I ICDB S ICDC="" D  Q $S(ICDC="":"",1:ICDC)
 . ;WAS ; N ICDA S ICDA="" F  S ICDO=$O(@(ICDR_"""AN"","_+ICDS_","_+ICDO_")")) Q:+ICDO'>0  D  Q:$L(ICDC)
 . N ICDA S ICDA="" F  S ICDO=$O(@(ICDR_"""AN"","_+ICDS_","""_ICDO_""")")) Q:+ICDO'>0  D  Q:$L(ICDC)
 . . ;WAS; N ICDI S ICDI=0 F  S ICDI=$O(@(ICDR_"""AN"","_+ICDS_","_+ICDO_","_+ICDI_")")) Q:+ICDI'>0  D  Q:$L(ICDC)
 . . N ICDI S ICDI=0 F  S ICDI=$O(@(ICDR_"""AN"","_+ICDS_","""_ICDO_""","_+ICDI_")")) Q:+ICDI'>0  D  Q:$L(ICDC)
 . . . N ICDE,ICDH S ICDE=$O(@(ICDR_+ICDI_",66,""B"","_(ICDD+.001)_")"),-1) Q:ICDE'?7N
 . . . S ICDH=$O(@(ICDR_+ICDI_",66,""B"","_ICDE_","" "")"),-1) Q:+ICDH'>0
 . . . S ICDA=$G(@(ICDR_+ICDI_",66,"_ICDH_",0)")),ICDA=+($P(ICDA,"^",2))
 . . . ;WAS; S:+ICDA>0 ICDC=ICDO S ICDC=$S(+($G(ICDC))>0:$$COD^ICDEX(+ICDC),1:"")
 . . . S:+ICDA>0 ICDC=ICDO S ICDC=$S($L(ICDC):$$COD^ICDEX(ICDC),1:"")
 . ; End WorldVistA Change 8/2015
 Q $S(ICDC="":"",1:ICDC)
PREV(CODE,SYS,CDT) ; Previous ICD Code (active or inactive)
 ;
 ; Input:
 ; 
 ;    CODE   ICD Code or Null for the last code
 ;    SYS    Coding System - see ^ICDS
 ;              
 ;              1 = ICD-9-CM
 ;              2 = ICD-9-PCS
 ;             30 = ICD-10-CM
 ;             31 = ICD-10-PCS
 ;             
 ;   CDT   Code Date to check
 ;         If CDT is passed, then the code
 ;         returned is the previous active 
 ;         code based on date.  If it is 
 ;         not passed then the previous 
 ;         code is returned regardless of 
 ;         status.
 ;         
 ; Output:
 ; 
 ;    The Previous ICD Code, Null if none
 ;
 N ICDB,ICDC,ICDG,ICDF,ICDD,ICDE,ICDI,ICDR,ICDS,ICDO,ICDN,ICDY
 S ICDC=$TR($G(CODE)," ",""),ICDD=$G(CDT),ICDB=ICDD?7N
 S ICDY=$$SYS^ICDEX(+($G(SYS)))
 S:ICDY'>0&($L(ICDC)) ICDY=$$SYS^ICDEX(ICDC)
 S ICDF=$$FILE^ICDEX(+ICDY)
 Q:'$L(ICDC)&(ICDY'>0) "" S ICDS=0,ICDE=""
 S:+ICDY>0 ICDS=+ICDY I $L(ICDC) D
 . S:"^80^80.1^"'[("^"_ICDF_"^") ICDF=$$CODEFI^ICDEX(ICDC)
 . S ICDE=$P($$CODECS^ICDEX(ICDC,ICDF),"^",1) S:ICDS>0 ICDE=ICDS
 Q:+ICDY>0&(+($G(ICDE))>0)&(+ICDY'=+($G(ICDE))) ""
 S:+ICDS'>0&(+($G(ICDE))>0) ICDS=+($G(ICDE)) Q:+ICDS'>0 ""
 S ICDR=$$ROOT^ICDEX(ICDS) Q:'$L(ICDR) ""
 S ICDO=$$NUM^ICDEX(ICDC) Q:$L(ICDC)&(+ICDO'>0) ""
 I 'ICDB D  Q $S(ICDC="":"",1:ICDC)
 . ;;Begin WorldVistA Change 8/2015 DJW - treat code as string
 . ;WAS; S:+ICDO'>0 ICDO=$O(@(ICDR_"""AN"","_+ICDS_","" "")"),-1)+1
 . S:+ICDO'>0 ICDO="" ; **OSE/SMH - this line is different**
 . S ICDN=0,ICDC=""
 . ;WAS; S ICDN=$O(@(ICDR_"""AN"","_+ICDS_","_+ICDO_")"),-1)
 . S ICDN=$O(@(ICDR_"""AN"","_+ICDS_","""_ICDO_""")"),-1)
 . ;WAS; S ICDC=$S(+ICDN>0:$$COD^ICDEX(+ICDN),1:"")
 . S ICDC=$S($L(ICDN):$$COD^ICDEX(ICDN),1:"")
 I ICDB S ICDC="" D  Q $S(ICDC="":"",1:ICDC)
 . N ICDA S ICDA="" S:+ICDO'>0 ICDO="" ; **OSE/SMH - this line is different**
 . ;WAS; F  S ICDO=$O(@(ICDR_"""AN"","_+ICDS_","_+ICDO_")"),-1) Q:+ICDO'>0  D  Q:$L(ICDC)
 . F  S ICDO=$O(@(ICDR_"""AN"","_+ICDS_","""_ICDO_""")"),-1) Q:+ICDO'>0  D  Q:$L(ICDC)
 . . ;WAS; N ICDI S ICDI=0 F  S ICDI=$O(@(ICDR_"""AN"","_+ICDS_","_+ICDO_","_+ICDI_")")) Q:+ICDI'>0  D  Q:$L(ICDC)
 . . N ICDI S ICDI=0 F  S ICDI=$O(@(ICDR_"""AN"","_+ICDS_","""_ICDO_""","_+ICDI_")")) Q:+ICDI'>0  D  Q:$L(ICDC)
 . . . N ICDE,ICDH S ICDE=$O(@(ICDR_+ICDI_",66,""B"","_(ICDD+.001)_")"),-1) Q:ICDE'?7N
 . . . S ICDH=$O(@(ICDR_+ICDI_",66,""B"","_ICDE_","" "")"),-1) Q:+ICDH'>0
 . . . S ICDA=$G(@(ICDR_+ICDI_",66,"_ICDH_",0)")),ICDA=+($P(ICDA,"^",2))
 . . . ;WAS ;S:+ICDA>0 ICDC=ICDO S ICDC=$S(+($G(ICDC))>0:$$COD^ICDEX(+ICDC),1:"")
 . . . S:+ICDA>0 ICDC=ICDO S ICDC=$S($L(ICDC):$$COD^ICDEX(ICDC),1:"")
 . ; End WorldVistA Change 8/2015
 Q $S(ICDC="":"",1:ICDC)
HIST(CODE,ARY,SYS)  ; Activation History
 ;
 ; Input:
 ; 
 ;    CODE   ICD Code                   (required)
 ;    .ARY   Array, passed by Reference (required)
 ;    SYS    Coding System - see ^ICDS
 ;              
 ;              1 = ICD-9-CM
 ;              2 = ICD-9-PCS
 ;             30 = ICD-10-CM
 ;             31 = ICD-10-PCS
 ;
 ; Output:    Mirrors ARY(0) (or, -1 on error)
 ; 
 ;    ARY(0) = Number of Activation History Entries
 ;    ARY(<date>) = status    where: 1 is Active
 ;    ARY("IEN") = <ien>
 ;
 Q:$G(CODE)="" -1  K ARY
 N ICDC,ICDF,ICDS,ICDE,ICDI,ICDA,ICDN,ICDD,ICDR,ICDF,ICDS,ICDY
 S ICDC=$TR($G(CODE)," ","") Q:'$L(ICDC) -1  S ICDY=$$SYS^ICDEX($G(SYS))
 S:+ICDY'>0 ICDY=$$SYS^ICDEX(ICDC)
 S ICDS=0 S:+ICDY>0 ICDS=+ICDY
 S ICDF=$$CODEFI^ICDEX(ICDC) Q:+ICDF'>0 -1
 S ICDE=$P($$CODECS^ICDEX(ICDC,ICDF),"^",1) Q:+ICDE'>0 -1
 S:+ICDS'>0&(+ICDE>0) ICDS=ICDE
 Q:+ICDS>0&(ICDS'=+ICDE) -1
 S ICDR=$$ROOT^ICDEX(ICDF) Q:'$L(ICDR) -1
 S ICDI=$$CODEABA^ICDEX(ICDC,ICDR,+ICDS) Q:+ICDI'>0 -1
 S ICDE=$P($G(@(ICDR_ICDI_",1)")),"^",1) Q:+ICDS>0&(ICDS'=+ICDE) -1
 S ARY("IEN")=ICDI,ICDA="" M ICDA=@(ICDR_ICDI_",66)")
 K ICDA("B") S ARY(0)=+($P($G(ICDA(0)),"^",4))
 S:+ARY(0)=0 ARY(0)=-1 K:ARY(0)=-1 ARY("IEN")
 S (ICDI,ICDC)=0 F  S ICDI=$O(ICDA(ICDI)) Q:+ICDI=0  D
 . S ICDD=$P($G(ICDA(ICDI,0)),"^",1) Q:+ICDD=0
 . S ICDF=$P($G(ICDA(ICDI,0)),"^",2) Q:'$L(ICDF)
 . S ICDC=ICDC+1,ARY(0)=ICDC,ARY(ICDD)=ICDF
 Q ARY(0)
PERIOD(CODE,ARY,SYS) ; Return Activation/Inactivation Period in ARY
 ;
 ; Input:
 ; 
 ;    CODE   ICD Code (required)
 ;    ARY    Array, passed by Reference (required)
 ;    SYS    Coding System - see ^ICDS
 ;              
 ;              1 = ICD-9-CM
 ;              2 = ICD-9-PCS
 ;             30 = ICD-10-CM
 ;             31 = ICD-10-PCS
 ;
 ; Output:  
 ; 
 ;          $$PERIOD  Number of activation periods found
 ; 
 ;          ARY(0) = IEN ^ Selectable ^ Error Message
 ;          
 ;            Where IEN = -1 if error
 ;            Selectable = 0 for unselectable
 ;            Error Message if applicable
 ;            
 ;          ARY(Activation Date) = Inactivation Date^Short Name
 ;
 ;            Where the Short Name is versioned as follows:
 ;
 ;            Period is active   - Text for TODAY's date
 ;            Period is inactive - Text for inactivation date
 ;
 I $G(CODE)="" S ARY(0)="-1^0^Code not specified" Q 0
 K ARY N ICD1,ICDC,ICDBA,ICDF,ICDG,ICDS,ICDE,ICDI,ICDI,ICDA,ICDN,ICDD,ICDR,ICDF,ICDS,ICDY,ICDP,ICDT
 S ICDC=$TR($G(CODE)," ","") I '$L(ICDC) S ARY(0)="-1^0^Invalid Code specified" Q 0
 I $D(^ICD9("AVA",(CODE_" ")))!($D(^ICD0("AVA",(CODE_" ")))) S ARY(0)="-1^0^Invalid Code specified" Q 0
 S ICDY=$$SYS^ICDEX($G(SYS))
 I +ICDY'>0 D
 . N ICDF,ICDE S ICDF=$$CODEFI^ICDEX(ICDC) Q:+ICDF'>0
 . S ICDE=$P($$CODECS^ICDEX(ICDC,ICDF),"^",1) Q:+ICDE'>0
 . S ICDY=$$SYS^ICDEX(ICDE)
 S ICDS=+($G(ICDY)) I +ICDS'>0 S ARY(0)="-1^0^Invalid or undetermined Coding System" Q 0
 S ICDR=$$ROOT^ICDEX(ICDS) I '$L(ICDR) S ARY(0)="-1^0^Undetermined global root" Q 0
 S ICDI=$$CODEABA^ICDEX(ICDC,ICDR,+ICDS) I +ICDI'>0 S ARY(0)="-1^0^IEN not found" Q 0
 S ICDP=$S(ICDR["ICD9":3,1:4),ICD1=$G(@(ICDR_ICDI_",1)")),ICDN=$$MRST(ICDR,ICDI)
 S ICDG=ICDR_ICDI_",67,",ICDT=$O(@(ICDG_"""B"","" "")"),-1),ICDT=$O(@(ICDG_"""B"","_+ICDT_","" "")"),-1)
 S ICDT=$P($G(@(ICDG_+ICDT_",0)")),"^",2),ARY(0)=ICDI_"^"_'$P(ICD1,"^",7)
 S (ICDA,ICDBA)=0,ICDG=ICDR_ICDI_",66,"
 F  Q:ICDBA  D
 . N ICDBI,ICDCA,ICDST,ICDV S ICDA=$O(@(ICDG_"""B"","_ICDA_")"))
 . I ICDA="" S ICDBA=1 Q
 . S ICDF=$O(@(ICDG_"""B"","_ICDA_",0)"))
 . I '+ICDF S ICDBA=1 Q
 . S ICDST=$P($G(@(ICDG_ICDF_",0)")),"^",2)
 . Q:'ICDST  ;outer loop looks for active
 . ; Versioned text for activation date
 . S ICDV=$$MRST(ICDR,ICDI) S:$L(ICDV) ICDT=ICDV
 . S ARY(ICDA)="^"_ICDT,ICDBI=0,ICDI=ICDA
 . F  Q:ICDBI  D
 . . S ICDI=$O(@(ICDG_"""B"","_ICDI_")"))
 . . ; If no inactivation date for ICDA then use TODAY's text
 . . I ICDI="" S ARY(ICDA)="^"_ICDN,(ICDBI,ICDBA)=1 Q
 . . S ICDF=$O(@(ICDG_"""B"","_ICDI_",0)"))
 . . ; If no effective date ICDF for ICDI then use TODAY's text
 . . I '+ICDF S ARY(ICDA)="^"_ICDN,(ICDBI,ICDBA)=1 Q
 . . S ICDST=$P($G(@(ICDG_ICDF_",0)")),"^",2)
 . . ; If Status ICDST not Inactive then use TODAY's text
 . . I ICDST S ARY(ICDA)="^"_ICDN,ICDBI=1 Q
 . . ; Versioned text for inactive date
 . . S ICDV=$$MRST(ICDR,+($G(ARY(0))),ICDI)
 . . S:$L(ICDV) $P(ARY(ICDA),"^",2)=ICDV
 . . S $P(ARY(ICDA),"^")=ICDI
 . . S ICDBI=1,ICDA=ICDI,ICDCA=0
 S (ICDI,ICDC)=0 F  S ICDI=$O(ARY(ICDI)) Q:+ICDI'>0  S ICDC=ICDC+1
 S:ICDC'>0 ARY(0)="-1^0^No activation periods found"
 Q ICDC
MRST(ICD,X,Y) ; Most Recent Description from Date
 N ICDI,ICDT,ICDE,ICDH,ICDR S ICDR=$G(ICD),ICDI=+($G(X)),ICDT=$G(Y)
 Q:'$L(ICDR)!(ICDR'["^")!(ICDR'["(") ""  Q:+ICDI'>0 ""  I ICDT'>0 D  Q X
 . N ICDE,ICDH S ICDE=+($O(@(ICDR_+ICDI_",67,""B"","" "")"),-1))
 . S ICDH=+($O(@(ICDR_+ICDI_",67,""B"","_ICDE_","" "")"),-1))
 . S X=$P($G(@(ICDR_+ICDI_",67,"_ICDH_",0)")),"^",2)
 S ICDE=+($O(@(ICDR_+ICDI_",67,""B"","_+ICDT_")"),-1))
 S ICDH=+($O(@(ICDR_+ICDI_",67,""B"","_ICDE_","" "")"),-1))
 S X=$P($G(@(ICDR_+ICDI_",67,"_ICDH_",0)")),"^",2)
 Q X

ICDEX
ICDEX ;SLC/KER - ICD Extractor - Main Entry Points ;Jan 15, 2019@11:35
 ;;18.0;DRG Grouper;**57,67,OSEHRA**;Oct 20, 2000;Build 1
 ;
 ; *OSEHRA change: add missing QUIT in MD to prevent fallthrough error ,M11,
 ;
 ; Global Variables
 ;    None
 ;
 ; External References
 ;    None
 ;
 ; Parameters for listed APIs
 ;
 ;    ARY     A local array passed by reference .ARY
 ;
 ;    CDT     This is the Code Set Versioning Date (Fileman
 ;            format) and is used to resolve the correct 
 ;            entry of a file or sub-file.
 ;
 ;    EDT     External Date allowed by Fileman
 ;
 ;    CODE    This is an ICD Diagnostic or Procedural code
 ;
 ;    FIELD   This is a field number from either file 80 or 80.1
 ;
 ;    FILE    File Number 80 or 80.1
 ;
 ;    FMT     Input format "I"=Internal "E"=External
 ;
 ;    IEN     Internal Entry Number of file 80 or 80.1
 ;
 ;    IEN1    Internal Entry Number of a specified sub-file
 ;
 ;    IEN2    Internal Entry Number of file 80 or 80.1
 ;
 ;    LEN     Length of the string of text in an array.
 ;            When passed, the short description or long
 ;            description will be parsed into string
 ;            lengths not to exceed the length passed.
 ;
 ;    MDC     Major Diagnostic Category (pointer to 
 ;            file #80.3)
 ;
 ;    NUM     Converts a code to a numeric representation 
 ;            of the code (used on the AN cross-reference)
 ;            for the $$NEXT and $$PREV APIs
 ;
 ;    REV     Directionality flag for $ORDER
 ;
 ;               0    $Order Forwards (default)
 ;               1    $Order in Reverse
 ;
 ;    ROOT    Global Root ^ICD9( or ^ICD0(
 ;
 ;    STD     Coding Standard
 ;
 ;               0    ICD (default)
 ;               1    CPT/HCPCS
 ;               2    DRG
 ;               3    LEX
 ;
 ;    SYS     Coding System
 ;
 ;               1    ICD     ICD-9-CM
 ;               2    ICP     ICD-9-PCS
 ;              30    1OD     ICD-10-CM
 ;              31    10P     ICD-10-PCS
 ;
 ;    TYPE    This is any identifier that can determine the
 ;            type of ICD code (diagnosis or procedure) that
 ;            is being used.  It can be a:
 ;
 ;              File Number           80 or 80.1
 ;              Global Root           ^ICD9( or ^ICD0(
 ;              Source Abbreviation   ICD, ICP, 10D OR 10P
 ;              Coding System         1, 2, 30, 31
 ;              Code                  250.01, B58.81, 50.11
 ;
 ;    TXT     Text String to search for in file 80/80.1
 ;
 ;    VER     Versioning flag
 ;
 ;               0  Unversioned search, return active/inactive codes
 ;               1  Versioned search, return only active codes
 ;
 ;    WORD    This is a single word parsed from a string
 ;
EN ; Main Entry Point
HELP ; Developer Help for an API
 D EN^ICDEXH Q
 ; 
 ; Code APIs
ICDDX(CODE,CDT,SYS,FMT,LOC) ; Dx Code Info
 Q $$ICDDX^ICDEXC($G(CODE),$P($G(CDT),".",1),$G(SYS),$G(FMT),$G(LOC))
ICDOP(CODE,CDT,SYS,FMT,LOC) ; Procedure Code Info
 Q $$ICDOP^ICDEXC($G(CODE),$P($G(CDT),".",1),$G(SYS),$G(FMT),$G(LOC))
ICDD(CODE,ARY,CDT,SYS,LEN) ; Description in Array
 Q $$ICDD^ICDEXC($G(CODE),.ARY,$P($G(CDT),".",1),$G(SYS),+($G(LEN)))
CODEN(CODE,FILE) ; IEN of code
 Q $$CODEN^ICDEXC($G(CODE),$G(FILE))
CODEC(FILE,IEN) ; Code from an IEN
 Q $$CODE^ICDEXC($G(FILE),$G(IEN))
CODEBA(CODE,ROOT) ; IEN from Code/Root
 Q $$CODEBA^ICDEXC($G(CODE),$G(ROOT))
CODEABA(CODE,ROOT,SYS) ; IEN from Code/Root/Coding System
 Q $$CODEABA^ICDEXC($G(CODE),$G(ROOT),$G(SYS))
RDX(CODE,CDT) ; Resolve Diagnosis Code Fragment
 Q $$RDX^ICDEXC4($G(CODE),$G(CDT))
 ;  
 ; Code APIs (code data/versioned data)
CODEFI(CODE) ; File for code
 Q $$CODEFI^ICDEXC2($G(CODE))
CODECS(CODE,FILE,CDT) ; Coding system for code/file
 Q $$CODECS^ICDEXC2($G(CODE),$G(FILE),$P($G(CDT),".",1))
CSI(FILE,IEN) ; Coding system for IEN
 Q $$CSI^ICDEXC2($G(FILE),$G(IEN))
VMDC(IEN,CDT,FMT) ; Major Diagnostic Category
 Q $$VMDC^ICDEXC2($G(IEN),$P($G(CDT),".",1),$G(FMT))
VAGEL(IEN,CDT,FMT) ; Age Low
 Q $$VAGEL^ICDEXC2($G(IEN),$P($G(CDT),".",1),$G(FMT))
VAGEH(IEN,CDT,FMT) ; Age High
 Q $$VAGEH^ICDEXC2($G(IEN),$P($G(CDT),".",1),$G(FMT))
VCC(IEN,CDT,FMT) ; Complication/Comorbidity
 Q $$VCC^ICDEXC2($G(IEN),$P($G(CDT),".",1),$G(FMT))
VCCP(IEN,CDT,FMT) ; CC Primary Flag
 Q $$VCCP^ICDEXC2($G(IEN),$P($G(CDT),".",1),$G(FMT))
VSEX(FILE,IEN,CDT,FMT) ; Sex for file
 Q $$VSEX^ICDEXC2($G(FILE),$G(IEN),$P($G(CDT),".",1),$G(FMT))
SAI(FILE,IEN,CDT) ; Status/Active/Inactive Dates
 Q $$SAI^ICDEXC2($G(FILE),$G(IEN),$P($G(CDT),".",1))
 ;  
 ; Code APIs (text/strings)
VST(FILE,IEN,CDT)     ; Short Text
 Q $$VST^ICDEXC3($G(FILE),$G(IEN),$P($G(CDT),".",1))
VLT(FILE,IEN,CDT) ; Long Text
 Q $$VLT^ICDEXC3($G(FILE),$G(IEN),$P($G(CDT),".",1))
VSTD(IEN,CDT)  ; Short Text - Diagnosis
 Q $$VSTD^ICDEXC3($G(IEN),$P($G(CDT),".",1))
VSTP(IEN,CDT) ; Short Text - Procedures
 Q $$VSTP^ICDEXC3($G(IEN),$P($G(CDT),".",1))
VLTD(IEN,CDT) ; Description - Diagnosis
 Q $$VLTD^ICDEXC3($G(IEN),$P($G(CDT),".",1))
VLTP(IEN,CDT) ; Description - Procedures
 Q $$VLTP^ICDEXC3($G(IEN),$P($G(CDT),".",1))
SD(FILE,IEN,CDT,ARY,LEN) ; Short Description (formatted)
 Q $$SD^ICDEXC3($G(FILE),$G(IEN),$P($G(CDT),".",1),.ARY,$G(LEN))
LD(FILE,IEN,CDT,ARY,LEN) ; Long Description (formatted)
 Q $$LD^ICDEXC3($G(FILE),$G(IEN),$P($G(CDT),".",1),.ARY,$G(LEN))
SDH(FILE,IEN,ARY) ; Short Description History
 Q $$SDH^ICDEXC4($G(FILE),$G(IEN),.ARY)
LDH(FILE,IEN,ARY) ; Long Description History
 Q $$LDH^ICDEXC4($G(FILE),$G(IEN),.ARY)
PAR(ARY,LEN) ; Parse Array
 D PAR^ICDEXC3(.ARY,$G(LEN)) Q
IEN(CODE,ROOT,SYS) ; IEN from Code/Root/Coding System
 Q $$IEN^ICDEXC3($G(CODE),$G(ROOT),$G(SYS))
 ;  
 ; API Support
STATCHK(CODE,CDT,SYS) ; Status of ICD Code
 Q $$STATCHK^ICDEXA($G(CODE),$P($G(CDT),".",1),$G(SYS))
DTBR(CDT,STD,SYS) ; Date Business Rules
 Q $$DTBR^ICDEXA($P($G(CDT),".",1),$G(STD),$G(SYS))
IMP(SYS,CDT) ; Implementation Date
 Q $$IMP^ICDEXA($G(SYS),$P($G(CDT),".",1))
MSG(CDT,STD,SYS) ; Warning Message
 Q $$MSG^ICDEXA($P($G(CDT),".",1),$G(STD),$G(SYS))
SEL(FILE,IEN) ; Entry is Selectable
 Q $$SEL^ICDEXA($G(FILE),$G(IEN))
NEXT(CODE,SYS,CDT) ; Next Code
 Q $$NEXT^ICDEXA2($G(CODE),$G(SYS),$P($G(CDT),".",1))
PREV(CODE,SYS,CDT) ; Previous Code
 Q $$PREV^ICDEXA2($G(CODE),$G(SYS),$P($G(CDT),".",1))
HIST(CODE,ARY,SYS) ; Activation History
 Q $$HIST^ICDEXA2($G(CODE),.ARY,$G(SYS))
PERIOD(CODE,ARY,SYS) ; Activation Periods
 Q $$PERIOD^ICDEXA2($G(CODE),.ARY,$G(SYS))
OBA(FILE,CODE,SYS,REV) ; $Order BA/ABA
 Q $$OBA^ICDEXA3($G(FILE),$G(CODE),$G(SYS),$G(REV))
OD(FILE,WORD,SYS,REV) ; $Order D/AD
 Q $$OD^ICDEXA3($G(FILE),$G(WORD),$G(SYS),$G(REV))
DLM(FILE,IEN,FIELD,CDT) ; Date Last Modified
 Q $$DLM^ICDEXA3($G(FILE),$G(IEN),$G(FIELD),$P($G(CDT),".",1))
CS(FILE,FMT,CDT) ; Select Coding System (lookup)
 Q $$CS^ICDEXA3($G(FILE),$G(FMT),$P($G(CDT),".",1))
 ;  
 ; Data Extraction Support
EFF(FILE,IEN,CDT) ; Effective date and status
 Q $$EFF^ICDEXS($G(FILE),$G(IEN),$P($G(CDT),".",1))
IA(FILE,IEN) ; Initial Activation Date
 Q $$IA^ICDEXS($G(FILE),$G(IEN))
LA(FILE,IEN,CDT) ; Last Activation Date
 Q $$LA^ICDEXS($G(FILE),$G(IEN),$P($G(CDT),".",1))
LI(FILE,IEN,CDT) ; Last Inactivation Date
 Q $$LI^ICDEXS($G(FILE),$G(IEN),$P($G(CDT),".",1))
LS(FILE,IEN,CDT,FMT) ; Last Status
 Q $$LS^ICDEXS($G(FILE),$G(IEN),$P($G(CDT),".",1),$G(FMT))
NUM(CODE) ; Convert Code to a Numeric
 Q $$NUM^ICDEXS($G(CODE))
COD(NUM) ; Convert Numeric to a Code
 Q $$COD^ICDEXS($G(NUM))
IE(CODE) ; Internal or External Format
 Q $$IE^ICDEXS($G(CODE))
FILE(SYS) ; File Number from System
 Q $$FILE^ICDEXS($G(SYS))
ROOT(SYS) ; Global Root
 Q $$ROOT^ICDEXS($G(SYS))
SYS(SYS,CDT,FMT) ; Resolve System (uses file 80.4)
 Q $$SYS^ICDEXS($G(SYS),$P($G(CDT),".",1),$G(FMT))
SINFO(SYS,CDT) ; System Info (uses file 80.4)
 Q $$SINFO^ICDEXS($G(SYS),$P($G(CDT),".",1))
SNAM(SYS) ; System Name from Coding System
 Q $$SNAM^ICDEXS($G(SYS))
SAB(SYS,CDT) ; Source Abbreviation
 Q $$SAB^ICDEXS($G(SYS),$P($G(CDT),".",1))
EXC(FILE,IEN) ; Exclude From lookup
 Q $$EXC^ICDEXS($G(FILE),$G(IEN))
VER(SYS,REL) ; Coding System Version
 Q $$VER^ICDEXS2($G(SYS),$G(REL))
HDR(FILE) ; File Header Node
 Q $$HDR^ICDEXS2($G(FILE))
 ;  
 ; DRG Grouper Extraction Support
ISA(IEN1,IEN2,FIELD) ; Is Code 1 a condition of Code 2 (ICDDRG)
 Q $$ISA^ICDEXD($G(IEN1),$G(IEN2),$G(FIELD))
ISVALID(FILE,IEN,CDT) ; Is an ICD code Valid
 Q $$ISVALID^ICDEXD2($G(FILE),$G(IEN),$G(CDT))
EXIST(IEN,FIELD) ; Does a condition Exist (ICDDRGX)
 Q $$EXIST^ICDEXD($G(IEN),$G(FIELD))
GETDRG(FILE,IEN,CDT,MDC) ; DRGs for an Fiscal Year (ICDGTDRG)
 Q $$GETDRG^ICDEXD($G(FILE),$G(IEN),$P($G(CDT),".",1),$G(MDC))
MD(FILE,IEN,CDT,ARY,FLAG) ; MDC DRGs
 D MD^ICDEXD2($G(FILE),$G(IEN),$P($G(CDT),".",1),.ARY,$G(FLAG)) Q  ; *OSEHRA add Q
EFM(EDT) ; Convert External Date to FM (ICDGTDRG)
 Q $$EFM^ICDEXD6($G(EDT))
FY(CDT) ; FY 4 digit year (ICDGTDRG)
 Q $$FY^ICDEXD6($P($G(CDT),".",1))
VMDCDX(IEN,CDT) ; Versioned MDC for DX (ICDREF)
 Q $$VMDCDX^ICDEXD2($G(IEN),$P($G(CDT),".",1))
VMDCOP(IEN,MDC,CDT) ; Versioned MDC for Op/Pro (ICDREF)
 Q $$VMDCOP^ICDEXD2($G(IEN),$G(MDC),$P($G(CDT),".",1))
REF(IEN,CDT) ; Return Reference Table (ICDREF)
 Q $$REF^ICDEXD2($G(IEN),$G(CDT))
MDCG(IEN,CDT,ARY) ; Set up array of MDCs (ICDDRG)
 D MDCG^ICDEXD2($G(IEN),$P($G(CDT),".",1),.ARY) Q
MDCT(IEN,CDT,ARY,FMT) ; For Multiple MDC DX Codes (ICDDRG)
 Q $$MDCT^ICDEXD2($G(IEN),$P($G(CDT),".",1),.ARY,$G(FMT))
MDCD(IEN,MDC,CDT) ; Check for default MDC (ICDDRG)
 Q $$MDCD^ICDEXD2($G(IEN),$G(MDC),$G(CDT))
MDCN(IEN) ; Major Diagnostic Category Name
 Q $$MDCN^ICDEXD2(+($G(IEN)))
MOR(IEN) ; Major O.R. Procedure (ICDDRG)
 Q $$MOR^ICDEXD2($G(IEN))
UPDX(IEN) ; Unacceptable as Principle DX
 Q $$UPDX^ICDEXD6($G(IEN))
POAE(IEN) ; Present on Admission Exempt
 Q $$POAE^ICDEXD6($G(IEN))
HAC(IEN) ; Hospital Acquired Conditions
 Q $$HAC^ICDEXD6($G(IEN))
NOT(IEN,SUB,FMT) ; Codes not Used With
 Q $$NOT^ICDEXD3($G(IEN),$G(SUB),$G(FMT))
REQ(IEN,SUB,FMT) ; Codes Required With
 Q $$REQ^ICDEXD3($G(IEN),$G(SUB),$G(FMT))
NCC(IEN,SUB,FMT) ; Codes not Considered CC With
 Q $$NCC^ICDEXD3($G(IEN),$G(SUB),$G(FMT))
ICDID(FILE,ID,CODE) ; Check if ICD identifier exist
 Q $$ICDID^ICDEXD4($G(FILE),$G(ID),$G(CODE))
IDSTR(FILE,IEN) ; ICD identifier string (legacy)
 Q $$IDSTR^ICDEXD4($G(FILE),$G(IEN))
ICDIDS(FILE,IEN,ARY) ; Returns array of ICD identifiers
 Q $$ICDIDS^ICDEXD4($G(FILE),$G(IEN),.ARY)
ISOWNCC(IEN,CDT,FMT) ; Return CC if DX is Own CC
 Q $$ISOWNCC^ICDEXD4($G(IEN),$G(CDT),$G(FMT))
ICDRGCC(DRG,CDT) ; Get CC/MCC flag from DRG
 Q $$ICDRGCC^ICDEXD4($G(DRG),$G(CDT))
INQ ; Inquire to the ICD Files
 D INQ^ICDEXD4 Q
EFD(X) ; Get Effective date in range (interactive)
 Q $$EFD^ICDEXD6
PDXE(IEN) ; Primary DX Exclusion Code
 Q $$PDXE^ICDEXD3($G(IEN))
DRG(CODE,CDT) ; Returns information about a DRG
 Q $$DRG^ICDEXD5($G(CODE),$G(CDT))
DRGW(IEN) ; DRG Weighted Work Unit (WWU)
 Q $$DRGW^ICDEXD6($G(IEN))
DRGDES(IEN,CDT,ARY,LEN) ; Formatted DRG Description
 Q $$DRGDES^ICDEXD5($G(IEN),$G(CDT),.ARY,$G(LEN))
DRGD(CODE,OUTARR,CDT) ; Unformatted DRG Description
 Q $$DRGD^ICDEXD5($G(CODE),$G(OUTARR),$G(CDT))
DRGN(CODE) ; Return the IEN of DRG
 Q $$DRGN^ICDEXD6($G(CODE))
DRGC(IEN) ; DRG Code
 Q $$DRGC^ICDEXD6($G(IEN))
GETDATE(IEN) ; Calculate Effective Date
 Q $$GETDATE^ICDEXD5($G(IEN))
 ;  
 ; Lookup
LK ; Special Lookup (called by DIC)
 D LK^ICDEXLK Q
LKTX(X,ROOT,CDT,SYS,VER,OUT) ; Lookup Text in ROOT (silent)
 Q $$LK^ICDEXLK3($G(X),$G(ROOT),$P($G(CDT),".",1),$G(SYS),$G(VER),$G(OUT))
Y(ROOT,IEN,CDT,FMT) ; Output Variable Y from Lookup
 D Y^ICDEXLK2($G(ROOT),$G(IEN),$P($G(CDT),".",1),$G(FMT)) Q
TOKEN(X,ROOT,SYS,ARY) ; Parse Text into Words
 D TOKEN^ICDTOKN($G(X),$G(ROOT),$G(SYS),.ARY) Q
WORD(X,ROOT,SYS) ; Word is Found
 Q $$WORD^ICDEXLK3($G(X),$G(ROOT),$G(SYS))

MPIFXMLP
MPIFXMLP ;OAK/ELZ - MPIF PROBLISTIC SEARCH ;2019-05-09  11:10 AM
 ;;1.0;MASTER PATIENT INDEX VISTA;**61,67,OSEHRA**;30 Apr 99;Build 3
 ;
 ; *OSEHRA changes by Sam Habiel (c) 2018.
 ; To test: DG REGISTER PATIENT; there should be no MPI lookup.
 ;
ZPATIENT(RETURN,MPIARR) ; - query for patients based on traits *OSEHRA rename PATIENT -> ZPATIENT to prevent MPI lookup
 ;  MPIARR("")=""
 ;
 ;
 N MPIXML,MPIXMLR,MPID,MPIPAT
 K RETURN
 S MPIXML=$$XMLBLD(.MPIARR)
 D POST^MPIFHWSC(MPIXML,.MPIXMLR)
 I '$D(MPIXMLR) S RETURN="-1^Query to Person Search returned nothing." Q
 D PARSE(.RETURN,.MPIXMLR)
 ;
 ; convert dob to fm format
 ; Story 722746 need DOD formatted as well if there is one
 S MPIPAT=0 F  S MPIPAT=$O(RETURN(MPIPAT)) Q:'MPIPAT  S:$D(RETURN(MPIPAT,"DOD")) RETURN(MPIPAT,"DOD")=$$HL7TFM^XLFDT(RETURN(MPIPAT,"DOD")) I $D(RETURN(MPIPAT,"DOB")) S RETURN(MPIPAT,"DOB")=$$HL7TFM^XLFDT(RETURN(MPIPAT,"DOB"))
 ;
 ;
 Q
 ;
XMLBLD(MPIARR) ; setup xml to search
 ; MPIARR - Array of traits for seach
 ;    Returns XML for the search
 ;
 ; $$SITE^VASITE - #10112
 ;
 N MPIXML,MPISITE,QUOTE,MPITHRES,MPIDT,MPIDUZ,MPIPRID
 S QUOTE=""""
 S MPISITE=$P($$SITE^VASITE,"^",3)
 S MPIPRID=$P($$PARAM^HLCS2,"^",3)
 S MPIDT=$$FMTHL7^XLFDT($$NOW^XLFDT)
 S MPIDUZ=$P(^VA(200,DUZ,0),"^") D STDNAME^XLFNAME(.MPIDUZ,"C")
 S MPITHRES=80
 ;
 ; heading
 S MPIXML="<IDM_REQUEST type="_QUOTE_"SEARCH_PROFILE"_QUOTE_"><METADATA>"
 S MPIXML=MPIXML_"<FIELD name="_QUOTE_"SENDINGFACILITY"_QUOTE_" value="
 S MPIXML=MPIXML_QUOTE_MPISITE_QUOTE_"/><FIELD name="_QUOTE_"matchType"
 S MPIXML=MPIXML_QUOTE_" value="_QUOTE_"VISTA_REG"_QUOTE_"/><FIELD name="
 S MPIXML=MPIXML_QUOTE_"returnMax"_QUOTE_" value="_QUOTE_"100"_QUOTE_"/>"
 S MPIXML=MPIXML_"<FIELD name="_QUOTE_"algorithm"_QUOTE_" value="_QUOTE
 S MPIXML=MPIXML_"PROB"_QUOTE_"/><FIELD name="_QUOTE_"minScore"_QUOTE
 S MPIXML=MPIXML_" value="_QUOTE_MPITHRES_QUOTE_"/><FIELD name="_QUOTE
 S MPIXML=MPIXML_"scopingOrganization"_QUOTE_" value="_QUOTE_"VA_DOD"
 S MPIXML=MPIXML_QUOTE_"/><FIELD name="_QUOTE_"versionCode"_QUOTE
 S MPIXML=MPIXML_" value="_QUOTE_"3.0"_QUOTE_"/><FIELD name="_QUOTE
 S MPIXML=MPIXML_"sendingApplicationName"_QUOTE_" value="_QUOTE
 S MPIXML=MPIXML_"VISTA_REG"_QUOTE_"/><FIELD name="_QUOTE_"PROCESSINGID"
 S MPIXML=MPIXML_QUOTE_" value="_QUOTE_MPIPRID_QUOTE_"/></METADATA>"
 S MPIXML=MPIXML_"<ARGUMENTS><ARGUMENT name="_QUOTE
 S MPIXML=MPIXML_"searchProfile"_QUOTE_"><IDMHEADER>"
 S MPIXML=MPIXML_"<SENDING_APP>VISTA_REG</SENDING_APP><MSG_DATE_TIME>"
 S MPIXML=MPIXML_MPIDT_"</MSG_DATE_TIME><MSG_CONTROL_ID>"_$J
 S MPIXML=MPIXML_"</MSG_CONTROL_ID><PROCESSING_ID>"_MPIPRID
 S MPIXML=MPIXML_"</PROCESSING_ID><TRIGGER><EVENT>Local Client</EVENT>"
 S MPIXML=MPIXML_"<ACTOR>"_DUZ_"~PN~"_MPISITE_"~USVHA^"
 S MPIXML=MPIXML_$G(MPIDUZ("FAMILY"))_"^"_$G(MPIDUZ("GIVEN"))_"</ACTOR>"
 S MPIXML=MPIXML_"<DATETIME>"_MPIDT_"</DATETIME><SOURCE>VISTA</SOURCE>"
 S MPIXML=MPIXML_"</TRIGGER></IDMHEADER><PROFILE>"
 ;
 ; name traits
 S MPIXML=MPIXML_"<NAME type="_QUOTE_"L"_QUOTE_">"
 D IFADD("FirstName",.MPIARR,.MPIXML,"FIRSTNAME")
 D IFADD("MiddleName",.MPIARR,.MPIXML,"MIDDLENAME")
 D IFADD("Suffix",.MPIARR,.MPIXML,"SUFFIX")
 D IFADD("Surname",.MPIARR,.MPIXML,"LASTNAME")
 S MPIXML=MPIXML_"</NAME>"
 ;
 ; other traits
 I $G(MPIARR("SSN"))'="" D
 . S MPIXML=MPIXML_"<IDENTIFIER type="_QUOTE_"SS"_QUOTE_" subtype="
 . S MPIXML=MPIXML_QUOTE_"ACTIVE"_QUOTE_"><ID>"_MPIARR("SSN")
 . S MPIXML=MPIXML_"</ID></IDENTIFIER>"
 I $G(MPIARR("DOB"))'="" D
 . S MPIXML=MPIXML_"<ATTRIBUTE type="_QUOTE_"DOB"_QUOTE_"><VALUE>"
 . S MPIXML=MPIXML_$$FMTHL7^XLFDT(MPIARR("DOB"))_"</VALUE></ATTRIBUTE>"
 I $G(MPIARR("Gender"))'="" D
 . S MPIXML=MPIXML_"<ATTRIBUTE type="_QUOTE_"GENDER"_QUOTE_">"
 . S MPIXML=MPIXML_"<VALUE>"_MPIARR("Gender")_"</VALUE></ATTRIBUTE>"
 I $G(MPIARR("MMN"))'="" D
 . S MPIXML=MPIXML_"<ATTRIBUTE type="_QUOTE_"MMN"_QUOTE_">"
 . S MPIXML=MPIXML_"<VALUE>"_MPIARR("MMN")_"</VALUE></ATTRIBUTE>"
 I $G(MPIARR("MBI"))'="" D
 . S MPIXML=MPIXML_"<ATTRIBUTE type="_QUOTE_"MULTIBIRTH"_QUOTE_">"
 . S MPIXML=MPIXML_"<VALUE>"_MPIARR("MBI")_"</VALUE></ATTRIBUTE>"
 ;
 ;POB stuff
 S MPIARR("MPIVar")=$$CONV($G(MPIARR("POBCity")))
 I MPIARR("MPIVar")'=""!($G(MPIARR("POBState"))'="") D
 . S MPIXML=MPIXML_"<ADDRESS type="_QUOTE_"N"_QUOTE_">"
 . D IFADD("MPIVar",.MPIARR,.MPIXML,"CITY")
 . D IFADD("POBState",.MPIARR,.MPIXML,"STATE")
 . S MPIXML=MPIXML_"</ADDRESS>"
 ;
 ;address stuff
 I $G(MPIARR("ResAddL1"))'=""!($G(MPIARR("ResAddL2"))'="")!($G(MPIARR("ResAddCity"))'="")!($G(MPIARR("ResAddZip4"))'="")!($G(MPIARR("ResAddL3"))'="")!($G(MPIARR("ResAddState"))'="") D
 . S MPIXML=MPIXML_"<ADDRESS type="_QUOTE_"P"_QUOTE_">"
 . S MPIARR("MPIVar")=$$CONV($G(MPIARR("ResAddL1")))
 . D IFADD("MPIVar",.MPIARR,.MPIXML,"STREET1")
 . S MPIARR("MPIVar")=$$CONV($G(MPIARR("ResAddL2")))
 . D IFADD("MPIVar",.MPIARR,.MPIXML,"STREET2")
 . S MPIARR("MPIVar")=$$CONV($G(MPIARR("ResAddL3")))
 . D IFADD("MPIVar",.MPIARR,.MPIXML,"STREET3")
 . S MPIARR("MPIVar")=$$CONV($G(MPIARR("ResAddCity")))
 . D IFADD("MPIVar",.MPIARR,.MPIXML,"CITY")
 . D IFADD("ResAddState",.MPIARR,.MPIXML,"STATE")
 . D IFADD("ResAddZip4",.MPIARR,.MPIXML,"ZIPCODE")
 . D IFADD("ResAddProvince",.MPIARR,.MPIXML,"PROVINCECODE")
 . D IFADD("ResAddPCode",.MPIARR,.MPIXML,"POSTALCODE")
 . D IFADD("ResAddCountry",.MPIARR,.MPIXML,"COUNTRY")
 . S MPIXML=MPIXML_"</ADDRESS>"
 ;
 ; phone
 I $G(MPIARR("ResPhone"))'=""&($G(MPIARR("ResPhone"))'["""") D
 . S MPIARR("MPIVar")=$$CONV($G(MPIARR("ResPhone")))
 . I MPIARR("MPIVar")'="" D
 .. S MPIXML=MPIXML_"<PHONE type="_QUOTE_"HOME"_QUOTE_"><NUMBER>"
 .. S MPIXML=MPIXML_MPIARR("MPIVar")_"</NUMBER></PHONE>"
 ;
 ; dod
 I $G(MPIARR("DOD"))'="" D
 . S MPIXML=MPIXML_"<ATTRIBUTE type="_QUOTE_"DOD"_QUOTE_"><VALUE>"
 . S MPIXML=MPIXML_$$FMTHL7^XLFDT(MPIARR("DOD"))_"</VALUE></ATTRIBUTE>"
 ;
 ; end data
 S MPIXML=MPIXML_"</PROFILE></ARGUMENT></ARGUMENTS></IDM_REQUEST>"
 K MPIARR("MPIVar")
 Q MPIXML
 ;
IFADD(MPIVAR,MPIARR,MPIXML,MPIXMLN) ;check if there, if so add it to the XML
 ; MPIVAR is the MPIARR variable name
 ; MPIXMLN is the name of the XML to encase
 ; modifies MPIXML to add if it is there
 I $G(MPIARR(MPIVAR))'="" D
 . S MPIXML=MPIXML_"<"_MPIXMLN_">"_MPIARR(MPIVAR)_"</"_MPIXMLN_">"
 Q
 ;
CONV(FIELD) ;check for &, ', > and <
 I FIELD["&" S FIELD=$P(FIELD,"&")_"&amp;"_$P(FIELD,"&",2)
 I FIELD["'" S FIELD=$P(FIELD,"'")_"&apos;"_$P(FIELD,"'",2)
 S:(FIELD["<") FIELD=$$CONVA(FIELD,"<")
 S:(FIELD[">") FIELD=$$CONVA(FIELD,">")
 Q FIELD
 ;
CONVA(FIELD,ENCHAR) ;handle <<pob city>>
 N I,X,VAL
 S VAL="",I=$L(FIELD,ENCHAR) F X=1:1:I S VAL=VAL_$P(FIELD,ENCHAR,X)
 Q VAL
 ;
PARSE(MPIDATA,MPIXML) ; - parse the data
 ;
 ; EN^MXMLPRSE - #4149
 ;
 K ^TMP($J,"MPIFXMLP")
 N MPICB,MPIUSE,MPIVAR,MPIPAT,MPIALIAS,MPILOC,MPIIDS
 S (MPIPAT,MPIIDS)=0
 S MPICB("STARTELEMENT")="SE^MPIFXMLP"
 S MPICB("CHARACTERS")="VALUE^MPIFXMLP"
 S ^TMP($J,"MPIFXMLP",1)=MPIXML
 D EN^MXMLPRSE($NA(^TMP($J,"MPIFXMLP")),.MPICB)
 K ^TMP($J,"MPIFXMLP")
 Q
 ;
SE(MPIN,MPIA) ; - used for the parser to call back with STARTELEMENT
 ;
 ; just to protect the process
 S MPIN=$G(MPIN)
 S MPIA("type")=$G(MPIA("type"))
 S MPIA("subtype")=$G(MPIA("subtype"))
 S MPIA("name")=$G(MPIA("name"))
 S MPIA("value")=$G(MPIA("value"))
 ; my variable to protect
 S MPIUSE=$G(MPIUSE)
 ;
 ; got a business rule error
 I MPIN="RESULT",MPIA("type")="AA",MPIA("subtype")="QE" S MPIDATA("Result")="QE" Q
 ; don't use these
 I MPIN="IDM_RESPONSE"!(MPIN="METADATA")!(MPIN="IDATTR") Q
 I MPIN="RESULT"!(MPIN="ISSUER")!(MPIN="STATUS") Q
 I MPIN="EFFECTIVE"!(MPIN="BADADDRESSCODE")!(MPIN="BADADDRESSTEXT") Q
 I MPIN="IDATTR",MPIA("type")="PSEUDO_SSN",MPIA("subtype")="CODE" Q
 I MPIN="ASSOC",MPIA("type")="ALIAS_SSN" Q
 ;
 ; save some field data
 I MPIN="FIELD" S:MPIA("name")]"" MPIDATA(MPIA("name"))=MPIA("value") Q
 ;
 I MPIN="PROFILE" S MPIPAT=MPIPAT+1,MPIALIAS=0,MPILOC="MPIDATA("_MPIPAT Q
 I MPIN="NAME" D  Q
 . S MPIUSE=MPIA("type")
 . S:MPIUSE="A" MPIALIAS=MPIALIAS+1
 I MPIN="FIRSTNAME",MPIUSE="L" S MPIVAR=",""FirstName"")" Q
 I MPIN="LASTNAME",MPIUSE="L" S MPIVAR=",""Surname"")" Q
 I MPIN="MIDDLENAME",MPIUSE="L" S MPIVAR=",""MiddleName"")" Q
 I MPIN="SUFFIX",MPIUSE="L" S MPIVAR=",""Suffix"")" Q
 I MPIN="PREFIX",MPIUSE="L" S MPIVAR=",""Prefix"")" Q
 I MPIN="FIRSTNAME",MPIUSE="A" S MPIVAR=",""ALIAS"","_MPIALIAS_",""FirstName"")" Q
 I MPIN="LASTNAME",MPIUSE="A" S MPIVAR=",""ALIAS"","_MPIALIAS_",""Surname"")" Q
 I MPIN="MIDDLENAME",MPIUSE="A" S MPIVAR=",""ALIAS"","_MPIALIAS_",""MiddleName"")" Q
 I MPIN="SUFFIX",MPIUSE="A" S MPIVAR=",""ALIAS"","_MPIALIAS_",""Suffix"")" Q
 I MPIN="PREFIX",MPIUSE="A" S MPIVAR=",""ALIAS"","_MPIALIAS_",""Prefix"")" Q
 I MPIN="IDENTIFIER" D  Q
 . I MPIA("type")="SS",MPIA("subtype")="ALIAS" S MPIUSE="ALIASSSN" Q
 . I MPIA("type")="SS" S MPIUSE="SSN" Q
 . I MPIA("type")="NI",MPIA("subtype")="IDM" S MPIUSE="ICN" Q
 . I MPIA("type")="NI",MPIA("subtype")="" S MPIIDS=MPIIDS+1,MPIUSE="IDS" Q
 I MPIN="ID" D  Q
 . I MPIUSE="ALIASSSN" S MPIVAR=",""ALIAS"","_MPIALIAS_",""SSN"")" Q
 . I MPIUSE="SSN" S MPIVAR=",""SSN"")" K MPIUSE Q
 . I MPIUSE="ICN" S MPIVAR=",""ICN"")" K MPIUSE Q
 . I MPIUSE="EDIPI" S MPIVAR=",""EDIPI"")" K MPIUSE Q
 . I MPIUSE="IDS" S MPIVAR=",""IDS"","_MPIIDS_",""ID"")" Q
 I MPIN="SOURCE" S MPIVAR=",""IDS"","_MPIIDS_",""SOURCE"")" Q
 I MPIN="ATTRIBUTE" D  Q
 . I MPIA("type")="SCORE" S MPIUSE="Score" Q
 . I MPIA("type")="MMN" S MPIUSE="MMN" Q
 . I MPIA("type")="DOB" S MPIUSE="DOB" Q
 . I MPIA("type")="GENDER" S MPIUSE="Gender" Q
 . ; Story 722746 (elz) need DOD if there is one
 . I MPIA("type")="DEATHDATE" S MPIUSE="DOD" Q
 I MPIN="VALUE" D  K MPIUSE Q
 . I $L(MPIUSE) S MPIVAR=","""_MPIUSE_""")"
 I MPIN="ADDRESS" D  Q
 . I MPIA("type")="N" S MPIUSE="POB"
 . I MPIA("type")="P" S MPIUSE="ResAdd"
 . I MPIA("type")="BA" S MPIUSE="BA"
 I MPIN="CITY" S MPIVAR=","""_MPIUSE_"City"")" Q
 I MPIN="STATE" S MPIVAR=","""_MPIUSE_"State"")" Q
 I MPIN="PROVINCECODE" S MPIVAR=","""_MPIUSE_"Province"")" Q
 I MPIN="COUNTRY" S MPIVAR=","""_MPIUSE_"Country"")" Q
 I MPIN="PHONE",MPIA("type")="Home" S MPIUSE="ResPhone" Q
 I MPIN="NUMBER" S MPIVAR=","""_MPIUSE_""")" Q
 I MPIN="STREET1" S MPIVAR=","""_MPIUSE_"L1"")" Q
 I MPIN="STREET2" S MPIVAR=","""_MPIUSE_"L2"")" Q
 I MPIN="STREET3" S MPIVAR=","""_MPIUSE_"L3"")" Q
 I MPIN="ZIPCODE" S MPIVAR=","""_MPIUSE_"Zip4"")" Q
 I MPIN="POSTALCODE" S MPIVAR=","""_MPIUSE_"PCode"")" Q
 ;
 Q
 ;
VALUE(MPIT) ; - used by the parser to call back with CHARACTERS
 S:$D(MPIVAR) @(MPILOC_MPIVAR)=MPIT K MPIVAR Q
 Q



