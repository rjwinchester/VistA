KIDS Distribution saved on Dec 16, 2015@10:13:18
Updated version supporting coverage analysis in Cache systems.
**KIDS**:MASH*1.3*0^

**INSTALL NAME**
MASH*1.3*0
"BLD",9546,0)
MASH*1.3*0^MASH UTILITIES^0^3151216^n
"BLD",9546,1,0)
^^5^5^3151216^
"BLD",9546,1,1,0)
Updated version of the open source M Advanced Shell (MASH) package.  
"BLD",9546,1,2,0)
This version includes the M-Unit testing functionality and adds 
"BLD",9546,1,3,0)
the capability of performing coverage analysis in Intersystems Cache 
"BLD",9546,1,4,0)
systems to the previous ability to perform such analyses in GT.M 
"BLD",9546,1,5,0)
systems.
"BLD",9546,4,0)
^9.64PA^17.9001^1
"BLD",9546,4,17.9001,0)
17.9001
"BLD",9546,4,17.9001,222)
y^y^f^^n^^y^m^n
"BLD",9546,4,"B",17.9001,17.9001)

"BLD",9546,6.3)
4
"BLD",9546,"INI")
ZZUTPRE
"BLD",9546,"INID")
^n^n
"BLD",9546,"INIT")
ZZUTPOST
"BLD",9546,"KRN",0)
^9.67PA^779.2^20
"BLD",9546,"KRN",.4,0)
.4
"BLD",9546,"KRN",.401,0)
.401
"BLD",9546,"KRN",.402,0)
.402
"BLD",9546,"KRN",.403,0)
.403
"BLD",9546,"KRN",.5,0)
.5
"BLD",9546,"KRN",.84,0)
.84
"BLD",9546,"KRN",3.6,0)
3.6
"BLD",9546,"KRN",3.8,0)
3.8
"BLD",9546,"KRN",9.2,0)
9.2
"BLD",9546,"KRN",9.8,0)
9.8
"BLD",9546,"KRN",9.8,"NM",0)
^9.68A^10^10
"BLD",9546,"KRN",9.8,"NM",1,0)
ut^^0^B230412209
"BLD",9546,"KRN",9.8,"NM",2,0)
ut1^^0^B226313375
"BLD",9546,"KRN",9.8,"NM",3,0)
utcover^^0^B52893402
"BLD",9546,"KRN",9.8,"NM",4,0)
utt1^^0^B39370749
"BLD",9546,"KRN",9.8,"NM",5,0)
utt2^^0^B501728
"BLD",9546,"KRN",9.8,"NM",6,0)
utt3^^0^B1628564
"BLD",9546,"KRN",9.8,"NM",7,0)
utt4^^0^B1568129
"BLD",9546,"KRN",9.8,"NM",8,0)
utt5^^0^B23054235
"BLD",9546,"KRN",9.8,"NM",9,0)
utt6^^0^B39118749
"BLD",9546,"KRN",9.8,"NM",10,0)
uttcovr^^0^B186023122
"BLD",9546,"KRN",9.8,"NM","B","ut",1)

"BLD",9546,"KRN",9.8,"NM","B","ut1",2)

"BLD",9546,"KRN",9.8,"NM","B","utcover",3)

"BLD",9546,"KRN",9.8,"NM","B","utt1",4)

"BLD",9546,"KRN",9.8,"NM","B","utt2",5)

"BLD",9546,"KRN",9.8,"NM","B","utt3",6)

"BLD",9546,"KRN",9.8,"NM","B","utt4",7)

"BLD",9546,"KRN",9.8,"NM","B","utt5",8)

"BLD",9546,"KRN",9.8,"NM","B","utt6",9)

"BLD",9546,"KRN",9.8,"NM","B","uttcovr",10)

"BLD",9546,"KRN",19,0)
19
"BLD",9546,"KRN",19,"NM",0)
^9.68A^3^3
"BLD",9546,"KRN",19,"NM",1,0)
utMUNIT^^0
"BLD",9546,"KRN",19,"NM",2,0)
utMUNIT GROUP EDIT^^0
"BLD",9546,"KRN",19,"NM",3,0)
utMUNIT GROUP RUN^^0
"BLD",9546,"KRN",19,"NM","B","utMUNIT",1)

"BLD",9546,"KRN",19,"NM","B","utMUNIT GROUP EDIT",2)

"BLD",9546,"KRN",19,"NM","B","utMUNIT GROUP RUN",3)

"BLD",9546,"KRN",19.1,0)
19.1
"BLD",9546,"KRN",101,0)
101
"BLD",9546,"KRN",409.61,0)
409.61
"BLD",9546,"KRN",771,0)
771
"BLD",9546,"KRN",779.2,0)
779.2
"BLD",9546,"KRN",870,0)
870
"BLD",9546,"KRN",8989.51,0)
8989.51
"BLD",9546,"KRN",8989.52,0)
8989.52
"BLD",9546,"KRN",8994,0)
8994
"BLD",9546,"KRN",8994,"NM",0)
^9.68A^3^3
"BLD",9546,"KRN",8994,"NM",1,0)
utMUNIT-TEST GROUP LOAD^^0
"BLD",9546,"KRN",8994,"NM",2,0)
utMUNIT-TEST LOAD^^0
"BLD",9546,"KRN",8994,"NM",3,0)
utMUNIT-TEST NEXT^^0
"BLD",9546,"KRN",8994,"NM","B","utMUNIT-TEST GROUP LOAD",1)

"BLD",9546,"KRN",8994,"NM","B","utMUNIT-TEST LOAD",2)

"BLD",9546,"KRN",8994,"NM","B","utMUNIT-TEST NEXT",3)

"BLD",9546,"KRN","B",.4,.4)

"BLD",9546,"KRN","B",.401,.401)

"BLD",9546,"KRN","B",.402,.402)

"BLD",9546,"KRN","B",.403,.403)

"BLD",9546,"KRN","B",.5,.5)

"BLD",9546,"KRN","B",.84,.84)

"BLD",9546,"KRN","B",3.6,3.6)

"BLD",9546,"KRN","B",3.8,3.8)

"BLD",9546,"KRN","B",9.2,9.2)

"BLD",9546,"KRN","B",9.8,9.8)

"BLD",9546,"KRN","B",19,19)

"BLD",9546,"KRN","B",19.1,19.1)

"BLD",9546,"KRN","B",101,101)

"BLD",9546,"KRN","B",409.61,409.61)

"BLD",9546,"KRN","B",771,771)

"BLD",9546,"KRN","B",779.2,779.2)

"BLD",9546,"KRN","B",870,870)

"BLD",9546,"KRN","B",8989.51,8989.51)

"BLD",9546,"KRN","B",8989.52,8989.52)

"BLD",9546,"KRN","B",8994,8994)

"BLD",9546,"QDEF")
^^^^NO^^^^NO^^NO
"BLD",9546,"QUES",0)
^9.62^^
"BLD",9546,"REQB",0)
^9.611^^
"DATA",17.9001,1,0)
TESTS FOR UNIT TEST ROUTINES
"DATA",17.9001,1,1,0)
^17.90011^5^5
"DATA",17.9001,1,1,1,0)
%utt1
"DATA",17.9001,1,1,2,0)
%utt2
"DATA",17.9001,1,1,3,0)
%utt3
"DATA",17.9001,1,1,4,0)
%utt4
"DATA",17.9001,1,1,5,0)
%utt5
"DATA",17.9001,1,2,0)
^^4^4^3141008^
"DATA",17.9001,1,2,1,0)
This group will run all of the unit tests associated with the M-Unit
"DATA",17.9001,1,2,2,0)
code.  In addition, the routine %utt6 should be run as a regular routine
"DATA",17.9001,1,2,3,0)
from the top, and it will run all of the unit tests and,if on a G.TM
"DATA",17.9001,1,2,4,0)
system will run coverage analysis as well.
"FIA",17.9001)
M-UNIT TEST GROUP
"FIA",17.9001,0)
^%ut(17.9001,
"FIA",17.9001,0,0)
17.9001
"FIA",17.9001,0,1)
y^y^f^^n^^y^m^n
"FIA",17.9001,0,10)

"FIA",17.9001,0,11)

"FIA",17.9001,0,"RLRO")

"FIA",17.9001,0,"VR")
1.3^MASH
"FIA",17.9001,17.9001)
0
"FIA",17.9001,17.90011)
0
"FIA",17.9001,17.90012)
0
"INI")
ZZUTPRE
"INIT")
ZZUTPOST
"KRN",19,11538,-1)
0^1
"KRN",19,11538,0)
utMUNIT^M-Unit Tester^^B^^^^^^^^
"KRN",19,11538,1,0)
^^1^1^3140805^
"KRN",19,11538,1,1,0)
This is the context option for M-Unit Test functionality.
"KRN",19,11538,"RPC",0)
^19.05P^3^3
"KRN",19,11538,"RPC",1,0)
utMUNIT-TEST GROUP LOAD
"KRN",19,11538,"RPC",2,0)
utMUNIT-TEST LOAD
"KRN",19,11538,"RPC",3,0)
utMUNIT-TEST NEXT
"KRN",19,11538,"U")
M-UNIT TESTER
"KRN",19,11539,-1)
0^2
"KRN",19,11539,0)
utMUNIT GROUP EDIT^M-Unit Test Group Edit^^E^^^^^^^^TOOLKIT
"KRN",19,11539,1,0)
^19.06^6^6^3031030^^^
"KRN",19,11539,1,1,0)
This option can be used to maintain a listing of unit tests related to a 
"KRN",19,11539,1,2,0)
specific topic.  The Group identifies the topic, and the unit tests 
"KRN",19,11539,1,3,0)
related to that topic are added in the multiple.  Unit Tests can be run 
"KRN",19,11539,1,4,0)
by selecting a group, and all unit tests included in the multiple will be 
"KRN",19,11539,1,5,0)
used for the test.  In addition, any other references under the XTROU tag 
"KRN",19,11539,1,6,0)
in any of the included test routines will be included in the run.
"KRN",19,11539,30)
%ut(17.9001,
"KRN",19,11539,31)
AEMQL
"KRN",19,11539,50)
17.9001
"KRN",19,11539,51)
.01;1
"KRN",19,11539,"U")
M-UNIT TEST GROUP EDIT
"KRN",19,11540,-1)
0^3
"KRN",19,11540,0)
utMUNIT GROUP RUN^Run M-Unit Tests From Test Groups^^R^^^^^^^^TOOLKIT
"KRN",19,11540,1,0)
^^2^2^3031030^
"KRN",19,11540,1,1,0)
Provides a means of initiating a unit test run from the menu system based 
"KRN",19,11540,1,2,0)
on entries in the M-UNIT TEST GROUP file (#17.9001).
"KRN",19,11540,25)
PICKSET^%ut
"KRN",19,11540,"U")
RUN M-UNIT TESTS FROM TEST GRO
"KRN",8994,3261,-1)
0^1
"KRN",8994,3261,0)
utMUNIT-TEST GROUP LOAD^GUISET^%ut^4^^^^1
"KRN",8994,3262,-1)
0^2
"KRN",8994,3262,0)
utMUNIT-TEST LOAD^GUILOAD^%ut^4^^^^1
"KRN",8994,3263,-1)
0^3
"KRN",8994,3263,0)
utMUNIT-TEST NEXT^GUINEXT^%ut^4^^^^1
"MBREQ")
0
"ORD",16,8994)
8994;16;1;;;;;;;RPCDEL^XPDIA1
"ORD",16,8994,0)
REMOTE PROCEDURE
"ORD",18,19)
19;18;;;OPT^XPDTA;OPTF1^XPDIA;OPTE1^XPDIA;OPTF2^XPDIA;;OPTDEL^XPDIA
"ORD",18,19,0)
OPTION
"PKG",222,-1)
1^1
"PKG",222,0)
MASH UTILITIES^%u^Utilities associated with the M Advanced Shell
"PKG",222,20,0)
^9.402P^^
"PKG",222,22,0)
^9.49I^1^1
"PKG",222,22,1,0)
1.3^3151216^3151216
"PKG",222,22,1,"PAH",1,0)
0^3151216
"PKG",222,22,1,"PAH",1,1,0)
^^5^5^3151216
"PKG",222,22,1,"PAH",1,1,1,0)
Updated version of the open source M Advanced Shell (MASH) package.  
"PKG",222,22,1,"PAH",1,1,2,0)
This version includes the M-Unit testing functionality and adds 
"PKG",222,22,1,"PAH",1,1,3,0)
the capability of performing coverage analysis in Intersystems Cache 
"PKG",222,22,1,"PAH",1,1,4,0)
systems to the previous ability to perform such analyses in GT.M 
"PKG",222,22,1,"PAH",1,1,5,0)
systems.
"QUES","XPF1",0)
Y
"QUES","XPF1","??")
^D REP^XPDH
"QUES","XPF1","A")
Shall I write over your |FLAG| File
"QUES","XPF1","B")
YES
"QUES","XPF1","M")
D XPF1^XPDIQ
"QUES","XPF2",0)
Y
"QUES","XPF2","??")
^D DTA^XPDH
"QUES","XPF2","A")
Want my data |FLAG| yours
"QUES","XPF2","B")
YES
"QUES","XPF2","M")
D XPF2^XPDIQ
"QUES","XPI1",0)
YO
"QUES","XPI1","??")
^D INHIBIT^XPDH
"QUES","XPI1","A")
Want KIDS to INHIBIT LOGONs during the install
"QUES","XPI1","B")
NO
"QUES","XPI1","M")
D XPI1^XPDIQ
"QUES","XPM1",0)
PO^VA(200,:EM
"QUES","XPM1","??")
^D MG^XPDH
"QUES","XPM1","A")
Enter the Coordinator for Mail Group '|FLAG|'
"QUES","XPM1","B")

"QUES","XPM1","M")
D XPM1^XPDIQ
"QUES","XPO1",0)
Y
"QUES","XPO1","??")
^D MENU^XPDH
"QUES","XPO1","A")
Want KIDS to Rebuild Menu Trees Upon Completion of Install
"QUES","XPO1","B")
NO
"QUES","XPO1","M")
D XPO1^XPDIQ
"QUES","XPZ1",0)
Y
"QUES","XPZ1","??")
^D OPT^XPDH
"QUES","XPZ1","A")
Want to DISABLE Scheduled Options, Menu Options, and Protocols
"QUES","XPZ1","B")
NO
"QUES","XPZ1","M")
D XPZ1^XPDIQ
"QUES","XPZ2",0)
Y
"QUES","XPZ2","??")
^D RTN^XPDH
"QUES","XPZ2","A")
Want to MOVE routines to other CPUs
"QUES","XPZ2","B")
NO
"QUES","XPZ2","M")
D XPZ2^XPDIQ
"RTN")
12
"RTN","ZZUTPOST")
0^^B31712373
"RTN","ZZUTPOST",1,0)
%utPOST ;VEN-SMH/JLI - post install for M-Unit Test software ;12/16/15  08:58
"RTN","ZZUTPOST",2,0)
 ;;1.3;MASH UTILITIES;;DEC 16,2015;Build 4
"RTN","ZZUTPOST",3,0)
 ; Submitted to OSEHRA DEC 16, 2015 by Joel L. Ivey under the Apache 2 license (http://www.apache.org/licenses/LICENSE-2.0.html)
"RTN","ZZUTPOST",4,0)
 ; Original routine authored by Sam H. Habiel 07/2013-04/2014
"RTN","ZZUTPOST",5,0)
 ; Additions and modifications made by Joel L. Ivey 05/2014-08/2015
"RTN","ZZUTPOST",6,0)
 ;
"RTN","ZZUTPOST",7,0)
 N X,I
"RTN","ZZUTPOST",8,0)
 I +$SY=47 D  R X:$G(DTIME,300) D MES^XPDUTL(" ")
"RTN","ZZUTPOST",9,0)
 . S X(1)=" "
"RTN","ZZUTPOST",10,0)
 . S X(2)="In the next section, as it tries to copy the ut* routines"
"RTN","ZZUTPOST",11,0)
 . S X(3)="to %ut* routines watch for text that indicates the following:"
"RTN","ZZUTPOST",12,0)
 . S X(4)=" "
"RTN","ZZUTPOST",13,0)
 . S X(5)="cp: cannot create regular file `/_ut.m': Permission denied"
"RTN","ZZUTPOST",14,0)
 . S X(6)=" "
"RTN","ZZUTPOST",15,0)
 . S X(7)="If this is seen, respond Yes at the prompt after the attempt:"
"RTN","ZZUTPOST",16,0)
 . S X(8)="   Press ENTER to continue: "
"RTN","ZZUTPOST",17,0)
 . F I=1:1:18 D MES^XPDUTL(" ") ; create a blank screen for text
"RTN","ZZUTPOST",18,0)
 . D MES^XPDUTL(.X)
"RTN","ZZUTPOST",19,0)
 . Q
"RTN","ZZUTPOST",20,0)
 D RENAME
"RTN","ZZUTPOST",21,0)
 I +$SY=47 D  R X:$G(DTIME,300) I "Yy"[$E($G(X)) D GTMPROB
"RTN","ZZUTPOST",22,0)
 . K X
"RTN","ZZUTPOST",23,0)
 . S X(1)=" "
"RTN","ZZUTPOST",24,0)
 . S X(2)="  Your entry on the next line may not echo"
"RTN","ZZUTPOST",25,0)
 . S X(3)="If error text was seen enter Y (and RETURN):  NO// "
"RTN","ZZUTPOST",26,0)
 . D MES^XPDUTL(.X)
"RTN","ZZUTPOST",27,0)
 . Q
"RTN","ZZUTPOST",28,0)
 Q
"RTN","ZZUTPOST",29,0)
 ;
"RTN","ZZUTPOST",30,0)
RENAME ;
"RTN","ZZUTPOST",31,0)
 N %S,%D ; Source, destination
"RTN","ZZUTPOST",32,0)
 S U="^"
"RTN","ZZUTPOST",33,0)
 S %S="ut^ut1^utcover^utt1^utt2^utt3^utt4^utt5^utt6^uttcovr"
"RTN","ZZUTPOST",34,0)
 S %D="%ut^%ut1^%utcover^%utt1^%utt2^%utt3^%utt4^%utt5^%utt6^%uttcovr"
"RTN","ZZUTPOST",35,0)
 ;
"RTN","ZZUTPOST",36,0)
MOVE ; rename % routines
"RTN","ZZUTPOST",37,0)
 N %,X,Y,M
"RTN","ZZUTPOST",38,0)
 F %=1:1:$L(%D,"^") D  D MES(M) I +$SY=47 D MES(" ")
"RTN","ZZUTPOST",39,0)
 . S M="",X=$P(%S,U,%) ; from
"RTN","ZZUTPOST",40,0)
 . S Y=$P(%D,U,%) ; to
"RTN","ZZUTPOST",41,0)
 . Q:X=""
"RTN","ZZUTPOST",42,0)
 . S M="Routine: "_$J(X,8)
"RTN","ZZUTPOST",43,0)
 . Q:Y=""  I $T(^@X)=""  S M=M_"  Missing" Q
"RTN","ZZUTPOST",44,0)
 . S M=M_" Loaded, "
"RTN","ZZUTPOST",45,0)
 . D COPY(X,Y)
"RTN","ZZUTPOST",46,0)
 . S M=M_"Saved as "_$J(Y,8)
"RTN","ZZUTPOST",47,0)
 ;
"RTN","ZZUTPOST",48,0)
 QUIT  ; END
"RTN","ZZUTPOST",49,0)
 ;
"RTN","ZZUTPOST",50,0)
COPY(FROM,TO) ;
"RTN","ZZUTPOST",51,0)
 N XVAL
"RTN","ZZUTPOST",52,0)
 I +$SYSTEM=0 S XVAL="ZL @FROM ZS @TO" X XVAL QUIT
"RTN","ZZUTPOST",53,0)
 I +$SYSTEM=47 DO  QUIT
"RTN","ZZUTPOST",54,0)
 . S FROM=$$PATH(FROM)
"RTN","ZZUTPOST",55,0)
 . S TO=$$PATH(TO,"WRITE")
"RTN","ZZUTPOST",56,0)
 . N CMD S CMD="cp "_FROM_" "_TO
"RTN","ZZUTPOST",57,0)
 . O "cp":(shell="/bin/sh":command=CMD:WRITEONLY)::"PIPE"
"RTN","ZZUTPOST",58,0)
 . U "cp" C "cp"
"RTN","ZZUTPOST",59,0)
 QUIT
"RTN","ZZUTPOST",60,0)
 ;
"RTN","ZZUTPOST",61,0)
PATH(ROUTINE,MODE) ; for GT.M return source file with path for a routine
"RTN","ZZUTPOST",62,0)
 ;input: ROUTINE=Name of routine
"RTN","ZZUTPOST",63,0)
 ;       MODE="READ" or "WRITE" defaults to READ
"RTN","ZZUTPOST",64,0)
 ;output: Full filename
"RTN","ZZUTPOST",65,0)
 ;
"RTN","ZZUTPOST",66,0)
 S MODE=$G(MODE,"READ") ;set MODE to default value
"RTN","ZZUTPOST",67,0)
 N FILE S FILE=$TR(ROUTINE,"%","_")_".m" ;convert rtn name to filename
"RTN","ZZUTPOST",68,0)
 N ZRO S ZRO=$ZRO
"RTN","ZZUTPOST",69,0)
 ;
"RTN","ZZUTPOST",70,0)
 ; Get source routine
"RTN","ZZUTPOST",71,0)
 N %ZR
"RTN","ZZUTPOST",72,0)
 I MODE="READ" D SILENT^%RSEL(ROUTINE,"SRC") Q %ZR(ROUTINE)_FILE
"RTN","ZZUTPOST",73,0)
 ;
"RTN","ZZUTPOST",74,0)
 ; We are writing. Parse directories and get 1st routine directory
"RTN","ZZUTPOST",75,0)
 N DIRS
"RTN","ZZUTPOST",76,0)
 D PARSEZRO(.DIRS,ZRO)
"RTN","ZZUTPOST",77,0)
 N PATH S PATH=$$ZRO1ST(.DIRS)
"RTN","ZZUTPOST",78,0)
 ;
"RTN","ZZUTPOST",79,0)
 QUIT PATH_FILE ;end of PATH return directory and filename
"RTN","ZZUTPOST",80,0)
 ;
"RTN","ZZUTPOST",81,0)
 ;
"RTN","ZZUTPOST",82,0)
PARSEZRO(DIRS,ZRO) ; Parse $zroutines properly into an array
"RTN","ZZUTPOST",83,0)
 N PIECE
"RTN","ZZUTPOST",84,0)
 N I
"RTN","ZZUTPOST",85,0)
 F I=1:1:$L(ZRO," ") S PIECE(I)=$P(ZRO," ",I)
"RTN","ZZUTPOST",86,0)
 N CNT S CNT=1
"RTN","ZZUTPOST",87,0)
 F I=0:0 S I=$O(PIECE(I)) Q:'I  D
"RTN","ZZUTPOST",88,0)
 . S DIRS(CNT)=$G(DIRS(CNT))_PIECE(I)
"RTN","ZZUTPOST",89,0)
 . I DIRS(CNT)["("&(DIRS(CNT)[")") S CNT=CNT+1 QUIT
"RTN","ZZUTPOST",90,0)
 . I DIRS(CNT)'["("&(DIRS(CNT)'[")") S CNT=CNT+1 QUIT
"RTN","ZZUTPOST",91,0)
 . S DIRS(CNT)=DIRS(CNT)_" " ; prep for next piece
"RTN","ZZUTPOST",92,0)
 QUIT
"RTN","ZZUTPOST",93,0)
 ;
"RTN","ZZUTPOST",94,0)
ZRO1ST(DIRS) ; $$ Get first routine directory
"RTN","ZZUTPOST",95,0)
 N OUT ; $$ return
"RTN","ZZUTPOST",96,0)
 N %1 S %1=DIRS(1) ; 1st directory
"RTN","ZZUTPOST",97,0)
 ; Parse with (...)
"RTN","ZZUTPOST",98,0)
 I %1["(" DO
"RTN","ZZUTPOST",99,0)
 . S OUT=$P(%1,"(",2)
"RTN","ZZUTPOST",100,0)
 . I OUT[" " S OUT=$P(OUT," ")
"RTN","ZZUTPOST",101,0)
 . E  S OUT=$P(OUT,")")
"RTN","ZZUTPOST",102,0)
 ; no parens
"RTN","ZZUTPOST",103,0)
 E  S OUT=%1
"RTN","ZZUTPOST",104,0)
 ;
"RTN","ZZUTPOST",105,0)
 ; Add trailing slash
"RTN","ZZUTPOST",106,0)
 I $E(OUT,$L(OUT))'="/" S OUT=OUT_"/"
"RTN","ZZUTPOST",107,0)
 QUIT OUT
"RTN","ZZUTPOST",108,0)
 ;
"RTN","ZZUTPOST",109,0)
MES(T,B) ;Write message.
"RTN","ZZUTPOST",110,0)
 S B=$G(B)
"RTN","ZZUTPOST",111,0)
 I $L($T(BMES^XPDUTL)) D BMES^XPDUTL(T):B,MES^XPDUTL(T):'B Q
"RTN","ZZUTPOST",112,0)
 W:B ! W !,T
"RTN","ZZUTPOST",113,0)
 Q
"RTN","ZZUTPOST",114,0)
 ;
"RTN","ZZUTPOST",115,0)
TEST ; @TEST - TESTING TESTING
"RTN","ZZUTPOST",116,0)
 ;
"RTN","ZZUTPOST",117,0)
 N ZR S ZR="o(p r) /var/abc(/var/abc/r/) /abc/def $gtm_dist/libgtmutl.so vista.so"
"RTN","ZZUTPOST",118,0)
 N DIRS D PARSEZRO(.DIRS,ZR)
"RTN","ZZUTPOST",119,0)
 N FIRSTDIR S FIRSTDIR=$$ZRO1ST(.DIRS)
"RTN","ZZUTPOST",120,0)
 I FIRSTDIR'="p" S $EC=",U1,"
"RTN","ZZUTPOST",121,0)
 ;
"RTN","ZZUTPOST",122,0)
 N ZR S ZR="/var/abc(/var/abc/r/) o(p r) /abc/def $gtm_dist/libgtmutl.so vista.so"
"RTN","ZZUTPOST",123,0)
 N DIRS D PARSEZRO(.DIRS,ZR)
"RTN","ZZUTPOST",124,0)
 N FIRSTDIR S FIRSTDIR=$$ZRO1ST(.DIRS)
"RTN","ZZUTPOST",125,0)
 I FIRSTDIR'="/var/abc/r/" S $EC=",U1,"
"RTN","ZZUTPOST",126,0)
 ;
"RTN","ZZUTPOST",127,0)
 N ZR S ZR="/abc/def /var/abc(/var/abc/r/) o(p r) $gtm_dist/libgtmutl.so vista.so"
"RTN","ZZUTPOST",128,0)
 N DIRS D PARSEZRO(.DIRS,ZR)
"RTN","ZZUTPOST",129,0)
 N FIRSTDIR S FIRSTDIR=$$ZRO1ST(.DIRS)
"RTN","ZZUTPOST",130,0)
 I FIRSTDIR'="/abc/def" S $EC=",U1,"
"RTN","ZZUTPOST",131,0)
 ;
"RTN","ZZUTPOST",132,0)
 WRITE "All tests have run successfully!",!
"RTN","ZZUTPOST",133,0)
 QUIT
"RTN","ZZUTPOST",134,0)
 ;
"RTN","ZZUTPOST",135,0)
GTMPROB ; come here in case of error trying to run unit tests - checks whether renaming worked
"RTN","ZZUTPOST",136,0)
 N X
"RTN","ZZUTPOST",137,0)
 S X(1)=" "
"RTN","ZZUTPOST",138,0)
 S X(2)="*** An error occurred during renaming of routines to %ut*."
"RTN","ZZUTPOST",139,0)
 S X(3)="*** The renaming has been seen to fail on one type of Linux system."
"RTN","ZZUTPOST",140,0)
 S X(4)="*** In this case, at the Linux command line copy each ut*.m routine"
"RTN","ZZUTPOST",141,0)
 S X(5)="*** (ut.m, ut1.m, utt1.m, utt2.m, utt3.m, utt4.m, utt5.m, utt6.m, and "
"RTN","ZZUTPOST",142,0)
 S X(6)="*** uttcovr.m) to _ut*.m (e.g., 'cp ut.m _ut.m', 'cp ut1.m _ut1.m',"
"RTN","ZZUTPOST",143,0)
 S X(7)="*** 'cp utt1.m _utt1.m', etc., to 'cp uttcovr.m _uttcovr.m').  Then in GT.M"
"RTN","ZZUTPOST",144,0)
 S X(8)="*** use the command 'ZLINK %ut', then 'ZLINK %ut1', etc., these may"
"RTN","ZZUTPOST",145,0)
 S X(9)="*** indicate an undefined local variable error, but continue doing it."
"RTN","ZZUTPOST",146,0)
 S X(10)="*** When complete, use the M command 'DO ^%utt1' to run the unit tests on"
"RTN","ZZUTPOST",147,0)
 S X(11)="*** the %ut and %ut1 routines to confirm they are working"
"RTN","ZZUTPOST",148,0)
 S X(12)=" "
"RTN","ZZUTPOST",149,0)
 S X(13)="  Press Enter to continue: "
"RTN","ZZUTPOST",150,0)
 D MES^XPDUTL(.X)
"RTN","ZZUTPOST",151,0)
 R X:$G(DTIME,300)
"RTN","ZZUTPOST",152,0)
 Q
"RTN","ZZUTPRE")
0^^B7184945
"RTN","ZZUTPRE",1,0)
%utPRE ;VEN/SMH/JLI - pre installation routine to set up MASH UTILITIES package and assign %ut routines and globals ;12/16/15  08:59
"RTN","ZZUTPRE",2,0)
 ;;1.3;MASH UTILITIES;;DEC 16, ;Build 4
"RTN","ZZUTPRE",3,0)
 ; Submitted to OSEHRA Dec 16, 2015 by Joel L. Ivey under the Apache 2 license (http://www.apache.org/licenses/LICENSE-2.0.html)
"RTN","ZZUTPRE",4,0)
 ; Original routine authored by Sam H. Habiel 07/2013-04/2014
"RTN","ZZUTPRE",5,0)
 ;
"RTN","ZZUTPRE",6,0)
 ;
"RTN","ZZUTPRE",7,0)
 ; The following is used to create, if it does not exist, the MASH UTILITIES
"RTN","ZZUTPRE",8,0)
 ; package, and to assign the %u namespace to this package.  This special
"RTN","ZZUTPRE",9,0)
 ; processing is necessary, since the input transform currently will not accept a
"RTN","ZZUTPRE",10,0)
 ; % or lower case character in the namespace.
"RTN","ZZUTPRE",11,0)
 I '$D(^DIC(9.4,"B","MASH UTILITIES")) N DIC,X S DIC="^DIC(9.4,",DIC(0)="",X="MASH UTILITIES",DIC("DR")="1////%u;2///Utilities associated with the M Advanced Shell" D FILE^DICN
"RTN","ZZUTPRE",12,0)
 ; and if necessary, as in CACHE, map %ut routine and namespace in the current account.
"RTN","ZZUTPRE",13,0)
 I +$SY=0 D CACHEMAP ; This routine is CACHE specific
"RTN","ZZUTPRE",14,0)
 Q
"RTN","ZZUTPRE",15,0)
 ; The following code was provided by Sam Habiel to map %
"RTN","ZZUTPRE",16,0)
CACHEMAP ; Map %ut* Globals and Routines away from %SYS in Cache
"RTN","ZZUTPRE",17,0)
 ; Get current namespace
"RTN","ZZUTPRE",18,0)
 N NMSP
"RTN","ZZUTPRE",19,0)
 I $P($P($ZV,") ",2),"(")<2012 S NMSP=$ZU(5)
"RTN","ZZUTPRE",20,0)
 I $P($P($ZV,") ",2),"(")>2011 S NMSP=$NAMESPACE
"RTN","ZZUTPRE",21,0)
 ;
"RTN","ZZUTPRE",22,0)
 N $ET S $ET="ZN NMSP D ^%ZTER S $EC="""""
"RTN","ZZUTPRE",23,0)
 ;
"RTN","ZZUTPRE",24,0)
 ZN "%SYS" ; Go to SYS
"RTN","ZZUTPRE",25,0)
 ;
"RTN","ZZUTPRE",26,0)
 ; Props
"RTN","ZZUTPRE",27,0)
 N % S %=##Class(Config.Namespaces).Get(NMSP,.PROP) ; Get all namespace properties
"RTN","ZZUTPRE",28,0)
 I '% W !,"Error="_$SYSTEM.Status.GetErrorText(%) S $EC=",U-CONFIG-FAIL," QUIT
"RTN","ZZUTPRE",29,0)
 ;
"RTN","ZZUTPRE",30,0)
 N DBG S DBG=PROP("Globals")  ; get the database globals location
"RTN","ZZUTPRE",31,0)
 N DBR S DBR=PROP("Routines") ; get the database routines location
"RTN","ZZUTPRE",32,0)
 S PROP("Database")="VISTA" ; needed for call to MapGlobals.Create below
"RTN","ZZUTPRE",33,0)
 ;
"RTN","ZZUTPRE",34,0)
 ; Map %ut globals away from %SYS
"RTN","ZZUTPRE",35,0)
 N %
"RTN","ZZUTPRE",36,0)
 ;S %=##class(Config.Configuration).GetGlobalMapping(NMSP,"%ut*","",DBG,DBG)
"RTN","ZZUTPRE",37,0)
 S %=##Class(Config.MapGlobals).Get(NMSP,"%ut*",.PROP)
"RTN","ZZUTPRE",38,0)
 ;I '% S %=##class(Config.Configuration).AddGlobalMapping(NMSP,"%ut*","",DBG,DBG)
"RTN","ZZUTPRE",39,0)
 I '% S %=##Class(Config.MapGlobals).Create(NMSP,"%ut",.PROP) ; doesn't work with "%ut*"
"RTN","ZZUTPRE",40,0)
 ;
"RTN","ZZUTPRE",41,0)
 I '% W !,"Error="_$SYSTEM.Status.GetErrorText(%) S $EC=",U-CONFIG-FAIL," QUIT
"RTN","ZZUTPRE",42,0)
 ;
"RTN","ZZUTPRE",43,0)
 ; Map %ut routines away from %SYS
"RTN","ZZUTPRE",44,0)
 N PROPRTN S PROPRTN("Database")=DBR
"RTN","ZZUTPRE",45,0)
 N % S %=##Class(Config.MapRoutines).Get(NMSP,"%ut*",.PROPRTN)
"RTN","ZZUTPRE",46,0)
 N PROPRTN S PROPRTN("Database")=DBR  ; Cache seems to like deleting this
"RTN","ZZUTPRE",47,0)
 I '% S %=##Class(Config.MapRoutines).Create(NMSP,"%ut*",.PROPRTN)
"RTN","ZZUTPRE",48,0)
 I '% W !,"Error="_$SYSTEM.Status.GetErrorText(%) S $EC=",U-CONFIG-FAIL," QUIT
"RTN","ZZUTPRE",49,0)
 ZN NMSP ; Go back
"RTN","ZZUTPRE",50,0)
 QUIT
"RTN","ut")
0^1^B230412209
"RTN","ut",1,0)
%ut ;VEN-SMH/JLI - PRIMARY PROGRAM FOR M-UNIT TESTING ;12/16/15  08:40
"RTN","ut",2,0)
 ;;1.3;MASH UTILITIES;;Dec 16, 2015;Build 4
"RTN","ut",3,0)
 ; Submitted to OSEHRA Dec 16, 2015 by Joel L. Ivey under the Apache 2 license (http://www.apache.org/licenses/LICENSE-2.0.html)
"RTN","ut",4,0)
 ; Original routine authored by Joel L. Ivey as XTMUNIT while working for U.S. Department of Veterans Affairs 2003-2012
"RTN","ut",5,0)
 ; Includes addition of %utVERB and %utBREAK arguments and code related to them as well as other substantial additions authored by Sam Habiel 07/2013-04/2014
"RTN","ut",6,0)
 ; Additional work by Joel L. Ivey 05/14-12/15
"RTN","ut",7,0)
 ;
"RTN","ut",8,0)
 ; This routine and its companion, %ut1, provide the basic functionality for
"RTN","ut",9,0)
 ; running unit tests on parts of M programs either at the command line level
"RTN","ut",10,0)
 ; or via the M-Unit GUI application for windows operating systems.
"RTN","ut",11,0)
 ;
"RTN","ut",12,0)
 ; Original by Dr. Joel Ivey
"RTN","ut",13,0)
 ; Contributions by Dr. Sam Habiel
"RTN","ut",14,0)
 ;   comments moved to %ut1 due to space requirements
"RTN","ut",15,0)
 ;
"RTN","ut",16,0)
 D ^%utt6 ; runs unit tests on all of it
"RTN","ut",17,0)
 Q
"RTN","ut",18,0)
 ;
"RTN","ut",19,0)
EN(%utRNAM,%utVERB,%utBREAK) ; .SR Entry point with primary test routine name, optional 1 for verbose output
"RTN","ut",20,0)
 N %utLIST,%utROU,%ut
"RTN","ut",21,0)
 I '+$G(%utVERB) S %utVERB=0
"RTN","ut",22,0)
 S %utLIST=1,%utROU(%utLIST)=%utRNAM
"RTN","ut",23,0)
 K ^TMP("%ut",$J,"UTVALS")
"RTN","ut",24,0)
 D SETUT
"RTN","ut",25,0)
 D EN1(.%utROU,%utLIST)
"RTN","ut",26,0)
 Q
"RTN","ut",27,0)
 ;
"RTN","ut",28,0)
SETUT ;
"RTN","ut",29,0)
 ; VEN/SMH 26JUL2013
"RTN","ut",30,0)
 I '($D(IO)#2) S IO=$P
"RTN","ut",31,0)
 S U="^"
"RTN","ut",32,0)
 ; VEN/SMH 26JUL2013 END
"RTN","ut",33,0)
 ;
"RTN","ut",34,0)
 ; ZEXCEPT: %ut  -- NEWED ON ENTRY
"RTN","ut",35,0)
 S %ut("IO")=IO
"RTN","ut",36,0)
 S %ut=1 ; set to identify unit test being run check with $$ISUTEST^%ut()
"RTN","ut",37,0)
 ;
"RTN","ut",38,0)
 ; ZEXCEPT: %utBREAK
"RTN","ut",39,0)
 I $G(%utBREAK) S %ut("BREAK")=1
"RTN","ut",40,0)
 Q
"RTN","ut",41,0)
 ;
"RTN","ut",42,0)
EN1(%utROU,%utLIST) ;
"RTN","ut",43,0)
 ; VEN/SMH 26JUL2013 - This block is refactored to fix problems with
"RTN","ut",44,0)
 ; SETUP and TEARDOWN not happening at the right time
"RTN","ut",45,0)
 N %utERRL,%utK,%utI,%utJ,%utSTRT
"RTN","ut",46,0)
 ; ZEXCEPT: %utVERB   -- ARGUMENT TO EN
"RTN","ut",47,0)
 ; ZEXCEPT: %utGUI      -- CONDITIONALLY DEFINED BY GUINEXT
"RTN","ut",48,0)
 ; ZEXCEPT: %ut  -- NEWED IN EN
"RTN","ut",49,0)
 ;
"RTN","ut",50,0)
 ; Structure map for %ut
"RTN","ut",51,0)
 ; -- CURR = Counter for routine number. Used as sub in %utROU
"RTN","ut",52,0)
 ; -- ECNT = Entry point count in loop (cf. NERT); VEN/SMH - Needed?
"RTN","ut",53,0)
 ; -- FAIL = Number of failures
"RTN","ut",54,0)
 ; -- CHK  = Number of checks ran (TF/EQ/FAIL)
"RTN","ut",55,0)
 ; -- NENT = Number of entry points ran
"RTN","ut",56,0)
 ; -- ERRN = Number of errors
"RTN","ut",57,0)
 S %ut("CURR")=0,%ut("ECNT")=0,%ut("FAIL")=0,%ut("CHK")=0,%ut("NENT")=0,%ut("ERRN")=0
"RTN","ut",58,0)
 ;
"RTN","ut",59,0)
 ; -- GET LIST OF ROUTINES --
"RTN","ut",60,0)
 ; first get any tree of routines from this one
"RTN","ut",61,0)
 D GETTREE^%ut1(.%utROU,.%utLIST)
"RTN","ut",62,0)
 ;
"RTN","ut",63,0)
 ; Now process each routine that has been referenced
"RTN","ut",64,0)
 N CURRROU
"RTN","ut",65,0)
 S %ut("CURR")=0
"RTN","ut",66,0)
 F  S %ut("CURR")=%ut("CURR")+1 Q:'$D(%utROU(%ut("CURR")))  S CURRROU=%utROU(%ut("CURR")) D  I $T(@("SHUTDOWN^"_CURRROU))'="" D @("SHUTDOWN^"_CURRROU)
"RTN","ut",67,0)
 . ; 141018 - add ability to run STARTUP and SHUTDOWN in each routine JLI
"RTN","ut",68,0)
 . I $T(@("STARTUP^"_CURRROU))'="" D @("STARTUP^"_CURRROU) ; 141018
"RTN","ut",69,0)
 . N %utETRY ; Test list to run
"RTN","ut",70,0)
 . ;
"RTN","ut",71,0)
 . ; Collect Test list.
"RTN","ut",72,0)
 . D CHEKTEST^%ut1(%utROU(%ut("CURR")),.%ut,.%utETRY)
"RTN","ut",73,0)
 . ;
"RTN","ut",74,0)
 . ; if a SETUP entry point exists, save it off in %ut
"RTN","ut",75,0)
 . S %ut("SETUP")="" ; 141018 need to clear any previous values JLI
"RTN","ut",76,0)
 . N %utSETUP S %utSETUP="SETUP^"_%utROU(%ut("CURR"))
"RTN","ut",77,0)
 . S %ut("LINE")=$T(@%utSETUP) I %ut("LINE")'="" S %ut("SETUP")=%utSETUP
"RTN","ut",78,0)
 . K %utSETUP ; we're done!
"RTN","ut",79,0)
 . ;
"RTN","ut",80,0)
 . ; if a TEARDOWN entry point exists, ditto
"RTN","ut",81,0)
 . S %ut("TEARDOWN")="" ; 141018 need to clear any previous values JLI
"RTN","ut",82,0)
 . N %utTEARDOWN S %utTEARDOWN="TEARDOWN^"_%utROU(%ut("CURR"))
"RTN","ut",83,0)
 . S %ut("LINE")=$T(@%utTEARDOWN) I %ut("LINE")'="" S %ut("TEARDOWN")=%utTEARDOWN
"RTN","ut",84,0)
 . K %utTEARDOWN ; done here.
"RTN","ut",85,0)
 . ;
"RTN","ut",86,0)
 . ; VEN/SMH 26JUL2013 - this block changed to correct running of setup and teardown
"RTN","ut",87,0)
 . ; run each of the specified entry points
"RTN","ut",88,0)
 . ;
"RTN","ut",89,0)
 . ; == THIS FOR/DO BLOCK IS THE CENTRAL TEST RUNNER ==
"RTN","ut",90,0)
 . S %utI=0
"RTN","ut",91,0)
 . F  S %utI=$O(%utETRY(%utI)) Q:%utI'>0  S %ut("ENUM")=%ut("ERRN")+%ut("FAIL") D
"RTN","ut",92,0)
 . . N $ETRAP S $ETRAP="D ERROR^%ut"
"RTN","ut",93,0)
 . . ;
"RTN","ut",94,0)
 . . ; Run Set-up Code (only if present)
"RTN","ut",95,0)
 . . S %ut("ENT")=$G(%ut("SETUP")) ; Current entry
"RTN","ut",96,0)
 . . S %ut("NAME")="Set-up Code"
"RTN","ut",97,0)
 . . D:%ut("ENT")]"" @%ut("ENT")
"RTN","ut",98,0)
 . . ;
"RTN","ut",99,0)
 . . ; Run actual test
"RTN","ut",100,0)
 . . S %ut("ECNT")=%ut("ECNT")+1
"RTN","ut",101,0)
 . . S %ut("NAME")=%utETRY(%utI,"NAME")
"RTN","ut",102,0)
 . . S %ut("ENT")=%utETRY(%utI)_"^"_%utROU(%ut("CURR"))
"RTN","ut",103,0)
 . . I %utVERB,'$D(%utGUI) D VERBOSE1(.%utETRY,%utI) ; Say what we executed.
"RTN","ut",104,0)
 . . D @%ut("ENT")
"RTN","ut",105,0)
 . . ;
"RTN","ut",106,0)
 . . ; Run Teardown Code (only if present)
"RTN","ut",107,0)
 . . S %ut("ENT")=$G(%ut("TEARDOWN"))
"RTN","ut",108,0)
 . . S %ut("NAME")="Teardown Code"
"RTN","ut",109,0)
 . . D:%ut("ENT")]"" @%ut("ENT")
"RTN","ut",110,0)
 . . ;
"RTN","ut",111,0)
 . . ; ENUM = Number of errors + failures
"RTN","ut",112,0)
 . . ; Only print out the success message [OK] If our error number remains
"RTN","ut",113,0)
 . . ; the same as when we started the loop.
"RTN","ut",114,0)
 . . I %utVERB,'$D(%utGUI) D
"RTN","ut",115,0)
 . . . I %ut("ENUM")=(%ut("ERRN")+%ut("FAIL")) D VERBOSE(.%utETRY,%utI,1) I 1
"RTN","ut",116,0)
 . . . E  D VERBOSE(.%utETRY,%utI,0)
"RTN","ut",117,0)
 . . . Q
"RTN","ut",118,0)
 . . Q
"RTN","ut",119,0)
 . ; keep a %utCNT of number of entry points executed across all routines
"RTN","ut",120,0)
 . S %ut("NENT")=%ut("NENT")+%ut("ENTN")
"RTN","ut",121,0)
 . Q
"RTN","ut",122,0)
 ;
"RTN","ut",123,0)
 ; -- SHUTDOWN --
"RTN","ut",124,0)
 D SETIO^%ut1
"RTN","ut",125,0)
 W !!,"Ran ",%utLIST," Routine",$S(%utLIST>1:"s",1:""),", ",%ut("NENT")," Entry Tag",$S(%ut("NENT")>1:"s",1:"")
"RTN","ut",126,0)
 W !,"Checked ",%ut("CHK")," test",$S(%ut("CHK")>1:"s",1:""),", with ",%ut("FAIL")," failure",$S(%ut("FAIL")'=1:"s",1:"")," and encountered ",%ut("ERRN")," error",$S(%ut("ERRN")'=1:"s",1:""),"."
"RTN","ut",127,0)
 S ^TMP("%ut",$J,"UTVALS")=%utLIST_U_%ut("NENT")_U_%ut("CHK")_U_%ut("FAIL")_U_%ut("ERRN") ; JLI 150621 so programs running several sets of unit tests can generate totals
"RTN","ut",128,0)
 D RESETIO^%ut1
"RTN","ut",129,0)
 Q
"RTN","ut",130,0)
 ; -- end EN1
"RTN","ut",131,0)
VERBOSE(%utETRY,%utI,SUCCESS) ; Say whether we succeeded or failed.
"RTN","ut",132,0)
 ; ZEXCEPT: %ut - NEWED IN EN
"RTN","ut",133,0)
 D SETIO^%ut1
"RTN","ut",134,0)
 N I F I=$X+3:1:73 W "-"
"RTN","ut",135,0)
 W ?73
"RTN","ut",136,0)
 I $G(SUCCESS) W "[OK]"
"RTN","ut",137,0)
 E  W "[FAIL]"
"RTN","ut",138,0)
 D RESETIO^%ut1
"RTN","ut",139,0)
 Q
"RTN","ut",140,0)
 ;
"RTN","ut",141,0)
VERBOSE1(%utETRY,%utI) ; Print out the entry point info
"RTN","ut",142,0)
 ; ZEXCEPT: %ut - NEWED IN EN
"RTN","ut",143,0)
 D SETIO^%ut1
"RTN","ut",144,0)
 W !,%utETRY(%utI) I $G(%utETRY(%utI,"NAME"))'="" W " - ",%utETRY(%utI,"NAME")
"RTN","ut",145,0)
 D RESETIO^%ut1
"RTN","ut",146,0)
 Q
"RTN","ut",147,0)
 ;
"RTN","ut",148,0)
CHKTF(XTSTVAL,XTERMSG) ; Entry point for checking True or False values
"RTN","ut",149,0)
 ; ZEXCEPT: %utERRL,%utGUI - CREATED IN SETUP, KILLED IN END
"RTN","ut",150,0)
 ; ZEXCEPT: %ut - NEWED IN EN
"RTN","ut",151,0)
 ; ZEXCEPT: XTGUISEP - newed in GUINEXT
"RTN","ut",152,0)
 I '$D(XTSTVAL) D NVLDARG^%ut1("CHKTF") Q
"RTN","ut",153,0)
 I $G(XTERMSG)="" S XTERMSG="no failure message provided"
"RTN","ut",154,0)
 S %ut("CHK")=$G(%ut("CHK"))+1
"RTN","ut",155,0)
 I '$D(%utGUI) D
"RTN","ut",156,0)
 . D SETIO^%ut1
"RTN","ut",157,0)
 . I 'XTSTVAL W !,%ut("ENT")," - " W:%ut("NAME")'="" %ut("NAME")," - " D
"RTN","ut",158,0)
 . . W XTERMSG,! S %ut("FAIL")=%ut("FAIL")+1,%utERRL(%ut("FAIL"))=%ut("NAME"),%utERRL(%ut("FAIL"),"MSG")=XTERMSG,%utERRL(%ut("FAIL"),"ENTRY")=%ut("ENT")
"RTN","ut",159,0)
 . . I $D(%ut("BREAK")) BREAK  ; Break upon failure
"RTN","ut",160,0)
 . . Q
"RTN","ut",161,0)
 . I XTSTVAL W "."
"RTN","ut",162,0)
 . D RESETIO^%ut1
"RTN","ut",163,0)
 . Q
"RTN","ut",164,0)
 I $D(%utGUI),'XTSTVAL S %ut("CNT")=%ut("CNT")+1,@%ut("RSLT")@(%ut("CNT"))=%ut("LOC")_XTGUISEP_"FAILURE"_XTGUISEP_XTERMSG,%ut("FAIL")=%ut("FAIL")+1
"RTN","ut",165,0)
 Q
"RTN","ut",166,0)
 ;
"RTN","ut",167,0)
CHKEQ(XTEXPECT,XTACTUAL,XTERMSG) ; Entry point for checking values to see if they are EQUAL
"RTN","ut",168,0)
 N FAILMSG
"RTN","ut",169,0)
 ; ZEXCEPT: %utERRL,%utGUI -CREATED IN SETUP, KILLED IN END
"RTN","ut",170,0)
 ; ZEXCEPT: %ut  -- NEWED IN EN
"RTN","ut",171,0)
 ; ZEXCEPT: XTGUISEP - newed in GUINEXT
"RTN","ut",172,0)
 I '$D(XTEXPECT)!'$D(XTACTUAL) D NVLDARG^%ut1("CHKEQ") Q
"RTN","ut",173,0)
 S XTACTUAL=$G(XTACTUAL),XTEXPECT=$G(XTEXPECT)
"RTN","ut",174,0)
 I $G(XTERMSG)="" S XTERMSG="no failure message provided"
"RTN","ut",175,0)
 S %ut("CHK")=%ut("CHK")+1
"RTN","ut",176,0)
 I XTEXPECT'=XTACTUAL S FAILMSG="<"_XTEXPECT_"> vs <"_XTACTUAL_"> - "
"RTN","ut",177,0)
 I '$D(%utGUI) D
"RTN","ut",178,0)
 . D SETIO^%ut1
"RTN","ut",179,0)
 . I XTEXPECT'=XTACTUAL W !,%ut("ENT")," - " W:%ut("NAME")'="" %ut("NAME")," - " W FAILMSG,XTERMSG,! D
"RTN","ut",180,0)
 . . S %ut("FAIL")=%ut("FAIL")+1,%utERRL(%ut("FAIL"))=%ut("NAME"),%utERRL(%ut("FAIL"),"MSG")=XTERMSG,%utERRL(%ut("FAIL"),"ENTRY")=%ut("ENT")
"RTN","ut",181,0)
     . . I $D(%ut("BREAK")) BREAK  ; Break upon failure
"RTN","ut",182,0)
 . . Q
"RTN","ut",183,0)
 . E  W "."
"RTN","ut",184,0)
 . D RESETIO^%ut1
"RTN","ut",185,0)
 . Q
"RTN","ut",186,0)
 I $D(%utGUI),XTEXPECT'=XTACTUAL S %ut("CNT")=%ut("CNT")+1,@%ut("RSLT")@(%ut("CNT"))=%ut("LOC")_XTGUISEP_"FAILURE"_XTGUISEP_FAILMSG_XTERMSG,%ut("FAIL")=%ut("FAIL")+1
"RTN","ut",187,0)
 Q
"RTN","ut",188,0)
 ;
"RTN","ut",189,0)
FAIL(XTERMSG) ; Entry point for generating a failure message
"RTN","ut",190,0)
 D FAIL^%ut1($G(XTERMSG))
"RTN","ut",191,0)
 Q
"RTN","ut",192,0)
 ;
"RTN","ut",193,0)
SUCCEED ; Entry point for forcing a success (Thx David Whitten)
"RTN","ut",194,0)
 ; ZEXCEPT: %utERRL,%utGUI - CREATED IN SETUP, KILLED IN END
"RTN","ut",195,0)
 ; ZEXCEPT: %ut - NEWED IN EN
"RTN","ut",196,0)
 ; Switch IO and write out the dot for activity
"RTN","ut",197,0)
 I '$D(%utGUI) D
"RTN","ut",198,0)
 . D SETIO^%ut1
"RTN","ut",199,0)
 . W "."
"RTN","ut",200,0)
 . D RESETIO^%ut1
"RTN","ut",201,0)
 ;
"RTN","ut",202,0)
 ; Increment test counter
"RTN","ut",203,0)
 S %ut("CHK")=%ut("CHK")+1
"RTN","ut",204,0)
 QUIT
"RTN","ut",205,0)
 ;
"RTN","ut",206,0)
CHKLEAKS(%utCODE,%utLOC,%utINPT) ; functionality to check for variable leaks on executing a section of code
"RTN","ut",207,0)
 ; %utCODE - A string that specifies the code that is to be XECUTED and checked for leaks.
"RTN","ut",208,0)
 ;            this should be a complete piece of code (e.g., "S X=$$NOW^XLFDT()" or "D EN^%ut(""ROUNAME"")")
"RTN","ut",209,0)
 ; %utLOC  - A string that is used to indicate the code tested for variable leaks
"RTN","ut",210,0)
 ; %utINPT - An optional variable which may be passed by reference.  This may
"RTN","ut",211,0)
 ;           be used to pass any variable values, etc. into the code to be
"RTN","ut",212,0)
 ;           XECUTED.  In this case, set the subscript to the variable name and the
"RTN","ut",213,0)
 ;           value of the subscripted variable to the desired value of the subscript.
"RTN","ut",214,0)
 ;              e.g., (using NAME as my current namespace)
"RTN","ut",215,0)
 ;                   S CODE="S %utINPT=$$ENTRY^ROUTINE(ZZVALUE1,ZZVALUE2)"
"RTN","ut",216,0)
 ;                   S NAMELOC="ENTRY^ROUTINE leak test"   (or simply "ENTRY^ROUTINE")
"RTN","ut",217,0)
 ;                   S NAMEINPT("ZZVALUE1")=ZZVALUE1
"RTN","ut",218,0)
 ;                   S NAMEINPT("ZZVALUE2")=ZZVALUE2
"RTN","ut",219,0)
 ;                   D CHKLEAKS^%ut(CODE,NAMELOC,.NAMEINPT)
"RTN","ut",220,0)
 ;
"RTN","ut",221,0)
 ;           If part of a unit test, any leaked variables in ENTRY^ROUTINE which result
"RTN","ut",222,0)
 ;           from running the code with the variables indicated will be shown as FAILUREs.
"RTN","ut",223,0)
 ;
"RTN","ut",224,0)
 ;           If called outside of a unit test, any leaked variables will be printed to the
"RTN","ut",225,0)
 ;           current device.
"RTN","ut",226,0)
 ;
"RTN","ut",227,0)
 N (%utCODE,%utLOC,%utINPT,DUZ,IO,U,%utERRL,%ut,%utGUI,%utERR,%utI,%utJ,%utK,%utLIST,%utROU,%utSTRT,XTGUISEP)
"RTN","ut",228,0)
 ; ZEXCEPT: %ut - part of exclusive NEW TESTS FOR EXISTENCE ONLY
"RTN","ut",229,0)
 ; ZEXCEPT: %utVAR - handled by exclusive NEW
"RTN","ut",230,0)
 ;
"RTN","ut",231,0)
 ; ACTIVATE ANY VARIABLES PASSED AS SUBSCRIPTS TO %utINPT TO THEIR VALUES
"RTN","ut",232,0)
 S %utVAR=" " F  S %utVAR=$O(%utINPT(%utVAR)) Q:%utVAR=""  S (@%utVAR)=%utINPT(%utVAR)
"RTN","ut",233,0)
 X %utCODE
"RTN","ut",234,0)
 N ZZUTVAR S ZZUTVAR="%"
"RTN","ut",235,0)
 I $G(%ut)=1 D
"RTN","ut",236,0)
 . I $D(@ZZUTVAR),'$D(%utINPT(ZZUTVAR)) D FAIL^%ut(%utLOC_" VARIABLE LEAK: "_ZZUTVAR)
"RTN","ut",237,0)
 . F  S ZZUTVAR=$O(@ZZUTVAR) Q:ZZUTVAR=""  I $E(ZZUTVAR,1,3)'="%ut",'$D(%utINPT(ZZUTVAR)),",DUZ,IO,U,DTIME,ZZUTVAR,DT,%ut,XTGUISEP,"'[(","_ZZUTVAR_",") D FAIL^%ut(%utLOC_" VARIABLE LEAK: "_ZZUTVAR)
"RTN","ut",238,0)
 . Q
"RTN","ut",239,0)
 I '($G(%ut)=1) D
"RTN","ut",240,0)
 . I $D(@ZZUTVAR),'$D(%utINPT(ZZUTVAR)) W !,%utLOC_" VARIABLE LEAK: "_ZZUTVAR
"RTN","ut",241,0)
 . F  S ZZUTVAR=$O(@ZZUTVAR) Q:ZZUTVAR=""  I $E(ZZUTVAR,1,3)'="%ut",'$D(%utINPT(ZZUTVAR)),",DUZ,IO,U,DTIME,ZZUTVAR,DT,%ut,XTGUISEP,"'[(","_ZZUTVAR_",") W !,%utLOC_" VARIABLE LEAK: "_ZZUTVAR
"RTN","ut",242,0)
 . Q
"RTN","ut",243,0)
 Q
"RTN","ut",244,0)
 ;
"RTN","ut",245,0)
ERROR ; record errors
"RTN","ut",246,0)
 ; ZEXCEPT: %utERRL,%utGUI,%utERR -CREATED IN SETUP, KILLED IN END
"RTN","ut",247,0)
 ; ZEXCEPT: %ut  -- NEWED ON ENTRY
"RTN","ut",248,0)
 ; ZEXCEPT: XTGUISEP - newed in GUINEXT
"RTN","ut",249,0)
 S %ut("CHK")=%ut("CHK")+1
"RTN","ut",250,0)
 I '$D(%utGUI) D ERROR1
"RTN","ut",251,0)
 I $D(%utGUI) D
"RTN","ut",252,0)
 . S %ut("CNT")=%ut("CNT")+1
"RTN","ut",253,0)
 . S %utERR=%utERR+1
"RTN","ut",254,0)
 . S @%ut("RSLT")@(%ut("CNT"))=%ut("LOC")_XTGUISEP_"ERROR"_XTGUISEP_$S(+$SY=47:$ZS,1:$ZE)
"RTN","ut",255,0)
 . Q
"RTN","ut",256,0)
 S @($S(+$SY=47:"$ZS",1:"$ZE")_"="_""""""),$EC=""
"RTN","ut",257,0)
 Q
"RTN","ut",258,0)
 ;
"RTN","ut",259,0)
ERROR1 ;
"RTN","ut",260,0)
 I $G(%ut("BREAK")) BREAK  ; if we are asked to break upon error, please do so!
"RTN","ut",261,0)
 ; ZEXCEPT: %utERRL -CREATED IN SETUP, KILLED IN END
"RTN","ut",262,0)
 ; ZEXCEPT: %ut  -- NEWED ON ENTRY
"RTN","ut",263,0)
 D SETIO^%ut1
"RTN","ut",264,0)
 W !,%ut("ENT")," - " W:%ut("NAME")'="" %ut("NAME")," - Error: " W $S(+$SY=47:$ZS,1:$ZE),! D
"RTN","ut",265,0)
 . S %ut("ERRN")=%ut("ERRN")+1,%utERRL(%ut("ERRN"))=%ut("NAME"),%utERRL(%ut("FAIL"),"MSG")=$S(+$SY=47:$ZS,1:$ZE),%utERRL(%ut("FAIL"),"ENTRY")=%ut("ENT")
"RTN","ut",266,0)
 . Q
"RTN","ut",267,0)
 D RESETIO^%ut1
"RTN","ut",268,0)
 Q
"RTN","ut",269,0)
 ;
"RTN","ut",270,0)
ISUTEST() ; .SUPPORTED API TO DETERMINE IF CURRENTLY IN UNIT TEST
"RTN","ut",271,0)
 ; ZEXCEPT: %ut  -- NEWED ON ENTRY
"RTN","ut",272,0)
 Q $G(%ut)=1
"RTN","ut",273,0)
 ;
"RTN","ut",274,0)
PICKSET ; .OPT Interactive selection of MUnit Test Group
"RTN","ut",275,0)
 N DIC,Y,%utROU,%utLIST,DIR
"RTN","ut",276,0)
 I '$$ISUTEST^%ut() S DIC=17.9001,DIC(0)="AEQM" D ^DIC Q:Y'>0  W ! D GETSET(+Y,.%utROU,.%utLIST) N DIC,Y,%ut D SETUT D EN1(.%utROU,%utLIST) S DIR(0)="EA",DIR("A")="Enter RETURN to continue:" D ^DIR K DIR
"RTN","ut",277,0)
 Q
"RTN","ut",278,0)
 ;
"RTN","ut",279,0)
RUNSET(SETNAME,VERBOSE) ; .SR Run with Specified Selection of MUnit Test Group
"RTN","ut",280,0)
 N Y,%utROU,%utLIST,%utVERB
"RTN","ut",281,0)
 Q:$G(SETNAME)=""
"RTN","ut",282,0)
 S %utVERB=$G(VERBOSE,0)
"RTN","ut",283,0)
 S Y=+$$FIND1^DIC(17.9001,"","X",SETNAME) Q:Y'>0
"RTN","ut",284,0)
 D GETSET(Y,.%utROU,.%utLIST)
"RTN","ut",285,0)
 N Y,SETNAME,%ut
"RTN","ut",286,0)
 D SETUT
"RTN","ut",287,0)
 D EN1(.%utROU,%utLIST)
"RTN","ut",288,0)
 Q
"RTN","ut",289,0)
 ;
"RTN","ut",290,0)
 ; DOSET CAN BE USED TO RUN A SET OF TESTS BASED ON THE IEN IN THE MUNIT TEST GROUP file (#17.9001)
"RTN","ut",291,0)
DOSET(IEN,%utVERB) ; 140731 JLI added %utVERB as a second argument
"RTN","ut",292,0)
 ; IEN - Internal entry number for selected set of tests in the MUNIT TEST GROUP file (#17.9001)
"RTN","ut",293,0)
 ; %utVERB - optional input that indicates verbose output is permitted
"RTN","ut",294,0)
 ;
"RTN","ut",295,0)
 N %utROU,%utLIST
"RTN","ut",296,0)
 I '$D(%utVERB) S %utVERB=0
"RTN","ut",297,0)
 S %utLIST=0
"RTN","ut",298,0)
 D GETSET($G(IEN),.%utROU,.%utLIST)
"RTN","ut",299,0)
 I %utLIST>0  N IEN,%ut D SETUT,EN1(.%utROU,%utLIST)
"RTN","ut",300,0)
 Q
"RTN","ut",301,0)
 ;
"RTN","ut",302,0)
GETSET(IEN,%utROU,%utLIST) ;  JLI 140731 - called from PICKSET, RUNSET, DOSET, GUISET
"RTN","ut",303,0)
 N IENS,%utROOT
"RTN","ut",304,0)
 S IENS=IEN_"," D GETS^DIQ(17.9001,IENS,"1*","","%utROOT")
"RTN","ut",305,0)
 S %utLIST=0,IENS="" F  S IENS=$O(%utROOT(17.90011,IENS)) Q:IENS=""  S %utLIST=%utLIST+1,%utROU(%utLIST)=%utROOT(17.90011,IENS,.01)
"RTN","ut",306,0)
 Q
"RTN","ut",307,0)
 ;
"RTN","ut",308,0)
COV(NMSP,COVCODE,VERBOSITY) ; simply make it callable from %ut1 as well (along with other APIs) JLI 150101
"RTN","ut",309,0)
 D COV^%ut1(NMSP,COVCODE,+$G(VERBOSITY)) ; see COV^%ut1 for description of arguments
"RTN","ut",310,0)
 Q
"RTN","ut",311,0)
 ;
"RTN","ut",312,0)
MULTAPIS(TESTROUS) ; .SR - RUN TESTS FOR SPECIFIED ROUTINES AND ENTRY POINTS
"RTN","ut",313,0)
 ; input - TESTROUS - passed by reference
"RTN","ut",314,0)
 ; see TESTONLY in routine %utcover for full description of TESTROUS argument
"RTN","ut",315,0)
 D MULTAPIS^%utcover(.TESTROUS) ; RUN TESTS FOR SPECIFIED ROUTINES AND ENTRY POINTS
"RTN","ut",316,0)
 Q
"RTN","ut",317,0)
 ;
"RTN","ut",318,0)
COVERAGE(ROUNMSP,TESTROUS,XCLDROUS,RESLTLVL)    ;.SR - run coverage analysis for multiple routines and entry points
"RTN","ut",319,0)
 ; input ROUNMSP
"RTN","ut",320,0)
 ; input TESTROUS - passed by reference
"RTN","ut",321,0)
 ; input XCLDROUS - passed by reference
"RTN","ut",322,0)
 ; input RESLTLVL
"RTN","ut",323,0)
 ; see COVERAGE in routine %utcover for full description of arguments
"RTN","ut",324,0)
 D COVERAGE^%utcover(ROUNMSP,.TESTROUS,.XCLDROUS,+$G(RESLTLVL))
"RTN","ut",325,0)
 Q
"RTN","ut",326,0)
 ;
"RTN","ut",327,0)
GETUTVAL(UTDATA) ; .SR - returns totals for current unit test data in cumulative totals
"RTN","ut",328,0)
 ; usage   D GETUTVAL^%ut(.UTDATA)
"RTN","ut",329,0)
 ; input - UTDATA - passed by reference
"RTN","ut",330,0)
 ;
"RTN","ut",331,0)
 ; subscripted values returned:
"RTN","ut",332,0)
 ;   1) cumulative number of routines run;  2) cumulative number of entry tags;
"RTN","ut",333,0)
 ;   3) cumulative number of tests;         4) cummulative number of failures;
"RTN","ut",334,0)
 ;   5) cumulative number of errors
"RTN","ut",335,0)
 N VALS,I,VAL
"RTN","ut",336,0)
 S VALS=$G(^TMP("%ut",$J,"UTVALS")) I VALS="" Q
"RTN","ut",337,0)
 F I=1:1 S VAL=$P(VALS,U,I) Q:VAL=""  S UTDATA(I)=$G(UTDATA(I))+VAL
"RTN","ut",338,0)
 K ^TMP("%ut",$J,"UTVALS")
"RTN","ut",339,0)
 Q
"RTN","ut",340,0)
 ;
"RTN","ut",341,0)
LSTUTVAL(UTDATA) ; .SR - lists cumulative totals in UTDATA array
"RTN","ut",342,0)
 ; usage   D LSTUTVAL^%ut(.UTDATA)
"RTN","ut",343,0)
 ; input - UTDATA - passed by reference
"RTN","ut",344,0)
 W !!!,"------------ SUMMARY ------------"
"RTN","ut",345,0)
 W !,"Ran ",UTDATA(1)," Routine",$S(UTDATA(1)>1:"s",1:""),", ",UTDATA(2)," Entry Tag",$S(UTDATA(2)>1:"s",1:"")
"RTN","ut",346,0)
 W !,"Checked ",UTDATA(3)," test",$S(UTDATA(3)>1:"s",1:""),", with ",UTDATA(4)," failure",$S(UTDATA(4)'=1:"s",1:"")," and encountered ",UTDATA(5)," error",$S(UTDATA(5)'=1:"s",1:""),"."
"RTN","ut",347,0)
 Q
"RTN","ut",348,0)
 ;
"RTN","ut",349,0)
 ;
"RTN","ut",350,0)
GUISET(%utRSLT,XTSET) ; Entry point for GUI start with selected Test Set IEN - called by %ut-TEST GROUP LOAD rpc
"RTN","ut",351,0)
 N %utROU,%utLIST,%ut
"RTN","ut",352,0)
 D SETUT
"RTN","ut",353,0)
 S %ut("RSLT")=$NA(^TMP("MUNIT-%utRSLT",$J)) K @%ut("RSLT")
"RTN","ut",354,0)
 D GETSET(XTSET,.%utROU,.%utLIST)
"RTN","ut",355,0)
 D GETLIST(.%utROU,%utLIST,%ut("RSLT"))
"RTN","ut",356,0)
 S @%ut("RSLT")@(1)=(@%ut("RSLT")@(1))_"^1" ; 110719 mark as new version
"RTN","ut",357,0)
 S %utRSLT=%ut("RSLT")
"RTN","ut",358,0)
 Q
"RTN","ut",359,0)
 ;
"RTN","ut",360,0)
GUILOAD(%utRSLT,%utROUN) ; Entry point for GUI start with %utROUN containing primary routine name - called by %ut-TEST LOAD rpc
"RTN","ut",361,0)
 N %utROU,%ut
"RTN","ut",362,0)
 D SETUT
"RTN","ut",363,0)
 S %ut("RSLT")=$NA(^TMP("MUNIT-%utRSLT",$J)) K @%ut("RSLT")
"RTN","ut",364,0)
 S %utROU(1)=%utROUN
"RTN","ut",365,0)
 D GETLIST(.%utROU,1,%ut("RSLT"))
"RTN","ut",366,0)
 S @%ut("RSLT")@(1)=(@%ut("RSLT")@(1))_"^1" ; 110719 mark as new version
"RTN","ut",367,0)
 S %utRSLT=%ut("RSLT")
"RTN","ut",368,0)
 Q
"RTN","ut",369,0)
 ;
"RTN","ut",370,0)
GETLIST(%utROU,%utLIST,%utRSLT) ; called from GUISET, GUILOAD
"RTN","ut",371,0)
 N I,%utROUL,%utROUN,%ut,XTCOMNT,XTVALUE,%utCNT
"RTN","ut",372,0)
 S XTVALUE=$NA(^TMP("GUI-MUNIT",$J)) K @XTVALUE
"RTN","ut",373,0)
 S %utCNT=0,XTCOMNT=""
"RTN","ut",374,0)
 D GETTREE^%ut1(.%utROU,%utLIST)
"RTN","ut",375,0)
 F I=1:1 Q:'$D(%utROU(I))  S %utROUL(%utROU(I))=""
"RTN","ut",376,0)
 S %utROUN="" F  S %utROUN=$O(%utROUL(%utROUN)) Q:%utROUN=""  D LOAD(%utROUN,.%utCNT,XTVALUE,XTCOMNT,.%utROUL)
"RTN","ut",377,0)
 M @%utRSLT=@XTVALUE
"RTN","ut",378,0)
 K @%utRSLT@("SHUTDOWN")
"RTN","ut",379,0)
 K @%utRSLT@("STARTUP")
"RTN","ut",380,0)
 S @XTVALUE@("LASTROU")="" ; Use this to keep track of place in routines
"RTN","ut",381,0)
 Q
"RTN","ut",382,0)
 ;
"RTN","ut",383,0)
 ; generate list of unit test routines, entry points and comments on test for entry point
"RTN","ut",384,0)
LOAD(%utROUN,%utNCNT,XTVALUE,XTCOMNT,%utROUL) ; called from GETLIST, and recursively from LOAD
"RTN","ut",385,0)
 I $T(@("^"_%utROUN))="" S %utNCNT=%utNCNT+1,@XTVALUE@(%utNCNT)=%utROUN_"^^*** ERROR - ROUTINE NAME NOT FOUND" Q
"RTN","ut",386,0)
 S %utNCNT=%utNCNT+1,@XTVALUE@(%utNCNT)=%utROUN_U_U_XTCOMNT
"RTN","ut",387,0)
 ;N %utI,XTX1,XTX2,LINE
"RTN","ut",388,0)
 N %utI,XTX1,XTX2,LINE,LIST,I
"RTN","ut",389,0)
 ; 100622 JLI added code to identify STARTUP and TEARDOWN
"RTN","ut",390,0)
 I $T(@("STARTUP^"_%utROUN))'="",'$D(@XTVALUE@("STARTUP")) S @XTVALUE@("STARTUP")="STARTUP^"_%utROUN
"RTN","ut",391,0)
 I $T(@("SHUTDOWN^"_%utROUN))'="",'$D(@XTVALUE@("SHUTDOWN")) S @XTVALUE@("SHUTDOWN")="SHUTDOWN^"_%utROUN
"RTN","ut",392,0)
 ; JLI 140731 handle @TEST identified test tags
"RTN","ut",393,0)
 D NEWSTYLE^%ut1(.LIST,%utROUN)
"RTN","ut",394,0)
 F I=1:1:LIST S %utNCNT=%utNCNT+1,@XTVALUE@(%utNCNT)=%utROUN_U_LIST(I)
"RTN","ut",395,0)
 ; JLI 140731 end of @TEST addition
"RTN","ut",396,0)
 F %utI=1:1 S LINE=$T(@("XTENT+"_%utI_"^"_%utROUN)) S XTX1=$P(LINE,";",3) Q:XTX1=""  S XTX2=$P(LINE,";",4),%utNCNT=%utNCNT+1,@XTVALUE@(%utNCNT)=%utROUN_U_XTX1_U_XTX2
"RTN","ut",397,0)
 F %utI=1:1 S LINE=$T(@("XTROU+"_%utI_"^"_%utROUN)) S XTX1=$P(LINE,";",3) Q:XTX1=""  S XTCOMNT=$P(LINE,";",4) I '$D(%utROUL(XTX1)) S %utROUL(XTX1)="" D LOAD(XTX1,.%utNCNT,XTVALUE,XTCOMNT,.%utROUL)
"RTN","ut",398,0)
 Q
"RTN","ut",399,0)
 ;
"RTN","ut",400,0)
GUINEXT(%utRSLT,%utLOC,XTGUISEP) ; Entry point for GUI execute next test - called by %ut-TEST NEXT rpc
"RTN","ut",401,0)
 ; XTGUISEP - added 110719 to provide for changing separator for GUI
"RTN","ut",402,0)
 ;            return from ^ to another value ~~^~~  so that data returned
"RTN","ut",403,0)
 ;            is not affected by ^ values in the data - if not present
"RTN","ut",404,0)
 ;            sets value to default ^
"RTN","ut",405,0)
 N %utETRY,%utROUT,XTOLROU,XTVALUE,%utERR,%utGUI
"RTN","ut",406,0)
 N %ut
"RTN","ut",407,0)
 I $G(XTGUISEP)="" S XTGUISEP="^"
"RTN","ut",408,0)
 D SETUT
"RTN","ut",409,0)
 S %ut("LOC")=%utLOC
"RTN","ut",410,0)
 S %ut("CURR")=0,%ut("ECNT")=0,%ut("FAIL")=0,%ut("CHK")=0,%ut("NENT")=0,%ut("ERRN")=0
"RTN","ut",411,0)
 S XTVALUE=$NA(^TMP("GUI-MUNIT",$J))
"RTN","ut",412,0)
 S %ut("RSLT")=$NA(^TMP("GUINEXT",$J)) K @%ut("RSLT")
"RTN","ut",413,0)
 S %utRSLT=%ut("RSLT")
"RTN","ut",414,0)
 S %utETRY=$P(%utLOC,U),%utROUT=$P(%utLOC,U,2),XTOLROU=$G(@XTVALUE@("LASTROU"))
"RTN","ut",415,0)
 S %utGUI=1
"RTN","ut",416,0)
 S %ut("CHK")=0,%ut("CNT")=1,%utERR=0
"RTN","ut",417,0)
 ; I %utROUT'=XTOLROU D  I %utROUT="" S @%utRSLT@(1)="" K @XTVALUE Q  ;140731 JLI - commented out
"RTN","ut",418,0)
 ;D  I %utROUT="" S @%utRSLT@(1)="" K @XTVALUE Q  ; 140731 JLI - replaced previous line - moves check for SHUTDOWN at end of processing
"RTN","ut",419,0)
 D  I %utROUT="" S @%utRSLT@(1)="" Q  ; 141018 JLI - Have to leave XTVALUE intact, in case they simply run again for STARTUP, etc.
"RTN","ut",420,0)
 . I XTOLROU="",$D(@XTVALUE@("STARTUP")) D
"RTN","ut",421,0)
 . . S %ut("LOC")=@XTVALUE@("STARTUP")
"RTN","ut",422,0)
 . . N $ETRAP S $ETRAP="D ERROR^%ut"
"RTN","ut",423,0)
 . . D @(@XTVALUE@("STARTUP"))
"RTN","ut",424,0)
 . . Q
"RTN","ut",425,0)
 . S @XTVALUE@("LASTROU")=%utROUT I %utROUT'="",$T(@("SETUP^"_%utROUT))'="" D
"RTN","ut",426,0)
 . . S %ut("LOC")="SETUP^"_%utROUT
"RTN","ut",427,0)
 . . N $ETRAP S $ETRAP="D ERROR^%ut"
"RTN","ut",428,0)
 . . D @("SETUP^"_%utROUT)
"RTN","ut",429,0)
 . . Q
"RTN","ut",430,0)
 . I %utROUT="",$D(@XTVALUE@("SHUTDOWN")) D
"RTN","ut",431,0)
 . . S %ut("LOC")=@XTVALUE@("SHUTDOWN")
"RTN","ut",432,0)
 . . N $ETRAP S $ETRAP="D ERROR^%ut"
"RTN","ut",433,0)
 . . D @(@XTVALUE@("SHUTDOWN"))
"RTN","ut",434,0)
 . . Q
"RTN","ut",435,0)
 . Q
"RTN","ut",436,0)
 S %ut("LOC")=%utLOC
"RTN","ut",437,0)
 S %ut("CHK")=0,%ut("CNT")=1,%utERR=0
"RTN","ut",438,0)
 D  ; to limit range of error trap so we continue through other tests
"RTN","ut",439,0)
 . N $ETRAP S $ETRAP="D ERROR^%ut"
"RTN","ut",440,0)
 . D @%ut("LOC")
"RTN","ut",441,0)
 . Q
"RTN","ut",442,0)
 I $T(@("TEARDOWN^"_%utROUT))'="" D
"RTN","ut",443,0)
 . S %ut("LOC")="TEARDOWN^"_%utROUT
"RTN","ut",444,0)
 . N $ETRAP S $ETRAP="D ERROR^%ut"
"RTN","ut",445,0)
 . D @("TEARDOWN^"_%utROUT)
"RTN","ut",446,0)
 . Q
"RTN","ut",447,0)
 S @%ut("RSLT")@(1)=%ut("CHK")_XTGUISEP_(%ut("CNT")-1-%utERR)_XTGUISEP_%utERR
"RTN","ut",448,0)
 K ^TMP("%ut",$J,"UTVALS")
"RTN","ut",449,0)
 Q
"RTN","ut",450,0)
 ;
"RTN","ut1")
0^2^B226313375
"RTN","ut1",1,0)
%ut1 ;VEN/SMH/JLI - CONTINUATION OF M-UNIT PROCESSING ;12/16/15  08:38
"RTN","ut1",2,0)
 ;;1.3;MASH UTILITIES;;Dec 16, 2015;Build 4
"RTN","ut1",3,0)
 ; Submitted to OSEHRA Dec 16, 2015 by Joel L. Ivey under the Apache 2 license (http://www.apache.org/licenses/LICENSE-2.0.html)
"RTN","ut1",4,0)
 ; Original routine authored by Joel L. Ivey as XTMUNIT1 while working for U.S. Department of Veterans Affairs 2003-2012
"RTN","ut1",5,0)
 ; Includes addition of original COV entry and code related coverage analysis as well as other substantial additions authored by Sam Habiel 07/2013?04/2014
"RTN","ut1",6,0)
 ; Additions and modifications made by Joel L. Ivey 05/2014-12/2015
"RTN","ut1",7,0)
 ;
"RTN","ut1",8,0)
 D ^%utt6 ; runs unit tests from several perspectives
"RTN","ut1",9,0)
 Q
"RTN","ut1",10,0)
 ;
"RTN","ut1",11,0)
 ;following is original header from XTMUNIT1 in unreleased patch XT*7.3*81 VA code
"RTN","ut1",12,0)
 ;XTMUNIT1    ;JLI/FO-OAK-CONTINUATION OF UNIT TEST ROUTINE ;2014-04-17  5:26 PM
"RTN","ut1",13,0)
 ;;7.3;TOOLKIT;**81**;APR 25 1995;Build 24
"RTN","ut1",14,0)
 ;
"RTN","ut1",15,0)
 ;
"RTN","ut1",16,0)
 ; Original by Dr. Joel Ivey
"RTN","ut1",17,0)
 ; Major contributions by Dr. Sam Habiel
"RTN","ut1",18,0)
 ;
"RTN","ut1",19,0)
 ;
"RTN","ut1",20,0)
CHEKTEST(%utROU,%ut,%utUETRY) ; Collect Test list.
"RTN","ut1",21,0)
 ; %utROU - input - Name of routine to check for tags with @TEST attribute
"RTN","ut1",22,0)
 ; %ut - input/output - passed by reference
"RTN","ut1",23,0)
 ; %utUETRY - input/output - passed by reference
"RTN","ut1",24,0)
 ;
"RTN","ut1",25,0)
 ; Test list collected in two ways:
"RTN","ut1",26,0)
 ; - @TEST on labellines
"RTN","ut1",27,0)
 ; - Offsets of XTENT
"RTN","ut1",28,0)
 ;
"RTN","ut1",29,0)
 S %ut("ENTN")=0 ; Number of test, sub to %utUETRY.
"RTN","ut1",30,0)
 ;
"RTN","ut1",31,0)
 ; This stanza and everything below is for collecting @TEST.
"RTN","ut1",32,0)
 ; VEN/SMH - block refactored to use $TEXT instead of ^%ZOSF("LOAD")
"RTN","ut1",33,0)
 N I,LIST
"RTN","ut1",34,0)
 S I=$L($T(@(U_%utROU))) I I<0 Q "-1^Invalid Routine Name"
"RTN","ut1",35,0)
 D NEWSTYLE(.LIST,%utROU)
"RTN","ut1",36,0)
 F I=1:1:LIST S %ut("ENTN")=%ut("ENTN")+1,%utUETRY(%ut("ENTN"))=$P(LIST(I),U),%utUETRY(%ut("ENTN"),"NAME")=$P(LIST(I),U,2,99)
"RTN","ut1",37,0)
 ;
"RTN","ut1",38,0)
 ; This Stanza is to collect XTENT offsets
"RTN","ut1",39,0)
 N %utUI F %utUI=1:1 S %ut("ELIN")=$T(@("XTENT+"_%utUI_"^"_%utROU)) Q:$P(%ut("ELIN"),";",3)=""  D
"RTN","ut1",40,0)
 . S %ut("ENTN")=%ut("ENTN")+1,%utUETRY(%ut("ENTN"))=$P(%ut("ELIN"),";",3),%utUETRY(%ut("ENTN"),"NAME")=$P(%ut("ELIN"),";",4)
"RTN","ut1",41,0)
 . Q
"RTN","ut1",42,0)
 ;
"RTN","ut1",43,0)
 QUIT
"RTN","ut1",44,0)
 ;
"RTN","ut1",45,0)
 ; VEN/SMH 26JUL2013 - Moved GETTREE here.
"RTN","ut1",46,0)
GETTREE(%utROU,%utULIST) ;
"RTN","ut1",47,0)
 ; first get any other routines this one references for running subsequently
"RTN","ut1",48,0)
 ; then any that they refer to as well
"RTN","ut1",49,0)
 ; this builds a tree of all routines referred to by any routine including each only once
"RTN","ut1",50,0)
 N %utUK,%utUI,%utUJ,%utURNAM,%utURLIN
"RTN","ut1",51,0)
 F %utUK=1:1 Q:'$D(%utROU(%utUK))  D
"RTN","ut1",52,0)
 . F %utUI=1:1 S %utURLIN=$T(@("XTROU+"_%utUI_"^"_%utROU(%utUK))) S %utURNAM=$P(%utURLIN,";",3) Q:%utURNAM=""  D
"RTN","ut1",53,0)
 . . F %utUJ=1:1:%utULIST I %utROU(%utUJ)=%utURNAM S %utURNAM="" Q
"RTN","ut1",54,0)
 . . I %utURNAM'="",$T(@("+1^"_%utURNAM))="" W:'$D(XWBOS) "Referenced routine ",%utURNAM," not found.",! Q
"RTN","ut1",55,0)
 . . S:%utURNAM'="" %utULIST=%utULIST+1,%utROU(%utULIST)=%utURNAM
"RTN","ut1",56,0)
 QUIT
"RTN","ut1",57,0)
 ;
"RTN","ut1",58,0)
NEWSTYLE(LIST,ROUNAME) ; JLI 140726 identify and return list of newstyle tags or entries for this routine
"RTN","ut1",59,0)
 ; LIST - input, passed by reference - returns containing array with list of tags identified as tests
"RTN","ut1",60,0)
 ;                   LIST indicates number of tags identified, LIST(n)=tag^test_info where tag is entry point for test
"RTN","ut1",61,0)
 ; ROUNAME - input - routine name in which tests should be identified
"RTN","ut1",62,0)
 ;
"RTN","ut1",63,0)
 N I,VALUE,LINE
"RTN","ut1",64,0)
 K LIST S LIST=0
"RTN","ut1",65,0)
 ; search routine by line for a tag and @TEST declaration
"RTN","ut1",66,0)
 F I=1:1 S LINE=$T(@("+"_I_"^"_ROUNAME)) Q:LINE=""  S VALUE=$$CHECKTAG(LINE) I VALUE'="" S LIST=LIST+1,LIST(LIST)=VALUE
"RTN","ut1",67,0)
 Q
"RTN","ut1",68,0)
 ;
"RTN","ut1",69,0)
CHECKTAG(LINE) ; JLI 140726 check line to determine @test TAG
"RTN","ut1",70,0)
 ; LINE - input - Line of code to be checked
"RTN","ut1",71,0)
 ; returns null line if not @TEST line, otherwise TAG^NOTE
"RTN","ut1",72,0)
 N TAG,NOTE,CHAR
"RTN","ut1",73,0)
 I $E(LINE)=" " Q "" ; test entry must have a tag
"RTN","ut1",74,0)
 I $$UP(LINE)'["@TEST" Q "" ; must have @TEST declaration
"RTN","ut1",75,0)
 I $P($$UP(LINE),"@TEST")["(" Q "" ; can't have an argument
"RTN","ut1",76,0)
 S TAG=$P(LINE," "),LINE=$P(LINE," ",2,400),NOTE=$P($$UP(LINE),"@TEST"),LINE=$E(LINE,$L(NOTE)+5+1,$L(LINE))
"RTN","ut1",77,0)
 F  Q:NOTE=""  S CHAR=$E(NOTE),NOTE=$E(NOTE,2,$L(NOTE)) I " ;"'[CHAR Q  ;
"RTN","ut1",78,0)
 I $L(NOTE)'=0 Q "" ; @TEST must be first text on line
"RTN","ut1",79,0)
 F  Q:$E(LINE)'=" "  S LINE=$E(LINE,2,$L(LINE)) ; remove leading spaces from test info
"RTN","ut1",80,0)
 S TAG=TAG_U_LINE
"RTN","ut1",81,0)
 Q TAG
"RTN","ut1",82,0)
 ;
"RTN","ut1",83,0)
FAIL(XTERMSG) ; Entry point for generating a failure message
"RTN","ut1",84,0)
 ; ZEXCEPT: %utERRL,%utGUI -CREATED IN SETUP, KILLED IN END
"RTN","ut1",85,0)
 ; ZEXCEPT: %ut  -- NEWED ON ENTRY
"RTN","ut1",86,0)
 ; ZEXCEPT: XTGUISEP - newed in GUINEXT
"RTN","ut1",87,0)
 I $G(XTERMSG)="" S XTERMSG="no failure message provided"
"RTN","ut1",88,0)
 S %ut("CHK")=%ut("CHK")+1
"RTN","ut1",89,0)
 I '$D(%utGUI) D
"RTN","ut1",90,0)
 . D SETIO
"RTN","ut1",91,0)
 . W !,%ut("ENT")," - " W:%ut("NAME")'="" %ut("NAME")," - " W XTERMSG,! D
"RTN","ut1",92,0)
 . . S %ut("FAIL")=%ut("FAIL")+1,%utERRL(%ut("FAIL"))=%ut("NAME"),%utERRL(%ut("FAIL"),"MSG")=XTERMSG,%utERRL(%ut("FAIL"),"ENTRY")=%ut("ENT")
"RTN","ut1",93,0)
 . . I $D(%ut("BREAK")) BREAK  ; Break upon failure
"RTN","ut1",94,0)
 . . Q
"RTN","ut1",95,0)
 . D RESETIO
"RTN","ut1",96,0)
 . Q
"RTN","ut1",97,0)
 I $D(%utGUI) S %ut("CNT")=%ut("CNT")+1,@%ut("RSLT")@(%ut("CNT"))=%ut("LOC")_XTGUISEP_"FAILURE"_XTGUISEP_XTERMSG,%ut("FAIL")=%ut("FAIL")+1
"RTN","ut1",98,0)
 Q
"RTN","ut1",99,0)
 ;
"RTN","ut1",100,0)
NVLDARG(API) ; generate message for invalid arguments to test
"RTN","ut1",101,0)
 N XTERMSG
"RTN","ut1",102,0)
 ; ZEXCEPT: %ut  -- NEWED ON ENTRY
"RTN","ut1",103,0)
 ; ZEXCEPT: %utERRL,%utGUI -CREATED IN SETUP, KILLED IN END
"RTN","ut1",104,0)
 ; ZEXCEPT: XTGUISEP - newed in GUINEXT
"RTN","ut1",105,0)
 S XTERMSG="NO VALUES INPUT TO "_API_"^%ut - no evaluation possible"
"RTN","ut1",106,0)
 I '$D(%utGUI) D
"RTN","ut1",107,0)
 . D SETIO
"RTN","ut1",108,0)
 . W !,%ut("ENT")," - " W:%ut("NAME")'="" %ut("NAME")," - " W XTERMSG,! D
"RTN","ut1",109,0)
 . . S %ut("FAIL")=%ut("FAIL")+1,%utERRL(%ut("FAIL"))=%ut("NAME"),%utERRL(%ut("FAIL"),"MSG")=XTERMSG,%utERRL(%ut("FAIL"),"ENTRY")=%ut("ENT")
"RTN","ut1",110,0)
 . . Q
"RTN","ut1",111,0)
 . D RESETIO
"RTN","ut1",112,0)
 . Q
"RTN","ut1",113,0)
 I $D(%utGUI) S %ut("CNT")=%ut("CNT")+1,@%ut("RSLT")@(%ut("CNT"))=%ut("LOC")_XTGUISEP_"FAILURE"_XTGUISEP_XTERMSG,%ut("FAIL")=%ut("FAIL")+1
"RTN","ut1",114,0)
 Q
"RTN","ut1",115,0)
 ;
"RTN","ut1",116,0)
SETIO ; Set M-Unit Device to write the results to...
"RTN","ut1",117,0)
 ; ZEXCEPT: %ut  -- NEWED ON ENTRY
"RTN","ut1",118,0)
 I $IO'=%ut("IO") S (IO(0),%ut("DEV","OLD"))=$IO USE %ut("IO") SET IO=$IO
"RTN","ut1",119,0)
 QUIT
"RTN","ut1",120,0)
 ;
"RTN","ut1",121,0)
RESETIO ; Reset $IO back to the original device if we changed it.
"RTN","ut1",122,0)
 ; ZEXCEPT: %ut  -- NEWED ON ENTRY
"RTN","ut1",123,0)
 I $D(%ut("DEV","OLD")) S IO(0)=%ut("IO") U %ut("DEV","OLD") S IO=$IO K %ut("DEV","OLD")
"RTN","ut1",124,0)
 QUIT
"RTN","ut1",125,0)
 ;
"RTN","ut1",126,0)
 ; VEN/SMH 17DEC2013 - Remove dependence on VISTA - Uppercase here instead of XLFSTR.
"RTN","ut1",127,0)
UP(X) ;
"RTN","ut1",128,0)
 Q $TR(X,"abcdefghijklmnopqrstuvwxyz","ABCDEFGHIJKLMNOPQRSTUVWXYZ")
"RTN","ut1",129,0)
 ;
"RTN","ut1",130,0)
COV(NMSP,COVCODE,VERBOSITY) ; VEN/SMH - PUBLIC ENTRY POINT; Coverage calculations
"RTN","ut1",131,0)
 ; NMSP: Namespace of the routines to analyze. End with * to include all routines.
"RTN","ut1",132,0)
 ;       Not using * will only include the routine with NMSP name.
"RTN","ut1",133,0)
 ;       e.g. PSOM* will include all routines starting with PSOM
"RTN","ut1",134,0)
 ;            PSOM will only include PSOM.
"RTN","ut1",135,0)
 ; COVCODE: Mumps code to run over which coverage will be calculated. Typically Unit Tests.
"RTN","ut1",136,0)
 ; VERBOSITY (optional): Scalar from -1 to 3.
"RTN","ut1",137,0)
 ;    - -1 = Global output in ^TMP("%utCOVREPORT",$J)
"RTN","ut1",138,0)
 ;    - 0 = Print only total coverage
"RTN","ut1",139,0)
 ;    - 1 = Break down by routine
"RTN","ut1",140,0)
 ;    - 2 = Break down by routine and tag
"RTN","ut1",141,0)
 ;    - 3 = Break down by routine and tag, and print lines that didn't execute for each tag.
"RTN","ut1",142,0)
 ;
"RTN","ut1",143,0)
 ; ZEXCEPT: %utcovxx - SET and KILLED in this code at top level
"RTN","ut1",144,0)
 ; ZEXCEPT: %Monitor,%apiOBJ,DecomposeStatus,LineByLine,Start,Stop,System,class - not variables parts of classes
"RTN","ut1",145,0)
 N COVER,COVERSAV,I,NMSP1,RTN,RTNS,ERR,STATUS
"RTN","ut1",146,0)
 I (+$SY=47) D  ; GT.M only!
"RTN","ut1",147,0)
 . N %ZR ; GT.M specific
"RTN","ut1",148,0)
 . D SILENT^%RSEL(NMSP,"SRC") ; GT.M specific. On Cache use $O(^$R(RTN)).
"RTN","ut1",149,0)
 . N RN S RN=""
"RTN","ut1",150,0)
 . W !,"Loading routines to test coverage...",!
"RTN","ut1",151,0)
 . F  S RN=$O(%ZR(RN)) Q:RN=""  W RN," " D
"RTN","ut1",152,0)
 . . N L2 S L2=$T(+2^@RN)
"RTN","ut1",153,0)
 . . S L2=$TR(L2,$C(9,32)) ; Translate spaces and tabs out
"RTN","ut1",154,0)
 . . I $E(L2,1,2)'=";;" K %ZR(RN)  ; Not a human produced routine
"RTN","ut1",155,0)
 . ;
"RTN","ut1",156,0)
 . M RTNS=%ZR
"RTN","ut1",157,0)
 . K %ZR
"RTN","ut1",158,0)
 . Q
"RTN","ut1",159,0)
 ;
"RTN","ut1",160,0)
 I (+$SY=0) D  ; CACHE SPECIFIC
"RTN","ut1",161,0)
 . S NMSP1=NMSP I NMSP["*" S NMSP1=$P(NMSP,"*")
"RTN","ut1",162,0)
 . I $D(^$R(NMSP1)) S RTNS(NMSP1)=""
"RTN","ut1",163,0)
 . I NMSP["*" S RTN=NMSP1 F  S RTN=$O(^$R(RTN)) Q:RTN'[NMSP1  S RTNS(RTN)=""
"RTN","ut1",164,0)
 . Q
"RTN","ut1",165,0)
 ;
"RTN","ut1",166,0)
 ; ZEXCEPT: CTRAP - not really a variable
"RTN","ut1",167,0)
 S VERBOSITY=+$G(VERBOSITY) ; Get 0 if not passed.
"RTN","ut1",168,0)
 ;
"RTN","ut1",169,0)
 ;
"RTN","ut1",170,0)
 N GL
"RTN","ut1",171,0)
 S GL=$NA(^TMP("%utCOVCOHORT",$J))
"RTN","ut1",172,0)
 I '$D(^TMP("%utcovrunning",$J)) K @GL
"RTN","ut1",173,0)
 D RTNANAL(.RTNS,GL) ; save off any current coverage data
"RTN","ut1",174,0)
 I '$D(^TMP("%utcovrunning",$J)) N EXIT S EXIT=0 D  Q:EXIT
"RTN","ut1",175,0)
 . K ^TMP("%utCOVCOHORTSAV",$J)
"RTN","ut1",176,0)
 . M ^TMP("%utCOVCOHORTSAV",$J)=^TMP("%utCOVCOHORT",$J)
"RTN","ut1",177,0)
 . K ^TMP("%utCOVRESULT",$J)
"RTN","ut1",178,0)
 . S ^TMP("%utcovrunning",$J)=1,%utcovxx=1
"RTN","ut1",179,0)
 . ;
"RTN","ut1",180,0)
 . I (+$SY=47) VIEW "TRACE":1:$NA(^TMP("%utCOVRESULT",$J))  ; GT.M START PROFILING
"RTN","ut1",181,0)
 . ;
"RTN","ut1",182,0)
 . I (+$SY=0) D  ; CACHE CODE TO START PROFILING
"RTN","ut1",183,0)
 . . S STATUS=##class(%Monitor.System.LineByLine).Start($lb(NMSP),$lb("RtnLine"),$lb($j))
"RTN","ut1",184,0)
 . . I +STATUS'=1 D DecomposeStatus^%apiOBJ(STATUS,.ERR,"-d") F I=1:1:ERR W ERR(I),!
"RTN","ut1",185,0)
 . . I +STATUS'=1 K ERR S EXIT=1
"RTN","ut1",186,0)
 . . Q
"RTN","ut1",187,0)
 . Q
"RTN","ut1",188,0)
 DO  ; Run the code, but keep our variables to ourselves.
"RTN","ut1",189,0)
 . NEW $ETRAP,$ESTACK
"RTN","ut1",190,0)
 . I (+$SY=47) D  ; GT.M SPECIFIC
"RTN","ut1",191,0)
 . . SET $ETRAP="Q:($ES&$Q) -9 Q:$ES  W ""CTRL-C ENTERED"""
"RTN","ut1",192,0)
 . . USE $PRINCIPAL:(CTRAP=$C(3))
"RTN","ut1",193,0)
 . . Q
"RTN","ut1",194,0)
 . NEW (DUZ,IO,COVCODE,U,DILOCKTM,DISYS,DT,DTIME,IOBS,IOF,IOM,ION,IOS,IOSL,IOST,IOT,IOXY)
"RTN","ut1",195,0)
 . XECUTE COVCODE
"RTN","ut1",196,0)
 . Q
"RTN","ut1",197,0)
 ; GT.M STOP PROFILING if this is the original level that started it
"RTN","ut1",198,0)
 I $D(^TMP("%utcovrunning",$J)),$D(%utcovxx) D
"RTN","ut1",199,0)
 . I (+$SY=47) VIEW "TRACE":0:$NA(^TMP("%utCOVRESULT",$J)) ; GT.M SPECIFIC
"RTN","ut1",200,0)
 . I (+$SY=0) ; CACHE SPECIFIC
"RTN","ut1",201,0)
 . K %utcovxx,^TMP("%utcovrunning",$J)
"RTN","ut1",202,0)
 . Q
"RTN","ut1",203,0)
 ;
"RTN","ut1",204,0)
 I '$D(^TMP("%utcovrunning",$J)) D
"RTN","ut1",205,0)
 . I (+$SY=0) D  ; CACHE SPECIFIC CODE
"RTN","ut1",206,0)
 . . S COVERSAV=$NA(^TMP("%utCOVCOHORTSAV",$J)) K @COVERSAV
"RTN","ut1",207,0)
 . . S COVER=$NA(^TMP("%utCOVCOHORT",$J)) K @COVER
"RTN","ut1",208,0)
 . . D CACHECOV(COVERSAV,COVER)
"RTN","ut1",209,0)
 . . D TOTAGS(COVERSAV,0),TOTAGS(COVER,1)
"RTN","ut1",210,0)
 . . D ##class(%Monitor.System.LineByLine).Stop()
"RTN","ut1",211,0)
 . . Q
"RTN","ut1",212,0)
 . D COVCOV($NA(^TMP("%utCOVCOHORT",$J)),$NA(^TMP("%utCOVRESULT",$J))) ; Venn diagram matching between globals
"RTN","ut1",213,0)
 . ; Report
"RTN","ut1",214,0)
 . I VERBOSITY=-1 D
"RTN","ut1",215,0)
 . . K ^TMP("%utCOVREPORT",$J)
"RTN","ut1",216,0)
 . . D COVRPTGL($NA(^TMP("%utCOVCOHORTSAV",$J)),$NA(^TMP("%utCOVCOHORT",$J)),$NA(^TMP("%utCOVRESULT",$J)),$NA(^TMP("%utCOVREPORT",$J)))
"RTN","ut1",217,0)
 . . Q
"RTN","ut1",218,0)
 . E  D COVRPT($NA(^TMP("%utCOVCOHORTSAV",$J)),$NA(^TMP("%utCOVCOHORT",$J)),$NA(^TMP("%utCOVRESULT",$J)),VERBOSITY)
"RTN","ut1",219,0)
 . Q
"RTN","ut1",220,0)
 QUIT
"RTN","ut1",221,0)
 ;
"RTN","ut1",222,0)
CACHECOV(GLOBSAV,GLOB) ;
"RTN","ut1",223,0)
 ; ZEXCEPT: %Monitor,GetMetrics,GetRoutineCount,GetRoutineName,LineByLine,System,class - not variable names, part of classes
"RTN","ut1",224,0)
 N DIF,I,METRIC,METRICNT,METRICS,MTRICNUM,ROUNAME,ROUNUM,X,XCNP,XXX
"RTN","ut1",225,0)
 I $$ISUTEST(),'$D(^TMP("%utt4val",$J)) S ROUNUM=1,METRICS="RtnLine",METRICNT=1,ROUNAME="%ut"
"RTN","ut1",226,0)
 I $D(^TMP("%utt4val",$J))!'$$ISUTEST() S ROUNUM=##class(%Monitor.System.LineByLine).GetRoutineCount(),METRICS=##class(%Monitor.System.LineByLine).GetMetrics(),METRICNT=$l(METRICS,",")
"RTN","ut1",227,0)
 ; if only running to do coverage, should be 1
"RTN","ut1",228,0)
 S MTRICNUM=0 F I=1:1:METRICNT S METRIC=$P(METRICS,",",I) I METRIC="RtnLine" S MTRICNUM=I Q
"RTN","ut1",229,0)
 ;
"RTN","ut1",230,0)
 F I=1:1:ROUNUM D
"RTN","ut1",231,0)
 . I $D(^TMP("%utt4val",$J))!'$$ISUTEST() S ROUNAME=##class(%Monitor.System.LineByLine).GetRoutineName(I)
"RTN","ut1",232,0)
 . ; get routine loaded into location
"RTN","ut1",233,0)
 . S DIF=$NA(@GLOBSAV@(ROUNAME)),DIF=$E(DIF,1,$L(DIF)-1)_",",XCNP=0,X=ROUNAME
"RTN","ut1",234,0)
 . X ^%ZOSF("LOAD")
"RTN","ut1",235,0)
 . M @GLOB@(ROUNAME)=@GLOBSAV@(ROUNAME)
"RTN","ut1",236,0)
 . Q
"RTN","ut1",237,0)
 ;
"RTN","ut1",238,0)
 I $D(^TMP("%utt4val",$J))!'$$ISUTEST() F XXX=1:1:ROUNUM D GETVALS(XXX,GLOB,MTRICNUM)
"RTN","ut1",239,0)
 Q
"RTN","ut1",240,0)
 ;
"RTN","ut1",241,0)
GETVALS(ROUNUM,GLOB,MTRICNUM) ; get data on number of times a line seen (set into VAL)
"RTN","ut1",242,0)
 ; ZEXCEPT: %Monitor,%New,%ResultSet,Execute,GetData,GetRoutineName,LineByLine,Next,System,class - not variables parts of Cache classes
"RTN","ut1",243,0)
 N LINE,MORE,ROUNAME,RSET,VAL,X
"RTN","ut1",244,0)
 ;
"RTN","ut1",245,0)
 S RSET=##class(%ResultSet).%New("%Monitor.System.LineByLine:Result")
"RTN","ut1",246,0)
 S ROUNAME=##class(%Monitor.System.LineByLine).GetRoutineName(ROUNUM)
"RTN","ut1",247,0)
 S LINE=RSET.Execute(ROUNAME)
"RTN","ut1",248,0)
 F LINE=1:1 S MORE=RSET.Next() Q:'MORE  D
"RTN","ut1",249,0)
 . S X=RSET.GetData(1)
"RTN","ut1",250,0)
 . S VAL=$LI(X,MTRICNUM)
"RTN","ut1",251,0)
 . S @GLOB@(ROUNAME,LINE,"C")=+VAL ; values are 0 if not seen, otherwises positive number
"RTN","ut1",252,0)
 . Q
"RTN","ut1",253,0)
 D RSET.Close()
"RTN","ut1",254,0)
 Q
"RTN","ut1",255,0)
 ;
"RTN","ut1",256,0)
TOTAGS(GLOBAL,ACTIVE) ; convert to lines from tags and set value only if not seen
"RTN","ut1",257,0)
 N ACTIVCOD,LINE,LINENUM,ROU,ROUCODE
"RTN","ut1",258,0)
 S ROU="" F  S ROU=$O(@GLOBAL@(ROU)) Q:ROU=""  D
"RTN","ut1",259,0)
 . M ROUCODE(ROU)=@GLOBAL@(ROU) K @GLOBAL@(ROU)
"RTN","ut1",260,0)
 . N TAG,OFFSET,OLDTAG S TAG="",OFFSET=0,OLDTAG=""
"RTN","ut1",261,0)
 . F LINENUM=1:1 Q:'$D(ROUCODE(ROU,LINENUM,0))  D
"RTN","ut1",262,0)
 . . S LINE=ROUCODE(ROU,LINENUM,0)
"RTN","ut1",263,0)
 . . S ACTIVCOD=$$LINEDATA(LINE,.TAG,.OFFSET)
"RTN","ut1",264,0)
 . . I TAG'=OLDTAG S @GLOBAL@(ROU,TAG)=TAG
"RTN","ut1",265,0)
 . . I ACTIVE,ACTIVCOD,(+$G(ROUCODE(ROU,LINENUM,"C"))'>0) S @GLOBAL@(ROU,TAG,OFFSET)=LINE
"RTN","ut1",266,0)
 . . I 'ACTIVE,ACTIVCOD S @GLOBAL@(ROU,TAG,OFFSET)=LINE
"RTN","ut1",267,0)
 . . Q
"RTN","ut1",268,0)
 . Q
"RTN","ut1",269,0)
 Q
"RTN","ut1",270,0)
 ;
"RTN","ut1",271,0)
LINEDATA(LINE,TAG,OFFSET) ;
"RTN","ut1",272,0)
 ; LINE   - input - the line of code
"RTN","ut1",273,0)
 ; TAG    - passed by reference -
"RTN","ut1",274,0)
 ; OFFSET - passed by reference
"RTN","ut1",275,0)
 N CODE,NEWTAG
"RTN","ut1",276,0)
 S NEWTAG=""
"RTN","ut1",277,0)
 S OFFSET=$G(OFFSET)+1
"RTN","ut1",278,0)
 F  Q:$E(LINE,1)=" "  Q:$E(LINE,1)=$C(9)  Q:LINE=""  S NEWTAG=NEWTAG_$E(LINE,1),LINE=$E(LINE,2,$L(LINE))
"RTN","ut1",279,0)
 S NEWTAG=$P(NEWTAG,"(")
"RTN","ut1",280,0)
 I NEWTAG'="" S TAG=NEWTAG,OFFSET=0
"RTN","ut1",281,0)
 S CODE=1
"RTN","ut1",282,0)
 F  S:(LINE="")!($E(LINE)=";") CODE=0 Q:'CODE  Q:(" ."'[$E(LINE))  S LINE=$E(LINE,2,$L(LINE))
"RTN","ut1",283,0)
 Q CODE
"RTN","ut1",284,0)
 ;
"RTN","ut1",285,0)
RTNANAL(RTNS,GL) ; [Private] - Routine Analysis
"RTN","ut1",286,0)
 ; Create a global similar to the trace global produced by GT.M in GL
"RTN","ut1",287,0)
 ; Only non-comment lines are stored.
"RTN","ut1",288,0)
 ; A tag is always stored. Tag,0 is stored only if there is code on the tag line (format list or actual code).
"RTN","ut1",289,0)
 ; tags by themselves don't count toward the total.
"RTN","ut1",290,0)
 ;
"RTN","ut1",291,0)
 N RTN S RTN=""
"RTN","ut1",292,0)
 F  S RTN=$O(RTNS(RTN)) Q:RTN=""  D                       ; for each routine
"RTN","ut1",293,0)
 . N TAG
"RTN","ut1",294,0)
 . S TAG=RTN                                              ; start the tags at the first
"RTN","ut1",295,0)
 . N I,LN F I=2:1 S LN=$T(@TAG+I^@RTN) Q:LN=""  D         ; for each line, starting with the 3rd line (2 off the first tag)
"RTN","ut1",296,0)
 . . I $E(LN)?1A D  QUIT                                  ; formal line
"RTN","ut1",297,0)
 . . . N T                                                ; Terminator
"RTN","ut1",298,0)
 . . . N J F J=1:1:$L(LN) S T=$E(LN,J) Q:T'?1AN           ; Loop to...
"RTN","ut1",299,0)
 . . . S TAG=$E(LN,1,J-1)                                 ; Get tag
"RTN","ut1",300,0)
 . . . S @GL@(RTN,TAG)=TAG                                ; store line
"RTN","ut1",301,0)
 . . . ;I T="(" S @GL@(RTN,TAG,0)=LN                      ; formal list
"RTN","ut1",302,0)
 . . . I T="(" D                                          ; formal list
"RTN","ut1",303,0)
 . . . . N PCNT,STR,CHR S PCNT=0,STR=$E(LN,J+1,$L(LN))
"RTN","ut1",304,0)
 . . . . F  S CHR=$E(STR),STR=$E(STR,2,$L(STR)) Q:(PCNT=0)&(CHR=")")  D
"RTN","ut1",305,0)
 . . . . . I CHR="(" S PCNT=PCNT+1
"RTN","ut1",306,0)
 . . . . . I CHR=")" S PCNT=PCNT-1
"RTN","ut1",307,0)
 . . . . . Q
"RTN","ut1",308,0)
 . . . . S STR=$TR(STR,$C(9,32))
"RTN","ut1",309,0)
 . . . . I $E(STR)=";" QUIT
"RTN","ut1",310,0)
 . . . . S @GL@(RTN,TAG,0)=LN
"RTN","ut1",311,0)
 . . . . Q
"RTN","ut1",312,0)
 . . . E  D                                               ; No formal list
"RTN","ut1",313,0)
 . . . . N LNTR S LNTR=$P(LN,TAG,2,999),LNTR=$TR(LNTR,$C(9,32)) ; Get rest of line, Remove spaces and tabs
"RTN","ut1",314,0)
 . . . . I $E(LNTR)=";" QUIT                              ; Comment
"RTN","ut1",315,0)
 . . . . S @GL@(RTN,TAG,0)=LN                             ; Otherwise, store for testing
"RTN","ut1",316,0)
 . . . S I=0                                              ; Start offsets from zero (first one at the for will be 1)
"RTN","ut1",317,0)
 . . I $C(32,9)[$E(LN) D  QUIT                            ; Regular line
"RTN","ut1",318,0)
 . . . N LNTR S LNTR=$TR(LN,$C(32,9,46))                     ; Remove all spaces and tabs - JLI 150202 remove periods as well
"RTN","ut1",319,0)
 . . . I $E(LNTR)=";" QUIT                                ; Comment line -- don't want.
"RTN","ut1",320,0)
 . . . S @GL@(RTN,TAG,I)=LN                               ; Record line
"RTN","ut1",321,0)
 QUIT
"RTN","ut1",322,0)
 ;
"RTN","ut1",323,0)
ACTLINES(GL) ; [Private] $$ ; Count active lines
"RTN","ut1",324,0)
 ;
"RTN","ut1",325,0)
 N CNT S CNT=0
"RTN","ut1",326,0)
 N REF S REF=GL
"RTN","ut1",327,0)
 N GLQL S GLQL=$QL(GL)
"RTN","ut1",328,0)
 F  S REF=$Q(@REF) Q:REF=""  Q:(GL'=$NA(@REF,GLQL))  D
"RTN","ut1",329,0)
 . N REFQL S REFQL=$QL(REF)
"RTN","ut1",330,0)
 . N LASTSUB S LASTSUB=$QS(REF,REFQL)
"RTN","ut1",331,0)
 . I LASTSUB?1.N S CNT=CNT+1
"RTN","ut1",332,0)
 QUIT CNT
"RTN","ut1",333,0)
 ;
"RTN","ut1",334,0)
COVCOV(C,R) ; [Private] - Analyze coverage Cohort vs Result
"RTN","ut1",335,0)
 N RTN S RTN=""
"RTN","ut1",336,0)
 F  S RTN=$O(@C@(RTN)) Q:RTN=""  D  ; For each routine in cohort set
"RTN","ut1",337,0)
 . I '$D(@R@(RTN)) QUIT             ; Not present in result set
"RTN","ut1",338,0)
 . N TAG S TAG=""
"RTN","ut1",339,0)
 . F  S TAG=$O(@R@(RTN,TAG)) Q:TAG=""  D  ; For each tag in the routine in the result set
"RTN","ut1",340,0)
 . . N LN S LN=""
"RTN","ut1",341,0)
 . . F  S LN=$O(@R@(RTN,TAG,LN)) Q:LN=""  D  ; for each line in the tag in the routine in the result set
"RTN","ut1",342,0)
 . . . I $D(@C@(RTN,TAG,LN)) K ^(LN)  ; if present in cohort, kill off
"RTN","ut1",343,0)
 QUIT
"RTN","ut1",344,0)
 ;
"RTN","ut1",345,0)
COVRPT(C,S,R,V) ; [Private] - Coverage Report
"RTN","ut1",346,0)
 ; C = COHORT    - Global name
"RTN","ut1",347,0)
 ; S = SURVIVORS - Global name
"RTN","ut1",348,0)
 ; R = RESULT    - Global name
"RTN","ut1",349,0)
 ; V = Verbosity - Scalar from -1 to 3
"RTN","ut1",350,0)
 ; JLI 150702 -  modified to be able to do unit tests on setting up the text via COVRPTLS
"RTN","ut1",351,0)
 N X,I
"RTN","ut1",352,0)
 S X=$NA(^TMP("%ut1-covrpt",$J)) K @X
"RTN","ut1",353,0)
 D COVRPTLS(C,S,R,V,X)
"RTN","ut1",354,0)
 I '$$ISUTEST^%ut() F I=1:1 W:$D(@X@(I)) !,@X@(I) I '$D(@X@(I)) K @X Q
"RTN","ut1",355,0)
 Q
"RTN","ut1",356,0)
 ;
"RTN","ut1",357,0)
COVRPTLS(C,S,R,V,X) ;
"RTN","ut1",358,0)
 ;
"RTN","ut1",359,0)
 N LINNUM S LINNUM=0
"RTN","ut1",360,0)
 N ORIGLINES S ORIGLINES=$$ACTLINES(C)
"RTN","ut1",361,0)
 N LEFTLINES S LEFTLINES=$$ACTLINES(S)
"RTN","ut1",362,0)
 ;W !!
"RTN","ut1",363,0)
 S LINNUM=LINNUM+1,@X@(LINNUM)="",LINNUM=LINNUM+1,@X@(LINNUM)=""
"RTN","ut1",364,0)
 ;W "ORIG: "_ORIGLINES,!
"RTN","ut1",365,0)
 S LINNUM=LINNUM+1,@X@(LINNUM)="ORIG: "_ORIGLINES
"RTN","ut1",366,0)
 ;W "LEFT: "_LEFTLINES,!
"RTN","ut1",367,0)
 S LINNUM=LINNUM+1,@X@(LINNUM)="LEFT: "_LEFTLINES
"RTN","ut1",368,0)
 ;W "COVERAGE PERCENTAGE: "_$S(ORIGLINES:$J(ORIGLINES-LEFTLINES/ORIGLINES*100,"",2),1:100.00),!
"RTN","ut1",369,0)
 S LINNUM=LINNUM+1,@X@(LINNUM)="COVERAGE PERCENTAGE: "_$S(ORIGLINES:$J((ORIGLINES-LEFTLINES)/ORIGLINES*100,"",2),1:100.00)
"RTN","ut1",370,0)
 ;W !!
"RTN","ut1",371,0)
 S LINNUM=LINNUM+1,@X@(LINNUM)="",LINNUM=LINNUM+1,@X@(LINNUM)=""
"RTN","ut1",372,0)
 ;W "BY ROUTINE:",!
"RTN","ut1",373,0)
 S LINNUM=LINNUM+1,@X@(LINNUM)="BY ROUTINE:"
"RTN","ut1",374,0)
 I V=0 QUIT  ; No verbosity. Don't print routine detail
"RTN","ut1",375,0)
 N RTN S RTN=""
"RTN","ut1",376,0)
 F  S RTN=$O(@C@(RTN)) Q:RTN=""  D
"RTN","ut1",377,0)
 . N O S O=$$ACTLINES($NA(@C@(RTN)))
"RTN","ut1",378,0)
 . N L S L=$$ACTLINES($NA(@S@(RTN)))
"RTN","ut1",379,0)
 . ;W ?3,RTN,?21,$S(O:$J(O-L/O*100,"",2),1:"100.00"),!
"RTN","ut1",380,0)
 . N XX,XY S XX="  "_RTN_"                    ",XX=$E(XX,1,12)
"RTN","ut1",381,0)
 . S XY="        "_$S(O:$J((O-L)/O*100,"",2)_"%",1:"------"),XY=$E(XY,$L(XY)-11,$L(XY))
"RTN","ut1",382,0)
 . ;S LINNUM=LINNUM+1,@X@(LINNUM)=XX_$S(O:$J((O-L)/O*100,"",2)_"%",1:"------")_"  "_(O-L)_" out of "_O
"RTN","ut1",383,0)
 . S LINNUM=LINNUM+1,@X@(LINNUM)=XX_XY_"  "_(O-L)_" out of "_O
"RTN","ut1",384,0)
 . I V=1 QUIT  ; Just print the routine coverage for V=1
"RTN","ut1",385,0)
 . N TAG S TAG=""
"RTN","ut1",386,0)
 . F  S TAG=$O(@C@(RTN,TAG)) Q:TAG=""  D
"RTN","ut1",387,0)
 . . N O S O=$$ACTLINES($NA(@C@(RTN,TAG)))
"RTN","ut1",388,0)
 . . N L S L=$$ACTLINES($NA(@S@(RTN,TAG)))
"RTN","ut1",389,0)
 . . ;W ?5,TAG,?21,$S(O:$J(O-L/O*100,"",2),1:"100.00"),!
"RTN","ut1",390,0)
 . . S XX="    "_TAG_"                  ",XX=$E(XX,1,20)
"RTN","ut1",391,0)
 . . ;S XY="        ("_(O-L)_"/"_O_")",XY=$E(XY,$L(XY)-11,$L(XY)),XX=XX_XY
"RTN","ut1",392,0)
 . . S XY="      "_$S(O:$J((O-L)/O*100,"",2)_"%",1:"------"),XY=$E(XY,$L(XY)-7,$L(XY))
"RTN","ut1",393,0)
 . . S LINNUM=LINNUM+1,@X@(LINNUM)=XX_XY_"  "_(O-L)_" out of "_O
"RTN","ut1",394,0)
 . . I V=2 QUIT  ; Just print routine/tags coverage for V=2; V=3 print uncovered lines
"RTN","ut1",395,0)
 . . N LN S LN=""
"RTN","ut1",396,0)
 . . ;F  S LN=$O(@S@(RTN,TAG,LN)) Q:LN=""  W TAG_"+"_LN_": "_^(LN),!
"RTN","ut1",397,0)
 . . F  S LN=$O(@S@(RTN,TAG,LN)) Q:LN=""  S LINNUM=LINNUM+1,@X@(LINNUM)=TAG_"+"_LN_": "_^(LN)
"RTN","ut1",398,0)
 . . Q
"RTN","ut1",399,0)
 . Q
"RTN","ut1",400,0)
 QUIT
"RTN","ut1",401,0)
 ;
"RTN","ut1",402,0)
COVRPTGL(C,S,R,OUT) ; [Private] - Coverage Global for silent invokers
"RTN","ut1",403,0)
 ; C = COHORT    - Global name
"RTN","ut1",404,0)
 ; S = SURVIVORS - Global name
"RTN","ut1",405,0)
 ; R = RESULT    - Global name
"RTN","ut1",406,0)
 ; OUT = OUTPUT  - Global name
"RTN","ut1",407,0)
 ;
"RTN","ut1",408,0)
 N O S O=$$ACTLINES(C)
"RTN","ut1",409,0)
 N L S L=$$ACTLINES(S)
"RTN","ut1",410,0)
 S @OUT=(O-L)_"/"_O
"RTN","ut1",411,0)
 N RTN,TAG,LN S (RTN,TAG,LN)=""
"RTN","ut1",412,0)
 F  S RTN=$O(@C@(RTN)) Q:RTN=""  D
"RTN","ut1",413,0)
 . N O S O=$$ACTLINES($NA(@C@(RTN)))
"RTN","ut1",414,0)
 . N L S L=$$ACTLINES($NA(@S@(RTN)))
"RTN","ut1",415,0)
 . S @OUT@(RTN)=(O-L)_"/"_O
"RTN","ut1",416,0)
 . F  S TAG=$O(@C@(RTN,TAG)) Q:TAG=""  D
"RTN","ut1",417,0)
 . . N O S O=$$ACTLINES($NA(@C@(RTN,TAG)))
"RTN","ut1",418,0)
 . . N L S L=$$ACTLINES($NA(@S@(RTN,TAG)))
"RTN","ut1",419,0)
 . . S @OUT@(RTN,TAG)=(O-L)_"/"_O
"RTN","ut1",420,0)
 . . F  S LN=$O(@S@(RTN,TAG,LN)) Q:LN=""  S @OUT@(RTN,TAG,LN)=@S@(RTN,TAG,LN)
"RTN","ut1",421,0)
 QUIT
"RTN","ut1",422,0)
 ;
"RTN","ut1",423,0)
ISUTEST() ;
"RTN","ut1",424,0)
 Q $$ISUTEST^%ut()
"RTN","utcover")
0^3^B52893402
"RTN","utcover",1,0)
%utcover ;JLI - generic coverage and unit test runner ;12/16/15  08:42
"RTN","utcover",2,0)
 ;;1.3;MASH UTILITIES;;Dec 16, 2015;Build 4
"RTN","utcover",3,0)
 ; Submitted to OSEHRA Dec 16, 2015 by Joel L. Ivey under the Apache 2 license (http://www.apache.org/licenses/LICENSE-2.0.html)
"RTN","utcover",4,0)
 ; Original routine authored by Joel L. Ivey 08/15.  Additional work 08/15-12/15.
"RTN","utcover",5,0)
 ;
"RTN","utcover",6,0)
 ; Changes:  (Moved from %ut and %ut1)
"RTN","utcover",7,0)
 ; 130726 SMH - Moved test collection logic from %utUNIT to here (multiple places)
"RTN","utcover",8,0)
 ; 131218 SMH - dependence on XLFSTR removed
"RTN","utcover",9,0)
 ; 131218 SMH - CHEKTEST refactored to use $TEXT instead of ^%ZOSF("LOAD")
"RTN","utcover",10,0)
 ; 131218 SMH - CATCHERR now nulls out $ZS if on GT.M
"RTN","utcover",11,0)
 ;
"RTN","utcover",12,0)
 ; ------- COMMENTS moved from %ut due to space requirements
"RTN","utcover",13,0)
 ;
"RTN","utcover",14,0)
 ; 100622 JLI - corrected typo in comments where %utINPT was listed as %utINP
"RTN","utcover",15,0)
 ; 100622 JLI - removed a comment which indicated data could potentially be returned from the called routine
"RTN","utcover",16,0)
 ;              in the %utINPT array.
"RTN","utcover",17,0)
 ; 100622 JLI - added code to handle STARTUP and SHUTDOWN from GUI app
"RTN","utcover",18,0)
 ; 110719 JLI - modified separators in GUI handling from ^ to ~~^~~
"RTN","utcover",19,0)
 ;              in the variable XTGUISEP if using a newer version of the
"RTN","utcover",20,0)
 ;              GUI app (otherwise, it is simply set to ^) since results
"RTN","utcover",21,0)
 ;              with a series of ^ embedded disturbed the output reported
"RTN","utcover",22,0)
 ; 130726 SMH - Fixed SETUP and TEARDOWN so that they run before/after each
"RTN","utcover",23,0)
 ;              test rather than once. General refactoring.
"RTN","utcover",24,0)
 ; 130726 SMH - SETUT initialized IO in case it's not there to $P. Inits vars
"RTN","utcover",25,0)
 ;              using DT^DICRW.
"RTN","utcover",26,0)
 ; 131217 SMH - Change call in SETUP to S U="^" instead of DT^DICRW
"RTN","utcover",27,0)
 ; 131218 SMH - Any checks to $ZE will also check $ZS for GT.M.
"RTN","utcover",28,0)
 ; 131218 SMH - Remove calls to %ZISUTL to manage devices to prevent dependence on VISTA.
"RTN","utcover",29,0)
 ;              Use %utNIT("DEV","OLD") for old devices
"RTN","utcover",30,0)
 ; 140109 SMH - Add parameter %utBREAK - Break upon error
"RTN","utcover",31,0)
 ; 1402   SMH - Break will cause the break to happen even on failed tests.
"RTN","utcover",32,0)
 ; 140401 SMH - Added Succeed entry point for take it into your hands tester.
"RTN","utcover",33,0)
 ; 140401 SMH - Reformatted the output of M-Unit so that the test's name
"RTN","utcover",34,0)
 ;              will print BEFORE the execution of the test. This has been
"RTN","utcover",35,0)
 ;              really confusing for beginning users of M-Unit, so this was
"RTN","utcover",36,0)
 ;              necessary.
"RTN","utcover",37,0)
 ; 140401 SMH - OK message gets printed at the end of --- as [OK].
"RTN","utcover",38,0)
 ; 140401 SMH - FAIL message now prints. Previously, OK failed to be printed.
"RTN","utcover",39,0)
 ;              Unfortunately, that's rather passive aggressive. Now it
"RTN","utcover",40,0)
 ;              explicitly says that a test failed.
"RTN","utcover",41,0)
 ; 140503 SMH - Fixed IO issues all over the routine. Much simpler now.
"RTN","utcover",42,0)
 ; 140731 JLI - Combined routine changes between JLI and SMH
"RTN","utcover",43,0)
 ;              Moved routines from %utNIT and %utNIT1 to %ut and %ut1
"RTN","utcover",44,0)
 ;              Updated unit test routines (%utt1 to %utt6)
"RTN","utcover",45,0)
 ;              Created M-UNIT TEST GROUP file at 17.9001 based on the 17.9001 file
"RTN","utcover",46,0)
 ; 141030 JLI - Removed tag TESTCOVR and code under it, not necessary
"RTN","utcover",47,0)
 ;              since %uttcovr can handle all of the calling needed
"RTN","utcover",48,0)
 ;              Added call to run routine %utt6 if run from the top,
"RTN","utcover",49,0)
 ;              since this will run the full range of unit tests
"RTN","utcover",50,0)
 ;              Modified STARTUP and SHUTDOWN commands to handle in
"RTN","utcover",51,0)
 ;              each routine where they are available, since only
"RTN","utcover",52,0)
 ;              running one STARTUP and SHUTDOWN (the first seen by
"RTN","utcover",53,0)
 ;              the program) restricted their use in suites of multiple
"RTN","utcover",54,0)
 ;              tests.
"RTN","utcover",55,0)
 ; 150101 JLI - Added COV entry to %ut (in addition to current in %ut1) so it is easier
"RTN","utcover",56,0)
 ;              to remember how to use it.
"RTN","utcover",57,0)
 ; 150621 JLI - Added a global location to pick up summary data for a unit test call, so
"RTN","utcover",58,0)
 ;              programs running multiple calls can generate a summary if desired.
"RTN","utcover",59,0)
 ;
"RTN","utcover",60,0)
 ;
"RTN","utcover",61,0)
 D EN^%ut("%uttcovr") ; unit tests
"RTN","utcover",62,0)
 Q
"RTN","utcover",63,0)
 ;
"RTN","utcover",64,0)
MULTAPIS(TESTROUS) ; RUN TESTS FOR SPECIFIED ROUTINES AND ENTRY POINTS
"RTN","utcover",65,0)
 ; can be run from %ut using D MULTAPIS^%ut(.TESTROUS)
"RTN","utcover",66,0)
 ; input TESTROUS - passed by reference - array of routine names to run tests for
"RTN","utcover",67,0)
 ;               specify those to be called directly by including ^ as part of
"RTN","utcover",68,0)
 ;               TAG^ROUTINE or ^ROUTINE.
"RTN","utcover",69,0)
 ;               ROUTINE names without a ^ will be called as EN^%ut("ROUTINE")
"RTN","utcover",70,0)
 ;               Sometimes to get complete coverage, different entry points may
"RTN","utcover",71,0)
 ;               need to be called (e.g., at top and for VERBOSE), these should each
"RTN","utcover",72,0)
 ;               be included.
"RTN","utcover",73,0)
 ;               If the subscript is a number, it will take the list of comma separated
"RTN","utcover",74,0)
 ;               values as the routines.  If the the subscript is not a number, it will
"RTN","utcover",75,0)
 ;               take it as a routine to be added to the list, then if the value of the
"RTN","utcover",76,0)
 ;               contains a comma separated list of routines, they will be added as well.
"RTN","utcover",77,0)
 ;               Thus a value of
"RTN","utcover",78,0)
 ;                 TESTROUS(1)="A^ROU1,^ROU1,^ROU2,ROU3"
"RTN","utcover",79,0)
 ;               or a value of
"RTN","utcover",80,0)
 ;                 TESTROUS("A^ROU1")="^ROU1,^ROU2,ROU3"
"RTN","utcover",81,0)
 ;               will both result in tests for
"RTN","utcover",82,0)
 ;                 D A^ROU1,^ROU1,^ROU2,EN^%ut("ROU3")
"RTN","utcover",83,0)
 K ^TMP("%utcover",$J,"TESTROUS")
"RTN","utcover",84,0)
 M ^TMP("%utcover",$J,"TESTROUS")=TESTROUS
"RTN","utcover",85,0)
 D COVENTRY
"RTN","utcover",86,0)
 K ^TMP("%utcover",$J,"TESTROUS")
"RTN","utcover",87,0)
 Q
"RTN","utcover",88,0)
 ;
"RTN","utcover",89,0)
COVENTRY ; setup of COVERAGE NEWs most variables, so TESTROUS passed by global
"RTN","utcover",90,0)
 ;
"RTN","utcover",91,0)
 N I,ROU,VAL,VALS,UTDATA,TESTS,TESTROUS
"RTN","utcover",92,0)
 M TESTROUS=^TMP("%utcover",$J,"TESTROUS")
"RTN","utcover",93,0)
 S ROU="" F  S ROU=$O(TESTROUS(ROU)) Q:ROU=""  D
"RTN","utcover",94,0)
 . I ROU'=+ROU S TESTS(ROU)=""
"RTN","utcover",95,0)
 . F I=1:1 S VAL=$P(TESTROUS(ROU),",",I) Q:VAL=""  S TESTS(VAL)=""
"RTN","utcover",96,0)
 . Q
"RTN","utcover",97,0)
 S ROU="" F  S ROU=$O(TESTS(ROU)) Q:ROU=""  D
"RTN","utcover",98,0)
 . W !!,"------------------- RUNNING ",ROU," -------------------"
"RTN","utcover",99,0)
 . I ROU[U D @ROU
"RTN","utcover",100,0)
 . I ROU'[U D @("EN^%ut("""_ROU_""")")
"RTN","utcover",101,0)
 . D GETUTVAL^%ut(.UTDATA)
"RTN","utcover",102,0)
 . Q
"RTN","utcover",103,0)
 I $D(UTDATA) D LSTUTVAL^%ut(.UTDATA)
"RTN","utcover",104,0)
 Q
"RTN","utcover",105,0)
 ;
"RTN","utcover",106,0)
COVERAGE(ROUNMSP,TESTROUS,XCLDROUS,RESLTLVL) ; run coverage analysis for multiple routines and entry points
"RTN","utcover",107,0)
 ; can be run from %ut using D COVERAGE^%ut(ROUNMSP,.TESTROUS,.XCLDROUS,RESLTLVL)
"RTN","utcover",108,0)
 ; input ROUNMSP - Namespace for routine(s) to be analyzed
"RTN","utcover",109,0)
 ;                 ROUNAME will result in only the routine ROUNAME being analyzed
"RTN","utcover",110,0)
 ;                 ROUN* will result in all routines beginning with ROUN being analyzed
"RTN","utcover",111,0)
 ; input TESTROUS - passed by reference - see TESTROUS description for JUSTTEST
"RTN","utcover",112,0)
 ; input XCLDROUS - passed by reference - routines passed in a manner similar to TESTROUS,
"RTN","utcover",113,0)
 ;                  but only the routine names, whether as arguments or a comma separated
"RTN","utcover",114,0)
 ;                  list of routines, will be excluded from the analysis of coverage.  These
"RTN","utcover",115,0)
 ;                  would normally be names of routines which are only for unit tests, or
"RTN","utcover",116,0)
 ;                  others which should not be included in the analysis for some reason.
"RTN","utcover",117,0)
 ; input RESLTLVL - This value determines the amount of information to be generated for the
"RTN","utcover",118,0)
 ;                  analysis.  A missing or null value will be considered to be level 1
"RTN","utcover",119,0)
 ;                     1  -  Listing of analysis only for routine overall
"RTN","utcover",120,0)
 ;                     2  -  Listing of analysis for routine overall and for each TAG
"RTN","utcover",121,0)
 ;                     3  -  Full analysis for each tag, and lists out those lines which were
"RTN","utcover",122,0)
 ;                           not executed during the analysis
"RTN","utcover",123,0)
 ;
"RTN","utcover",124,0)
 N I,ROU,TYPE,XCLUDE
"RTN","utcover",125,0)
 S RESLTLVL=$G(RESLTLVL,1)
"RTN","utcover",126,0)
 I (RESLTLVL<1) S RESLTLVL=1
"RTN","utcover",127,0)
 I (RESLTLVL>3) S RESLTLVL=3
"RTN","utcover",128,0)
 M ^TMP("%utcover",$J,"TESTROUS")=TESTROUS ;
"RTN","utcover",129,0)
 D COV^%ut1(ROUNMSP,"D COVENTRY^%utcover",-1)
"RTN","utcover",130,0)
 K ^TMP("%utcover",$J,"TESTROUS")
"RTN","utcover",131,0)
 S ROU="" F  S ROU=$O(XCLDROUS(ROU)) Q:ROU=""  D SETROUS(.XCLUDE,.XCLDROUS,ROU)
"RTN","utcover",132,0)
 N TEXTGLOB S TEXTGLOB=$NA(^TMP("%utcover-text",$J)) K @TEXTGLOB
"RTN","utcover",133,0)
 D LIST(.XCLUDE,RESLTLVL,TEXTGLOB)
"RTN","utcover",134,0)
 F I=1:1 Q:'$D(@TEXTGLOB@(I))  W !,@TEXTGLOB@(I)
"RTN","utcover",135,0)
 K @TEXTGLOB
"RTN","utcover",136,0)
 Q
"RTN","utcover",137,0)
 ;
"RTN","utcover",138,0)
SETROUS(XCLUDE,XCLDROUS,ROU) ;
"RTN","utcover",139,0)
 ; XCLUDE   - passed by reference - on return contains array with indices as routines to exclude from analysis
"RTN","utcover",140,0)
 ; XCLDROUS - passed by referenc - array may contain a comma-delimited list of routines to exclude from analysis
"RTN","utcover",141,0)
 ; ROU      - input - if non-numberic is name of routine to exclude from analysis
"RTN","utcover",142,0)
 N I,VAL
"RTN","utcover",143,0)
 I ROU'=+ROU S XCLUDE(ROU)=""
"RTN","utcover",144,0)
 F I=1:1 S VAL=$P(XCLDROUS(ROU),",",I) Q:VAL=""  S XCLUDE(VAL)=""
"RTN","utcover",145,0)
 Q
"RTN","utcover",146,0)
 ;
"RTN","utcover",147,0)
LIST(XCLDROUS,TYPE,TEXTGLOB,GLOB,LINNUM) ;
"RTN","utcover",148,0)
 ; ZEXCEPT: TYPE1  - NEWed and set below for recursion
"RTN","utcover",149,0)
 ; input - ROULIST - a comma separated list of routine names that will
"RTN","utcover",150,0)
 ;       be used to identify desired routines.  Any name
"RTN","utcover",151,0)
 ;       that begins with one of the specified values will
"RTN","utcover",152,0)
 ;       be included
"RTN","utcover",153,0)
 ; input - TYPE - value indicating amount of detail desired
"RTN","utcover",154,0)
 ;       3=full with listing of untouched lines
"RTN","utcover",155,0)
 ;       2=moderated with listing by tags
"RTN","utcover",156,0)
 ;       1=summary with listing by routine
"RTN","utcover",157,0)
 ; input - TEXTGLOB - closed global location in which text is returned
"RTN","utcover",158,0)
 ; input - GLOB - used for unit tests - specifies global to work with
"RTN","utcover",159,0)
 ;                so that coverage data is not impacted
"RTN","utcover",160,0)
 ;
"RTN","utcover",161,0)
 N CURRCOV,CURRLIN,LINCOV,LINE,LINTOT,ROULIST,ROUNAME,TAG,TOTCOV,TOTLIN,XVAL
"RTN","utcover",162,0)
 ;
"RTN","utcover",163,0)
 I '$D(LINNUM) S LINNUM=0 ; initialize on first entry
"RTN","utcover",164,0)
 I '$D(GLOB) N GLOB S GLOB=$NA(^TMP("%utCOVREPORT",$J))
"RTN","utcover",165,0)
 D TRIMDATA(.XCLDROUS,GLOB) ; remove undesired routines from data
"RTN","utcover",166,0)
 ;
"RTN","utcover",167,0)
 N JOB,NAME,BASE,TEXT,VAL
"RTN","utcover",168,0)
 S TOTCOV=0,TOTLIN=0
"RTN","utcover",169,0)
 ; F NAME="%utCOVREPORT","%utCOVRESULT","%utCOVCOHORT","%utCOVCOHORTSAV" D
"RTN","utcover",170,0)
 I TYPE>1 S ROUNAME="" F  S ROUNAME=$O(@GLOB@(ROUNAME)) Q:ROUNAME=""  S XVAL=^(ROUNAME) D
"RTN","utcover",171,0)
 . S CURRCOV=$P(XVAL,"/"),CURRLIN=$P(XVAL,"/",2)
"RTN","utcover",172,0)
 . S LINNUM=LINNUM+1,@TEXTGLOB@(LINNUM)="",LINNUM=LINNUM+1,@TEXTGLOB@(LINNUM)=""
"RTN","utcover",173,0)
 . S TEXT="Routine "_ROUNAME_"              ",TEXT=$E(TEXT,1,20)
"RTN","utcover",174,0)
 . I CURRLIN>0 S VAL="     ("_$J((100*CURRCOV)/CURRLIN,"",2),VAL=$E(VAL,$L(VAL)-6,$L(VAL))
"RTN","utcover",175,0)
 . S LINNUM=LINNUM+1,@TEXTGLOB@(LINNUM)=TEXT_"   "_$S(CURRLIN>0:VAL_"%)",1:"  ------ ")_"   "_CURRCOV_" out of "_CURRLIN_" lines covered"
"RTN","utcover",176,0)
 . I TYPE>1 S LINNUM=LINNUM+1,@TEXTGLOB@(LINNUM)="  - "_$S(TYPE=2:"Summary",1:"Detailed Breakdown")
"RTN","utcover",177,0)
 . S TAG="" F  S TAG=$O(@GLOB@(ROUNAME,TAG)) Q:TAG=""  S XVAL=^(TAG) D
"RTN","utcover",178,0)
 . . S LINCOV=$P(XVAL,"/"),LINTOT=$P(XVAL,"/",2)
"RTN","utcover",179,0)
 . . S TEXT=" Tag "_TAG_"^"_ROUNAME_"                ",TEXT=$E(TEXT,1,26)
"RTN","utcover",180,0)
 . . I LINTOT>0 S VAL="     ("_$J((100*LINCOV)/LINTOT,"",2),VAL=$E(VAL,$L(VAL)-6,$L(VAL))
"RTN","utcover",181,0)
 . . S LINNUM=LINNUM+1,@TEXTGLOB@(LINNUM)=TEXT_$S(LINTOT>0:VAL_"%)",1:"  ------ ")_"   "_LINCOV_" out of "_LINTOT_" lines covered"
"RTN","utcover",182,0)
 . . I TYPE=2 Q
"RTN","utcover",183,0)
 . . I LINCOV=LINTOT Q
"RTN","utcover",184,0)
 . . S LINNUM=LINNUM+1,@TEXTGLOB@(LINNUM)="   the following is a list of the lines **NOT** covered"
"RTN","utcover",185,0)
 . . S LINE="" F  S LINE=$O(@GLOB@(ROUNAME,TAG,LINE)) Q:LINE=""  D
"RTN","utcover",186,0)
 . . . I LINE=0 S LINNUM=LINNUM+1,@TEXTGLOB@(LINNUM)="     "_TAG_"  "_@GLOB@(ROUNAME,TAG,LINE) Q
"RTN","utcover",187,0)
 . . . S LINNUM=LINNUM+1,@TEXTGLOB@(LINNUM)="     "_TAG_"+"_LINE_"  "_@GLOB@(ROUNAME,TAG,LINE)
"RTN","utcover",188,0)
 . . . Q
"RTN","utcover",189,0)
 . . Q
"RTN","utcover",190,0)
 . Q
"RTN","utcover",191,0)
 ; for type=3 generate a summary at bottom after detail
"RTN","utcover",192,0)
 I TYPE=3 N TYPE1 S TYPE1=2 D LIST(.XCLDROUS,2,TEXTGLOB,GLOB,.LINNUM) K TYPE1
"RTN","utcover",193,0)
 I TYPE=2,$G(TYPE1) Q  ; CAME IN FROM ABOVE LINE
"RTN","utcover",194,0)
 ; summarize by just routine name
"RTN","utcover",195,0)
 S LINNUM=LINNUM+1,@TEXTGLOB@(LINNUM)="",LINNUM=LINNUM+1,@TEXTGLOB@(LINNUM)=""
"RTN","utcover",196,0)
 S ROUNAME="" F  S ROUNAME=$O(@GLOB@(ROUNAME)) Q:ROUNAME=""  S XVAL=^(ROUNAME) D
"RTN","utcover",197,0)
 . S CURRCOV=$P(XVAL,"/"),CURRLIN=$P(XVAL,"/",2)
"RTN","utcover",198,0)
 . S TOTCOV=TOTCOV+CURRCOV,TOTLIN=TOTLIN+CURRLIN
"RTN","utcover",199,0)
 . I CURRLIN>0 S VAL="     ("_$J((100*CURRCOV)/CURRLIN,"",2),VAL=$E(VAL,$L(VAL)-6,$L(VAL))
"RTN","utcover",200,0)
 . S LINNUM=LINNUM+1,@TEXTGLOB@(LINNUM)="Routine "_ROUNAME_"     "_$S(CURRLIN>0:VAL_"%)",1:"  ------ ")_"   "_CURRCOV_" out of "_CURRLIN_" lines covered"
"RTN","utcover",201,0)
 S LINNUM=LINNUM+1,@TEXTGLOB@(LINNUM)="",LINNUM=LINNUM+1,@TEXTGLOB@(LINNUM)=""
"RTN","utcover",202,0)
 S LINNUM=LINNUM+1,@TEXTGLOB@(LINNUM)="Overall Analysis "_TOTCOV_" out of "_TOTLIN_" lines covered"_$S(TOTLIN>0:" ("_$P((100*TOTCOV)/TOTLIN,".")_"% coverage)",1:"")
"RTN","utcover",203,0)
 Q
"RTN","utcover",204,0)
 ;
"RTN","utcover",205,0)
TRIMDATA(ROULIST,GLOB) ;
"RTN","utcover",206,0)
 N ROUNAME
"RTN","utcover",207,0)
 S ROUNAME="" F  S ROUNAME=$O(ROULIST(ROUNAME)) Q:ROUNAME=""  K @GLOB@(ROUNAME)
"RTN","utcover",208,0)
 Q
"RTN","utcover",209,0)
 ;
"RTN","utt1")
0^4^B39370749
"RTN","utt1",1,0)
%utt1 ; VEN/SMH-JLI - Testing routines for M-Unit;12/16/15  08:43
"RTN","utt1",2,0)
 ;;1.3;MASH UTILITIES;;Dec 16, 2015;Build 4
"RTN","utt1",3,0)
 ; Submitted to OSEHRA Dec 16, 2015 by Joel L. Ivey under the Apache 2 license (http://www.apache.org/licenses/LICENSE-2.0.html)
"RTN","utt1",4,0)
 ; Original routine authored by Sam H. Habiel 07/2013-04/2014
"RTN","utt1",5,0)
 ; Additions and modifications made by Joel L. Ivey 05/2014-12/2015
"RTN","utt1",6,0)
 ;
"RTN","utt1",7,0)
 ; THIS ROUTINE IS THE UNIFIED UNIT TESTER FOR ALL OF M-UNIT.
"RTN","utt1",8,0)
 ;
"RTN","utt1",9,0)
 ; Dear Users,
"RTN","utt1",10,0)
 ;
"RTN","utt1",11,0)
 ; I know about about the irony of a test suite for the testing suite,
"RTN","utt1",12,0)
 ; so stop snikering. Aside from that, it's actually going to be hard.
"RTN","utt1",13,0)
 ;
"RTN","utt1",14,0)
 ; Truly yours,
"RTN","utt1",15,0)
 ;
"RTN","utt1",16,0)
 ; Sam H
"RTN","utt1",17,0)
 ;
"RTN","utt1",18,0)
 D EN^%ut($T(+0),1) ; Run tests here, be verbose.
"RTN","utt1",19,0)
 QUIT
"RTN","utt1",20,0)
 ;
"RTN","utt1",21,0)
STARTUP ; M-Unit Start-Up - This runs before anything else.
"RTN","utt1",22,0)
 ; ZEXCEPT: KBANCOUNT - created here, removed in SHUTDOWN
"RTN","utt1",23,0)
 S ^TMP($J,"%ut","STARTUP")=""
"RTN","utt1",24,0)
 S KBANCOUNT=1
"RTN","utt1",25,0)
 QUIT
"RTN","utt1",26,0)
 ;
"RTN","utt1",27,0)
SHUTDOWN ; M-Unit Shutdown - This runs after everything else is done.
"RTN","utt1",28,0)
 ; ZEXCEPT: KBANCOUNT - created in STARTUP, removed here
"RTN","utt1",29,0)
 K ^TMP($J,"%ut","STARTUP")
"RTN","utt1",30,0)
 K KBANCOUNT
"RTN","utt1",31,0)
 QUIT
"RTN","utt1",32,0)
 ;
"RTN","utt1",33,0)
 ;
"RTN","utt1",34,0)
 ;
"RTN","utt1",35,0)
SETUP ; This runs before every test.
"RTN","utt1",36,0)
 ; ZEXCEPT: KBANCOUNT - created in STARTUP, removed in SHUTDOWN
"RTN","utt1",37,0)
 S KBANCOUNT=KBANCOUNT+1
"RTN","utt1",38,0)
 QUIT
"RTN","utt1",39,0)
 ;
"RTN","utt1",40,0)
TEARDOWN ; This runs after every test
"RTN","utt1",41,0)
 ; ZEXCEPT: KBANCOUNT - created in STARTUP, removed in SHUTDOWN
"RTN","utt1",42,0)
 S KBANCOUNT=KBANCOUNT-1
"RTN","utt1",43,0)
 QUIT
"RTN","utt1",44,0)
 ;
"RTN","utt1",45,0)
 ;
"RTN","utt1",46,0)
 ;
"RTN","utt1",47,0)
T1 ; @TEST - Make sure Start-up Ran
"RTN","utt1",48,0)
 D CHKTF($D(^TMP($J,"%ut","STARTUP")),"Start-up node on ^TMP must exist")
"RTN","utt1",49,0)
 QUIT
"RTN","utt1",50,0)
 ;
"RTN","utt1",51,0)
T2 ; @TEST - Make sure Set-up runs
"RTN","utt1",52,0)
 ; ZEXCEPT: KBANCOUNT - created in STARTUP, removed in SHUTDOWN
"RTN","utt1",53,0)
 D CHKEQ(KBANCOUNT,2,"KBANCount not incremented properly at SETUP")
"RTN","utt1",54,0)
 QUIT
"RTN","utt1",55,0)
 ;
"RTN","utt1",56,0)
T3 ; @TEST - Make sure Teardown runs
"RTN","utt1",57,0)
 ; ZEXCEPT: KBANCOUNT - created in STARTUP, removed in SHUTDOWN
"RTN","utt1",58,0)
 D CHKEQ(KBANCOUNT,2,"KBANCount not decremented properly at TEARDOWN")
"RTN","utt1",59,0)
 QUIT
"RTN","utt1",60,0)
 ;
"RTN","utt1",61,0)
T4 ; Specified in XTMTAG
"RTN","utt1",62,0)
 ; 140731 JLI - note that this will fail when run from the GUI runner, since it calls each tag separately
"RTN","utt1",63,0)
 ; ZEXCEPT: %utETRY - newed and created in EN1^%ut
"RTN","utt1",64,0)
 ; ZEXCEPT: %utGUI      -- CONDITIONALLY DEFINED BY GUINEXT^%ut
"RTN","utt1",65,0)
 I $G(%utGUI) D CHKEQ(%utETRY,"T4","T4 should be the value for %utETRY in the GUI Runner")
"RTN","utt1",66,0)
 I '$G(%utGUI) D CHKEQ(%utETRY(4),"T4","T4 should be the collected as the fourth entry in %utETRY")
"RTN","utt1",67,0)
 QUIT
"RTN","utt1",68,0)
 ;
"RTN","utt1",69,0)
T5 ; ditto
"RTN","utt1",70,0)
 ; ZEXCEPT: %ut - NEWed and created in EN1^%ut
"RTN","utt1",71,0)
 D CHKTF(0,"This is an intentional failure.")
"RTN","utt1",72,0)
 D CHKEQ(%ut("FAIL"),1,"By this point, we should have failed one test")
"RTN","utt1",73,0)
 D FAIL^%ut("Intentionally throwing a failure")
"RTN","utt1",74,0)
 D CHKEQ(%ut("FAIL"),2,"By this point, we should have failed two tests")
"RTN","utt1",75,0)
 ; S %ut("FAIL")=0 ; Okay... Boy's and Girls... as the developer I can do that.
"RTN","utt1",76,0)
 QUIT
"RTN","utt1",77,0)
 ;
"RTN","utt1",78,0)
T6 ; ditto
"RTN","utt1",79,0)
 ; ZEXCEPT: %ut - NEWed and created in EN1^%ut
"RTN","utt1",80,0)
 N TESTCOUNT S TESTCOUNT=%ut("CHK")
"RTN","utt1",81,0)
 D SUCCEED^%ut
"RTN","utt1",82,0)
 D SUCCEED^%ut
"RTN","utt1",83,0)
 D CHKEQ(%ut("CHK"),TESTCOUNT+2,"Succeed should increment the number of tests")
"RTN","utt1",84,0)
 QUIT
"RTN","utt1",85,0)
 ;
"RTN","utt1",86,0)
T7 ; Make sure we write to principal even though we are on another device
"RTN","utt1",87,0)
 ; This is a rather difficult test to carry out for GT.M and Cache...
"RTN","utt1",88,0)
 ; ZEXCEPT: GetEnviron,Util,delete,newversion,readonly - not really variables
"RTN","utt1",89,0)
 N D
"RTN","utt1",90,0)
 I +$SY=47 S D="/tmp/test.txt" ; All GT.M ; VMS not supported.
"RTN","utt1",91,0)
 I +$SY=0 D  ; All Cache
"RTN","utt1",92,0)
 . I $ZVERSION(1)=2 S D=$SYSTEM.Util.GetEnviron("temp")_"\test.txt" I 1 ; Windows
"RTN","utt1",93,0)
 . E  S D="/tmp/test.txt" ; not windows; VMS not supported.
"RTN","utt1",94,0)
 I +$SY=0 O D:"NWS" ; Cache new file
"RTN","utt1",95,0)
 I +$SY=47 O D:(newversion) ; GT.M new file
"RTN","utt1",96,0)
 U D
"RTN","utt1",97,0)
 WRITE "HELLO",!
"RTN","utt1",98,0)
 WRITE "HELLO",!
"RTN","utt1",99,0)
 C D
"RTN","utt1",100,0)
 ;
"RTN","utt1",101,0)
 ; Now open back the file, and read the hello, but open in read only so
"RTN","utt1",102,0)
 ; M-Unit will error out if it will write something out there.
"RTN","utt1",103,0)
 ;
"RTN","utt1",104,0)
 I +$SY=0 O D:"R"
"RTN","utt1",105,0)
 I +$SY=47 O D:(readonly)
"RTN","utt1",106,0)
 U D
"RTN","utt1",107,0)
 N X READ X:1
"RTN","utt1",108,0)
 D CHKTF(X="HELLO")  ; This should write to the screen the dot not to the file.
"RTN","utt1",109,0)
 D CHKTF(($$LO($IO)=$$LO(D)),"IO device didn't get reset back")       ; $$LO is b/c of a bug in Cache/Windows. $IO is not the same cas D.
"RTN","utt1",110,0)
 I +$SY=0 C D:"D"
"RTN","utt1",111,0)
 I +$SY=47 C D:(delete)
"RTN","utt1",112,0)
 U $P
"RTN","utt1",113,0)
 S IO=$IO
"RTN","utt1",114,0)
 QUIT
"RTN","utt1",115,0)
 ;
"RTN","utt1",116,0)
 ; At the moment T8^%utt1 throws a fail, with no message
"RTN","utt1",117,0)
 ; in the GUI runner.  For some reason, both X and Y
"RTN","utt1",118,0)
 ; variables are returned as null strings, while in the
"RTN","utt1",119,0)
 ; command line runner, Y has a value containing the
"RTN","utt1",120,0)
 ; word being sought
"RTN","utt1",121,0)
 ;
"RTN","utt1",122,0)
T8 ; If IO starts with another device, write to that device as if it's the pricipal device
"RTN","utt1",123,0)
 ; ZEXCEPT: GetEnviron,Util,delete,newversion,readonly - not really variables
"RTN","utt1",124,0)
 N D
"RTN","utt1",125,0)
 I +$SY=47 S D="/tmp/test.txt" ; All GT.M ; VMS not supported.
"RTN","utt1",126,0)
 I +$SY=0 D  ; All Cache
"RTN","utt1",127,0)
 . I $ZVERSION(1)=2 S D=$SYSTEM.Util.GetEnviron("temp")_"\test.txt" I 1 ; Windows
"RTN","utt1",128,0)
 . E  S D="/tmp/test.txt" ; not windows; VMS not supported.
"RTN","utt1",129,0)
 I +$SY=0 O D:"NWS" ; Cache new file
"RTN","utt1",130,0)
 I +$SY=47 O D:(newversion) ; GT.M new file
"RTN","utt1",131,0)
 S IO=D
"RTN","utt1",132,0)
 U D
"RTN","utt1",133,0)
 D ^%utt4 ; Run some Unit Tests
"RTN","utt1",134,0)
 C D
"RTN","utt1",135,0)
 I +$SY=0 O D:"R" ; Cache read only
"RTN","utt1",136,0)
 I +$SY=47 O D:(readonly) ; GT.M read only
"RTN","utt1",137,0)
 U D
"RTN","utt1",138,0)
 N X,Y,Z R X:1,Y:1,Z:1
"RTN","utt1",139,0)
 I +$SY=0 C D:"D"
"RTN","utt1",140,0)
 I +$SY=47 C D:(delete)
"RTN","utt1",141,0)
 ;D CHKTF(Y["MAIN") ; JLI 140829 commented out, gui doesn't run verbose
"RTN","utt1",142,0)
 D CHKTF((Y["MAIN")!(Z["T2 - Test 2"),"Write to system during test didn't work")
"RTN","utt1",143,0)
 S IO=$P
"RTN","utt1",144,0)
 QUIT
"RTN","utt1",145,0)
 ;
"RTN","utt1",146,0)
COVRPTGL ;
"RTN","utt1",147,0)
 N GL1,GL2,GL3,GL4
"RTN","utt1",148,0)
 S GL1=$NA(^TMP("%utCOVCOHORTSAVx",$J)) K @GL1
"RTN","utt1",149,0)
 S GL2=$NA(^TMP("%utCOVCOHORTx",$J)) K @GL2
"RTN","utt1",150,0)
 S GL3=$NA(^TMP("%utCOVRESULTx",$J)) K @GL3
"RTN","utt1",151,0)
 S GL4=$NA(^TMP("%utCOVREPORTx",$J)) K @GL4
"RTN","utt1",152,0)
 D SETGLOBS^%uttcovr(GL1,GL2)
"RTN","utt1",153,0)
 D COVRPTGL^%ut1(GL1,GL2,GL3,GL4)
"RTN","utt1",154,0)
 D CHKEQ($G(@GL4@("%ut1","ACTLINES")),"0/9","Wrong number of lines covered f>>or ACTLINES")
"RTN","utt1",155,0)
 D CHKEQ($G(@GL4@("%ut1","ACTLINES",9))," QUIT CNT","Wrong result for last l>>ine not covered for ACTLINES")
"RTN","utt1",156,0)
 D CHKEQ($G(@GL4@("%ut1","CHEKTEST")),"8/10","Wrong number of lines covered >>for CHEKTEST")
"RTN","utt1",157,0)
 D CHKEQ($G(@GL4@("%ut1","CHEKTEST",39))," . Q","Wrong result for last line >>not covered for CHEKTEST")
"RTN","utt1",158,0)
 K @GL1,@GL2,@GL3,@GL4
"RTN","utt1",159,0)
 Q
"RTN","utt1",160,0)
 ;
"RTN","utt1",161,0)
LO(X) Q $TR(X,"ABCDEFGHIJKLMNOPQRSTUVWXYZ","abcdefghijklmnopqrstuvwxyz")
"RTN","utt1",162,0)
 ; Shortcut methods for M-Unit
"RTN","utt1",163,0)
CHKTF(X,Y) ;
"RTN","utt1",164,0)
 D CHKTF^%ut(X,$G(Y))
"RTN","utt1",165,0)
 QUIT
"RTN","utt1",166,0)
 ;
"RTN","utt1",167,0)
CHKEQ(A,B,M) ;
"RTN","utt1",168,0)
 D CHKEQ^%ut(A,B,$G(M))
"RTN","utt1",169,0)
 QUIT
"RTN","utt1",170,0)
 ;
"RTN","utt1",171,0)
XTENT ; Entry points
"RTN","utt1",172,0)
 ;;T4;Entry point using XTMENT
"RTN","utt1",173,0)
 ;;T5;Error count check
"RTN","utt1",174,0)
 ;;T6;Succeed Entry Point
"RTN","utt1",175,0)
 ;;T7;Make sure we write to principal even though we are on another device
"RTN","utt1",176,0)
 ;;T8;If IO starts with another device, write to that device as if it's the pricipal device
"RTN","utt1",177,0)
 ;;COVRPTGL;coverage report returning global
"RTN","utt1",178,0)
 ;
"RTN","utt1",179,0)
XTROU ; Routines containing additional tests
"RTN","utt1",180,0)
 ;;%utt2; old %utNITU
"RTN","utt1",181,0)
 ;;%utt4; old %utNITW
"RTN","utt1",182,0)
 ;;%utt5;
"RTN","utt1",183,0)
 ;;%utt6;
"RTN","utt1",184,0)
 ;;%uttcovr;coverage related tests
"RTN","utt2")
0^5^B501728
"RTN","utt2",1,0)
%utt2 ; VEN/SMH - Bad Ass Continuation of Unit Tests;12/16/15  08:44
"RTN","utt2",2,0)
 ;;1.3;MASH UTILITIES;;Dec 16, 2015;Build 4
"RTN","utt2",3,0)
 ; Submitted to OSEHRA Dec 16, 2015 by Joel L. Ivey under the Apache 2 license (http://www.apache.org/licenses/LICENSE-2.0.html)
"RTN","utt2",4,0)
 ; Original routine authored by Sam H. Habiel
"RTN","utt2",5,0)
 ; Modifications made by Joel L. Ivey 05/2014-09/2015
"RTN","utt2",6,0)
 ;
"RTN","utt2",7,0)
 ;
"RTN","utt2",8,0)
T11 ; @TEST An @TEST Entry point in Another Routine invoked through XTROU offsets
"RTN","utt2",9,0)
 D CHKTF^%ut(1)
"RTN","utt2",10,0)
 QUIT
"RTN","utt2",11,0)
T12 ;
"RTN","utt2",12,0)
 D CHKTF^%ut(1)
"RTN","utt2",13,0)
 QUIT
"RTN","utt2",14,0)
XTENT ;
"RTN","utt2",15,0)
 ;;T12;An XTENT offset entry point in Another Routine invoked through XTROU offsets
"RTN","utt3")
0^6^B1628564
"RTN","utt3",1,0)
%utt3 ; VEN/SMH-JLI - Unit Tests Coverage Tests;12/16/15  08:45
"RTN","utt3",2,0)
 ;;1.3;MASH UTILITIES;;Dec 16, 2015;Build 4
"RTN","utt3",3,0)
 ; Submitted to OSEHRA Dec 16, 2015 by Joel L. Ivey under the Apache 2 license (http://www.apache.org/licenses/LICENSE-2.0.html)
"RTN","utt3",4,0)
 ; Original routine authored by Sam H. Habiel 07/2013-04/2014
"RTN","utt3",5,0)
 ; Additions and modifications made by Joel L. Ivey 05/2014-08/2015
"RTN","utt3",6,0)
 ;
"RTN","utt3",7,0)
XTMUNITV ; VEN/SMH - Unit Tests Coverage Tests;2014-04-16  7:14 PM
"RTN","utt3",8,0)
 ;
"RTN","utt3",9,0)
 ; *** BE VERY CAREFUL IN MODIFIYING THIS ROUTINE ***
"RTN","utt3",10,0)
 ; *** THE UNIT TEST COUNTS ACTIVE AND INACTIVE LINES OF CODE ***
"RTN","utt3",11,0)
 ; *** IF YOU MODIFY THIS, MODIFY XTMUNITW AS WELL ***
"RTN","utt3",12,0)
 ;
"RTN","utt3",13,0)
 ; Coverage tester in %utt4
"RTN","utt3",14,0)
 ; 20 Lines of code
"RTN","utt3",15,0)
 ; 5 do not run as they are dead code
"RTN","utt3",16,0)
 ; Expected Coverage: 15/20 = 75%
"RTN","utt3",17,0)
 ;
"RTN","utt3",18,0)
STARTUP ; Doesn't count
"RTN","utt3",19,0)
 N X    ; Counts
"RTN","utt3",20,0)
 S X=1  ; Counts
"RTN","utt3",21,0)
 QUIT   ; Counts
"RTN","utt3",22,0)
 ;
"RTN","utt3",23,0)
SHUTDOWN K X,Y QUIT     ; Counts; ZEXCEPT: X,Y
"RTN","utt3",24,0)
 ;
"RTN","utt3",25,0)
SETUP S Y=$G(Y)+1 QUIT  ; Counts
"RTN","utt3",26,0)
 ;
"RTN","utt3",27,0)
TEARDOWN ; Doesn't count
"RTN","utt3",28,0)
 S Y=Y-1 ; Counts
"RTN","utt3",29,0)
 QUIT    ; Counts
"RTN","utt3",30,0)
 ;
"RTN","utt3",31,0)
T1 ; @TEST Test 1
"RTN","utt3",32,0)
 D CHKTF^%ut($D(Y)) ; Counts
"RTN","utt3",33,0)
 QUIT                   ; Counts
"RTN","utt3",34,0)
 ;
"RTN","utt3",35,0)
T2 ; @TEST Test 2
"RTN","utt3",36,0)
 D INTERNAL(1)          ; Counts
"RTN","utt3",37,0)
 D CHKTF^%ut(1)     ; Counts
"RTN","utt3",38,0)
 QUIT                   ; Counts
"RTN","utt3",39,0)
 S X=1                  ; Dead code
"RTN","utt3",40,0)
 QUIT                   ; Dead code
"RTN","utt3",41,0)
 ;
"RTN","utt3",42,0)
INTERNAL(A) ; Counts
"RTN","utt3",43,0)
 S A=A+1    ; Counts
"RTN","utt3",44,0)
 QUIT       ; Counts
"RTN","utt3",45,0)
 S A=2      ; Dead code
"RTN","utt3",46,0)
 S Y=2      ; Dead code
"RTN","utt3",47,0)
 QUIT       ; Dead code
"RTN","utt4")
0^7^B1568129
"RTN","utt4",1,0)
%utt4 ; VEN/SMH/JLI - Coverage Test Runner;12/16/15  08:45
"RTN","utt4",2,0)
 ;;1.3;MASH UTILITIES;;Dec 16, 2015;Build 4
"RTN","utt4",3,0)
 ; Submitted to OSEHRA Dec 16, 2015 by Joel L. Ivey under the Apache 2 license (http://www.apache.org/licenses/LICENSE-2.0.html)
"RTN","utt4",4,0)
 ; Original routine authored by Sam H. Habiel 07/2013-04/2014
"RTN","utt4",5,0)
 ; Additions and modifications made by Joel L. Ivey 05/2014-08/2015
"RTN","utt4",6,0)
 ;
"RTN","utt4",7,0)
XTMUNITW ; VEN/SMH - Coverage Test Runner;2014-04-17  3:30 PM
"RTN","utt4",8,0)
 ;;7.3;KERNEL TOOLKIT;;
"RTN","utt4",9,0)
 ;
"RTN","utt4",10,0)
 ; This tests code in XTMUNITV for coverage
"RTN","utt4",11,0)
 D EN^%ut($T(+0),1) QUIT
"RTN","utt4",12,0)
 ;
"RTN","utt4",13,0)
MAIN ; @TEST - Test coverage calculations
"RTN","utt4",14,0)
 Q:$D(^TMP("%uttcovr",$J))  ; already running coverage analysis from %uttcovr
"RTN","utt4",15,0)
 S ^TMP("%utt4val",$J)=1
"RTN","utt4",16,0)
 D COV^%ut("%utt3","D EN^%ut(""%utt3"",1)",-1)  ; Only produce output global.
"RTN","utt4",17,0)
 D CHKEQ^%ut("14/19",^TMP("%utCOVREPORT",$J))
"RTN","utt4",18,0)
 D CHKEQ^%ut("2/5",^TMP("%utCOVREPORT",$J,"%utt3","INTERNAL"))
"RTN","utt4",19,0)
 D CHKTF^%ut($D(^TMP("%utCOVREPORT",$J,"%utt3","T2",4)))
"RTN","utt4",20,0)
 D CHKEQ^%ut("1/1",^TMP("%utCOVREPORT",$J,"%utt3","SETUP"))
"RTN","utt4",21,0)
 K ^TMP("%utt4val",$J)
"RTN","utt4",22,0)
 QUIT
"RTN","utt5")
0^8^B23054235
"RTN","utt5",1,0)
%utt5 ;JLI - test for aspects of MUnit functionality ;12/16/15  08:47
"RTN","utt5",2,0)
 ;;1.3;MASH UTILITIES;;Dec 16, 2015;Build 4
"RTN","utt5",3,0)
 ; Submitted to OSEHRA Dec 16, 2015 by Joel L. Ivey under the Apache 2 license (http://www.apache.org/licenses/LICENSE-2.0.html)
"RTN","utt5",4,0)
 ; Original routine authored by Joel L. Ivey 05/2014-12/2015.
"RTN","utt5",5,0)
 ;
"RTN","utt5",6,0)
 Q
"RTN","utt5",7,0)
 ;
"RTN","utt5",8,0)
OLDSTYLE ;
"RTN","utt5",9,0)
 ; ZEXCEPT: %ut - Newed in EN^%zu
"RTN","utt5",10,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",11,0)
 I $D(%utt6var) S %ut("ENT")="OLDSTYLE",%utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"OLDSTYLE")=""
"RTN","utt5",12,0)
 D CHKEQ^%ut(5,5,"SET EQUAL ON PURPOSE - OLDSTYLE DONE")
"RTN","utt5",13,0)
 D CHKTF^%ut(4=4,"MY EQUAL VALUE")
"RTN","utt5",14,0)
 Q
"RTN","utt5",15,0)
 ;
"RTN","utt5",16,0)
OLDSTYL1 ;
"RTN","utt5",17,0)
 ; ZEXCEPT: %ut - Newed in EN^%zu
"RTN","utt5",18,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",19,0)
 I $D(%utt6var) S %ut("ENT")="OLDSTYL1",%utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"OLDSTYL1")=""
"RTN","utt5",20,0)
 D CHKEQ^%ut(4,4,"SET EQUAL ON PURPOSE - OLDSTYL1 DONE")
"RTN","utt5",21,0)
 Q
"RTN","utt5",22,0)
 ;
"RTN","utt5",23,0)
NEWSTYLE ; @TEST identify new style test indicator functionality
"RTN","utt5",24,0)
 ; ZEXCEPT: %ut - Newed in EN^%zu
"RTN","utt5",25,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",26,0)
 I $D(%utt6var) S %ut("ENT")="NEWSTYLE" S %utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"NEWSTYLE")=""
"RTN","utt5",27,0)
 D CHKEQ^%ut(4,4,"SET EQUAL ON PURPOSE - NEWSTYLE DONE")
"RTN","utt5",28,0)
 Q
"RTN","utt5",29,0)
 ;
"RTN","utt5",30,0)
BADCHKEQ ;
"RTN","utt5",31,0)
 ; ZEXCEPT: %ut - Newed in EN^%zu
"RTN","utt5",32,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",33,0)
 I $D(%utt6var) S %ut("ENT")="BADCHKEQ" S %utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"BADCHKEQ")=""
"RTN","utt5",34,0)
 D CHKEQ^%ut(4,3,"SET UNEQUAL ON PURPOSE - SHOULD FAIL")
"RTN","utt5",35,0)
 Q
"RTN","utt5",36,0)
 ;
"RTN","utt5",37,0)
BADCHKTF ;
"RTN","utt5",38,0)
 ; ZEXCEPT: %ut - Newed in EN^%zu
"RTN","utt5",39,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",40,0)
 I $D(%utt6var) S %ut("ENT")="BADCHKTF" S %utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"BADCHKTF")=""
"RTN","utt5",41,0)
 D CHKTF^%ut(0,"SET FALSE (0) ON PURPOSE - SHOULD FAIL")
"RTN","utt5",42,0)
 Q
"RTN","utt5",43,0)
 ;
"RTN","utt5",44,0)
BADERROR ;
"RTN","utt5",45,0)
 ; ZEXCEPT: %ut - Newed in EN^%zu
"RTN","utt5",46,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",47,0)
 N X
"RTN","utt5",48,0)
 I $D(%utt6var) S %ut("ENT")="BADERROR" S %utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"BADERROR")=""
"RTN","utt5",49,0)
 ; following syntax error is on purpose to throw an error
"RTN","utt5",50,0)
 S X= ; syntax error on purpose
"RTN","utt5",51,0)
 Q
"RTN","utt5",52,0)
 ;
"RTN","utt5",53,0)
CALLFAIL ;
"RTN","utt5",54,0)
 ; ZEXCEPT: %ut - Newed in EN^%zu
"RTN","utt5",55,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",56,0)
 N X
"RTN","utt5",57,0)
 I $D(%utt6var) S %ut("ENT")="CALLFAIL" S %utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"CALLFAIL")=""
"RTN","utt5",58,0)
 D FAIL^%ut("Called FAIL to test it")
"RTN","utt5",59,0)
 Q
"RTN","utt5",60,0)
 ;
"RTN","utt5",61,0)
LEAKSOK ;
"RTN","utt5",62,0)
 N CODE,LOCATN,MYVALS,X
"RTN","utt5",63,0)
 S CODE="S X=$$NOW^XLFDT()",LOCATN="LEAKSOK TEST",MYVALS("X")=""
"RTN","utt5",64,0)
 D CHKLEAKS^%ut(CODE,LOCATN,.MYVALS) ; should find no leaks
"RTN","utt5",65,0)
 Q
"RTN","utt5",66,0)
 ;
"RTN","utt5",67,0)
LEAKSBAD ;
"RTN","utt5",68,0)
 N CODE,LOCATN,MYVALS,X
"RTN","utt5",69,0)
 S CODE="S X=$$NOW^XLFDT()",LOCATN="LEAKSBAD TEST - X NOT SPECIFIED"
"RTN","utt5",70,0)
 D CHKLEAKS^%ut(CODE,LOCATN,.MYVALS) ; should find X since it isn't indicated
"RTN","utt5",71,0)
 Q
"RTN","utt5",72,0)
 ;
"RTN","utt5",73,0)
NVLDARG1 ;
"RTN","utt5",74,0)
 D CHKEQ^%ut(1)
"RTN","utt5",75,0)
 Q
"RTN","utt5",76,0)
 ;
"RTN","utt5",77,0)
ISUTEST ;
"RTN","utt5",78,0)
 D CHKTF^%ut($$ISUTEST^%ut,"ISUTEST returned FALSE!")
"RTN","utt5",79,0)
 Q
"RTN","utt5",80,0)
 ;
"RTN","utt5",81,0)
BADFORM1(X) ; @TEST should not be selected - arguments
"RTN","utt5",82,0)
 ; ZEXCEPT: %ut - Newed in EN^%zu
"RTN","utt5",83,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",84,0)
 I $D(%utt6var) S %ut("ENT")="NEWSTYLE" S %utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"BADFORM1")=""
"RTN","utt5",85,0)
 D CHKEQ^%ut(4,3,"SHOULD NOT BE SELECTED - ARGUMENTS - BADFORM1")
"RTN","utt5",86,0)
 Q
"RTN","utt5",87,0)
 ;
"RTN","utt5",88,0)
BADFORM2 ; ABC @TEST should not be selected - @TEST NOT FIRST
"RTN","utt5",89,0)
 ; ZEXCEPT: %ut - Newed in EN^%zu
"RTN","utt5",90,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",91,0)
 I $D(%utt6var) S %utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"BADFORM2")=""
"RTN","utt5",92,0)
 D CHKEQ^%ut(4,3,"SHOULD NOT BE SELECTED - @TEST NOT FIRST - BADFORM2")
"RTN","utt5",93,0)
 Q
"RTN","utt5",94,0)
 ;
"RTN","utt5",95,0)
STARTUP ;
"RTN","utt5",96,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",97,0)
 ; ZEXCEPT: KBANCOUNT created here, killed in SHUTDOWN
"RTN","utt5",98,0)
 I $D(%utt6var),$D(^TMP("%utt5",$J)) K ^TMP("%utt5",$J)
"RTN","utt5",99,0)
 I $D(%utt6var) S %utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"STARTUP")=""
"RTN","utt5",100,0)
 ; following brought from %utt1, since only one STARTUP can RUN in a set
"RTN","utt5",101,0)
 I '$D(%utt6var) D
"RTN","utt5",102,0)
 . S ^TMP($J,"%ut","STARTUP")=""
"RTN","utt5",103,0)
 . S KBANCOUNT=1
"RTN","utt5",104,0)
 . Q
"RTN","utt5",105,0)
 Q
"RTN","utt5",106,0)
 ;
"RTN","utt5",107,0)
SHUTDOWN ;
"RTN","utt5",108,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",109,0)
 ; ZEXCEPT: KBANCOUNT created in STARTUP, killed here
"RTN","utt5",110,0)
 I $D(%utt6var) S %utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"SHUTDOWN")=""
"RTN","utt5",111,0)
 ; following brought from %utt1, since only one SHUTDOWN can RUN in a set
"RTN","utt5",112,0)
 I '$D(%utt6var) D
"RTN","utt5",113,0)
 . K ^TMP($J,"%ut","STARTUP")
"RTN","utt5",114,0)
 . K KBANCOUNT
"RTN","utt5",115,0)
 . Q
"RTN","utt5",116,0)
 Q
"RTN","utt5",117,0)
 ;
"RTN","utt5",118,0)
SETUP ;
"RTN","utt5",119,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",120,0)
 I $D(%utt6var) S %utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"SETUP")=""
"RTN","utt5",121,0)
 Q
"RTN","utt5",122,0)
 ;
"RTN","utt5",123,0)
TEARDOWN ;
"RTN","utt5",124,0)
 ; ZEXCEPT: %utt6cnt,%utt6var - if present, NEWED following top entry of routine %utt6
"RTN","utt5",125,0)
 I $D(%utt6var) S %utt6cnt=$G(%utt6cnt)+1,^TMP("%utt5",$J,%utt6cnt,"TEARDOWN")=""
"RTN","utt5",126,0)
 Q
"RTN","utt5",127,0)
 ;
"RTN","utt5",128,0)
XTENT ;
"RTN","utt5",129,0)
 ;;OLDSTYLE; identify old style test indicator functionality
"RTN","utt5",130,0)
 ;;OLDSTYL1; identify old style test indicator 2
"RTN","utt5",131,0)
 ;;BADCHKEQ; CHKEQ should fail on unequal value
"RTN","utt5",132,0)
 ;;BADCHKTF; CHKTF should fail on false value
"RTN","utt5",133,0)
 ;;BADERROR; throws an error on purpose
"RTN","utt5",134,0)
 ;;CALLFAIL; called FAIL to test it
"RTN","utt5",135,0)
 ;;LEAKSOK;check leaks should be ok
"RTN","utt5",136,0)
 ;;LEAKSBAD;check leaks with leak
"RTN","utt5",137,0)
 ;;NVLDARG1;check invalid arg in CHKEQ
"RTN","utt5",138,0)
 ;;ISUTEST;check ISUTEST inside unit test
"RTN","utt6")
0^9^B39118749
"RTN","utt6",1,0)
%utt6 ;JLI - Unit tests for MUnit functionality ;12/16/15  08:47
"RTN","utt6",2,0)
 ;;1.3;MASH UTILITIES;;Dec 16, 2015;Build 4
"RTN","utt6",3,0)
 ; Submitted to OSEHRA Dec 16, 2015 by Joel L. Ivey under the Apache 2 license (http://www.apache.org/licenses/LICENSE-2.0.html)
"RTN","utt6",4,0)
 ; Original routine authored by Joel L. Ivey 05/2014-12/2015
"RTN","utt6",5,0)
 ;
"RTN","utt6",6,0)
 ;
"RTN","utt6",7,0)
 ; This routine uses ZZUTJLI2 as a test routine, it does not include the routine as an extension,
"RTN","utt6",8,0)
 ; since it uses it for tests.
"RTN","utt6",9,0)
 ;
"RTN","utt6",10,0)
 ; ZZUTJLI2 currently contains 3 tests (2 old style, 1 new style), it also specifies STARTUP and
"RTN","utt6",11,0)
 ; SHUTDOWN (should be 1 each) and SETUP and TEARDOWN (should be 3 each, 1 for each test) enteries, each of these
"RTN","utt6",12,0)
 ; creates an entry under the ^TMP("ZZUTJLI2" global node, indicating function then continues the process.
"RTN","utt6",13,0)
 ; Should be 2+3n entries (1+1 for STARTUP and SHUTDOWN, then 3 for each of the tests (SETUP, test,
"RTN","utt6",14,0)
 ; and TEARDOWN).
"RTN","utt6",15,0)
 ;
"RTN","utt6",16,0)
 ; This first section is more of a functional test, since it checks the full unit test processing from both
"RTN","utt6",17,0)
 ; a command line and a GUI call approach.  Data for analysis is saved under ^TMP("ZZUTJLI2_C", for command
"RTN","utt6",18,0)
 ; line and ^TMP("ZZUTJLI2_G", for gui processing.
"RTN","utt6",19,0)
 ;
"RTN","utt6",20,0)
 ; The counts for the command line processing are based on the number of unit test tags
"RTN","utt6",21,0)
 ; determined for the GUI processing as well.  The numbers are 2 (startup and shutdown)
"RTN","utt6",22,0)
 ;  + 3 x the number of tests present.
"RTN","utt6",23,0)
 ;
"RTN","utt6",24,0)
 ; run unit tests by command line
"RTN","utt6",25,0)
 N VERBOSE
"RTN","utt6",26,0)
 S VERBOSE=0
"RTN","utt6",27,0)
VERBOSE ;
"RTN","utt6",28,0)
 I '$D(VERBOSE) N VERBOSE S VERBOSE=1
"RTN","utt6",29,0)
 N ZZUTCNT,JLICNT,JLIEXPCT,JLII,JLIX,ZZUTRSLT,%utt5,%utt6,%utt6var
"RTN","utt6",30,0)
 W !!,"RUNNING COMMAND LINE TESTS VIA DOSET^%ut",!
"RTN","utt6",31,0)
 D DOSET^%ut(1,VERBOSE) ; run `1 in M-UNIT TEST GROUP file
"RTN","utt6",32,0)
 ;
"RTN","utt6",33,0)
 W !!!,"Running command line tests by RUNSET^%ut",!
"RTN","utt6",34,0)
 D RUNSET^%ut("TESTS FOR UNIT TEST ROUTINES")
"RTN","utt6",35,0)
 ;
"RTN","utt6",36,0)
 ; Call GUISET to obtain list of tags via entry in M-UNIT TEST GROUP file
"RTN","utt6",37,0)
 ; silent to the user
"RTN","utt6",38,0)
 D GUISET^%ut(.%utt6,1)
"RTN","utt6",39,0)
 K ^TMP("%utt6_GUISET",$J) M ^TMP("%utt6_GUISET",$J)=@%utt6
"RTN","utt6",40,0)
 ;
"RTN","utt6",41,0)
 W !!!,"RUNNING COMMAND LINE UNIT TESTS FOR %utt5",!
"RTN","utt6",42,0)
 N ZZUTCNT,JLICNT,JLIEXPCT,JLII,JLIX,ZZUTRSLT
"RTN","utt6",43,0)
 S ZZUTCNT=0
"RTN","utt6",44,0)
 K ^TMP("%utt5",$J) ; kill any contents of data storage
"RTN","utt6",45,0)
 D EN^%ut("%utt5",VERBOSE) ; should do STARTUP(1x), then SETUP, test, TEARDOWN (each together 3x) and SHUTDOWN (1x)
"RTN","utt6",46,0)
 K ^TMP("%utt5_C",$J) M ^TMP("%utt5_C",$J)=^TMP("%utt5",$J)
"RTN","utt6",47,0)
 ;
"RTN","utt6",48,0)
 ; now run unit tests by GUI - first determines unit test tags
"RTN","utt6",49,0)
 W !!!,"RUNNING UNIT TESTS FOR %utt5 VIA GUI CALLS - Silent",!
"RTN","utt6",50,0)
 S ZZUTCNT=0
"RTN","utt6",51,0)
 K ^TMP("%utt5",$J),^TMP("%utt6",$J)
"RTN","utt6",52,0)
 D GUILOAD^%ut(.%utt6,"%utt5")
"RTN","utt6",53,0)
 M ^TMP("%utt6",$J)=@%utt6
"RTN","utt6",54,0)
 S %utt6=$NA(^TMP("%utt6",$J))
"RTN","utt6",55,0)
 ; then run each tag separately
"RTN","utt6",56,0)
 ; JLICNT is count of unit test tags, which can be determined for GUI call for each unit test tag
"RTN","utt6",57,0)
 S JLICNT=0 F JLII=1:1 S JLIX=$G(@%utt6@(JLII)) Q:JLIX=""  I $P(JLIX,U,2)'="" S JLICNT=JLICNT+1 D GUINEXT^%ut(.ZZUTRSLT,$P(JLIX,U,2)_U_$P(JLIX,U))
"RTN","utt6",58,0)
 ; and close it with a null routine name
"RTN","utt6",59,0)
 D GUINEXT^%ut(.ZZUTRSLT,"")
"RTN","utt6",60,0)
 K ^TMP("%utt5_G",$J) M ^TMP("%utt5_G",$J)=^TMP("%utt5",$J)
"RTN","utt6",61,0)
 S JLIEXPCT=2+(3*JLICNT) ; number of lines that should be in the global nodes for command line and GUI
"RTN","utt6",62,0)
 ;
"RTN","utt6",63,0)
 W !!,"NOW RUNNING UNIT TESTS FOR %uttcovr",!!
"RTN","utt6",64,0)
 D EN^%ut("%uttcovr",VERBOSE)
"RTN","utt6",65,0)
 ;
"RTN","utt6",66,0)
 ; now run the unit tests in this routine
"RTN","utt6",67,0)
 W !!,"NOW RUNNING UNIT TESTS FOR %utt6",!!
"RTN","utt6",68,0)
 D EN^%ut("%utt6",VERBOSE)
"RTN","utt6",69,0)
 K ^TMP("%utt5",$J),^TMP("%utt5_C",$J),^TMP("%utt5_G",$J),^TMP("%utt6",$J),^TMP("%utt6_GUISET",$J)
"RTN","utt6",70,0)
 ; clean up after GUI calls as well
"RTN","utt6",71,0)
 K ^TMP("GUI-MUNIT",$J),^TMP("GUINEXT",$J),^TMP("MUNIT-%utRSLT",$J)
"RTN","utt6",72,0)
 Q
"RTN","utt6",73,0)
 ;
"RTN","utt6",74,0)
 ;
"RTN","utt6",75,0)
 ;           WARNING     --      WARNING     --      WARNING
"RTN","utt6",76,0)
 ; If the number of NEW STYLE tests in %utt5 is increased (it is currently 1), then the following
"RTN","utt6",77,0)
 ; test will need to be updated to reflect the change(s)
"RTN","utt6",78,0)
 ;     END OF WARNING  --  END OF WARNING  --  END OF WARNING
"RTN","utt6",79,0)
 ;
"RTN","utt6",80,0)
SETROUS ; @TEST - generate array with indices of routines to exclude
"RTN","utt6",81,0)
 N ROU,XCLDROUS,ROULIST
"RTN","utt6",82,0)
 S XCLDROUS(1)="ROU1NAME,ROU2NAME"
"RTN","utt6",83,0)
 S XCLDROUS("ROUNAME3")="ROUNAME4,ROUNAME5"
"RTN","utt6",84,0)
 D SETROUS^%utcover(.ROULIST,.XCLDROUS,1)
"RTN","utt6",85,0)
 D CHKTF('$D(ROULIST(1)),"SETROUS returned number for routine")
"RTN","utt6",86,0)
 D CHKTF($D(ROULIST("ROU1NAME")),"Didn't get first name on numeric subscript")
"RTN","utt6",87,0)
 D CHKTF($D(ROULIST("ROU2NAME")),"Didn't get second name on numeric subscript")
"RTN","utt6",88,0)
 D SETROUS^%utcover(.ROULIST,.XCLDROUS,"ROUNAME3")
"RTN","utt6",89,0)
 D CHKTF($D(ROULIST("ROUNAME3")),"Didn't get name for routine argument")
"RTN","utt6",90,0)
 D CHKTF($D(ROULIST("ROUNAME4")),"Didn't get first name on routine subscript")
"RTN","utt6",91,0)
 D CHKTF($D(ROULIST("ROUNAME5")),"Didn't get second name on routine subscript")
"RTN","utt6",92,0)
 Q
"RTN","utt6",93,0)
 ;
"RTN","utt6",94,0)
NEWSTYLE ; tests return of valid new style or @TEST indicators
"RTN","utt6",95,0)
 N LIST
"RTN","utt6",96,0)
 D NEWSTYLE^%ut1(.LIST,"%utt5")
"RTN","utt6",97,0)
 D CHKEQ^%ut(LIST,1,"Returned an incorrect number ("_LIST_") of New Style indicators - should be one")
"RTN","utt6",98,0)
 I LIST>0 D CHKEQ^%ut(LIST(1),"NEWSTYLE^identify new style test indicator functionality","Returned incorrect TAG^reason "_LIST(1))
"RTN","utt6",99,0)
 I LIST>0 D CHKEQ^%ut($G(LIST(2)),"","Returned a value for LIST(2) - should not have any value (i.e., null)")
"RTN","utt6",100,0)
 ; the following is basically just for coverage
"RTN","utt6",101,0)
 D PICKSET^%ut
"RTN","utt6",102,0)
 Q
"RTN","utt6",103,0)
 ;
"RTN","utt6",104,0)
CKGUISET ;
"RTN","utt6",105,0)
 ; ZEXCEPT: %utt6var - if present, is NEWed and created in code following VERBOSE
"RTN","utt6",106,0)
 I '$D(%utt6var) Q
"RTN","utt6",107,0)
 N MAX
"RTN","utt6",108,0)
 S MAX=$O(^TMP("%utt6_GUISET",$J,""),-1)
"RTN","utt6",109,0)
 D CHKTF(^TMP("%utt6_GUISET",$J,MAX)["%utt6^NEWSTYLE","GUISET returned incorrect list")
"RTN","utt6",110,0)
 Q
"RTN","utt6",111,0)
 ;
"RTN","utt6",112,0)
CHKCMDLN ; check command line processing of %utt5
"RTN","utt6",113,0)
 ; ZEXCEPT: JLIEXPCT,%utt6var - if present NEWed and created in code following VERBOSE tag
"RTN","utt6",114,0)
 I '$D(%utt6var) Q
"RTN","utt6",115,0)
 D CHKTF($D(^TMP("%utt5_C",$J,JLIEXPCT))=10,"Not enough entries in %utt5 expected "_JLIEXPCT)
"RTN","utt6",116,0)
 D CHKTF($D(^TMP("%utt5_C",$J,JLIEXPCT+1))=0,"Too many entries in %utt5 expected "_JLIEXPCT)
"RTN","utt6",117,0)
 D CHKTF($O(^TMP("%utt5_C",$J,1,""))="STARTUP","Incorrect function for entry 1,'"_$O(^TMP("%utt5_C",$J,1,""))_"' should be 'STARTUP'")
"RTN","utt6",118,0)
 D CHKTF($O(^TMP("%utt5_C",$J,JLIEXPCT,""))="SHUTDOWN","Incorrect function for entry "_JLIEXPCT_", '"_$O(^TMP("%utt5_C",$J,JLIEXPCT,""))_"' should be 'SHUTDOWN'")
"RTN","utt6",119,0)
 Q
"RTN","utt6",120,0)
 ;
"RTN","utt6",121,0)
CHKGUI ; check GUI processing of %utt5
"RTN","utt6",122,0)
 ; ZEXCEPT: JLIEXPCT,%utt6var - if present NEWed and created in code following VERBOSE tag
"RTN","utt6",123,0)
 I '$D(%utt6var) Q
"RTN","utt6",124,0)
 D CHKTF($D(^TMP("%utt5_G",$J,JLIEXPCT))=10,"Not enough entries in %utt5 expected "_JLIEXPCT)
"RTN","utt6",125,0)
 D CHKTF($D(^TMP("%utt5_G",$J,JLIEXPCT+1))=0,"Too many entries in %utt5 expected "_JLIEXPCT)
"RTN","utt6",126,0)
 D CHKTF($O(^TMP("%utt5_G",$J,1,""))="STARTUP","Incorrect function for entry 1,'"_$O(^TMP("%utt5Z_G",1,""))_"' should be 'STARTUP'")
"RTN","utt6",127,0)
 D CHKTF($O(^TMP("%utt5_G",$J,JLIEXPCT,""))="SHUTDOWN","Incorrect function for entry "_JLIEXPCT_", '"_$O(^TMP("%utt5_G",$J,JLIEXPCT,""))_"' should be 'SHUTDOWN'")
"RTN","utt6",128,0)
 Q
"RTN","utt6",129,0)
 ;
"RTN","utt6",130,0)
CHKTF(VALUE,MESSAGE) ;
"RTN","utt6",131,0)
 D CHKTF^%ut($G(VALUE),$G(MESSAGE))
"RTN","utt6",132,0)
 Q
"RTN","utt6",133,0)
 ;
"RTN","utt6",134,0)
XTENT ;
"RTN","utt6",135,0)
 ;;CHKCMDLN;check command line processing of %utt5
"RTN","utt6",136,0)
 ;;CHKGUI;check GUI processing of %utt5
"RTN","utt6",137,0)
 ;;CKGUISET;check list of tests returned by GUISET
"RTN","utt6",138,0)
 ;;NEWSTYLE;test return of valid new style or @TEST indicators
"RTN","uttcovr")
0^10^B186023122
"RTN","uttcovr",1,0)
%uttcovr ;JIVEYSOFT/JLI - runs coverage tests on %ut and %ut1 routines via unit tests ;12/16/15  08:48
"RTN","uttcovr",2,0)
 ;;1.3;MASH UTILITIES;;Dec 16, 2015;Build 4
"RTN","uttcovr",3,0)
 ; Submitted to OSEHRA Dec 16, 2015 by Joel L. Ivey under the Apache 2 license (http://www.apache.org/licenses/LICENSE-2.0.html)
"RTN","uttcovr",4,0)
 ; Original routine authored by Joel L. Ivey 05/2014-12/2015
"RTN","uttcovr",5,0)
 ;
"RTN","uttcovr",6,0)
 ;
"RTN","uttcovr",7,0)
 ; ZEXCEPT: DTIME - if present the value is Kernel timeout for reads
"RTN","uttcovr",8,0)
 N RUNCODE,XCLUDE
"RTN","uttcovr",9,0)
 ;
"RTN","uttcovr",10,0)
 ; Have it run the following entry points or, if no ^, call EN^%ut with routine name
"RTN","uttcovr",11,0)
 S RUNCODE(1)="^%utt1,%utt1,^%utt6,VERBOSE^%utt6,%uttcovr,^%ut,^%ut1,^%utcover"
"RTN","uttcovr",12,0)
 S RUNCODE("ENTRY^%uttcovr")=""
"RTN","uttcovr",13,0)
 ; Have the analysis EXCLUDE the following routines from coverage - unit test routines
"RTN","uttcovr",14,0)
 S XCLUDE(1)="%utt1,%utt2,%utt3,%utt4,%utt5,%utt6,%uttcovr"
"RTN","uttcovr",15,0)
 S XCLUDE(2)="%utf2hex" ; a GT.M system file, although it wasn't showing up anyway
"RTN","uttcovr",16,0)
 M ^TMP("%uttcovr",$J,"XCLUDE")=XCLUDE
"RTN","uttcovr",17,0)
 D COVERAGE^%ut("%ut*",.RUNCODE,.XCLUDE,3)
"RTN","uttcovr",18,0)
 Q
"RTN","uttcovr",19,0)
 ;
"RTN","uttcovr",20,0)
ENTRY ;
"RTN","uttcovr",21,0)
 K ^TMP("ENTRY^%uttcovr",$J,"VALS")
"RTN","uttcovr",22,0)
 M ^TMP("ENTRY^%uttcovr",$J,"VALS")=^TMP("%ut",$J,"UTVALS")
"RTN","uttcovr",23,0)
 K ^TMP("%ut",$J,"UTVALS")
"RTN","uttcovr",24,0)
 ; these tests run outside of unit tests to handle CHKLEAKS calls not in unit tests
"RTN","uttcovr",25,0)
 ; they need data set, so they are called in here
"RTN","uttcovr",26,0)
 ; LEAKSOK ;
"RTN","uttcovr",27,0)
 N CODE,LOCATN,MYVALS,X,I
"RTN","uttcovr",28,0)
 S CODE="S X=$$NOW^XLFDT()",LOCATN="LEAKSOK TEST",MYVALS("X")=""
"RTN","uttcovr",29,0)
 D CHKLEAKS^%ut(CODE,LOCATN,.MYVALS) ; should find no leaks
"RTN","uttcovr",30,0)
 ; LEAKSBAD ;
"RTN","uttcovr",31,0)
 N CODE,LOCATN,MYVALS,X
"RTN","uttcovr",32,0)
 S CODE="S X=$$NOW^XLFDT()",LOCATN="LEAKSBAD TEST - X NOT SPECIFIED"
"RTN","uttcovr",33,0)
 D CHKLEAKS^%ut(CODE,LOCATN,.MYVALS) ; should find X since it isn't indicated
"RTN","uttcovr",34,0)
 ; try to run coverage
"RTN","uttcovr",35,0)
 W !,"xxxxxxxxxxxxxxxxxxxx GOING TO COV^%ut FOR %utt5 at 3",!!!
"RTN","uttcovr",36,0)
 D COV^%ut("%ut1","D EN^%ut(""%utt5"")",3)
"RTN","uttcovr",37,0)
 W !,"xxxxxxxxxxxxxxxxxxxx GOING TO COV^%ut FOR %utt5 at -1",!!!
"RTN","uttcovr",38,0)
 D COV^%ut("%ut1","D EN^%ut(""%utt5"")",-1)
"RTN","uttcovr",39,0)
 N RUNCODE S RUNCODE(1)="^%utt4,^%ut"
"RTN","uttcovr",40,0)
 N XCLUDE M XCLUDE=^TMP("%uttcovr",$J,"XCLUDE")
"RTN","uttcovr",41,0)
 W !,"xxxxxxxxxxxxxxxxxxxx GOING TO MULTAPIS for %utt4 and %ut",!!!
"RTN","uttcovr",42,0)
 D MULTAPIS^%ut(.RUNCODE)
"RTN","uttcovr",43,0)
 W !,"xxxxxxxxxxxxxxxxxxxx GOING TO COVERAGE for %utt4 and %ut at 3",!!!
"RTN","uttcovr",44,0)
 D COVERAGE^%ut("%ut*",.RUNCODE,.XCLUDE,3)
"RTN","uttcovr",45,0)
 N GLT S GLT=$NA(^TMP("%uttcovr-text",$J)) K @GLT
"RTN","uttcovr",46,0)
 W !,"xxxxxxxxxxxxxxxxxxxx LISTING DATA VIA LIST",!!!
"RTN","uttcovr",47,0)
 D LIST^%utcover(.XCLUDE,3,GLT) ; get coverage for listing and trimdata in %utcover
"RTN","uttcovr",48,0)
 F I=1:1 Q:'$D(@GLT@(I))  W !,@GLT@(I)
"RTN","uttcovr",49,0)
 K @GLT
"RTN","uttcovr",50,0)
 ; restore unit test totals from before entry
"RTN","uttcovr",51,0)
 K ^TMP("%ut",$J,"UTVALS")
"RTN","uttcovr",52,0)
 M ^TMP("%ut",$J,"UTVALS")=^TMP("ENTRY^%uttcovr",$J,"VALS")
"RTN","uttcovr",53,0)
 K ^TMP("ENTRY^%uttcovr",$J,"VALS")
"RTN","uttcovr",54,0)
 W !,"xxxxxxxxxxxxxxxxxxxx Finished in ENTRY^%uttcovr",!!!
"RTN","uttcovr",55,0)
 Q
"RTN","uttcovr",56,0)
 ;
"RTN","uttcovr",57,0)
RTNANAL ; @TEST - routine analysis
"RTN","uttcovr",58,0)
 N ROUS,GLB
"RTN","uttcovr",59,0)
 S ROUS("%utt4")=""
"RTN","uttcovr",60,0)
 S GLB=$NA(^TMP("%uttcovr-rtnanal",$J)) K @GLB
"RTN","uttcovr",61,0)
 D RTNANAL^%ut1(.ROUS,GLB)
"RTN","uttcovr",62,0)
 D CHKTF($D(@GLB@("%utt4","MAIN"))>1,"Not enough 'MAIN' nodes found")
"RTN","uttcovr",63,0)
 D CHKTF($G(@GLB@("%utt4","MAIN",3))["D COV^%ut(""%utt3"",""D EN^%ut(""""%utt3"""",1)"",-1)","Incorrect data for line 2 in MAIN")
"RTN","uttcovr",64,0)
 D CHKTF($G(@GLB@("%utt4","MAIN",9))=" QUIT","Final QUIT not on expected line")
"RTN","uttcovr",65,0)
 K @GLB
"RTN","uttcovr",66,0)
 Q
"RTN","uttcovr",67,0)
 ;
"RTN","uttcovr",68,0)
COVCOV ; @TEST - check COVCOV - remove seen lines
"RTN","uttcovr",69,0)
 N C,R
"RTN","uttcovr",70,0)
 S C=$NA(^TMP("%uttcovr_C",$J))
"RTN","uttcovr",71,0)
 S R=$NA(^TMP("%uttcovr_R",$J))
"RTN","uttcovr",72,0)
 S @C@("ROU1")=""
"RTN","uttcovr",73,0)
 S @C@("ROU2")="",@R@("ROU2")=""
"RTN","uttcovr",74,0)
 S @C@("ROU2","TAG1")="",@R@("ROU2","TAG1")=""
"RTN","uttcovr",75,0)
 S @C@("ROU2","TAG1",1)="AAA"
"RTN","uttcovr",76,0)
 S @C@("ROU2","TAG1",2)="AAA",@R@("ROU2","TAG1",2)="AAA"
"RTN","uttcovr",77,0)
 S @C@("ROU2","TAG1",3)="ABB",@R@("ROU2","TAG1",3)="ABB"
"RTN","uttcovr",78,0)
 S @C@("ROU2","TAG2",6)="ACC"
"RTN","uttcovr",79,0)
 S @C@("ROU2","TAG2",7)="ADD",@R@("ROU2","TAG2",7)="ADD"
"RTN","uttcovr",80,0)
 S @C@("ROU3","TAG1",2)="BAA",@R@("ROU3","TAG1",2)="BAA"
"RTN","uttcovr",81,0)
 S @C@("ROU3","TAG1",3)="CAA"
"RTN","uttcovr",82,0)
 S @C@("ROU3","TAG1",4)="DAA"
"RTN","uttcovr",83,0)
 S @C@("ROU3","TAG1",5)="EAA",@R@("ROU3","TAG1",5)="EAA"
"RTN","uttcovr",84,0)
 S @C@("ROU3","TAG1",6)="FAA",@R@("ROU3","TAG1",6)="FAA"
"RTN","uttcovr",85,0)
 D COVCOV^%ut1(C,R)
"RTN","uttcovr",86,0)
 D CHKTF($D(@C@("ROU2","TAG1",1)),"Invalid value for ""ROU2"",""TAG1"",1")
"RTN","uttcovr",87,0)
 D CHKTF('$D(@C@("ROU2","TAG1",2)),"Unexpected value for ""ROU2"",""TAG1"",1")
"RTN","uttcovr",88,0)
 D CHKTF($D(@C@("ROU2","TAG2",6)),"Invalid value for ""ROU2"",""TAG1"",1")
"RTN","uttcovr",89,0)
 D CHKTF('$D(@C@("ROU2","TAG2",7)),"Unexpected value for ""ROU2"",""TAG1"",1")
"RTN","uttcovr",90,0)
 D CHKTF($D(@C@("ROU3","TAG1",4)),"Invalid value for ""ROU2"",""TAG1"",1")
"RTN","uttcovr",91,0)
 D CHKTF('$D(@C@("ROU3","TAG1",5)),"Unexpected value for ""ROU2"",""TAG1"",1")
"RTN","uttcovr",92,0)
 K @C,@R
"RTN","uttcovr",93,0)
 Q
"RTN","uttcovr",94,0)
 ;
"RTN","uttcovr",95,0)
COVRPT  ; @TEST
"RTN","uttcovr",96,0)
 N GL1,GL2,GL3,GL4,VRBOSITY,GL5
"RTN","uttcovr",97,0)
 S GL1=$NA(^TMP("%utCOVCOHORTSAVx",$J)) K @GL1
"RTN","uttcovr",98,0)
 S GL2=$NA(^TMP("%utCOVCOHORTx",$J)) K @GL2
"RTN","uttcovr",99,0)
 S GL3=$NA(^TMP("%utCOVRESULTx",$J)) K @GL3
"RTN","uttcovr",100,0)
 S GL4=$NA(^TMP("%utCOVREPORTx",$J)) K @GL4
"RTN","uttcovr",101,0)
 S GL5=$NA(^TMP("%ut1-covrpt",$J)) K @GL5
"RTN","uttcovr",102,0)
 D SETGLOBS(GL1,GL2)
"RTN","uttcovr",103,0)
 S VRBOSITY=1
"RTN","uttcovr",104,0)
 D COVRPT^%ut1(GL1,GL2,GL3,VRBOSITY)
"RTN","uttcovr",105,0)
 D CHKEQ("COVERAGE PERCENTAGE: 42.11",$G(@GL5@(5)),"Verbosity 1 - not expected percentage value")
"RTN","uttcovr",106,0)
 D CHKEQ("  %ut1            42.11%  8 out of 19",$G(@GL5@(9)),"Verbosity 1 - not expected value for line 9")
"RTN","uttcovr",107,0)
 D CHKTF('$D(@GL5@(10)),"Verbosity 1 - unexpected data in 10th line")
"RTN","uttcovr",108,0)
 ;
"RTN","uttcovr",109,0)
 S VRBOSITY=2
"RTN","uttcovr",110,0)
 D COVRPT^%ut1(GL1,GL2,GL3,VRBOSITY)
"RTN","uttcovr",111,0)
 D CHKEQ("    ACTLINES           0.00%  0 out of 9",$G(@GL5@(10)),"Verbosity 2 - not expected value for 10th line")
"RTN","uttcovr",112,0)
 D CHKEQ("    CHEKTEST          80.00%  8 out of 10",$G(@GL5@(11)),"Verbosity 2 - not expected value for 11th line")
"RTN","uttcovr",113,0)
 D CHKTF('$D(@GL5@(12)),"Verbosity 2 - unexpected data for 12th line")
"RTN","uttcovr",114,0)
 ;
"RTN","uttcovr",115,0)
 S VRBOSITY=3
"RTN","uttcovr",116,0)
 D COVRPT^%ut1(GL1,GL2,GL3,VRBOSITY)
"RTN","uttcovr",117,0)
 D CHKEQ("    ACTLINES           0.00%  0 out of 9",$G(@GL5@(10)),"Verbosity 3 - unexpected value for line 10")
"RTN","uttcovr",118,0)
 D CHKEQ("ACTLINES+9:  QUIT CNT",$G(@GL5@(19)),"Verbosity 3 - unexpected value for line 19")
"RTN","uttcovr",119,0)
 D CHKEQ("    CHEKTEST          80.00%  8 out of 10",$G(@GL5@(20)),"Verbosity 3 - unexpected value for line 20")
"RTN","uttcovr",120,0)
 D CHKEQ("CHEKTEST+39:  . Q",$G(@GL5@(22)),"Verbosity 3 - unexpected value for line 22")
"RTN","uttcovr",121,0)
 D CHKTF('$D(@GL5@(23)),"Verbosity 3 - unexpected line 23")
"RTN","uttcovr",122,0)
 K @GL1,@GL2,@GL3,@GL4,@GL5
"RTN","uttcovr",123,0)
 Q
"RTN","uttcovr",124,0)
 ;
"RTN","uttcovr",125,0)
COVRPTLS ; @TEST - coverage report returning text in global
"RTN","uttcovr",126,0)
 N GL1,GL2,GL3,GL4,VRBOSITY
"RTN","uttcovr",127,0)
 S GL1=$NA(^TMP("%utCOVCOHORTSAVx",$J)) K @GL1
"RTN","uttcovr",128,0)
 S GL2=$NA(^TMP("%utCOVCOHORTx",$J)) K @GL2
"RTN","uttcovr",129,0)
 S GL3=$NA(^TMP("%utCOVRESULTx",$J)) K @GL3
"RTN","uttcovr",130,0)
 S GL4=$NA(^TMP("%utCOVREPORTx",$J)) K @GL4
"RTN","uttcovr",131,0)
 D SETGLOBS(GL1,GL2)
"RTN","uttcovr",132,0)
 S VRBOSITY=1
"RTN","uttcovr",133,0)
 D COVRPTLS^%ut1(GL1,GL2,GL3,VRBOSITY,GL4)
"RTN","uttcovr",134,0)
 D CHKEQ("COVERAGE PERCENTAGE: 42.11",$G(@GL4@(5)),"Verbosity 1 - not expected percentage value")
"RTN","uttcovr",135,0)
 D CHKEQ("  %ut1            42.11%  8 out of 19",$G(@GL4@(9)),"Verbosity 1 - not expected value for line 9")
"RTN","uttcovr",136,0)
 D CHKTF('$D(@GL4@(10)),"Verbosity 1 - unexpected data in 10th line")
"RTN","uttcovr",137,0)
 K @GL4
"RTN","uttcovr",138,0)
 ;
"RTN","uttcovr",139,0)
 S VRBOSITY=2
"RTN","uttcovr",140,0)
 D COVRPTLS^%ut1(GL1,GL2,GL3,VRBOSITY,GL4)
"RTN","uttcovr",141,0)
 D CHKEQ("    ACTLINES           0.00%  0 out of 9",$G(@GL4@(10)),"Verbosity 2 - not expected value for 10th line")
"RTN","uttcovr",142,0)
 D CHKEQ("    CHEKTEST          80.00%  8 out of 10",$G(@GL4@(11)),"Verbosity 2 - not expected value for 11th line")
"RTN","uttcovr",143,0)
 D CHKTF('$D(@GL4@(12)),"Verbosity 2 - unexpected data for 12th line")
"RTN","uttcovr",144,0)
 K @GL4
"RTN","uttcovr",145,0)
 ;
"RTN","uttcovr",146,0)
 S VRBOSITY=3
"RTN","uttcovr",147,0)
 D COVRPTLS^%ut1(GL1,GL2,GL3,VRBOSITY,GL4)
"RTN","uttcovr",148,0)
 D CHKEQ("    ACTLINES           0.00%  0 out of 9",$G(@GL4@(10)),"Verbosity 3 - unexpected value for line 10")
"RTN","uttcovr",149,0)
 D CHKEQ("ACTLINES+9:  QUIT CNT",$G(@GL4@(19)),"Verbosity 3 - unexpected value for line 19")
"RTN","uttcovr",150,0)
 D CHKEQ("    CHEKTEST          80.00%  8 out of 10",$G(@GL4@(20)),"Verbosity 3 - unexpected value for line 20")
"RTN","uttcovr",151,0)
 D CHKEQ("CHEKTEST+39:  . Q",$G(@GL4@(22)),"Verbosity 3 - unexpected value for line 22")
"RTN","uttcovr",152,0)
 D CHKTF('$D(@GL4@(23)),"Verbosity 3 - unexpected line 23")
"RTN","uttcovr",153,0)
 ;
"RTN","uttcovr",154,0)
 K @GL1,@GL2,@GL3,@GL4
"RTN","uttcovr",155,0)
 Q
"RTN","uttcovr",156,0)
 ;
"RTN","uttcovr",157,0)
TRIMDATA ; @TEST - TRIMDATA in %utcover
"RTN","uttcovr",158,0)
 N GL1,XCLUD
"RTN","uttcovr",159,0)
 S GL1=$NA(^TMP("%uttcovr-trimdata",$J)) K @GL1
"RTN","uttcovr",160,0)
 S @GL1@("GOOD",1)="1"
"RTN","uttcovr",161,0)
 S @GL1@("BAD",1)="1"
"RTN","uttcovr",162,0)
 S XCLUD("BAD")=""
"RTN","uttcovr",163,0)
 D TRIMDATA^%utcover(.XCLUD,GL1)
"RTN","uttcovr",164,0)
 D CHKTF($D(@GL1@("GOOD")),"GOOD ENTRY WAS REMOVED")
"RTN","uttcovr",165,0)
 D CHKTF('$D(@GL1@("BAD")),"ENTRY WAS NOT TRIMMED")
"RTN","uttcovr",166,0)
 K @GL1,XCLUD
"RTN","uttcovr",167,0)
 Q
"RTN","uttcovr",168,0)
 ;
"RTN","uttcovr",169,0)
LIST ; @TEST - LIST in %utcover
"RTN","uttcovr",170,0)
 N GL1,GLT S GL1=$NA(^TMP("%uttcovr-list",$J)),GLT=$NA(^TMP("%uttcovr-text",$J))
"RTN","uttcovr",171,0)
 S @GL1@("%ut1")="89/160"
"RTN","uttcovr",172,0)
 S @GL1@("%ut1","%ut1")="2/2"
"RTN","uttcovr",173,0)
 S @GL1@("%ut1","ACTLINES")="0/8"
"RTN","uttcovr",174,0)
 S @GL1@("%ut1","ACTLINES",2)=" N CNT S CNT=0"
"RTN","uttcovr",175,0)
 S @GL1@("%ut1","ACTLINES",3)=" N REF S REF=GL"
"RTN","uttcovr",176,0)
 S @GL1@("%ut1","ACTLINES",4)=" N GLQL S GLQL=$QL(GL)"
"RTN","uttcovr",177,0)
 S @GL1@("%ut1","ACTLINES",5)=" F  S REF=$Q(@REF) Q:REF=""""  Q:(GL'=$NA(@REF,GLQL))  D"
"RTN","uttcovr",178,0)
 S @GL1@("%ut1","ACTLINES",6)=" . N REFQL S REFQL=$QL(REF)"
"RTN","uttcovr",179,0)
 S @GL1@("%ut1","ACTLINES",7)=" . N LASTSUB S LASTSUB=$QS(REF,REFQL)"
"RTN","uttcovr",180,0)
 S @GL1@("%ut1","ACTLINES",8)=" . I LASTSUB?1.N S CNT=CNT+1"
"RTN","uttcovr",181,0)
 S @GL1@("%ut1","ACTLINES",9)=" QUIT CNT"
"RTN","uttcovr",182,0)
 S @GL1@("%ut1","CHECKTAG")="11/11"
"RTN","uttcovr",183,0)
 S @GL1@("%ut1","CHEKTEST")="10/10"
"RTN","uttcovr",184,0)
 N XCLUD S XCLUD("%utt1")=""
"RTN","uttcovr",185,0)
 D LIST^%utcover(.XCLUD,1,GLT,GL1)
"RTN","uttcovr",186,0)
 D CHKEQ("Routine %ut1      (55.63%)   89 out of 160 lines covered",$G(@GLT@(3)),"Verbosity 1 - Unexpected text for line 3")
"RTN","uttcovr",187,0)
 D CHKEQ("Overall Analysis 89 out of 160 lines covered (55% coverage)",$G(@GLT@(6)),"Verbosity 1 - unexpected text for line 6")
"RTN","uttcovr",188,0)
 D CHKTF('$D(@GLT@(7)),"Verbosity 1 - Unexpected line 7 present")
"RTN","uttcovr",189,0)
 K @GLT
"RTN","uttcovr",190,0)
 ;
"RTN","uttcovr",191,0)
 D LIST^%utcover(.XCLUD,2,GLT,GL1)
"RTN","uttcovr",192,0)
 D CHKEQ("  - Summary",$G(@GLT@(4)),"Verbosity 2 - unexpected text at line 4")
"RTN","uttcovr",193,0)
 D CHKEQ(" Tag ACTLINES^%ut1          (0.00%)   0 out of 8 lines covered",$G(@GLT@(6)),"Verbosity 2 - unexpected text at line 6")
"RTN","uttcovr",194,0)
 D CHKEQ(" Tag CHEKTEST^%ut1        (100.00%)   10 out of 10 lines covered",$G(@GLT@(8)),"Verbosity 2 - unexpected text at line 8")
"RTN","uttcovr",195,0)
 D CHKTF($D(@GLT@(14)),"Verbosity 2 - expected line at line 14")
"RTN","uttcovr",196,0)
 D CHKTF('$D(@GLT@(15)),"Verbosity 2 - unexpected line at line 15")
"RTN","uttcovr",197,0)
 K @GLT
"RTN","uttcovr",198,0)
 ;
"RTN","uttcovr",199,0)
 D LIST^%utcover(.XCLUD,3,GLT,GL1)
"RTN","uttcovr",200,0)
 D CHKEQ(" Tag %ut1^%ut1            (100.00%)   2 out of 2 lines covered",$G(@GLT@(5)),"Verbosity 3 - Incorrect text at line 5")
"RTN","uttcovr",201,0)
 D CHKEQ("     ACTLINES+9   QUIT CNT",$G(@GLT@(15)),"Verbosity 3 - incorrect line 15")
"RTN","uttcovr",202,0)
 D CHKTF($D(@GLT@(31)),"Verbosity 3 - expected data in line 31")
"RTN","uttcovr",203,0)
 D CHKTF('$D(@GLT@(32)),"Verbosity 3 - did not expect a line 32")
"RTN","uttcovr",204,0)
 ;
"RTN","uttcovr",205,0)
 K @GL1,@GLT
"RTN","uttcovr",206,0)
 Q
"RTN","uttcovr",207,0)
 ;
"RTN","uttcovr",208,0)
SETGLOBS(GL1,GL2) ;
"RTN","uttcovr",209,0)
 S @GL1@("%ut1","ACTLINES")="ACTLINES"
"RTN","uttcovr",210,0)
 S @GL1@("%ut1","ACTLINES",0)="ACTLINES(GL) ; [Private] $$ ; Count active lines"
"RTN","uttcovr",211,0)
 S @GL1@("%ut1","ACTLINES",2)=" N CNT S CNT=0"
"RTN","uttcovr",212,0)
 S @GL1@("%ut1","ACTLINES",3)=" N REF S REF=GL"
"RTN","uttcovr",213,0)
 S @GL1@("%ut1","ACTLINES",4)=" N GLQL S GLQL=$QL(GL)"
"RTN","uttcovr",214,0)
 S @GL1@("%ut1","ACTLINES",5)=" F  S REF=$Q(@REF) Q:REF=""""  Q:(GL'=$NA(@REF,GLQL))  D"
"RTN","uttcovr",215,0)
 S @GL1@("%ut1","ACTLINES",6)=" . N REFQL S REFQL=$QL(REF)"
"RTN","uttcovr",216,0)
 S @GL1@("%ut1","ACTLINES",7)=" . N LASTSUB S LASTSUB=$QS(REF,REFQL)"
"RTN","uttcovr",217,0)
 S @GL1@("%ut1","ACTLINES",8)=" . I LASTSUB?1.N S CNT=CNT+1"
"RTN","uttcovr",218,0)
 S @GL1@("%ut1","ACTLINES",9)=" QUIT CNT"
"RTN","uttcovr",219,0)
 S @GL1@("%ut1","CHEKTEST")="CHEKTEST"
"RTN","uttcovr",220,0)
 S @GL1@("%ut1","CHEKTEST",0)="CHEKTEST(%utROU,%ut,%utUETRY) ; Collect Test list."
"RTN","uttcovr",221,0)
 S @GL1@("%ut1","CHEKTEST",13)=" N I,LIST"
"RTN","uttcovr",222,0)
 S @GL1@("%ut1","CHEKTEST",14)=" S I=$L($T(@(U_%utROU))) I I<0 Q ""-1^Invalid Routine Name"""
"RTN","uttcovr",223,0)
 S @GL1@("%ut1","CHEKTEST",31)=" D NEWSTYLE(.LIST,%utROU)"
"RTN","uttcovr",224,0)
 S @GL1@("%ut1","CHEKTEST",32)=" F I=1:1:LIST S %ut(""ENTN"")=%ut(""ENTN"")+1,%utUETRY(%ut(""ENTN""))=$P(LIST(I),U),%utUETRY(%ut(""ENTN""),""NAME"")=$P(LIST(I),U,2,99)"
"RTN","uttcovr",225,0)
 S @GL1@("%ut1","CHEKTEST",37)=" N %utUI F %utUI=1:1 S %ut(""ELIN"")=$T(@(""XTENT+""_%utUI_""^""_%utROU)) Q:$P(%ut(""ELIN""),"";"",3)=""""  D"
"RTN","uttcovr",226,0)
 S @GL1@("%ut1","CHEKTEST",38)=" . S %ut(""ENTN"")=%ut(""ENTN"")+1,%utUETRY(%ut(""ENTN""))=$P(%ut(""ELIN""),"";"",3),%utUETRY(%ut(""ENTN""),""NAME"")=$P(%ut(""ELIN""),"";"",4)"
"RTN","uttcovr",227,0)
 S @GL1@("%ut1","CHEKTEST",39)=" . Q"
"RTN","uttcovr",228,0)
 S @GL1@("%ut1","CHEKTEST",41)=" QUIT"
"RTN","uttcovr",229,0)
 S @GL1@("%ut1","CHEKTEST",9)=" S %ut(""ENTN"")=0 ; Number of test, sub to %utUETRY."
"RTN","uttcovr",230,0)
 S @GL2@("%ut1","ACTLINES")="ACTLINES"
"RTN","uttcovr",231,0)
 S @GL2@("%ut1","ACTLINES",0)="ACTLINES(GL) ; [Private] $$ ; Count active lines"
"RTN","uttcovr",232,0)
 S @GL2@("%ut1","ACTLINES",2)=" N CNT S CNT=0"
"RTN","uttcovr",233,0)
 S @GL2@("%ut1","ACTLINES",3)=" N REF S REF=GL"
"RTN","uttcovr",234,0)
 S @GL2@("%ut1","ACTLINES",4)=" N GLQL S GLQL=$QL(GL)"
"RTN","uttcovr",235,0)
 S @GL2@("%ut1","ACTLINES",5)=" F  S REF=$Q(@REF) Q:REF=""""  Q:(GL'=$NA(@REF,GLQL))  D"
"RTN","uttcovr",236,0)
 S @GL2@("%ut1","ACTLINES",6)=" . N REFQL S REFQL=$QL(REF)"
"RTN","uttcovr",237,0)
 S @GL2@("%ut1","ACTLINES",7)=" . N LASTSUB S LASTSUB=$QS(REF,REFQL)"
"RTN","uttcovr",238,0)
 S @GL2@("%ut1","ACTLINES",8)=" . I LASTSUB?1.N S CNT=CNT+1"
"RTN","uttcovr",239,0)
 S @GL2@("%ut1","ACTLINES",9)=" QUIT CNT"
"RTN","uttcovr",240,0)
 S @GL2@("%ut1","CHEKTEST")="CHEKTEST"
"RTN","uttcovr",241,0)
 S @GL2@("%ut1","CHEKTEST",38)=" . S %ut(""ENTN"")=%ut(""ENTN"")+1,%utUETRY(%ut(""ENTN""))=$P(%ut(""ELIN""),"";"",3),%utUETRY(%ut(""ENTN""),""NAME"")=$P(%ut(""ELIN""),"";"",4)"
"RTN","uttcovr",242,0)
 S @GL2@("%ut1","CHEKTEST",39)=" . Q"
"RTN","uttcovr",243,0)
 Q
"RTN","uttcovr",244,0)
 ;
"RTN","uttcovr",245,0)
 ;
"RTN","uttcovr",246,0)
CACHECOV ;@TEST - set up routine for analysis in globals
"RTN","uttcovr",247,0)
 N GLOB,GLOBT
"RTN","uttcovr",248,0)
 S GLOB=$NA(^TMP("%uttcovr1",$J)),GLOBT=$NA(@GLOB@("uttcovr2",$J)) K @GLOB,@GLOBT
"RTN","uttcovr",249,0)
 D CACHECOV^%ut1(GLOB,GLOBT)
"RTN","uttcovr",250,0)
 D CHKEQ($T(+1^%ut),@GLOB@("%ut",1,0),"BAD FIRST LINE LOADED FOR %ut")
"RTN","uttcovr",251,0)
 D CHKEQ($T(+14^%ut),@GLOBT@("%ut",14,0),"Bad 14th line loaded for %ut")
"RTN","uttcovr",252,0)
 K @GLOB,@GLOBT
"RTN","uttcovr",253,0)
 Q
"RTN","uttcovr",254,0)
 ;
"RTN","uttcovr",255,0)
GETVALS ; no test - primarily calls to Cache classes
"RTN","uttcovr",256,0)
 Q
"RTN","uttcovr",257,0)
 ;
"RTN","uttcovr",258,0)
LINEDATA ; @TEST - convert code line to based on tags and offset, and identify active code lines
"RTN","uttcovr",259,0)
 N CODE,LINE,OFFSET,TAG
"RTN","uttcovr",260,0)
 S LINE="TEST1 ; COMMENT ON TAG",TAG="",OFFSET=0
"RTN","uttcovr",261,0)
 S CODE=$$LINEDATA^%ut1(LINE,.TAG,.OFFSET) ;
"RTN","uttcovr",262,0)
 D CHKEQ(0,CODE,"Tag with comment identified as active code")
"RTN","uttcovr",263,0)
 D CHKEQ("TEST1",TAG,"Bad tag returned for TEST1")
"RTN","uttcovr",264,0)
 D CHKEQ(0,OFFSET,"Bad OFFSET returned for TEST1")
"RTN","uttcovr",265,0)
 ;
"RTN","uttcovr",266,0)
 S LINE=" ; COMMENT ONLY"
"RTN","uttcovr",267,0)
 S CODE=$$LINEDATA^%ut1(LINE,.TAG,.OFFSET) ;
"RTN","uttcovr",268,0)
 D CHKEQ(0,CODE,"Comment line identified as active code")
"RTN","uttcovr",269,0)
 D CHKEQ("TEST1",TAG,"Bad tag returned for TEST1+1")
"RTN","uttcovr",270,0)
 D CHKEQ(1,OFFSET,"Bad OFFSET returned for TEST1+1")
"RTN","uttcovr",271,0)
 ;
"RTN","uttcovr",272,0)
 S LINE=" S X=VALUE"
"RTN","uttcovr",273,0)
 S CODE=$$LINEDATA^%ut1(LINE,.TAG,.OFFSET) ;
"RTN","uttcovr",274,0)
 D CHKEQ(1,CODE,"Code line NOT identified as active code")
"RTN","uttcovr",275,0)
 D CHKEQ("TEST1",TAG,"Bad tag returned for TEST1+2")
"RTN","uttcovr",276,0)
 D CHKEQ(2,OFFSET,"Bad OFFSET returned for TEST1+2")
"RTN","uttcovr",277,0)
 ;
"RTN","uttcovr",278,0)
 S LINE="TEST2 S X=VALUE"
"RTN","uttcovr",279,0)
 S CODE=$$LINEDATA^%ut1(LINE,.TAG,.OFFSET) ;
"RTN","uttcovr",280,0)
 D CHKEQ(1,CODE,"Tag line with code NOT identified as active code")
"RTN","uttcovr",281,0)
 D CHKEQ("TEST2",TAG,"Bad tag returned for TEST2")
"RTN","uttcovr",282,0)
 D CHKEQ(0,OFFSET,"Bad OFFSET returned for TEST2")
"RTN","uttcovr",283,0)
 ;
"RTN","uttcovr",284,0)
 Q
"RTN","uttcovr",285,0)
 ;
"RTN","uttcovr",286,0)
TOTAGS ;@TEST - convert from lines of code by line number to lines ordered by tag, line from tag, and only not covered
"RTN","uttcovr",287,0)
 N ACTIVE,GLOB,GLOBT,X1,X0
"RTN","uttcovr",288,0)
 S GLOB=$NA(^TMP("%uttcovr",$J)),GLOBT=$NA(@GLOB@("TEST1")) K @GLOB
"RTN","uttcovr",289,0)
 S @GLOBT@(1,0)="LINE1 ; CODE1 LINE1+0 NOT ACTIVE"
"RTN","uttcovr",290,0)
 S @GLOBT@(2,0)=" CODE2 LINE+1 SEEN"
"RTN","uttcovr",291,0)
 S @GLOBT@(2,"C")=2
"RTN","uttcovr",292,0)
 S @GLOBT@(3,0)=" CODE3 LINE1+2 NOT SEEN"
"RTN","uttcovr",293,0)
 S @GLOBT@(4,0)="LINE4 CODE4 LINE4+0 SEEN"
"RTN","uttcovr",294,0)
 S @GLOBT@(4,"C")=5
"RTN","uttcovr",295,0)
 S @GLOBT@(5,0)=" ; CODE5 LINE4+1 NOT ACTIVE"
"RTN","uttcovr",296,0)
 S @GLOBT@(6,0)=" CODE6 LINE4+2 COVERED"
"RTN","uttcovr",297,0)
 S @GLOBT@(6,"C")=2
"RTN","uttcovr",298,0)
 S @GLOBT@(7,0)="LINE7 CODE7 LINE7+0 NOT COVERED"
"RTN","uttcovr",299,0)
 S @GLOBT@(8,0)=" CODE8 LINE7+1 NOT COVERED"
"RTN","uttcovr",300,0)
 S ACTIVE=1
"RTN","uttcovr",301,0)
 D TOTAGS^%ut1(GLOB,ACTIVE)
"RTN","uttcovr",302,0)
 D CHKEQ(1,($D(@GLOBT@("LINE1"))#2),"LINE1 TAG NOT IDENTIFIED")
"RTN","uttcovr",303,0)
 D CHKEQ(1,($D(@GLOBT@("LINE4"))#2),"LINE4 TAG NOT IDENTIFIED")
"RTN","uttcovr",304,0)
 D CHKEQ(1,($D(@GLOBT@("LINE7"))#2),"LINE7 TAG NOT IDENTIFIED")
"RTN","uttcovr",305,0)
 D CHKEQ(0,$D(@GLOBT@("LINE1",0)),"LINE1+0 SHOULD NOT BE INCLUDED - IT IS A COMMENT")
"RTN","uttcovr",306,0)
 D CHKEQ(0,$D(@GLOBT@("LINE1",1)),"LINE1+1 SHOULD NOT BE INCLUDED - IT WAS COVERED")
"RTN","uttcovr",307,0)
 D CHKEQ(1,$D(@GLOBT@("LINE1",2)),"LINE1+2 SHOULD BE INCLUDED - IT WAS NOT COVERED")
"RTN","uttcovr",308,0)
 D CHKEQ(0,$D(@GLOBT@("LINE4",0)),"LINE4+0 SHOULD NOT BE INCLUDED - IT WAS COVERED")
"RTN","uttcovr",309,0)
 D CHKEQ(0,$D(@GLOBT@("LINE4",1)),"LINE4+1 SHOULD NOT BE INCLUDED - IT IS A COMMENT")
"RTN","uttcovr",310,0)
 D CHKEQ(0,$D(@GLOBT@("LINE4",2)),"LINE4+2 SHOULD NOT BE INCLUDED - IT WAS COVERED")
"RTN","uttcovr",311,0)
 D CHKEQ(1,$D(@GLOBT@("LINE7",0)),"LINE7+0 SHOULD BE INCLUDED - IT IS NOT COVERED")
"RTN","uttcovr",312,0)
 D CHKEQ(1,$D(@GLOBT@("LINE7",1)),"LINE7+1 SHOULD BE INCLUDED - IT IS NOT COVERED")
"RTN","uttcovr",313,0)
 K @GLOB,@GLOBT
"RTN","uttcovr",314,0)
 Q
"RTN","uttcovr",315,0)
 ;
"RTN","uttcovr",316,0)
CHKEQ(EXPECTED,SEEN,COMMENT) ;
"RTN","uttcovr",317,0)
 D CHKEQ^%ut(EXPECTED,SEEN,$G(COMMENT))
"RTN","uttcovr",318,0)
 Q
"RTN","uttcovr",319,0)
 ;
"RTN","uttcovr",320,0)
CHKTF(VALUE,COMMENT) ;
"RTN","uttcovr",321,0)
 D CHKTF^%ut(VALUE,$G(COMMENT))
"RTN","uttcovr",322,0)
 Q
"SEC","^DIC",17.9001,17.9001,0,"AUDIT")
@
"SEC","^DIC",17.9001,17.9001,0,"DD")
@
"SEC","^DIC",17.9001,17.9001,0,"DEL")
@
"SEC","^DIC",17.9001,17.9001,0,"LAYGO")
@
"SEC","^DIC",17.9001,17.9001,0,"RD")
@
"SEC","^DIC",17.9001,17.9001,0,"WR")
@
"VER")
8.0^22.0
"^DD",17.9001,17.9001,0)
FIELD^^2^3
"^DD",17.9001,17.9001,0,"DT")
3140812
"^DD",17.9001,17.9001,0,"IX","B",17.9001,.01)

"^DD",17.9001,17.9001,0,"NM","MUNIT TEST GROUP")
 
"^DD",17.9001,17.9001,0,"VRPK")
MASH
"^DD",17.9001,17.9001,.01,0)
NAME^RF^^0;1^K:$L(X)>30!(X?.N)!($L(X)<3)!'(X'?1P.E) X
"^DD",17.9001,17.9001,.01,1,0)
^.1
"^DD",17.9001,17.9001,.01,1,1,0)
17.9001^B
"^DD",17.9001,17.9001,.01,1,1,1)
S ^%ut(17.9001,"B",$E(X,1,30),DA)=""
"^DD",17.9001,17.9001,.01,1,1,2)
K ^%ut(17.9001,"B",$E(X,1,30),DA)
"^DD",17.9001,17.9001,.01,3)
NAME MUST BE 3-30 CHARACTERS, NOT NUMERIC OR STARTING WITH PUNCTUATION
"^DD",17.9001,17.9001,1,0)
TEST ROUTINE^17.90011^^1;0
"^DD",17.9001,17.9001,2,0)
DESCRIPTION FOR GROUP^17.90012^^2;0
"^DD",17.9001,17.9001,2,21,0)
^^3^3^3140812^
"^DD",17.9001,17.9001,2,21,1,0)
This word processing field provides a location for the developer to enter
"^DD",17.9001,17.9001,2,21,2,0)
a description of the purpose or function of the M-Unit Test Group,
"^DD",17.9001,17.9001,2,21,3,0)
including if desired comments on the various routines in the group.
"^DD",17.9001,17.9001,2,23,0)
^^3^3^3140812^
"^DD",17.9001,17.9001,2,23,1,0)
This word processing field provides a location for the developer to enter
"^DD",17.9001,17.9001,2,23,2,0)
a description of the purpose or function of the M-Unit Test Group,
"^DD",17.9001,17.9001,2,23,3,0)
including if desired comments on the various routines in the group.
"^DD",17.9001,17.9001,2,"DT")
3140812
"^DD",17.9001,17.90011,0)
TEST ROUTINE SUB-FIELD^^.01^1
"^DD",17.9001,17.90011,0,"DT")
3140731
"^DD",17.9001,17.90011,0,"IX","B",17.90011,.01)

"^DD",17.9001,17.90011,0,"NM","TEST ROUTINE")
 
"^DD",17.9001,17.90011,0,"UP")
17.9001
"^DD",17.9001,17.90011,.01,0)
TEST ROUTINE^MF^^0;1^K:$L(X)>8!($L(X)<3) X
"^DD",17.9001,17.90011,.01,1,0)
^.1
"^DD",17.9001,17.90011,.01,1,1,0)
17.90011^B
"^DD",17.9001,17.90011,.01,1,1,1)
S ^%ut(17.9001,DA(1),1,"B",$E(X,1,30),DA)=""
"^DD",17.9001,17.90011,.01,1,1,2)
K ^%ut(17.9001,DA(1),1,"B",$E(X,1,30),DA)
"^DD",17.9001,17.90011,.01,3)
This is a routine to be used for the MUnit Test Group.  Answer must be 3-8 characters in length.
"^DD",17.9001,17.90011,.01,"DT")
3140731
"^DD",17.9001,17.90012,0)
DESCRIPTION FOR GROUP SUB-FIELD^^.01^1
"^DD",17.9001,17.90012,0,"DT")
3140812
"^DD",17.9001,17.90012,0,"NM","DESCRIPTION FOR GROUP")

"^DD",17.9001,17.90012,0,"UP")
17.9001
"^DD",17.9001,17.90012,.01,0)
DESCRIPTION FOR GROUP^W^^0;1^Q
"^DD",17.9001,17.90012,.01,3)
Enter a description for the Unit Test Group
"^DD",17.9001,17.90012,.01,21,0)
^.001^3^3^3140812^^
"^DD",17.9001,17.90012,.01,21,1,0)
This word processing field provides a location for the developer to enter 
"^DD",17.9001,17.90012,.01,21,2,0)
a description of the purpose or function of the M-Unit Test Group, 
"^DD",17.9001,17.90012,.01,21,3,0)
including if desired comments on the various routines in the group.
"^DD",17.9001,17.90012,.01,23,0)
^^3^3^3140812^
"^DD",17.9001,17.90012,.01,23,1,0)
This word processing field provides a location for the developer to enter
"^DD",17.9001,17.90012,.01,23,2,0)
a description of the purpose or function of the M-Unit Test Group,
"^DD",17.9001,17.90012,.01,23,3,0)
including if desired comments on the various routines in the group.
"^DD",17.9001,17.90012,.01,"DT")
3140812
"^DIC",17.9001,17.9001,0)
M-UNIT TEST GROUP^17.9001
"^DIC",17.9001,17.9001,0,"GL")
^%ut(17.9001,
"^DIC",17.9001,"B","M-UNIT TEST GROUP",17.9001)

**END**
**END**
